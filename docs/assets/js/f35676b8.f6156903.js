"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3447],{8293:function(e,t,r){r.d(t,{b:function(){return i}});var n=r(3401),i=function(e){return function(t){return(0,n.bA)(t,e)}}},9640:function(e,t,r){r.r(t),r.d(t,{assets:function(){return C},contentTitle:function(){return y},default:function(){return I},frontMatter:function(){return N},metadata:function(){return w},toc:function(){return E}});var n=r(7462),i=r(3366),a=r(7294),o=r(3905),s=r(3401),c=r(2041),l=r(6085),u=r(9354),p=r(3546),d=r(4388),m=r(809),b=r(8293),z=(0,d.t)(l.E,l.d),f=p.Cn,h=[[1,1],[6,2.5],[2,1],[3,3]].map((0,s.Iu)([4,2])),_=[{pss:[[[6.4,4.8],[15,5],[1,4],[10,4]],[[9.4,.4],[9.3,10.3],[8.1,.1],[7.53125,5.5]]],description:"This example illustrates Bezout's Theorem: a cubic-cubic intersection implies 3x3 = 9 intersections at most."},{pss:[h,(0,p.JQ)(h,-.125,1.125)],description:"Overlapping algebraically identical bezier curves have an infinite number of intersecions; this is indicated by the kind of intersection (kind === 5) and only the intersections at the endpoints of each curve are retrurned "},{pss:[[[1.5,.75]].map((0,b.b)(4)).map((0,s.Iu)([2,2])),[[0,0],[1,1],[2,1],[3,0]].map((0,b.b)(4)).map((0,s.Iu)([2,2]))],description:"point / cubic bezier curve - point is exactly on curve"},{pss:[[[1.5,.75],[1,1],[.5,.375]].map((0,b.b)(4)).map((0,s.Iu)([2,2])),[[0,0],[1,1],[2,1]].map((0,b.b)(4)).map((0,s.Iu)([2,2]))],description:"quadratic / quadratic bezier curves"}];function k(e){return function(t){var r=(0,u.P)(t,"#f00","transparent"),n=(0,u.P)(t,"#0f0","transparent"),i=_[e].pss,a=f.apply(void 0,i);return n(i[1].map(z)),r(i[0].map(z)),a.map((function(e){return r=z(e.p),(0,m.x)(t,"transparent","#00f")(r,5);var r})),[{result:a,params:[i]}]}}function v(){return a.createElement(a.Fragment,null,a.createElement("p",null,"Some examples are shown below:"),_.map((function(e,t){var r=e.pss;return a.createElement(a.Fragment,null,a.createElement("p",null,e.description),a.createElement(c.O,{functionName:"bezierBezierIntersection",draw:k(t),draggables:[].concat(r[0],r[1])}),a.createElement("hr",null))})))}var g=["components"],N={id:"intersection_bezier_bezier_intersection_bezier_bezier_intersection",title:"bezier-bezier-intersection"},y=void 0,w={unversionedId:"modules/intersection_bezier_bezier_intersection_bezier_bezier_intersection",id:"modules/intersection_bezier_bezier_intersection_bezier_bezier_intersection",title:"bezier-bezier-intersection",description:"Defined in intersection/bezier-bezier-intersection/bezier-bezier-intersection.ts:59",source:"@site/docs/modules/intersection_bezier_bezier_intersection_bezier_bezier_intersection.mdx",sourceDirName:"modules",slug:"/modules/intersection_bezier_bezier_intersection_bezier_bezier_intersection",permalink:"/FloBezier/docs/modules/intersection_bezier_bezier_intersection_bezier_bezier_intersection",draft:!1,tags:[],version:"current",frontMatter:{id:"intersection_bezier_bezier_intersection_bezier_bezier_intersection",title:"bezier-bezier-intersection"},sidebar:"sidebar",previous:{title:"bezier-bezier-intersection-fast",permalink:"/FloBezier/docs/modules/intersection_bezier_bezier_intersection_fast_bezier_bezier_intersection_fast"},next:{title:"get-coeffs-bez-bez",permalink:"/FloBezier/docs/modules/intersection_bezier_bezier_intersection_get_coefficients_get_coeffs_bez_bez"}},C={},E=[{value:"Parameters:",id:"parameters",level:4}],x={toc:E};function I(e){var t=e.components,r=(0,i.Z)(e,g);return(0,o.kt)("wrapper",(0,n.Z)({},x,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"function bezierBezierIntersection(ps1: number[][], ps2: number[][]): X[]\n")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Defined in ",(0,o.kt)("a",{parentName:"em",href:"https://github.com/FlorisSteenkamp/FloBezier/blob/a2fe14d/src/intersection/bezier-bezier-intersection/bezier-bezier-intersection.ts#L59"},"intersection/bezier-bezier-intersection/bezier-bezier-intersection.ts:59"))),(0,o.kt)("p",null,"Returns an array of intersections between two bezier curves up to cubic order\n(i.e. points, linear, quadratic or cubic bezier curves (i.e. order 0,1,2 or 3\ncurves).\nThe algorithm employed uses advanced techniques such as floating point error\nbounding, adaptive multi-precision floating point arithmetic, pre-filtering\nof easy cases, certified root finding and algebraic implicitization of the\ncurves in order to find ",(0,o.kt)("em",{parentName:"p"},"guaranteed")," accurate results."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"this algorithm is mathematically guaranteed accurate to within\n",(0,o.kt)("inlineCode",{parentName:"p"},"4 * Number.EPSILON")," in the returned ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," parameter values of the bezier\ncurves (bar underflow/overflow)")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"the returned intersections are ",(0,o.kt)("em",{parentName:"p"},"ordered")," by ",(0,o.kt)("inlineCode",{parentName:"p"},"t")," parameter value of the\nfirst bezier curve")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"if the two curves have an infinite number of intersections then the\nintersection of the endpoints of each curve with the other is returned\ninstead (and the intersection ",(0,o.kt)("inlineCode",{parentName:"p"},"kind")," property will equal ",(0,o.kt)("inlineCode",{parentName:"p"},"5"),")")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"each intersection in the returned array of intersections is an object with\nthe following properties (see the type [","[X]","]`):"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre"}," * `p`: point of intersection (calculated from the guaranteed root interval)\n * `t1`: first bezier curve's parameter `t` value (calculated from the guaranteed root interval)\n * `t2`: second bezier curve's parameter `t` value (calculated from the guaranteed root interval)\n * `kind`: kind of intersection (see [[X]] for details)\n * `ri1`: first bezier curve's root interval guaranteed to contain the\n          correct `t` value in the form `{ tS, tE, multiplicity }`,\n          where `tS` and `tE` are the start and end of the interval\n * `ri2`: second bezier curve's root interval guaranteed to contain the\n          correct `t` value in the form `{ tS, tE, multiplicity }`,\n          where `tS` and `tE` are the start and end of the interval\n * `box`: small box that is guaranteed to contain the intersection\n          (calculated from the guaranteed root interval)\n")))),(0,o.kt)(v,{mdxType:"BezierBezierIntersection"}),(0,o.kt)("h4",{id:"parameters"},"Parameters:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"Name"),(0,o.kt)("th",{parentName:"tr",align:null},"Type"),(0,o.kt)("th",{parentName:"tr",align:null},"Description"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"ps1")),(0,o.kt)("td",{parentName:"tr",align:null},"number","[][]"),(0,o.kt)("td",{parentName:"tr",align:null},"an order 0,1,2 or 3 bezier curve given as an ordered array of its control point coordinates, e.g. ",(0,o.kt)("inlineCode",{parentName:"td"},"[[0,0], [1,1], [2,1], [2,0]]"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},(0,o.kt)("inlineCode",{parentName:"td"},"ps2")),(0,o.kt)("td",{parentName:"tr",align:null},"number","[][]"),(0,o.kt)("td",{parentName:"tr",align:null},"an order 0,1,2 or 3 bezier curve given as an ordered array of its control point coordinates, e.g. ",(0,o.kt)("inlineCode",{parentName:"td"},"[[0,0], [1,1], [2,1], [2,0]]"))))))}I.isMDXComponent=!0}}]);