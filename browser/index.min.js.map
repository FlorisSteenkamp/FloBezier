{"version":3,"sources":["index.min.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","FloBezier3","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","_dereq_","_toConsumableArray","arr","Array","isArray","arr2","from","fromLine","_l","_slicedToArray","_l$","x0","y0","_l$2","x1","y1","xInterval","yInterval","evaluate","ps","x3","y3","evX","evY","_ps3","_ps3$","_ps3$2","evaluateX","evaluateY","undefined","κ","dx","evDx","dy","evDy","ddx","evDdx","evDdy","Math","sqrt","pow","evaluateDx","evaluateDy","evaluateDdx","evaluateDdy","κds","dκMod","ts","omt","b","c","d","x2","y2","h","j","_ps5","_ps5$","_ps5$2","_ps5$3","_ps5$4","tangent","normal","v","tanPs","totalCurvature","interval","_ps6","_ps6$","_ps6$2","_ps6$3","_ps6$4","evDs","ds","gaussQuadrature","getTAtLength","Poly","brent","lenAtT","evPs","xPs","getX","yPs","getY","dPs","getDx","getDy","ddPs","getDdx","getDdy","evaluateDddx","dddPs","getDddx","evaluateDddy","getDddy","getNormalizedBoundingBox","sinθ","cosθ","vectorToOrigin","Vector","transform","x","boundingPs","translateThenRotatePs","getBoundingBox","fromTo","t1","t2","p","from0ToT","fromTTo1","_ps8","_ps8$","_ps8$2","_ps8$3","_ps8$4","t3","s2","s3","_ps9","_ps9$","_ps9$2","_ps9$3","_ps9$4","splitAt","_ps10","_ps10$","_ps10$2","_ps10$3","_ps10$4","ps1","scale","factor","map","lineIntersection","_l2","_l2$","_l2$2","y","translate","len","rotate","allRoots","tsAtY","tsAtX","toQuadratic","_ps12","_ps12$","_ps12$2","_ps12$3","_ps12$4","toHybridQuadratic","_ps13","_ps13$","_ps13$2","_ps13$3","_ps13$4","evaluateHybridQuadratic","hq","th","_hq","P0","_hq$","_hq$$","_hq$$2","P2","evaluateQuadratic","evaluateLinear","_ps14","_ps14$","_ps14$2","clone","_ps15","_ps15$","_ps15$2","_ps15$3","_ps15$4","_ps16","_ps16$","_ps16$2","_ps16$3","toCubic","_ps17","_ps17$","_ps17$2","_ps17$3","coincident","P","Q","δ","calcPointAndNeighbor","pp1","normalVector","pp2","bestT","bestP","bestD","Number","POSITIVE_INFINITY","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","_t2","value","_d","distanceBetween","err","return","pp","_P","_Q","_calcPointAndNeighbor","tPQ0","dPQ0","_calcPointAndNeighbor2","tPQ1","dPQ1","_calcPointAndNeighbor3","tQP0","dQP0","_calcPointAndNeighbor4","tQP1","dQP1","tStartQ","tEndQ","tStartP","tEndP","count","_ref","_ref2","tSpanP","_calcPointAndNeighbor5","q","bezier3Intersection","ps2","Δ","intersection","Q_","P_","qRange","pRange","idx","cidx","_center","center","_center2","_Q_","_Q_2","Q0","Q3","_P_","_P_2","dQ","getDistanceToLineFunction","dQi","dQs","_dQs","dQ1","dQ2","C","dMin","min","dMax","max","_geoClip","geoClip","tMin","tMax","pSpan","qSpan","_ref3","_ref4","_span","tMinA","tMaxA","tMinB","tMaxB","A","B","span","tMin_","tMax_","abs","calcOtherT","apply","concat","tss","push","dPi","_dPs","dH0","dH2","dH10","dH11","dHmin","dHmax","DyMin","DyMax","errorBound","hornerErrorBound","DyMinMin","slice","DyMinMax","DyMaxMin","DyMaxMax","NEGATIVE_INFINITY","rootsMinMin","rootsMinMax","rootsMaxMin","rootsMaxMax","_P2","_P3","P1","P3","_Q2","_Q3","Q1","Q2","lengthP","sdst","lengthQ","moveX","moveY","_pp","tqsh","tqsv","tqs","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","tq","pq","squaredDistanceBetween","δMin","EPSILON","getLineEquation","_l3","_l3$","_l3$2","_getLineEquation","_getLineEquation2","reverse","sliceIterator","_arr","_n","_e","_s","_i","Object","TypeError","Memoize","grahamScan","rotatePs","translatePs","memoize","m1","_ps","_ps$","_ps$2","_ps$3","_ps2","_ps2$","_ps2$2","_ps2$3","differentiate","getBoundingHull","curvature","totalAbsoluteCurvature","interval_","key","result","getBoundingBoxTight","_ps7","_ps7$","_ps7$2","_ps7$3","_ps7$4","baseLength","box","_box","_box$","p0x","p0y","_box$2","p1x","p1y","axisAlignedBox","rotateThenTranslatePs","getBounds","roots","poly","minX","maxX","minY","maxY","tMinX","tMinY","tMaxX","tMaxY","_t","Bezier3","flo-gauss-quadrature","flo-graham-scan","flo-memoize","flo-poly","flo-vector2d","2","order","_GAUSS_CONSTANTS$orde","GAUSS_CONSTANTS","weights","abscissas","_interval","m2","4","8","16","3","stableSort","indxArray","sort","res","sorted","swap","temp","getSmallestIndxYThenX","smallest","smallestI","ps_","includeAllBoundaryPoints","delta","DELTA","_ps$splice","splice","_ps$splice2","cross","unshift","m","p1","p2","p3","ccw","SUPPORTED","results","WeakMap","param1","get","set","5","FloPoly","allRootsRecursive","clip0","INF","rangeFilter","inRange","quadraticRoots","filter","lowerBound","upperBound","negativeRootLowerBound_LMQ","positiveRootUpperBound_LMQ","dp","rootsWithin","intervals","peval","prevRoot","root","evA","evB","coreOperators","rootOperators","rootBounds","toCasStr","rootMagnitudeUpperBound_fujiwara","positiveRootLowerBound_LMQ","negativeRootUpperBound_LMQ","./core-operators.js","./root-bounds.js","./root-operators.js","equal","add","d1","d2","Δd","Δd1","Δd2","c1","c2","subtract","negate","multiplyByConst","multiply","fill","degree","evaluateAt0","signChanges","prevSign","sign","deflate","bs","invert","changeVariables","_i2","_j","acc","reflectAboutYAxis","sturmChain","pnext","shift","clip","maxCoefficient","p_","str","cStr","toString","conditionNumber","errorAnalysis","random","fromRoots","assign","./all-roots-recursive.js","./error-analysis.js","./from-roots.js","./random.js","_require","6","predictiveRandom","seed","RANGE","randomArray","odds","SEED","vs","values","flatRoots","randArr","flatCoefficients","createArrFunction","flatRootsArr","flatCoefficientsArr","7","maxAbs","ns","rootMagnitudeUpperBound_rouche","an","deg","timesUsed","ub","tempub","any","k","powres","POWERS","_p","root1","root2","numRootsWithin","as","bisection","fa","fb","fc","mflag","fac","fab","fbc","b_c","s_b","c_d","fs","_temp","dot","segSegIntersection","ab","cd","_ab","_cd","denom","rNumer","sNumer","doesSegSegIntersect","toUnitVector","scaleFactor","toLength","interpolate","mean","lengthSquared","manhattanDistanceBetween","manhattanLength","distanceBetweenPointAndLine","squaredDistanceBetweenPointAndLineSegment","w","l2","circumCenter","triangle","Sx","det3","Sy","inCenter","l1","l3","lengthSum","centroid","polygon","p0","_p2","_p3","_p4","z","rotateByθ","reverseRotate","rotate90Degrees","rotateNeg90Degrees","getClosestTo","cp","bestd","f2","fPs","f1"],"mappings":"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","file":"index.min.js","sourcesContent":["(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloBezier3 = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nvar _slicedToArray = function () {\n\tfunction sliceIterator(arr, i) {\n\t\tvar _arr = [];var _n = true;var _d = false;var _e = undefined;try {\n\t\t\tfor (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n\t\t\t\t_arr.push(_s.value);if (i && _arr.length === i) break;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_d = true;_e = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_n && _i[\"return\"]) _i[\"return\"]();\n\t\t\t} finally {\n\t\t\t\tif (_d) throw _e;\n\t\t\t}\n\t\t}return _arr;\n\t}return function (arr, i) {\n\t\tif (Array.isArray(arr)) {\n\t\t\treturn arr;\n\t\t} else if (Symbol.iterator in Object(arr)) {\n\t\t\treturn sliceIterator(arr, i);\n\t\t} else {\n\t\t\tthrow new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n\t\t}\n\t};\n}();\n\nfunction _toConsumableArray(arr) {\n\tif (Array.isArray(arr)) {\n\t\tfor (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n\t\t\tarr2[i] = arr[i];\n\t\t}return arr2;\n\t} else {\n\t\treturn Array.from(arr);\n\t}\n}\n\nvar Poly = _dereq_('flo-poly');\nvar Vector = _dereq_('flo-vector2d');\nvar Memoize = _dereq_('flo-memoize');\nvar gaussQuadrature = _dereq_('flo-gauss-quadrature');\nvar grahamScan = _dereq_('flo-graham-scan');\n\nvar DELTA = 1e-10;\n\nvar rotate = Vector.rotatePs,\n    translate = Vector.translatePs;\n\nvar memoize = Memoize.m1;\n\n/**\r\n * Returns the power basis representation of the bezier's x-coordinates.\r\n * This function is memoized on its points parameter by object reference.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {number[]} The power basis polynomial from highest power to lowest, \r\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\r\n */\nvar getX = memoize(function (ps) {\n\tvar _ps = _slicedToArray(ps, 4),\n\t    _ps$ = _slicedToArray(_ps[0], 1),\n\t    x0 = _ps$[0],\n\t    _ps$2 = _slicedToArray(_ps[1], 1),\n\t    x1 = _ps$2[0],\n\t    _ps$3 = _slicedToArray(_ps[2], 1),\n\t    x2 = _ps$3[0],\n\t    _ps$4 = _slicedToArray(_ps[3], 1),\n\t    x3 = _ps$4[0];\n\n\treturn [x3 - 3 * x2 + 3 * x1 - x0, // t^3\n\t3 * x2 - 6 * x1 + 3 * x0, // t^2\n\t3 * x1 - 3 * x0, // t^1\n\tx0];\n} // t^0\n);\n\n/**\r\n * Returns the power basis representation of the bezier's y-coordinates.\r\n * This function is memoized on its points parameter by object reference.\r\n * @param {number[][]} ps - A bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {number[]} The power basis polynomial from highest power to lowest, \r\n * e.g. at^3 + bt^2 + ct + d is returned as [a,b,c,d]\r\n */\nvar getY = memoize(function (ps) {\n\tvar _ps2 = _slicedToArray(ps, 4),\n\t    _ps2$ = _slicedToArray(_ps2[0], 2),\n\t    y0 = _ps2$[1],\n\t    _ps2$2 = _slicedToArray(_ps2[1], 2),\n\t    y1 = _ps2$2[1],\n\t    _ps2$3 = _slicedToArray(_ps2[2], 2),\n\t    y2 = _ps2$3[1],\n\t    _ps2$4 = _slicedToArray(_ps2[3], 2),\n\t    y3 = _ps2$4[1];\n\n\treturn [y3 - 3 * y2 + 3 * y1 - y0, // t^3\n\t3 * y2 - 6 * y1 + 3 * y0, // t^2\n\t3 * y1 - 3 * y0, // t^1\n\ty0];\n} // t^0\n);\n\n/**\r\n * Returns the derivative of the power basis representation of the bezier's \r\n * x-coordinates. This function is memoized on its points parameter by object \r\n * reference.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {number[]} The differentiated power basis polynomial from highest \r\n * power to lowest, e.g. at^2 + bt + c is returned as [a,b,c]\r\n */\nvar getDx = memoize(function (ps) {\n\treturn Poly.differentiate(getX(ps));\n});\n\n/**\r\n * Returns the derivative of the power basis representation of the bezier's \r\n * y-coordinates. This function is memoized on its points parameter by object \r\n * reference.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {number[]} The differentiated power basis polynomial from highest\r\n * power to lowest, e.g. at^2 + bt + c is returned as [a,b,c]\r\n */\nvar getDy = memoize(function (ps) {\n\treturn Poly.differentiate(getY(ps));\n});\n\n/**\r\n * Returns the second derivative of the power basis representation of the \r\n * bezier's x-coordinates. This function is memoized on its points parameter by \r\n * object reference.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {number[]} The twice differentiated power basis polynomial from \r\n * highest power to lowest, e.g. at + b is returned as [a,b]\r\n */\nvar getDdx = memoize(function (ps) {\n\treturn Poly.differentiate(getDx(ps));\n});\n\n/**\r\n * Returns the second derivative of the power basis representation of the \r\n * bezier's y-coordinates. This function is memoized on its points parameter by \r\n * object reference.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {number[]} The twice differentiated power basis polynomial from \r\n * highest power to lowest, e.g. at + b is returned as [a,b]\r\n */\nvar getDdy = memoize(function (ps) {\n\treturn Poly.differentiate(getDy(ps));\n});\n\n/**\r\n * Returns the third derivative of the power basis representation of the \r\n * bezier's x-coordinates. This function is memoized on its points parameter by \r\n * object reference.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {number[]} The thrice differentiated power basis polynomial (a \r\n * constant in array from), e.g. a is returned as [a]\r\n */\nvar getDddx = memoize(function (ps) {\n\treturn Poly.differentiate(getDdx(ps));\n});\n\n/**\r\n * Returns the third derivative of the power basis representation of the \r\n * bezier's y-coordinates. This function is memoized on its points parameter by \r\n * object reference.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {number[]} The thrice differentiated power basis polynomial (a \r\n * constant in array from), e.g. a is returned as [a]\r\n */\nvar getDddy = memoize(function (ps) {\n\treturn Poly.differentiate(getDdy(ps));\n});\n\n/** \r\n * <p>\r\n * Returns the convex hull of a bezier's control points. This hull bounds the \r\n * bezier curve. This function is memoized.\r\n * </p>\r\n * <p>\r\n * The tolerance at which the cross product of two nearly collinear lines of the \r\n * hull are considered collinear is 1e-12.\r\n * </p>\r\n  * @param {number[][]} ps - A bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {number[][]} An ordered array of convex hull points.\r\n */\nvar getBoundingHull = memoize(grahamScan);\n\n/**\r\n * Returns a cubic bezier from the given line with evenly spaced control points.\r\n * @param {number[][]} l - a 2d line represented by two points\r\n * @returns {number[][]} Control points of the cubic bezier.\r\n */\nfunction fromLine(l) {\n\tvar _l = _slicedToArray(l, 2),\n\t    _l$ = _slicedToArray(_l[0], 2),\n\t    x0 = _l$[0],\n\t    y0 = _l$[1],\n\t    _l$2 = _slicedToArray(_l[1], 2),\n\t    x1 = _l$2[0],\n\t    y1 = _l$2[1];\n\n\tvar xInterval = (x1 - x0) / 3;\n\tvar yInterval = (y1 - y0) / 3;\n\n\treturn [[x0, y0], [x0 + xInterval, y0 + yInterval], [x0 + xInterval * 2, y0 + yInterval * 2], [x1, y1]];\n}\n\n/** \r\n * Evaluates the given bezier curve at the parameter t. This function is \r\n * curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The parameter value where the bezier should be evaluated\r\n * @returns {number[]} The resultant point. \r\n **/\nfunction evaluate(ps, t) {\n\tvar _ps3 = _slicedToArray(ps, 4),\n\t    _ps3$ = _slicedToArray(_ps3[0], 2),\n\t    x0 = _ps3$[0],\n\t    y0 = _ps3$[1],\n\t    _ps3$2 = _slicedToArray(_ps3[3], 2),\n\t    x3 = _ps3$2[0],\n\t    y3 = _ps3$2[1];\n\n\tvar evX = evaluateX(ps);\n\tvar evY = evaluateY(ps);\n\n\tfunction f(t) {\n\t\tif (t === 0) {\n\t\t\treturn [x0, y0];\n\t\t} else if (t === 1) {\n\t\t\treturn [x3, y3];\n\t\t}\n\n\t\treturn [evX(t), evY(t)];\n\t}\n\n\treturn t === undefined ? f : f(t);\n}\n\n/** \r\n * @description Find bezier inflection points. \r\n **/\nfunction findBezierInflectionPoints(ps) {\n\tvar _ps4 = _slicedToArray(ps, 4),\n\t    _ps4$ = _slicedToArray(_ps4[0], 2),\n\t    x0 = _ps4$[0],\n\t    y0 = _ps4$[1],\n\t    _ps4$2 = _slicedToArray(_ps4[1], 2),\n\t    x1 = _ps4$2[0],\n\t    y1 = _ps4$2[1],\n\t    _ps4$3 = _slicedToArray(_ps4[2], 2),\n\t    x2 = _ps4$3[0],\n\t    y2 = _ps4$3[1],\n\t    _ps4$4 = _slicedToArray(_ps4[3], 2),\n\t    x3 = _ps4$4[0],\n\t    y3 = _ps4$4[1];\n\n\t// From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4\n\n\n\tvar ax = x1 - x0;var ay = y1 - y0;\n\tvar bx = x2 - x1 - ax;var by = y2 - y1 - ay;\n\tvar cx = x3 - x2 - ax - 2 * bx;var cy = y3 - y2 - ay - 2 * by;\n\n\t// From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:\n\t//   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);\n\t// We find the roots of the quadratic - a,b,c are the quadratic coefficients\n\tvar a = bx * cy - by * cx;\n\tvar b = ax * cy - ay * cx;\n\tvar c = ax * by - ay * bx;\n\n\tvar inflectionTimes = Poly.allRoots([a, b, c], 0, 1);\n\n\tvar evPs = evaluate(ps);\n\treturn inflectionTimes.map(evPs);\n}\n\n/**\r\n * Returns the curvature, κ, at a specific t. This function is curried. Alias\r\n * of curvature.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The parameter value where the curvature should be \r\n * evaluated\r\n * @returns {number}\r\n */\nfunction κ(ps, t) {\n\tvar evDx = evaluateDx(ps);\n\tvar evDy = evaluateDy(ps);\n\tvar evDdx = evaluateDdx(ps);\n\tvar evDdy = evaluateDdy(ps);\n\n\tfunction f(t) {\n\t\tvar dx = evDx(t);\n\t\tvar dy = evDy(t);\n\t\tvar ddx = evDdx(t);\n\t\tvar ddy = evDdy(t);\n\n\t\tvar a = dx * ddy - dy * ddx;\n\t\tvar b = Math.sqrt(Math.pow(dx * dx + dy * dy, 3));\n\n\t\treturn a / b;\n\t}\n\n\t// Curry\n\treturn t === undefined ? f : f(t);\n}\n\n/**\r\n * Alias of κ.\r\n */\nvar curvature = κ;\n\n/**\r\n * Helper function. This function is curried.\r\n * @ignore\r\n */\nfunction κds(ps, t) {\n\tvar evDx = evaluateDx(ps);\n\tvar evDy = evaluateDy(ps);\n\tvar evDdx = evaluateDdx(ps);\n\tvar evDdy = evaluateDdy(ps);\n\n\tfunction f(t) {\n\t\tvar dx = evDx(t);\n\t\tvar dy = evDy(t);\n\t\tvar ddx = evDdx(t);\n\t\tvar ddy = evDdy(t);\n\n\t\tvar a = dx * ddy - dy * ddx;\n\t\tvar b = dx * dx + dy * dy;\n\n\t\treturn a / b;\n\t}\n\n\t// Curry\n\treturn t === undefined ? f : f(t);\n}\n\n/** \r\n * Helper function. This function is curried.\r\n * A modified version of the differential of κ (use quotient rule, ignore \r\n * denominator and multiply by 2/3). We need to find the zeros of this function \r\n * to get the min/max curvature.\r\n * See <a href=\"http://math.info/Calculus/Curvature_Parametric/\">this</a> for\r\n * more details.\r\n * @ignore\r\n**/\nfunction dκMod(ps, t) {\n\tvar _ps5 = _slicedToArray(ps, 4),\n\t    _ps5$ = _slicedToArray(_ps5[0], 2),\n\t    x0 = _ps5$[0],\n\t    y0 = _ps5$[1],\n\t    _ps5$2 = _slicedToArray(_ps5[1], 2),\n\t    x1 = _ps5$2[0],\n\t    y1 = _ps5$2[1],\n\t    _ps5$3 = _slicedToArray(_ps5[2], 2),\n\t    x2 = _ps5$3[0],\n\t    y2 = _ps5$3[1],\n\t    _ps5$4 = _slicedToArray(_ps5[3], 2),\n\t    x3 = _ps5$4[0],\n\t    y3 = _ps5$4[1];\n\n\tfunction f(t) {\n\n\t\tvar ts = t * t;\n\t\tvar omt = 1 - t;\n\n\t\tvar a = ts * x3;\n\t\tvar b = ts * y3;\n\t\tvar c = 2 * t - 3 * ts;\n\t\tvar d = (3 * t - 1) * omt;\n\t\tvar e = omt * omt;\n\t\tvar f = 3 * (a + c * x2 - d * x1 - e * x0);\n\t\tvar g = 3 * (b + c * y2 - d * y1 - e * y0);\n\t\tvar h = 6 * (t * y3 - (3 * t - 1) * y2 + (3 * t - 2) * y1 + omt * y0);\n\t\tvar i = 6 * (t * x3 - (3 * t - 1) * x2 + (3 * t - 2) * x1 + omt * x0);\n\t\tvar j = Math.sqrt(f * f + g * g);\n\n\t\treturn 4 * (f * (y3 - 3 * y2 + 3 * y1 - y0) - g * (x3 - 3 * x2 + 3 * x1 - x0)) * Math.pow(j, 3) - (f * h - b * g) * (2 * h * g + 2 * b * f) * j;\n\t}\n\n\treturn t === undefined ? f : f(t);\n}\n\n/**\r\n * Returns the tangent unit vector of a cubic bezier curve at a specific t. This \r\n * function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The parameter value where the tangent should be evaluated\r\n * @returns {number[]}\r\n */\nfunction tangent(ps, t) {\n\tvar evDx = evaluateDx(ps);\n\tvar evDy = evaluateDy(ps);\n\n\tfunction f(t) {\n\t\tvar dx = evDx(t);\n\t\tvar dy = evDy(t);\n\t\tvar d = Math.sqrt(dx * dx + dy * dy);\n\n\t\treturn [dx / d, dy / d];\n\t}\n\n\t// Curry\n\treturn t === undefined ? f : f(t);\n}\n\n/**\r\n * Returns the normal unit vector of a cubic bezier curve at a specific t. This\r\n * function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The parameter value where the normal should be evaluated\r\n * @returns {number[]}\r\n */\nfunction normal(ps, t) {\n\tvar tanPs = tangent(ps);\n\n\tfunction f(t) {\n\t\tvar v = tanPs(t);\n\t\treturn [v[1], -v[0]];\n\t}\n\n\t// Curry\n\treturn t === undefined ? f : f(t);\n}\n\n/**\r\n * <p>\r\n * Categorizes the given cubic bezier curve according to whether it has a loop,\r\n * a cusp, or zero, one or two inflection points all of which are mutually \r\n * exclusive. \r\n * </p>\r\n * <p>\r\n * See <a href=\"http://graphics.pixar.com/people/derose/publications/CubicClassification/paper.pdf\">\r\n * this</a> paper.\r\n * </p>\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {string} A value of 'L', 'C', '0', '1', or '2' depending on whether\r\n * the curve has a loop, a cusp, or zero, one or two inflection points.\r\n */\nfunction categorize(ps) {}\n// TODO - finish\n\n\n/**\r\n * Returns the total curvature of the bezier over the given interval using \r\n * Gaussian Quadrature integration with 16 wieghts and abscissas which is \r\n * generally very accurate and fast. This function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number[]} interval - The interval of integration (often === [0,1])\r\n * @returns {number} The total curvature.\r\n */\nfunction totalCurvature(ps, interval) {\n\tvar tanPs = tangent(ps);\n\n\tfunction f(interval) {}\n\t//return gaussQuadrature(κds(ps), interval);\n\t// TODO\n\t/*\r\n let [a,b] = interval;\r\n let tangentA = tanPs(a);\r\n let tangentB = tanPs(b);\r\n let sinθ = Vector.cross(tanA, tanB)\r\n */\n\n\t// Curry\n\treturn interval === undefined ? f : f(interval);\n}\n\n/**\r\n * TODO\r\n * Returns the total absolute curvature of the bezier over [0,1] using Gaussian \r\n * Quadrature integration with 16 wieghts and abscissas which is generally very \r\n * accurate and fast. This function is Memoized.\r\n * @param {number[]} interval_\r\n * @returns {number} The result in radians.\r\n */\nvar totalAbsoluteCurvature = memoize(function (ps) {\n\tvar totalAbsoluteCurvature = {}; // Lookup cache\n\n\treturn function (interval_) {\n\t\tvar interval = interval_ || [0, 1];\n\n\t\tvar key = '' + interval[0] + ', ' + interval[1];\n\t\tif (totalAbsoluteCurvature[key]) {\n\t\t\treturn totalAbsoluteCurvature[key];\n\t\t}\n\n\t\t// Numerically integrate the absolute curvature\n\t\tvar result = gaussQuadrature(function (t) {\n\t\t\treturn Math.abs(κds(ps)(t));\n\t\t}, interval);\n\t\ttotalAbsoluteCurvature[key] = result;\n\n\t\treturn result;\n\t};\n});\n\n/**\r\n * Returns the curve length in the specified interval. This function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number[]} interval - The paramter interval over which the lenght is \r\n * to be calculated (often === [0,1]).\r\n * @returns {number}\r\n */\nfunction length(interval, ps) {\n\tfunction f(ps) {\n\t\tif (interval[0] === interval[1]) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar _ps6 = _slicedToArray(ps, 4),\n\t\t    _ps6$ = _slicedToArray(_ps6[0], 2),\n\t\t    x0 = _ps6$[0],\n\t\t    y0 = _ps6$[1],\n\t\t    _ps6$2 = _slicedToArray(_ps6[1], 2),\n\t\t    x1 = _ps6$2[0],\n\t\t    y1 = _ps6$2[1],\n\t\t    _ps6$3 = _slicedToArray(_ps6[2], 2),\n\t\t    x2 = _ps6$3[0],\n\t\t    y2 = _ps6$3[1],\n\t\t    _ps6$4 = _slicedToArray(_ps6[3], 2),\n\t\t    x3 = _ps6$4[0],\n\t\t    y3 = _ps6$4[1];\n\t\t// Keep line below to ensure zero length curve returns zero!\n\n\n\t\tif (x0 === x1 && x1 === x2 && x2 === x3 && y0 === y1 && y1 === y2 && y2 === y3) {\n\t\t\treturn 0;\n\t\t}\n\t\tvar evDs = ds(ps);\n\t\treturn gaussQuadrature(evDs, interval);\n\t}\n\n\t// Curry\n\treturn ps === undefined ? f : f(ps);\n}\n\n/**\r\n * Returns the t parameter value where the given cubic bezier reaches the given\r\n * length, s, starting from t = 0. This function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number[]} s - The length\r\n * @returns {number}\r\n */\nfunction getTAtLength(ps, s) {\n\tvar lenAtT = function lenAtT(t) {\n\t\treturn length([0, t], ps);\n\t};\n\n\tfunction f(s) {\n\t\treturn Poly.brent(function (t) {\n\t\t\treturn lenAtT(t) - s;\n\t\t}, 0, 1);\n\t}\n\n\t// Curry\n\treturn s === undefined ? f : f(s);\n}\n\n/**\r\n * Returns ds. This function is curried.\r\n * @ignore\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The parameter value\r\n * @returns {number}\r\n */\nfunction ds(ps, t) {\n\tvar evDx = evaluateDx(ps);\n\tvar evDy = evaluateDy(ps);\n\n\tfunction f(t) {\n\t\tvar dx = evDx(t);\n\t\tvar dy = evDy(t);\n\n\t\treturn Math.sqrt(dx * dx + dy * dy);\n\t}\n\n\t// Curry\n\treturn t === undefined ? f : f(t);\n}\n/*\r\n function distanceToOrigin(ps,t) {\r\n\tconst evDx = evaluateDx(ps);\r\n\tconst evDy = evaluateDy(ps);\r\n\r\n\tfunction f(t) {\r\n\t\tlet dx = evDx(t);\r\n\t\tlet dy = evDy(t);\r\n\t\t\r\n\t\treturn Math.sqrt(dx*dx + dy*dy);\t\r\n\t}\r\n\r\n\t// Curry\r\n\treturn t === undefined ? f : f(t);\t\r\n}\r\n*/\n\n/**\r\n * Returns the x value of the given cubic bezier when evaluated at t. This\r\n * function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The t parameter\r\n * @returns {number} \r\n */\nfunction evaluateX(ps, t) {\n\tvar xPs = getX(ps); // Speed optimizing cache\n\tvar evPs = Poly.evaluate(xPs);\n\tfunction f(t) {\n\t\tif (t === 0) {\n\t\t\treturn ps[0][0];\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn ps[3][0];\n\t\t}\n\t\treturn evPs(t);\n\t}\n\treturn t === undefined ? f : f(t); // Curry\n}\n\n/**\r\n * Returns the y value of the given cubic bezier when evaluated at t. This\r\n * function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The t parameter\r\n * @returns {number} \r\n */\nfunction evaluateY(ps, t) {\n\tvar yPs = getY(ps); // Speed optimizing cache\n\tvar evPs = Poly.evaluate(yPs);\n\tfunction f(t) {\n\t\tif (t === 0) {\n\t\t\treturn ps[0][1];\n\t\t}\n\t\tif (t === 1) {\n\t\t\treturn ps[3][1];\n\t\t}\n\t\treturn evPs(t);\n\t}\n\treturn t === undefined ? f : f(t); // Curry\n}\n\n/**\r\n * Returns the x value of the once differentiated (with respect to t) cubic \r\n * bezier when evaluated at t. This function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The t parameter\r\n * @returns {number} \r\n */\nfunction evaluateDx(ps, t) {\n\tvar dPs = getDx(ps); // Speed optimizing cache\n\tvar f = Poly.evaluate(dPs);\n\treturn t === undefined ? f : f(t); // Curry\n}\n\n/**\r\n * Returns the y value of the once differentiated (with respect to t) cubic \r\n * bezier when evaluated at t. This function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The t parameter\r\n * @returns {number} \r\n */\nfunction evaluateDy(ps, t) {\n\tvar dPs = getDy(ps); // Speed optimizing cache\n\tvar f = Poly.evaluate(dPs);\n\treturn t === undefined ? f : f(t); // Curry\n}\n\n/**\r\n * Returns the x value of the twice differentiated (with respect to t) cubic \r\n * bezier when evaluated at t. This function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The t parameter\r\n * @returns {number} \r\n */\nfunction evaluateDdx(ps, t) {\n\tvar ddPs = getDdx(ps); // Speed optimizing cache\n\tvar f = Poly.evaluate(ddPs);\n\treturn t === undefined ? f : f(t); // Curry\n}\n\n/**\r\n * Returns the y value of the twice differentiated (with respect to t) cubic \r\n * bezier when evaluated at t. This function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The t parameter\r\n * @returns {number} \r\n */\nfunction evaluateDdy(ps, t) {\n\tvar ddPs = getDdy(ps); // Speed optimizing cache\n\tvar f = Poly.evaluate(ddPs);\n\treturn t === undefined ? f : f(t); // Curry\n}\n\n/**\r\n * Returns the x value of the thrice differentiated (with respect to t) cubic \r\n * bezier when evaluated at t. This function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The t parameter\r\n * @returns {number} \r\n */\nfunction evaluateDddx(ps, t) {\n\tvar dddPs = getDddx(ps); // Speed optimizing cache\n\tvar f = Poly.evaluate(dddPs);\n\treturn t === undefined ? f : f(t); // Curry\n}\n\n/**\r\n * Returns the y value of the thrice differentiated (with respect to t) cubic \r\n * bezier when evaluated at t. This function is curried.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} t - The t parameter\r\n * @returns {number} \r\n */\nfunction evaluateDddy(ps, t) {\n\tvar dddPs = getDddy(ps); // Speed optimizing cache\n\tvar f = Poly.evaluate(dddPs);\n\treturn t === undefined ? f : f(t); // Curry\n}\n\n// TODO - refactor getBounds, getBoundingBox, etc.\n/**\r\n * Helper function. Returns the bounding box of the normalized (i.e. first point \r\n * moved to origin and rotated so that last point lies on x-axis) given cubic \r\n * bezier.\r\n * @ignore\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number} sinθ - Sine of angle made by line from first bezier point to \r\n * last with x-axis.\r\n * @param {number} cosθ - Cosine of angle made by line from first bezier point \r\n * to last with x-axis.\r\n * @returns {number[][]} Bounding box in the form [[minX, minY], [maxX,maxY]\r\n */\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\n\tvar vectorToOrigin = Vector.transform(ps[0], function (x) {\n\t\treturn -x;\n\t});\n\n\tvar boundingPs = Vector.translateThenRotatePs(vectorToOrigin, -sinθ, cosθ, ps);\n\n\treturn getBoundingBox(boundingPs);\n}\n\n/**\r\n * Returns the tight bounding box of the given cubic bezier.\r\n * @returns {number[][]} The tight bounding box of the bezier as four ordered\r\n * points of a rotated rectangle.\r\n * TODO - test case of baseLength === 0\r\n */\nvar getBoundingBoxTight = memoize(function (ps) {\n\tvar _ps7 = _slicedToArray(ps, 4),\n\t    _ps7$ = _slicedToArray(_ps7[0], 2),\n\t    x0 = _ps7$[0],\n\t    y0 = _ps7$[1],\n\t    _ps7$2 = _slicedToArray(_ps7[1], 2),\n\t    x1 = _ps7$2[0],\n\t    y1 = _ps7$2[1],\n\t    _ps7$3 = _slicedToArray(_ps7[2], 2),\n\t    x2 = _ps7$3[0],\n\t    y2 = _ps7$3[1],\n\t    _ps7$4 = _slicedToArray(_ps7[3], 2),\n\t    x3 = _ps7$4[0],\n\t    y3 = _ps7$4[1];\n\n\tvar baseLength = Math.sqrt((x3 - x0) * (x3 - x0) + (y3 - y0) * (y3 - y0));\n\tvar sinθ = (y3 - y0) / baseLength;\n\tvar cosθ = (x3 - x0) / baseLength;\n\n\tvar box = getNormalizedBoundingBox(ps, sinθ, cosθ);\n\n\tvar _box = _slicedToArray(box, 2),\n\t    _box$ = _slicedToArray(_box[0], 2),\n\t    p0x = _box$[0],\n\t    p0y = _box$[1],\n\t    _box$2 = _slicedToArray(_box[1], 2),\n\t    p1x = _box$2[0],\n\t    p1y = _box$2[1];\n\n\tvar axisAlignedBox = [box[0], [p1x, p0y], box[1], [p0x, p1y]];\n\n\treturn Vector.rotateThenTranslatePs(sinθ, cosθ, ps[0], axisAlignedBox);\n});\n\n/**\r\n * Returns the axis-aligned bounding box of a given bezier.\r\n * @param {number[][]} ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @returns {number[][]} the axis-aligned bounding box in the form\r\n * [[minx, miny], [maxx,maxy]\r\n */\nvar getBoundingBox = memoize(function (ps) {\n\treturn getBounds(ps).box;\n});\n\n/**\r\n * Calculates and returns general bezier bounds.\r\n * @returns {object} The axis-aligned bounding box together with the t values\r\n * where the bounds on the bezier are reached.\r\n */\nvar getBounds = memoize(function (ps) {\n\n\t// Roots of derivative\n\tvar roots = [getDx(ps), getDy(ps)].map(function (poly) {\n\t\treturn Poly.allRoots(poly, 0, 1);\n\t});\n\n\t// Endpoints\n\troots[0].push(0, 1);\n\troots[1].push(0, 1);\n\n\tvar minX = Number.POSITIVE_INFINITY;\n\tvar maxX = Number.NEGATIVE_INFINITY;\n\tvar minY = Number.POSITIVE_INFINITY;\n\tvar maxY = Number.NEGATIVE_INFINITY;\n\n\tvar tMinX = undefined;\n\tvar tMinY = undefined;\n\tvar tMaxX = undefined;\n\tvar tMaxY = undefined;\n\n\t// Test points\n\tfor (var i = 0; i < roots[0].length; i++) {\n\t\tvar t = roots[0][i];\n\t\tvar x = evaluateX(ps, t);\n\t\tif (x < minX) {\n\t\t\tminX = x;tMinX = t;\n\t\t}\n\t\tif (x > maxX) {\n\t\t\tmaxX = x;tMaxX = t;\n\t\t}\n\t}\n\tfor (var _i = 0; _i < roots[1].length; _i++) {\n\t\tvar _t = roots[1][_i];\n\t\tvar y = evaluateY(ps, _t);\n\t\tif (y < minY) {\n\t\t\tminY = y;tMinY = _t;\n\t\t}\n\t\tif (y > maxY) {\n\t\t\tmaxY = y;tMaxY = _t;\n\t\t}\n\t}\n\n\tvar ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\n\tvar box = [[minX, minY], [maxX, maxY]];\n\n\treturn { ts: ts, box: box };\n});\n\n/**\r\n * <p>\r\n * Returns a cubic bezier curve that starts at the given curve and ends at the\r\n * given t parameter. Uses de Casteljau's algorithm. \r\n * </p>\r\n * <p>\r\n * A loose bound on the accuracy of the resultant points is given by: \r\n * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * </p>\r\n * @param {number[][]} ps - A cubic bezier curve\r\n * @param {number} t1 - The t parameter where the resultant bezier should start\r\n * @param {number} t2 - The t parameter where the resultant bezier should end\r\n * @returns {number[][]}\r\n */\nfunction fromTo(ps) {\n\treturn function (t1, t2) {\n\t\tif (t1 === t2) {\n\t\t\t// Degenerate case\n\t\t\tvar p = evaluate(ps, t1);\n\t\t\treturn [p, p, p, p];\n\t\t}\n\t\tvar t = fromTTo1(ps, t1);\n\t\treturn from0ToT(t, (t2 - t1) / (1 - t1));\n\t};\n};\n\n/**\r\n * <p>\r\n * Returns a cubic bezier curve that starts at the given curve's t=0 and ends \r\n * at the given t parameter. Uses de Casteljau's algorithm. \r\n * </p>\r\n * <p>\r\n * A loose bound on the accuracy of the resultant points is given by: \r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * </p>\r\n * @param {number[][]} ps - A cubic bezier curve\r\n * @param {number} t - The t parameter where the resultant bezier should end\r\n * @returns {number[][]}\r\n */\nfunction from0ToT(ps, t) {\n\tvar _ps8 = _slicedToArray(ps, 4),\n\t    _ps8$ = _slicedToArray(_ps8[0], 2),\n\t    x0 = _ps8$[0],\n\t    y0 = _ps8$[1],\n\t    _ps8$2 = _slicedToArray(_ps8[1], 2),\n\t    x1 = _ps8$2[0],\n\t    y1 = _ps8$2[1],\n\t    _ps8$3 = _slicedToArray(_ps8[2], 2),\n\t    x2 = _ps8$3[0],\n\t    y2 = _ps8$3[1],\n\t    _ps8$4 = _slicedToArray(_ps8[3], 2),\n\t    x3 = _ps8$4[0],\n\t    y3 = _ps8$4[1];\n\n\tvar s = 1 - t;\n\tvar t2 = t * t;\n\tvar t3 = t2 * t;\n\tvar s2 = s * s;\n\tvar s3 = s2 * s;\n\n\treturn [[x0, y0], [t * x1 + s * x0, t * y1 + s * y0], [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0], [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]];\n}\n\n/**\r\n * <p>\r\n * Returns a cubic bezier curve that starts at the given t parameter and \r\n * ends at t=1. Uses de Casteljau's algorithm.\r\n * </p>\r\n * <p>\r\n * A loose bound on the accuracy of the resultant points is given by: \r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * </p>\r\n * @param {number[][]} ps - A cubic bezier curve\r\n * @param {number} t - The t parameter where the resultant bezier should start\r\n * @returns {number[][]}\r\n */\nfunction fromTTo1(ps, t) {\n\tvar _ps9 = _slicedToArray(ps, 4),\n\t    _ps9$ = _slicedToArray(_ps9[0], 2),\n\t    x0 = _ps9$[0],\n\t    y0 = _ps9$[1],\n\t    _ps9$2 = _slicedToArray(_ps9[1], 2),\n\t    x1 = _ps9$2[0],\n\t    y1 = _ps9$2[1],\n\t    _ps9$3 = _slicedToArray(_ps9[2], 2),\n\t    x2 = _ps9$3[0],\n\t    y2 = _ps9$3[1],\n\t    _ps9$4 = _slicedToArray(_ps9[3], 2),\n\t    x3 = _ps9$4[0],\n\t    y3 = _ps9$4[1];\n\n\tvar s = 1 - t;\n\tvar t2 = t * t;\n\tvar t3 = t2 * t;\n\tvar s2 = s * s;\n\tvar s3 = s2 * s;\n\n\treturn [[t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0], [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1], [t * x3 + s * x2, t * y3 + s * y2], [x3, y3]];\n}\n\n/**\r\n * <p>\r\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges \r\n * [0,t] and [t,1]. Uses de Casteljau's algorithm. \r\n * </p>\r\n * <p>\r\n * A loose bound on the accuracy of the resultant points is given by: \r\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\r\n * abd η is Number.EPSILON.\r\n * </p>\r\n * @param {number[][]} ps - A cubic bezier curve\r\n * @param {number} t - The t parameter where the curve should be split\r\n * @returns {number[][]}\r\n */\nfunction splitAt(ps, t) {\n\tvar _ps10 = _slicedToArray(ps, 4),\n\t    _ps10$ = _slicedToArray(_ps10[0], 2),\n\t    x0 = _ps10$[0],\n\t    y0 = _ps10$[1],\n\t    _ps10$2 = _slicedToArray(_ps10[1], 2),\n\t    x1 = _ps10$2[0],\n\t    y1 = _ps10$2[1],\n\t    _ps10$3 = _slicedToArray(_ps10[2], 2),\n\t    x2 = _ps10$3[0],\n\t    y2 = _ps10$3[1],\n\t    _ps10$4 = _slicedToArray(_ps10[3], 2),\n\t    x3 = _ps10$4[0],\n\t    y3 = _ps10$4[1];\n\n\tvar s = 1 - t;\n\tvar t2 = t * t;\n\tvar t3 = t2 * t;\n\tvar s2 = s * s;\n\tvar s3 = s2 * s;\n\n\tvar ps1 = [[x0, y0], [t * x1 + s * x0, t * y1 + s * y0], [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0], [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0, t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]];\n\n\tvar ps2 = [ps1[3], [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1], [t * x3 + s * x2, t * y3 + s * y2], [x3, y3]];\n\n\treturn [ps1, ps2];\n}\n\n/**\r\n * Returns a human readable string representation of the given bezier.\r\n * @param {number[][]} ps - A bezier curve\r\n * @returns {string}\r\n */\nfunction toString(ps) {\n\tvar _ps11 = _slicedToArray(ps, 4),\n\t    _ps11$ = _slicedToArray(_ps11[0], 2),\n\t    x0 = _ps11$[0],\n\t    y0 = _ps11$[1],\n\t    _ps11$2 = _slicedToArray(_ps11[1], 2),\n\t    x1 = _ps11$2[0],\n\t    y1 = _ps11$2[1],\n\t    _ps11$3 = _slicedToArray(_ps11[2], 2),\n\t    x2 = _ps11$3[0],\n\t    y2 = _ps11$3[1],\n\t    _ps11$4 = _slicedToArray(_ps11[3], 2),\n\t    x3 = _ps11$4[0],\n\t    y3 = _ps11$4[1];\n\n\treturn '[[' + x0 + ',' + y0 + '],[' + x1 + ',' + y1 + '],[' + x2 + ',' + y2 + '],[' + x3 + ',' + y3 + ']]';\n}\n\n/**\r\n * Scales all control points of the given bezier by the given factor.\r\n * @param {number[][]} ps - A bezier curve\r\n * @param {number} factor - The scale factor\r\n * @returns {number[][]}\r\n */\nfunction scale(ps, factor) {\n\treturn ps.map(function (x) {\n\t\treturn [x[0] * factor, x[1] * factor];\n\t});\n}\n\n/**\r\n * Returns the bezier t values of the intersection between the given cubic \r\n * bezier and the given line.\r\n * @param {number[][]} ps - The bezier curve\r\n * @param {number[][]} l - The line given as a start and end point\r\n * @returns {number[]}\r\n */\nfunction lineIntersection(ps, l) {\n\tvar _l2 = _slicedToArray(l, 2),\n\t    _l2$ = _slicedToArray(_l2[0], 2),\n\t    x0 = _l2$[0],\n\t    y0 = _l2$[1],\n\t    _l2$2 = _slicedToArray(_l2[1], 2),\n\t    x1 = _l2$2[0],\n\t    y1 = _l2$2[1];\n\n\tvar x = x1 - x0,\n\t    y = y1 - y0;\n\n\tif (x === 0 && y === 0) {\n\t\treturn [];\n\t}\n\n\t// Move the line and the bezier together so the line's first point is on the\n\t// origin.\n\tps = translate([-x0, -y0], ps);\n\n\t// Rotate the bezier and line together so the line is y=0.\n\tvar len = Math.sqrt(x * x + y * y);\n\tvar sinθ = y / len;\n\tvar cosθ = x / len;\n\tps = rotate(-sinθ, cosθ, ps);\n\n\t// Find the intersection t values\n\treturn Poly.allRoots(getY(ps), 0, 1);\n}\n\n/**\r\n * Returns the bezier t values of the intersection between the given cubic \r\n * bezier and the given horizontal line.\r\n * @param {number[][]} ps - The bezier curve\r\n * @param {number[][]} y - The y value of the horizontal line\r\n * @returns {number[]}\r\n */\nfunction tsAtY(ps, y) {\n\t// Translate ps so that y = 0.\n\tps = ps.map(function (p) {\n\t\treturn [p[0], p[1] - y];\n\t});\n\n\t// Find the intersection t values\n\treturn Poly.allRoots(getY(ps), 0, 1);\n}\n\n/**\r\n * Returns the bezier t values of the intersection between the given cubic \r\n * bezier and the given vertical line.\r\n * @param {number[][]} ps - The bezier curve\r\n * @param {number[][]} y - The y value of the horizontal line\r\n * @returns {number[]}\r\n */\nfunction tsAtX(ps, x) {\n\t// Translate ps so that x = 0.\n\tps = ps.map(function (p) {\n\t\treturn [p[0] - x, p[1]];\n\t});\n\n\t// Find the intersection t values\n\treturn Poly.allRoots(getX(ps), 0, 1);\n}\n\n/**\r\n * Returns the best least squares quadratic bezier approximation to the given\r\n * cubic bezier. Note that the two bezier endpoints differ in general.\r\n * @param {number[][]} ps - A cubic bezier curve.\r\n * @returns {number[][]}\r\n */\nfunction toQuadratic(ps) {\n\tvar _ps12 = _slicedToArray(ps, 4),\n\t    _ps12$ = _slicedToArray(_ps12[0], 2),\n\t    x0 = _ps12$[0],\n\t    y0 = _ps12$[1],\n\t    _ps12$2 = _slicedToArray(_ps12[1], 2),\n\t    x1 = _ps12$2[0],\n\t    y1 = _ps12$2[1],\n\t    _ps12$3 = _slicedToArray(_ps12[2], 2),\n\t    x2 = _ps12$3[0],\n\t    y2 = _ps12$3[1],\n\t    _ps12$4 = _slicedToArray(_ps12[3], 2),\n\t    x3 = _ps12$4[0],\n\t    y3 = _ps12$4[1];\n\n\treturn [[19 / 20 * x0 + 3 / 20 * x1 + -3 / 20 * x2 + 1 / 20 * x3, 19 / 20 * y0 + 3 / 20 * y1 + -3 / 20 * y2 + 1 / 20 * y3], [-1 / 4 * x0 + 3 / 4 * x1 + 3 / 4 * x2 + -1 / 4 * x3, -1 / 4 * y0 + 3 / 4 * y1 + 3 / 4 * y2 + -1 / 4 * y3], [1 / 20 * x0 + -3 / 20 * x1 + 3 / 20 * x2 + 19 / 20 * x3, 1 / 20 * y0 + -3 / 20 * y1 + 3 / 20 * y2 + 19 / 20 * y3]];\n}\n\n/**\r\n * Returns the hybrid quadratic version of the given cubic bezier. For a \r\n * definition of hybrid quadratic bezier curves see <a href=\"http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\">\r\n * this paper</a>.\r\n * @param {number[][]} ps - A cubic bezier curve.\r\n * @returns {object[]} An array of three quadratic bezier points where the \r\n * middle point is a 'hybrid' point represented as a line (itself represented\r\n * by two points (a linear bezier curve)) which can be evaluated at a different \r\n * t value (call it th). If evaluated at the same t value the result is the same \r\n * as evaluating the original cubic bezier at t. The set generated by evaluating \r\n * the hybrid quadratic curve for all (t,th) value pairs forms a geometric area\r\n * bound around the orginal cubic bezier curve. The length of the linear bezier\r\n * curve mentioned above is a measure of how closely the cubic can be\r\n * represented as a quadratic bezier curve.\r\n */\nfunction toHybridQuadratic(ps) {\n\tvar _ps13 = _slicedToArray(ps, 4),\n\t    _ps13$ = _slicedToArray(_ps13[0], 2),\n\t    x0 = _ps13$[0],\n\t    y0 = _ps13$[1],\n\t    _ps13$2 = _slicedToArray(_ps13[1], 2),\n\t    x1 = _ps13$2[0],\n\t    y1 = _ps13$2[1],\n\t    _ps13$3 = _slicedToArray(_ps13[2], 2),\n\t    x2 = _ps13$3[0],\n\t    y2 = _ps13$3[1],\n\t    _ps13$4 = _slicedToArray(_ps13[3], 2),\n\t    x3 = _ps13$4[0],\n\t    y3 = _ps13$4[1];\n\n\treturn [[x0, y0], // evaluated at t\n\t[[(3 * x1 - x0) / 2, (3 * y1 - y0) / 2], // evaluated at (1-t)\n\t[(3 * x2 - x3) / 2, (3 * y2 - y3) / 2]], // evaluated at t\n\t[x3, y3] // evaluated at t\n\t];\n}\n\n/**\r\n * Evaluates the given hybrid quadratic at the given t and th parameters. (see \r\n * toHybridQuadratic for details).\r\n * @param {object[]} hq - A hybrid quadratic \r\n * @param {number} t - The bezier parameter value\r\n * @param {number} th - The parameter value for the hybrid quadratic point.\r\n */\nfunction evaluateHybridQuadratic(hq, t, th) {\n\tvar _hq = _slicedToArray(hq, 3),\n\t    P0 = _hq[0],\n\t    _hq$ = _slicedToArray(_hq[1], 2),\n\t    _hq$$ = _slicedToArray(_hq$[0], 2),\n\t    x10 = _hq$$[0],\n\t    y10 = _hq$$[1],\n\t    _hq$$2 = _slicedToArray(_hq$[1], 2),\n\t    x11 = _hq$$2[0],\n\t    y11 = _hq$$2[1],\n\t    P2 = _hq[2];\n\n\t//let x1 = x10*(1-th) + x11*th;\n\t//let y1 = y10*(1-th) + y11*th;\n\n\tvar P1 = evaluateLinear(hq[1], th);\n\n\t//let q = [P0, [x1,y1], P2];\n\treturn evaluateQuadratic([P0, P1, P2], t);\n}\n\n/**\r\n * Evaluates the given linear bezier (line) at a specific t value.\r\n * @param {number[][]} ps - A linear bezier curve.\r\n * @param {number} t - The value where the bezier should be evaluated\r\n * @returns {number[]}\r\n */\nfunction evaluateLinear(ps, t) {\n\tvar _ps14 = _slicedToArray(ps, 2),\n\t    _ps14$ = _slicedToArray(_ps14[0], 2),\n\t    x0 = _ps14$[0],\n\t    y0 = _ps14$[1],\n\t    _ps14$2 = _slicedToArray(_ps14[1], 2),\n\t    x1 = _ps14$2[0],\n\t    y1 = _ps14$2[1];\n\n\tvar x = x0 * (1 - t) + x1 * t;\n\tvar y = y0 * (1 - t) + y1 * t;\n\n\treturn [x, y];\n}\n\n/**\r\n * Returns a clone of the given cubic bezier. Use sparingly; this is not in the\r\n * spirit of functional programming.\r\n * @param {number[][]} ps - A cubic bezier given by its array of control points\r\n */\nfunction clone(ps) {\n\tvar _ps15 = _slicedToArray(ps, 4),\n\t    _ps15$ = _slicedToArray(_ps15[0], 2),\n\t    x0 = _ps15$[0],\n\t    y0 = _ps15$[1],\n\t    _ps15$2 = _slicedToArray(_ps15[1], 2),\n\t    x1 = _ps15$2[0],\n\t    y1 = _ps15$2[1],\n\t    _ps15$3 = _slicedToArray(_ps15[2], 2),\n\t    x2 = _ps15$3[0],\n\t    y2 = _ps15$3[1],\n\t    _ps15$4 = _slicedToArray(_ps15[3], 2),\n\t    x3 = _ps15$4[0],\n\t    y3 = _ps15$4[1];\n\n\treturn [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\n}\n\n/**\r\n * Evaluates the given quadratic bezier at a specific t value.\r\n * @param {number[][]} ps - A quadratic bezier curve.\r\n * @param {number} t - The value where the bezier should be evaluated\r\n * @returns {number[]}\r\n */\nfunction evaluateQuadratic(ps, t) {\n\tvar _ps16 = _slicedToArray(ps, 3),\n\t    _ps16$ = _slicedToArray(_ps16[0], 2),\n\t    x0 = _ps16$[0],\n\t    y0 = _ps16$[1],\n\t    _ps16$2 = _slicedToArray(_ps16[1], 2),\n\t    x1 = _ps16$2[0],\n\t    y1 = _ps16$2[1],\n\t    _ps16$3 = _slicedToArray(_ps16[2], 2),\n\t    x2 = _ps16$3[0],\n\t    y2 = _ps16$3[1];\n\n\tvar x = x0 * Math.pow(1 - t, 2) + x1 * 2 * (1 - t) * t + x2 * Math.pow(t, 2);\n\tvar y = y0 * Math.pow(1 - t, 2) + y1 * 2 * (1 - t) * t + y2 * Math.pow(t, 2);\n\n\treturn [x, y];\n}\n\n/**\r\n * Returns the cubic version of the given quadratic bezier curve. Quadratic \r\n * bezier curves can always be represented by cubics - the converse is false.\r\n * @param {number[][]} ps - A quadratic bezier curve.\r\n * @returns {number[][]}\r\n */\nfunction toCubic(ps) {\n\tvar _ps17 = _slicedToArray(ps, 3),\n\t    _ps17$ = _slicedToArray(_ps17[0], 2),\n\t    x0 = _ps17$[0],\n\t    y0 = _ps17$[1],\n\t    _ps17$2 = _slicedToArray(_ps17[1], 2),\n\t    x1 = _ps17$2[0],\n\t    y1 = _ps17$2[1],\n\t    _ps17$3 = _slicedToArray(_ps17[2], 2),\n\t    x2 = _ps17$3[0],\n\t    y2 = _ps17$3[1];\n\n\treturn [[x0, y0], [1 / 3 * x0 + 2 / 3 * x1, 1 / 3 * y0 + 2 / 3 * y1], [2 / 3 * x1 + 1 / 3 * x2, 2 / 3 * y1 + 1 / 3 * y2], [x2, y2]];\n}\n\n/**\r\n * Check if the two given cubic beziers are nearly coincident everywhere.\r\n * @param {number[][]} P - A cubic bezier curve.\r\n * @param {number[][]} Q - Another cubic bezier curve.\r\n * @param {number} δ - An indication of how closely the curves should stay to\r\n * each other before considered coincident.\r\n * @returns \r\n */\nfunction coincident(P, Q, δ) {\n\tif (δ === undefined) {\n\t\tδ = 1e-6;\n\t}\n\n\tvar _P = _slicedToArray(P, 4),\n\t    P0 = _P[0],\n\t    P1 = _P[1],\n\t    P2 = _P[2],\n\t    P3 = _P[3];\n\n\tvar _Q = _slicedToArray(Q, 4),\n\t    Q0 = _Q[0],\n\t    Q1 = _Q[1],\n\t    Q2 = _Q[2],\n\t    Q3 = _Q[3];\n\n\tvar _calcPointAndNeighbor = calcPointAndNeighbor(P, Q, 0),\n\t    pP0 = _calcPointAndNeighbor.pp,\n\t    tPQ0 = _calcPointAndNeighbor.t,\n\t    pPQ0 = _calcPointAndNeighbor.p,\n\t    dPQ0 = _calcPointAndNeighbor.d;\n\n\tvar _calcPointAndNeighbor2 = calcPointAndNeighbor(P, Q, 1),\n\t    pP1 = _calcPointAndNeighbor2.pp,\n\t    tPQ1 = _calcPointAndNeighbor2.t,\n\t    pPQ1 = _calcPointAndNeighbor2.p,\n\t    dPQ1 = _calcPointAndNeighbor2.d;\n\n\tvar _calcPointAndNeighbor3 = calcPointAndNeighbor(Q, P, 0),\n\t    pQ0 = _calcPointAndNeighbor3.pp,\n\t    tQP0 = _calcPointAndNeighbor3.t,\n\t    pQP0 = _calcPointAndNeighbor3.p,\n\t    dQP0 = _calcPointAndNeighbor3.d;\n\n\tvar _calcPointAndNeighbor4 = calcPointAndNeighbor(Q, P, 1),\n\t    pQ1 = _calcPointAndNeighbor4.pp,\n\t    tQP1 = _calcPointAndNeighbor4.t,\n\t    pQP1 = _calcPointAndNeighbor4.p,\n\t    dQP1 = _calcPointAndNeighbor4.d;\n\n\t// Check for start and end points coincident.\n\n\n\tvar tStartQ = 0;\n\tvar tEndQ = 1;\n\tvar tStartP = 0;\n\tvar tEndP = 1;\n\n\tvar count = 0;\n\tif (dPQ0 <= δ) {\n\t\ttStartQ = tPQ0;count++;\n\t}\n\tif (dPQ1 <= δ) {\n\t\ttEndQ = tPQ1;count++;\n\t}\n\tif (dQP0 <= δ) {\n\t\ttStartP = tQP0;count++;\n\t}\n\tif (dQP1 <= δ) {\n\t\ttEndP = tQP1;count++;\n\t}\n\n\t// At least 2 endpoints must be coincident.\n\tif (count < 2) {\n\t\treturn undefined;\n\t}\n\n\tif (tStartP > tEndP) {\n\t\tvar _ref = [tEndP, tStartP];\n\t\ttStartP = _ref[0];\n\t\ttEndP = _ref[1];\n\t}\n\tif (tStartQ > tEndQ) {\n\t\tvar _ref2 = [tEndQ, tStartQ];\n\t\ttStartQ = _ref2[0];\n\t\ttEndQ = _ref2[1];\n\t}\n\n\tvar tSpanP = tEndP - tStartP;\n\tvar tSpanQ = tEndQ - tStartQ;\n\n\t// We must check at least 8 additional points to ensure entire curve\n\t// is coincident, otherwise we may simply have found intersection \n\t// points.\n\t// TODO - Change so that we cut the curves to be about equal and check the\n\t// other two control points for closeness.\n\tvar res = true;\n\tfor (var i = 1; i < 10; i++) {\n\t\tvar t = tStartP + tSpanP * (i / 10);\n\n\t\tvar _calcPointAndNeighbor5 = calcPointAndNeighbor(P, Q, t),\n\t\t    pp = _calcPointAndNeighbor5.pp,\n\t\t    tt = _calcPointAndNeighbor5.t,\n\t\t    pq = _calcPointAndNeighbor5.p,\n\t\t    d = _calcPointAndNeighbor5.d;\n\n\t\tif (d > δ) {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\treturn { p: [tStartP, tEndP], q: [tStartQ, tEndQ] };\n\n\tfunction calcPointAndNeighbor(P, Q, t) {\n\t\t// TODO - must also check crossing of normals - for if two curves open\n\t\t// at endpoints and stop essentially at same point.\n\t\tvar pp1 = evaluate(P)(t);\n\t\tvar normalVector = normal(P)(0);\n\t\tvar pp2 = Vector.translate(pp1, normalVector);\n\t\tvar ts = lineIntersection(Q, [pp1, pp2]);\n\n\t\tvar bestT = undefined;\n\t\tvar bestP = undefined;\n\t\tvar bestD = Number.POSITIVE_INFINITY;\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = ts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar _t2 = _step.value;\n\n\t\t\t\tvar p = evaluate(Q)(_t2);\n\t\t\t\tvar _d = Vector.distanceBetween(p, pp1);\n\t\t\t\tif (_d < bestD) {\n\t\t\t\t\tbestT = _t2;\n\t\t\t\t\tbestP = p;\n\t\t\t\t\tbestD = _d;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn { pp: pp1, t: bestT, p: bestP, d: bestD };\n\t}\n}\n\n/**\r\n * <p>\r\n * Robust, extremely accurate and extremely fast (cubically convergent in \r\n * general with fast iteration steps) algorithm that returns the intersections \r\n * between two cubic beziers.\r\n * </p>\r\n * <p>\r\n * At stretches where the two curves run extremely close to (or on top of) each \r\n * other and curve the same direction an interval is returned instead of a \r\n * point.\r\n * </p>\r\n * <p>\r\n * The algorithm is based on a <a href=\"http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\">paper</a>\r\n * that finds the intersection of a fat line and a so-called geometric interval\r\n * making it faster and more accurate than the standard fat-line intersection\r\n * algorithm. The algorithm has been modified to prevent run-away recursion\r\n * by checking for coincident pieces at subdivision steps.\r\n * </p>\r\n * @param {number[][]} ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\r\n * @param {number[][]} ps2 - Another cubic bezier\r\n * @param {number} [δ] - An optional tolerance to within which the t parameter\r\n * should be calculated - defaults to the minimum value of 24*Number.EPSILON or \r\n * approximately 5e-15. Note that it might not make sense to set this to as \r\n * large as say 1e-5 since only a single iteration later the maximum accuracy \r\n * will be attained and not much speed will be gained anyway. Similarly if δ is \r\n * set to 1e-2 only two iterations will be saved. This is due to the algorithm \r\n * being cubically convergent (usually converging in about 4 to 8 iterations for \r\n * typical intersections).\r\n * @param {number} [Δ] - A tolerance that indicates how closely a stretch of the \r\n * beziers can run together before being considered coincident. Defaults to the\r\n * minimum possible value of 1e-6 if not specified.\r\n * @returns {Object[]} An array that contains the t-value pairs at intersection \r\n * of the first and second beziers respectively. The array can also contain t\r\n * range pairs for coincident pieces that can be either used or ignored\r\n * depending on the application, e.g. the return value might be [[0.1,0.2],\r\n * [0.3,0.5],[[0.4,0.5],[0.6,0.7]]] that indicates intersection points at t \r\n * values of t1=0.1 and t2=0.2 for the first and second bezier respectively as \r\n * well as at t1=0.3 and t2=0.5 and finally indicates the curves to be nearly \r\n * coincident from t1=0.4 to t1=0.5 for the first bezier and t2=0.6 to t=0.7 for\r\n * the second bezier.\r\n */\nfunction bezier3Intersection(ps1, ps2, δ, Δ) {\n\tvar dst = Vector.distanceBetween;\n\tvar sdst = Vector.squaredDistanceBetween;\n\n\t// The minimum value Δ can be. If it is too small the algorithm may take too\n\t// long in cases where the two curves run extremely close to each other for\n\t// their entire length and curve the same direction.\n\tvar ΔMin = 1e-6;\n\n\t// This is an estimate of the relative floating point error during clipping.\n\t// A bound is given by |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k\n\t// are the control points indexed by k=0,1,2,3 and η is machine epsilon, \n\t// i.e. Number.EPSILON. We quadruple the bound to be sure.\n\tvar δMin = 24 * Number.EPSILON;\n\n\t// Maximum error - limited to take rounding error into account.\n\tif (δ === undefined) {\n\t\tδ = 0;\n\t}\n\tδ = Math.max(δ, δMin);\n\tif (Δ === undefined) {\n\t\tΔ = ΔMin;\n\t}\n\tΔ = Math.max(Δ, ΔMin);\n\n\t// Intersection t values for both beziers\n\tvar tss = [];\n\t//let iterations = 0;\n\tintersection(ps1, ps2, [0, 1], [0, 1], 1, 0);\n\t//console.log(iterations);\n\treturn tss;\n\n\t// Helper function\n\tfunction intersection(Q_, P_, qRange, pRange, idx) {\n\t\t//iterations++;\n\t\tvar cidx = idx === 0 ? 1 : 0; // Counter flip-flop index\n\n\t\t// Move intersection toward the origin to prevent serious floating point \n\t\t// issues that are introduced specifically by the getLineEquation \n\t\t// function. This allows us to get a relative error in the final \n\t\t// result usually in the 10 ULPS or less range.\n\n\t\tvar _center = center(P_, Q_);\n\n\t\tvar _center2 = _slicedToArray(_center, 2);\n\n\t\tP_ = _center2[0];\n\t\tQ_ = _center2[1];\n\n\t\tvar _Q_ = Q_,\n\t\t    _Q_2 = _slicedToArray(_Q_, 4),\n\t\t    Q0 = _Q_2[0],\n\t\t    Q1 = _Q_2[1],\n\t\t    Q2 = _Q_2[2],\n\t\t    Q3 = _Q_2[3];\n\n\t\tvar _P_ = P_,\n\t\t    _P_2 = _slicedToArray(_P_, 4),\n\t\t    P0 = _P_2[0],\n\t\t    P1 = _P_2[1],\n\t\t    P2 = _P_2[2],\n\t\t    P3 = _P_2[3];\n\n\t\t// Get the implict line equation for the line from the first to the last\n\t\t// control point of Q. This equation gives the distance between any \n\t\t// point and the line.\n\n\n\t\tvar dQ = getDistanceToLineFunction([Q0, Q3]);\n\n\t\t// Calculate the distance from the control points of Q to the line \n\t\t// [Q0,Q3].\n\t\tvar dQi = function dQi(i) {\n\t\t\treturn dQ(Q_[i]);\n\t\t};\n\t\tvar dQs = [1, 2].map(dQi);\n\n\t\tvar _dQs = _slicedToArray(dQs, 2),\n\t\t    dQ1 = _dQs[0],\n\t\t    dQ2 = _dQs[1];\n\n\t\t// Calculate the fat line of Q.\n\n\n\t\tvar C = dQ1 * dQ2 > 0 ? 3 / 4 : 4 / 9;\n\t\tvar dMin = C * Math.min(0, dQ1, dQ2);\n\t\tvar dMax = C * Math.max(0, dQ1, dQ2);\n\n\t\tvar _geoClip = geoClip(P_, dQ, dMin, dMax),\n\t\t    tMin = _geoClip.tMin,\n\t\t    tMax = _geoClip.tMax;\n\n\t\tif (tMin === Number.POSITIVE_INFINITY) {\n\t\t\treturn; // No intersection\n\t\t}\n\n\t\t// The paper calls for a heuristic that if less than 30% will be\n\t\t// clipped, rather split the longest curve and find intersections in the\n\t\t// two halfs seperately.\n\t\tif (tMax - tMin > 0.7) {\n\t\t\t// Some length measure\n\t\t\tvar pSpan = pRange[1] - pRange[0];\n\t\t\tvar qSpan = qRange[1] - qRange[0];\n\n\t\t\tif (coincident(P_, Q_) !== undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Split the curve in half\n\t\t\tif (pSpan <= qSpan) {\n\t\t\t\tcidx = idx;\n\t\t\t\tvar _ref3 = [Q_, P_];\n\t\t\t\tP_ = _ref3[0];\n\t\t\t\tQ_ = _ref3[1];\n\t\t\t\tvar _ref4 = [qRange, pRange];\n\t\t\t\tpRange = _ref4[0];\n\t\t\t\tqRange = _ref4[1];\n\t\t\t}\n\n\t\t\t// Update t range.\n\t\t\tvar _span = pRange[1] - pRange[0];\n\n\t\t\t// 1st half\n\t\t\tvar tMinA = pRange[0];\n\t\t\tvar tMaxA = tMinA + _span / 2;\n\n\t\t\t// 2nd half\n\t\t\tvar tMinB = tMaxA;\n\t\t\tvar tMaxB = pRange[1];\n\n\t\t\tvar A = fromTo(P_)(0, 0.5);\n\t\t\tvar B = fromTo(P_)(0.5, 1);\n\t\t\tintersection(A, Q_, [tMinA, tMaxA], qRange, cidx);\n\t\t\tintersection(B, Q_, [tMinB, tMaxB], qRange, cidx);\n\t\t\treturn;\n\t\t}\n\n\t\t// Update t range.\n\t\tvar span = pRange[1] - pRange[0];\n\t\tvar tMin_ = tMin * span + pRange[0];\n\t\tvar tMax_ = tMax * span + pRange[0];\n\n\t\t// Clip\n\t\tP_ = fromTo(P_)(tMin, tMax);\n\n\t\tif (Math.abs(tMax_ - tMin_) < δ) {\n\t\t\tvar t1 = (tMax_ + tMin_) / 2;\n\t\t\tvar t2 = calcOtherT.apply(undefined, [t1].concat(_toConsumableArray([[ps1, ps2], [ps2, ps1]][idx])));\n\t\t\tif (t2 === undefined) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\ttss.push([[t2, t1], [t1, t2]][idx]);\n\t\t\treturn;\n\t\t}\n\n\t\t// Swap Q and P and iterate.\n\t\tintersection(P_, Q_, [tMin_, tMax_], qRange, cidx);\n\t}\n\n\tfunction geoClip(P, dQ, dMin, dMax) {\n\t\tvar dPi = function dPi(i) {\n\t\t\treturn dQ(P[i]);\n\t\t};\n\t\tvar dPs = [0, 1, 2, 3].map(dPi);\n\n\t\tvar _dPs = _slicedToArray(dPs, 4),\n\t\t    dP0 = _dPs[0],\n\t\t    dP1 = _dPs[1],\n\t\t    dP2 = _dPs[2],\n\t\t    dP3 = _dPs[3];\n\n\t\tvar hq = toHybridQuadratic(P);\n\t\tvar dH0 = dQ(hq[0]);\n\t\tvar dH2 = dQ(hq[2]);\n\t\tvar dH10 = dQ(hq[1][0]);\n\t\tvar dH11 = dQ(hq[1][1]);\n\t\tvar dHmin = Math.min(dH10, dH11);\n\t\tvar dHmax = Math.max(dH10, dH11);\n\n\t\tvar DyMin = [dH0 - 2 * dHmin + dH2, -2 * dH0 + 2 * dHmin, dH0];\n\n\t\tvar DyMax = [dH0 - 2 * dHmax + dH2, -2 * dH0 + 2 * dHmax, dH0];\n\n\t\tvar errorBound = 2 * Math.max(Poly.hornerErrorBound(DyMin, 1), Poly.hornerErrorBound(DyMax, 1));\n\t\tdMin = dMin - errorBound;\n\t\tdMax = dMax + errorBound;\n\n\t\tvar DyMinMin = DyMin.slice();\n\t\tDyMinMin[2] = DyMinMin[2] - dMin;\n\t\tvar DyMinMax = DyMin.slice();\n\t\tDyMinMax[2] = DyMinMax[2] - dMax;\n\n\t\tvar DyMaxMin = DyMax.slice();\n\t\tDyMaxMin[2] = DyMaxMin[2] - dMin;\n\t\tvar DyMaxMax = DyMax.slice();\n\t\tDyMaxMax[2] = DyMaxMax[2] - dMax;\n\n\t\tvar tMin = Number.POSITIVE_INFINITY;\n\t\tvar tMax = Number.NEGATIVE_INFINITY;\n\n\t\tvar rootsMinMin = Poly.allRoots(DyMinMin, 0, 1);\n\t\tvar rootsMinMax = Poly.allRoots(DyMinMax, 0, 1);\n\t\tvar rootsMaxMin = Poly.allRoots(DyMaxMin, 0, 1);\n\t\tvar rootsMaxMax = Poly.allRoots(DyMaxMax, 0, 1);\n\t\ttMin = Math.min.apply(Math, _toConsumableArray(rootsMinMin).concat(_toConsumableArray(rootsMinMax), _toConsumableArray(rootsMaxMin), _toConsumableArray(rootsMaxMax)));\n\t\ttMax = Math.max.apply(Math, _toConsumableArray(rootsMinMin).concat(_toConsumableArray(rootsMinMax), _toConsumableArray(rootsMaxMin), _toConsumableArray(rootsMaxMax)));\n\n\t\tif (dH0 >= dMin && dH0 <= dMax) {\n\t\t\ttMin = 0;\n\t\t}\n\t\tif (dH2 >= dMin && dH2 <= dMax) {\n\t\t\ttMax = 1;\n\t\t}\n\n\t\tif (tMin < 0) {\n\t\t\ttMin = 0;\n\t\t}\n\t\tif (tMax > 1) {\n\t\t\ttMax = 1;\n\t\t}\n\n\t\treturn { tMin: tMin, tMax: tMax };\n\t}\n\n\t/**\r\n  * Return the given two beziers but translated such that the shorter (by\r\n  * some length measure) is closer to the origin.\r\n  * @ignore\r\n  * @param {number[][]} P \r\n  * @param {number[][]} Q \r\n  */\n\tfunction center(P, Q) {\n\t\tvar _P2 = P,\n\t\t    _P3 = _slicedToArray(_P2, 4),\n\t\t    P0 = _P3[0],\n\t\t    P1 = _P3[1],\n\t\t    P2 = _P3[2],\n\t\t    P3 = _P3[3];\n\n\t\tvar _Q2 = Q,\n\t\t    _Q3 = _slicedToArray(_Q2, 4),\n\t\t    Q0 = _Q3[0],\n\t\t    Q1 = _Q3[1],\n\t\t    Q2 = _Q3[2],\n\t\t    Q3 = _Q3[3];\n\n\t\tvar lengthP = sdst(P0, P1) + sdst(P1, P2) + sdst(P2, P3);\n\t\tvar lengthQ = sdst(Q0, Q1) + sdst(Q1, Q2) + sdst(Q2, Q3);\n\n\t\tvar moveX = void 0;\n\t\tvar moveY = void 0;\n\t\tif (lengthQ < lengthP) {\n\t\t\tmoveX = (Q0[0] + Q1[0] + Q2[0] + Q3[0]) / 4;\n\t\t\tmoveY = (Q0[1] + Q1[1] + Q2[1] + Q3[1]) / 4;\n\t\t} else {\n\t\t\tmoveX = (P0[0] + P1[0] + P2[0] + P3[0]) / 4;\n\t\t\tmoveY = (P0[1] + P1[1] + P2[1] + P3[1]) / 4;\n\t\t}\n\t\tP = P.map(function (x) {\n\t\t\treturn [x[0] - moveX, x[1] - moveY];\n\t\t});\n\t\tQ = Q.map(function (x) {\n\t\t\treturn [x[0] - moveX, x[1] - moveY];\n\t\t});\n\n\t\treturn [P, Q];\n\t}\n\n\t/**\r\n  * Calculates the t-value of the closest point on Q to P(t).\r\n  * @ignore\r\n  * @param {number}\r\n  * @param {number[][]} Q \r\n  * @param {number[][]} P \r\n  */\n\tfunction calcOtherT(t, P, Q) {\n\t\tvar pp = evaluate(P)(t);\n\n\t\tvar _pp = _slicedToArray(pp, 2),\n\t\t    x = _pp[0],\n\t\t    y = _pp[1];\n\n\t\tvar tqsh = tsAtY(Q, y);\n\t\tvar tqsv = tsAtX(Q, x);\n\t\tif (!tqsh.length && !tqsv.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tvar tqs = [].concat(tqsh, tqsv);\n\n\t\tvar bestT = undefined;\n\t\tvar bestD = Number.POSITIVE_INFINITY;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = tqs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar tq = _step2.value;\n\n\t\t\t\tvar pq = evaluate(Q)(tq);\n\t\t\t\tvar d = sdst(pp, pq);\n\t\t\t\tif (d < bestD) {\n\t\t\t\t\tbestD = d;\n\t\t\t\t\tbestT = tq;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn bestT;\n\t}\n}\n\n/**\r\n * Get the implicit line equation from two 2d points in the form f(x,y) ax + by + c = 0\r\n * returned as the array [a,b,c].\r\n * @ignore\r\n * @param {number[][]} l - A line given by two points, e.g. [[2,0],[3,3]]\r\n * @returns {number[]}\r\n */\nfunction getLineEquation(l) {\n\tvar _l3 = _slicedToArray(l, 2),\n\t    _l3$ = _slicedToArray(_l3[0], 2),\n\t    x1 = _l3$[0],\n\t    y1 = _l3$[1],\n\t    _l3$2 = _slicedToArray(_l3[1], 2),\n\t    x2 = _l3$2[0],\n\t    y2 = _l3$2[1];\n\n\tvar a = y1 - y2;\n\tvar b = x2 - x1;\n\tvar c = x1 * y2 - x2 * y1;\n\n\treturn [a, b, c];\n}\n\nfunction getDistanceToLineFunction(l) {\n\t//let [a,b,c] = getNormalizedLineEquation(l);\n\tvar _getLineEquation = getLineEquation(l),\n\t    _getLineEquation2 = _slicedToArray(_getLineEquation, 3),\n\t    a = _getLineEquation2[0],\n\t    b = _getLineEquation2[1],\n\t    c = _getLineEquation2[2];\n\n\treturn function (p) {\n\t\treturn a * p[0] + b * p[1] + c;\n\t};\n}\n\n/**\r\n * Get the implicit line equation from two 2d points in the form f(x,y) ax + by + c = 0\r\n * where a^2 + b^2 = 1 returned as the array [a,b,c].\r\n * @param {number[][]} l - A line given by two points, e.g. [[2,0],[3,3]]\r\n * @returns {number[]}\r\n * @example\r\n * getNormalizedLineEquation([[1,0],[5,3]]); //=> [-0.6, 0.8, 0.6]\r\n */\nfunction getNormalizedLineEquation(l) {\n\tvar _l4 = _slicedToArray(l, 2),\n\t    _l4$ = _slicedToArray(_l4[0], 2),\n\t    x1 = _l4$[0],\n\t    y1 = _l4$[1],\n\t    _l4$2 = _slicedToArray(_l4[1], 2),\n\t    x2 = _l4$2[0],\n\t    y2 = _l4$2[1];\n\n\tvar a = y1 - y2;\n\tvar b = x2 - x1;\n\tvar c = x1 * y2 - x2 * y1;\n\n\tvar norm = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));\n\n\t// Normalize it\n\ta = a / norm;\n\tb = b / norm;\n\tc = c / norm;\n\n\treturn [a, b, c];\n}\n\n/**\r\n * Returns the given points (e.g. bezier) in reverse order.\r\n * @param {number[][]} ps\r\n * @returns {number[][]}\r\n */\nfunction reverse(ps) {\n\treturn ps.slice().reverse();\n}\n\n/**\r\n * <p>\r\n * Purely functional cubic bezier library, including robust \r\n * cubic-cubic bezier intersection.\r\n * </p>\r\n * <p> \r\n * A cubic bezier is represented as an array of points, i.e. \r\n * [p0, p1, p2, p3] where each point is an ordered pair, e.g. \r\n * [[0,0],[1,1],[2,1],[3,0]].\r\n * </p>\r\n */\nvar Bezier3 = {\n\trotate: rotate,\n\tgetX: getX,\n\tgetY: getY,\n\tgetDx: getDx,\n\tgetDy: getDy,\n\tgetDdx: getDdx,\n\tgetDdy: getDdy,\n\tgetDddx: getDddx,\n\tgetDddy: getDddy,\n\tgetBounds: getBounds,\n\tbezier3Intersection: bezier3Intersection,\n\tlineIntersection: lineIntersection,\n\ttsAtX: tsAtX,\n\ttsAtY: tsAtY,\n\tgetBoundingHull: getBoundingHull,\n\tfromLine: fromLine,\n\ttranslate: translate,\n\tevaluate: evaluate,\n\tκ: κ,\n\tdκMod: dκMod,\n\tcurvature: curvature,\n\ttangent: tangent,\n\tnormal: normal,\n\ttotalCurvature: totalCurvature,\n\ttotalAbsoluteCurvature: totalAbsoluteCurvature,\n\tlength: length,\n\tgetTAtLength: getTAtLength,\n\tevaluateX: evaluateX,\n\tevaluateY: evaluateY,\n\tevaluateDx: evaluateDx,\n\tevaluateDy: evaluateDy,\n\tevaluateDdx: evaluateDdx,\n\tevaluateDdy: evaluateDdy,\n\tevaluateDddx: evaluateDddx,\n\tevaluateDddy: evaluateDddy,\n\tgetBoundingBoxTight: getBoundingBoxTight,\n\tgetBoundingBox: getBoundingBox,\n\tfromTo: fromTo,\n\tsplitAt: splitAt,\n\tscale: scale,\n\ttoCubic: toCubic,\n\ttoQuadratic: toQuadratic,\n\ttoHybridQuadratic: toHybridQuadratic,\n\tevaluateHybridQuadratic: evaluateHybridQuadratic,\n\tevaluateQuadratic: evaluateQuadratic,\n\tevaluateLinear: evaluateLinear,\n\tcoincident: coincident,\n\tfrom0ToT: from0ToT,\n\tfromTTo1: fromTTo1,\n\tclone: clone,\n\treverse: reverse\n};\n\nmodule.exports = Bezier3;\n\n},{\"flo-gauss-quadrature\":2,\"flo-graham-scan\":3,\"flo-memoize\":4,\"flo-poly\":5,\"flo-vector2d\":6}],2:[function(_dereq_,module,exports){\n'use strict';\n\n// TODO A future improvement can be to use the Gauss–Kronrod rules\n// to estimate the error and thus choose a number of constants based\n// on the error.\n// TODO In future, the constants can be calculated and cached so we can\n// chooce any value for the order.\n\n\n/** \r\n * <p>\r\n * Integrates the given function using the Gaussian Quadrature method.\r\n * </p>\r\n * <p> \r\n * See https://en.wikipedia.org/wiki/Gaussian_quadrature\r\n * </p>\r\n * <p>\r\n * See http://pomax.github.io/bezierinfo/#arclength\r\n * </p>\r\n * \r\n * @param {function} f - The univariate function to be integrated\r\n * @param {number[]} interval - The integration interval\r\n * @param {number} order - Can be 2, 4, 8, or 16. Higher values give \r\n * more accurate results but is slower - defaults to 16.\r\n */\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction gaussQuadrature(f, interval, order) {\n\torder = order === undefined ? 16 : order;\n\tif (interval[0] === interval[1]) {\n\t\treturn 0;\n\t}\n\n\tvar _GAUSS_CONSTANTS$orde = GAUSS_CONSTANTS[order],\n\t    weights = _GAUSS_CONSTANTS$orde.weights,\n\t    abscissas = _GAUSS_CONSTANTS$orde.abscissas;\n\n\tvar _interval = _slicedToArray(interval, 2),\n\t    a = _interval[0],\n\t    b = _interval[1];\n\n\tvar result = 0;\n\tvar m1 = (b - a) / 2;\n\tvar m2 = (b + a) / 2;\n\tfor (var i = 0; i <= order - 1; i++) {\n\t\tresult += weights[i] * f(m1 * abscissas[i] + m2);\n\t}\n\n\treturn m1 * result;\n}\n\n// The Gaussian Legendre Quadrature method constants. \nvar GAUSS_CONSTANTS = {\n\t2: {\n\t\tweights: [1, 1],\n\t\tabscissas: [-0.5773502691896257, 0.5773502691896257]\n\t},\n\t4: {\n\t\tweights: [0.6521451548625461, 0.6521451548625461, 0.3478548451374538, 0.3478548451374538],\n\t\tabscissas: [-0.3399810435848563, 0.3399810435848563, -0.8611363115940526, 0.8611363115940526]\n\t},\n\t8: {\n\t\tweights: [0.3626837833783620, 0.3626837833783620, 0.3137066458778873, 0.3137066458778873, 0.2223810344533745, 0.2223810344533745, 0.1012285362903763, 0.1012285362903763],\n\t\tabscissas: [-0.1834346424956498, 0.1834346424956498, -0.5255324099163290, 0.5255324099163290, -0.7966664774136267, 0.7966664774136267, -0.9602898564975363, 0.9602898564975363]\n\t},\n\t// Taken from http://keisan.casio.com/exec/system/1330940731\n\t16: {\n\t\tabscissas: [-0.989400934991649932596, -0.944575023073232576078, -0.86563120238783174388, -0.7554044083550030338951, -0.6178762444026437484467, -0.4580167776572273863424, -0.28160355077925891323, -0.0950125098376374401853, 0.0950125098376374401853, 0.28160355077925891323, 0.4580167776572273863424, 0.617876244402643748447, 0.755404408355003033895, 0.8656312023878317438805, 0.944575023073232576078, 0.989400934991649932596],\n\t\tweights: [0.0271524594117540948518, 0.062253523938647892863, 0.0951585116824927848099, 0.1246289712555338720525, 0.1495959888165767320815, 0.169156519395002538189, 0.182603415044923588867, 0.189450610455068496285, 0.1894506104550684962854, 0.182603415044923588867, 0.1691565193950025381893, 0.149595988816576732081, 0.124628971255533872053, 0.095158511682492784809, 0.062253523938647892863, 0.027152459411754094852]\n\t}\n};\n\nmodule.exports = gaussQuadrature;\n\n},{}],3:[function(_dereq_,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar Vector = _dereq_('flo-vector2d');\n\nvar DELTA = 1e-10;\n\n/**\r\n * Performs a functional stable sort on the given array and \r\n * returns the newly sorted array.\r\n * @ignore\r\n */\nfunction stableSort(arr, f) {\n\tvar indxArray = [];\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tindxArray.push(i);\n\t}\n\n\tindxArray.sort(function (a, b) {\n\t\tvar res = f(arr[a], arr[b]);\n\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\n\t\treturn a - b;\n\t});\n\n\tvar sorted = [];\n\tfor (var _i = 0; _i < arr.length; _i++) {\n\t\tsorted.push(arr[indxArray[_i]]);\n\t}\n\n\treturn sorted;\n}\n\n/**\r\n * In-place swap two elements in the given array.\r\n * @ignore\r\n */\nfunction swap(arr, a, b) {\n\tif (a === b) {\n\t\treturn;\n\t}\n\n\tvar temp = arr[a];\n\tarr[a] = arr[b];\n\tarr[b] = temp;\n}\n\n/**\r\n * @ignore\r\n */\nfunction getSmallestIndxYThenX(ps) {\n\tvar smallest = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n\tvar smallestI = void 0;\n\tfor (var i = 0; i < ps.length; i++) {\n\t\tvar y = ps[i][1];\n\t\tif (y < smallest[1] || y === smallest[1] && ps[i][0] < smallest[0]) {\n\t\t\tsmallestI = i;\n\t\t\tsmallest = ps[i];\n\t\t}\n\t}\n\n\treturn smallestI;\n}\n\n/** \r\n * <p>\r\n * Finds the convex hull of the given set of 2d points using the   \r\n * Graham Scan algorithm and returns the hull as an array of points. \r\n * </p>\r\n * <p>\r\n * See https://en.wikipedia.org/wiki/Graham_scan\r\n * </p>\r\n * @param {number[][]} ps_ - A set of points\r\n * @param {boolean} includeAllBoundaryPoints - Set this to true to if all boundary points\r\n * should be returned, even redundant ones - defaults to false\r\n * @param {number} delta - Tolerance at which three points are considered collinear -\r\n * defaults to 1e-10\r\n * @returns {number[][]}\r\n */\nfunction grahamScan(ps_, includeAllBoundaryPoints, delta) {\n\tincludeAllBoundaryPoints = !!includeAllBoundaryPoints;\n\tdelta = delta === undefined ? DELTA : delta;\n\n\tfunction fail(p1, p2, p3) {\n\t\tvar res = Vector.ccw(p1, p2, p3, delta);\n\t\tif (includeAllBoundaryPoints) {\n\t\t\treturn res < 0;\n\t\t}\n\t\treturn res <= 0;\n\t}\n\n\tvar ps = ps_.slice();\n\tvar n = ps.length;\n\n\tvar idx = getSmallestIndxYThenX(ps);\n\n\tvar _ps$splice = ps.splice(idx, 1),\n\t    _ps$splice2 = _slicedToArray(_ps$splice, 1),\n\t    p = _ps$splice2[0];\n\n\tps = stableSort(ps, function (a, b) {\n\t\tvar res = Vector.cross(Vector.fromTo(p, b), Vector.fromTo(p, a));\n\t\tres = Math.abs(res) < delta ? 0 : res;\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\n\t\tres = a[1] - b[1];\n\t\tres = Math.abs(res) < delta ? 0 : res;\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\n\t\treturn a[0] - b[0];\n\t});\n\n\tps.unshift(p);\n\n\tvar m = 1;\n\tfor (var i = 2; i < n; i++) {\n\t\twhile (fail(ps[m - 1], ps[m], ps[i])) {\n\t\t\tif (m > 1) {\n\t\t\t\tm -= 1;\n\t\t\t\tcontinue;\n\t\t\t} else if (i === n - 1) {\n\t\t\t\tm -= 1;\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\ti += 1;\n\t\t\t}\n\t\t}\n\n\t\tm += 1;\n\t\tswap(ps, m, i);\n\t}\n\n\treturn ps.slice(0, m + 1);\n}\n\nmodule.exports = grahamScan;\n\n},{\"flo-vector2d\":6}],4:[function(_dereq_,module,exports){\n'use strict';\n\n/**\r\n * Memoization functions\r\n */\n\nvar Memoize = { m1: m1 };\n\nvar SUPPORTED = typeof WeakMap === 'function';\n\n/**\r\n * Memoize the given function. The function must have an arity of 1.\r\n */\nfunction m1(f) {\n\tif (!SUPPORTED) {\n\t\treturn f;\n\t}\n\n\tvar results = new WeakMap();\n\n\treturn function (param1) {\n\t\tvar result = results.get(param1);\n\t\tif (result !== undefined) {\n\t\t\t//console.log('cache hit');\n\t\t\treturn result;\n\t\t}\n\t\t//console.log('cache miss');\n\n\t\tresult = f(param1);\n\t\tresults.set(param1, result);\n\n\t\treturn result;\n\t};\n}\n\nmodule.exports = Memoize;\n\n},{}],5:[function(_dereq_,module,exports){\n(function (global){\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.FloPoly = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_==\"function\"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_==\"function\"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){\n'use strict';\n\nvar coreOperators = _dereq_('./core-operators.js');\nvar rootOperators = _dereq_('./root-operators.js');\nvar rootBounds = _dereq_('./root-bounds.js');\n\nvar brent = rootOperators.brent,\n    quadraticRoots = rootOperators.quadraticRoots;\nvar clip0 = coreOperators.clip0,\n    evaluate = coreOperators.evaluate,\n    differentiate = coreOperators.differentiate,\n    toCasStr = coreOperators.toCasStr;\nvar rootMagnitudeUpperBound_fujiwara = rootBounds.rootMagnitudeUpperBound_fujiwara,\n    positiveRootUpperBound_LMQ = rootBounds.positiveRootUpperBound_LMQ,\n    positiveRootLowerBound_LMQ = rootBounds.positiveRootLowerBound_LMQ,\n    negativeRootUpperBound_LMQ = rootBounds.negativeRootUpperBound_LMQ,\n    negativeRootLowerBound_LMQ = rootBounds.negativeRootLowerBound_LMQ;\n\n\nvar INF = Number.POSITIVE_INFINITY;\n\n/**\r\n * <p>Finds a near optimal approximation to the real roots (or those \r\n * within a range) of the input polynomial.\r\n * </p>\r\n * <p>\r\n * Only multiple roots of even order that is very close together may be \r\n * missed. (This is rarely a problem in practice - in a geometrical \r\n * application, for instance, this may mean two objects are barely \r\n * touching and returning either, all, or none of the repeated even \r\n * roots should not break the algorithm). \r\n * </p>\r\n * \r\n * @alias allRoots\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - Lower limit of root values that should be \r\n * returned - defaults to -∞\r\n * @param {number} b - Upper limit of root values that should be \r\n * returned - defaults to +∞\r\n * @returns {number[]} The found roots.\r\n * @impl_notes\r\n * @example\r\n * FloPoly.allRoots([1, -10, 35, -50, 24]); //=> [1, 2.0000000000000036, 3.0000000000000067, 4] \r\n */\nfunction allRootsRecursive(p, a, b) {\n\tp = clip0(p);\n\ta = a === undefined ? -INF : a;\n\tb = b === undefined ? +INF : b;\n\n\tvar d = p.length - 1;\n\tvar rangeFilter = inRange(a, b);\n\n\tif (d === 2) {\n\t\treturn quadraticRoots(p).filter(rangeFilter);\n\t\t// Investigate if any numerically stable algorithm could be as fast\n\t\t// as this algorithm (i.e by finding cubic roots within quadratic\n\t\t// root demarcated intervals via Brent's method. The cubicRoots \n\t\t// algoritm below has been removed since it was numerically \n\t\t// unstable.\n\t\t/*} else if (d === 3) {\r\n  \treturn cubicRoots(p)\r\n  \t\t.filter(rangeFilter)\r\n  \t\t.sort((a,b) => a-b)\r\n  } else if (d > 3) {*/\n\t} else if (d > 2) {\n\t\t// TODO The root bounding function below might have an impact on \n\t\t// performance - it would probably be better to use \n\t\t// positiveRootUpperBound_LMQ or (possibly) even better, the \n\t\t// linear version of it (see paper of Viglas, Akritas and \n\t\t// Strzebonski) and re-calculate bounds on every iteration.\n\t\tvar lowerBound = void 0;\n\t\tvar upperBound = void 0;\n\t\tif (a === -INF || b === +INF) {\n\t\t\t//let magnitudeBound = rootMagnitudeUpperBound_fujiwara(p);\n\t\t\t//lowerBound = a === -INF ? -magnitudeBound : a;\n\t\t\t//upperBound = b === +INF ? +magnitudeBound : b;\n\n\t\t\tif (a === -INF) {\n\t\t\t\tlowerBound = negativeRootLowerBound_LMQ(p);\n\t\t\t} else {\n\t\t\t\tlowerBound = a;\n\t\t\t}\n\t\t\tif (b === +INF) {\n\t\t\t\tupperBound = positiveRootUpperBound_LMQ(p);\n\t\t\t} else {\n\t\t\t\tupperBound = b;\n\t\t\t}\n\t\t} else {\n\t\t\tlowerBound = a;\n\t\t\tupperBound = b;\n\t\t}\n\n\t\t// If the roots of the differentiated polynomial is out of range \n\t\t// then the roots of the polynomial itself will also be out of \n\t\t// range.\n\t\tvar dp = differentiate(p);\n\t\tvar roots = allRootsRecursive(dp, lowerBound, upperBound).filter(rangeFilter);\n\n\t\tif (roots[0] !== lowerBound) {\n\t\t\t// For code coverage to cover the 'else' case we would need\n\t\t\t// to find a case where the lower bound actually matches the\n\t\t\t// root which would be very rare - needs further \n\t\t\t// investigation.\n\n\t\t\t// Not an actual root.\n\t\t\troots.unshift(lowerBound);\n\t\t}\n\t\tif (roots[roots.length - 1] !== upperBound) {\n\t\t\t// Not an actual root.\n\t\t\troots.push(upperBound);\n\t\t}\n\t\treturn rootsWithin(p, roots);\n\t} else if (d === 1) {\n\t\t// Less likely so put near bottom (micro optimization)\n\t\treturn [-p[1] / p[0]].filter(rangeFilter);\n\t} else if (d === 0) {\n\t\treturn []; // y = c -> no roots\t\n\t}\n\n\t// Least likely so put at bottom (micro optimization)\n\t// d === -1\n\t// y = 0 -> infinite number of roots\n\treturn [];\n}\n\n/**\r\n * Returns a function that returns true if x is in the range [a,b].\r\n *  \r\n * @ignore\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {function}\r\n */\nfunction inRange(a, b) {\n\treturn function (x) {\n\t\treturn x >= a && x <= b;\n\t};\n}\n\n/**\r\n * Finds all roots of the given polynomial within the given intervals.\r\n *  \r\n * @ignore\r\n * @param {number[]} p\r\n * @param {number[]} intervals\r\n * @returns {number[]} The found roots.\r\n */\nfunction rootsWithin(p, intervals) {\n\n\tvar roots = [];\n\tvar peval = evaluate(p);\n\n\tvar prevRoot = void 0;\n\tvar a = intervals[0];\n\tfor (var i = 1; i < intervals.length; i++) {\n\t\tvar root = void 0;\n\t\tvar b = intervals[i];\n\n\t\tvar evA = peval(a);\n\t\tvar evB = peval(b);\n\n\t\tvar k = evA * evB;\n\n\t\tif (k === 0) {\n\t\t\tif (evA === 0) {\n\t\t\t\troot = a;\n\t\t\t} else if (evB === 0 && i === intervals.length - 1) {\n\t\t\t\troot = b;\n\t\t\t}\n\t\t} else if (evA * evB < 0) {\n\t\t\troot = brent(peval, a, b);\n\t\t}\n\n\t\t// Add root if it exists and suppress exact duplicates\n\t\tif (root !== undefined && root !== prevRoot) {\n\t\t\troots.push(root);\n\t\t\tprevRoot = root;\n\t\t}\n\n\t\ta = b;\n\t}\n\n\treturn roots;\n}\n\nmodule.exports = allRootsRecursive;\n\n},{\"./core-operators.js\":2,\"./root-bounds.js\":7,\"./root-operators.js\":8}],2:[function(_dereq_,module,exports){\n'use strict';\n\nvar coreOperators = {\n\tequal: equal,\n\tadd: add,\n\tsubtract: subtract,\n\tmultiplyByConst: multiplyByConst,\n\tnegate: negate,\n\tdifferentiate: differentiate,\n\tmultiply: multiply,\n\tdegree: degree,\n\tevaluate: evaluate,\n\tevaluateAt0: evaluateAt0,\n\tsignChanges: signChanges,\n\tinvert: invert,\n\tchangeVariables: changeVariables,\n\treflectAboutYAxis: reflectAboutYAxis,\n\tsturmChain: sturmChain,\n\tclip: clip,\n\tclip0: clip0,\n\tdeflate: deflate,\n\tmaxCoefficient: maxCoefficient,\n\ttoCasStr: toCasStr\n\n\t/**\r\n  * Returns true if two polynomials are exactly equal by comparing \r\n  * coefficients.\r\n  * \r\n  * @param {number[]} p1 - A polynomial\r\n  * @param {number[]} p2 - Another polynomial \r\n  * @returns {boolean} True if exactly equal, false otherwise.\r\n  * @example\r\n  * FloPoly.equal([1,2,3,4], [1,2,3,4]);   //=> true\r\n  * FloPoly.equal([1,2,3,4], [1,2,3,4,5]); //=> false\r\n  */\n};function equal(p1, p2) {\n\tif (p1.length !== p2.length) {\n\t\treturn false;\n\t}\n\tfor (var i = 0; i < p1.length; i++) {\n\t\tif (p1[i] !== p2[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\n/**\r\n * Adds two polynomials.\r\n * \r\n * @param {number[]} p1 - The first polynomial\r\n * @param {number[]} p2 - The second polynomial\r\n * @returns {number[]} p1 + p2.\r\n * @example\r\n * FloPoly.add([1,2,3],[3,4]); //=> [1,5,7]\r\n */\nfunction add(p1, p2) {\n\t// Initialize result array  \n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar Δd = d1 - d2;\n\n\tvar Δd1 = 0;\n\tvar Δd2 = 0;\n\tif (Δd > 0) {\n\t\tΔd2 = -Δd;\n\t} else if (Δd < 0) {\n\t\tΔd1 = +Δd;\n\t}\n\n\tvar d = Math.max(d1, d2);\n\n\t// Add coefficients\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar c1 = p1[i + Δd1];\n\t\tvar c2 = p2[i + Δd2];\n\t\tresult.push((c1 || 0) + (c2 || 0));\n\t}\n\n\t// Ensure the result is a valid polynomial representation\n\treturn clip0(result);\n}\n\n/** \r\n * Subtracts the second polynomial from first.\r\n * \r\n * @param {number[]} p1 - The polynomial from which will be subtracted\r\n * @param {number[]} p2 - The polynomial that will be subtracted\r\n * @returns {number[]} p1 - p2\r\n * @example\r\n * FloPoly.subtract([2,3],[4,4]); //=> [-2, -1]\r\n */\nfunction subtract(p1, p2) {\n\t// Initialize result array  \n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar Δd = d1 - d2;\n\n\tvar Δd1 = 0;\n\tvar Δd2 = 0;\n\tif (Δd > 0) {\n\t\tΔd2 = -Δd;\n\t} else if (Δd < 0) {\n\t\tΔd1 = +Δd;\n\t}\n\n\tvar d = Math.max(d1, d2);\n\n\t// Add coefficients\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar c1 = p1[i + Δd1];\n\t\tvar c2 = p2[i + Δd2];\n\t\tresult.push((c1 || 0) - (c2 || 0));\n\t}\n\n\t// Ensure the result is a valid polynomial representation\n\treturn clip0(result);\n}\n\n/**\r\n * Negate the given polynomial (p -> -p).  \r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} -p\r\n * @example\r\n * FloPoly.negate([0.1, -0.2]); //=> [-0.1, 0.2]\r\n */\nfunction negate(p) {\n\treturn multiplyByConst(-1, p);\n}\n\n/**  \r\n * Differentiates the given polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} D(p)\r\n * @example\r\n * FloPoly.differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]\r\n */\nfunction differentiate(p) {\n\n\tvar result = [];\n\n\tvar d = p.length - 1;\n\tfor (var i = 0; i < d; i++) {\n\t\tresult.push((d - i) * p[i]);\n\t}\n\n\treturn result;\n}\n\n/**\r\n * <p> \r\n * Multiplies the two given polynomials and returns the result. \r\n * </p>\r\n * <p>\r\n * See <a href=\"https://en.wikipedia.org/wiki/Polynomial_arithmetic\">polynomial arithmetic</a>\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication\">polynomial multiplication</a>\r\n * </p>\r\n * <p>\r\n * See <a herf=\"http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf\">polynomial multiplication (pdf)</a>\r\n * </p>\r\n * @param {number[]} p1 - The one polynomial.\r\n * @param {number[]} p2 - The other polynomial.\r\n * @returns {number[]} p1 * p2\r\n * @example\r\n * FloPoly.multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]\r\n */\n// TODO Currently using O(n^2) algorithm - possibly change to a faster  \n// FFT algorithm for high degree polynomials? No, we are interested in\n// polynomials of degree 20 or lower.\nfunction multiply(p1, p2) {\n\tvar d1 = p1.length - 1;\n\tvar d2 = p2.length - 1;\n\tvar d = d1 + d2;\n\n\tvar result = new Array(d + 1).fill(0);\n\tfor (var i = 0; i < d1 + 1; i++) {\n\t\tfor (var j = 0; j < d2 + 1; j++) {\n\t\t\tresult[d - (i + j)] += p1[d1 - i] * p2[d2 - j];\n\t\t}\n\t}\n\n\treturn clip0(result);\n}\n\n/** \r\n * Multiplies 2 polynomials by a constant.\r\n * \r\n * @param {number} c - The constant\r\n * @param {number[]} p - The polynomial\r\n * @returns {number[]} c*p\r\n * @example \r\n * FloPoly.multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]  \r\n */\nfunction multiplyByConst(c, p) {\n\tif (c === 0) {\n\t\treturn [];\n\t}\n\n\tvar d = p.length - 1;\n\tvar result = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tresult.push(c * p[i]);\n\t}\n\n\t// We have to clip due to possible floating point underflow\n\treturn clip0(result);\n}\n\n/** \r\n * Returns the degree of the polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} \r\n * @example \r\n * FloPoly.degree([9,8,7,6,5,4,3,2,1]); //=> 9\r\n */\nfunction degree(p) {\n\treturn p.length - 1;\n}\n\n/** \r\n * Evaluates a univariate polynomial using Horner's method. This \r\n * function is curried (see examples below).  \r\n * \r\n * @see https://en.wikipedia.org/wiki/Horner%27s_method\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - The value at which to evaluate the polynomial.\r\n * @returns {number|function} The result if both parameters are supplied\r\n * or a function with arity one if only the first parameter is supplied.\r\n * @example\r\n * let ev = FloPoly.evaluate([3,2,1]);\r\n * ev(1); // => 6\r\n * ev(2); // => 17\r\n * \t\t \r\n * FloPoly.evaluate([3,2,1], 1); // => 6\r\n * FloPoly.evaluate([3,2,1], 2); // => 17\r\n * \r\n * FloPoly.evaluate([3,2,1])(1); // => 6\r\n * FloPoly.evaluate([3,2,1])(2); // => 17\r\n */\nfunction evaluate(p, a) {\n\tfunction evaluate(a) {\n\t\t//if p.length === 0 { return 0; }\n\t\tvar result = p[0];\n\t\tfor (var i = 1; i < p.length; i++) {\n\t\t\tresult = p[i] + result * a;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// Curry the function\n\treturn a === undefined ? evaluate : evaluate(a);\n}\n\n/** \r\n * Evaluates the given polynomial at 0 - it is much faster than at an \r\n * arbitrary point. \r\n *  \r\n * @param {number[]} p - The polynomial\r\n * @returns {number}\r\n * @example\r\n * FloPoly.evaluateAt0([3,2,99]); //=> 99\r\n */\nfunction evaluateAt0(p) {\n\treturn p[p.length - 1];\n};\n\n/** \r\n * <p>\r\n * Returns the number of sign changes in the polynomial coefficents \r\n * when ordered in descending order; zeros are ignored.\r\n * </p>\r\n * <p>\r\n * Descartes' rule of signs states (quoted from Wikipedia):\r\n * \"if the terms of a polynomial are ordered by descending variable \r\n * exponent, then the number of positive roots of the polynomial is \r\n * either equal to the number of sign differences between consecutive \r\n * nonzero coefficients, or is less than it by an even number. Multiple \r\n * roots of the same value are counted separately.\"\r\n * </p>\r\n * @see https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} The number of sign changes.\r\n * @example\r\n * FloPoly.signChanges([1,2,-3,0,0,3,-1]); //=> 3\r\n */\nfunction signChanges(p) {\n\tvar d = p.length - 1;\n\n\tvar result = 0;\n\tvar prevSign = Math.sign(p[0]);\n\tfor (var i = 1; i < d + 1; i++) {\n\t\tvar sign = Math.sign(p[i]);\n\n\t\tif (sign !== prevSign && sign !== 0) {\n\t\t\tresult++;\n\t\t\tprevSign = sign;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\r\n * Deflates the given polynomial by removing a factor (x - r), where\r\n * r is a root of the polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @param {number} root - A pre-calculated root of the polynomial.\r\n * @returns {number[]} The deflated polynomial.\r\n * @example\r\n * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2 \r\n * FloPoly.deflate([1, -5, 8, -4], 2); //=> [1, -3, 2] \r\n * FloPoly.deflate([1, -3, 2], 2);     //=> [1,-1] \r\n * FloPoly.deflate([1, -1], 1);        //=> [1]\r\n */\nfunction deflate(p, root) {\n\tvar d = p.length - 1;\n\tvar bs = [p[0]];\n\tfor (var i = 1; i < d; i++) {\n\t\tbs.push(p[i] + root * bs[i - 1]);\n\t}\n\n\treturn bs;\n}\n\n/**\r\n * Inverts the given polynomial by reversing the order of the \r\n * coefficients.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} p(x) -> x^deg(p) * p(1/x)\r\n * @example\r\n * FloPoly.invert([1,2,3,4]); // => [4,3,2,1]\r\n * FloPoly.invert([3,2,-5]);  // => [-5,2,3]\r\n */\nfunction invert(p) {\n\treturn p.slice().reverse();\n}\n\n/**\r\n * <p> \r\n * Performs a change of variables of the form: p(x) <- p(ax + b).\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system\">this stackoverflow question</a>\r\n * </p>\r\n * @param {number[]} p - The polynomial\r\n * @param {number} a\r\n * @param {number} b\r\n * @returns {number[]} The transformed polynomial.\r\n * @example\r\n * FloPoly.changeVariables([1,2,7], 3, 4); //=> [9, 30, 31]\r\n */\nfunction changeVariables(p, a, b) {\n\t// We let the coefficients of p(ax + b) be denoted by d_i in the \n\t// code below. \n\t// d_i is calculated as d = T*c, where c are the original \n\t// coefficients.\n\n\tvar d = p.length - 1;\n\n\t// Initialize a zero matrix\n\tvar t = [];\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tt.push(new Array(d + 1).fill(0));\n\t}\n\n\t// Calculate the triangular matrix T\n\tt[0][0] = 1;\n\tfor (var j = 1; j <= d; j++) {\n\t\tt[0][j] = b * t[0][j - 1];\n\t\tfor (var _i = 1; _i <= j; _i++) {\n\t\t\tt[_i][j] = b * t[_i][j - 1] + a * t[_i - 1][j - 1];\n\t\t}\n\t}\n\n\t// Multiply\n\tvar res = new Array(d + 1).fill(0);\n\tfor (var _i2 = 0; _i2 <= d; _i2++) {\n\t\tres[d - _i2] = 0;\n\t\tfor (var _j = _i2; _j <= d; _j++) {\n\t\t\tvar acc = t[_i2][_j] * p[d - _j];\n\t\t\tres[d - _i2] += acc;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n/**\r\n * Reflects the given polynomial about the Y-axis, i.e. perform the \r\n * change of variables: p(x) <- p(-x).\r\n * \r\n * @param {number[]} p - The polynomial to reflect\r\n * @returns {number[]} The reflected polynomial.\r\n * @example\r\n * FloPoly.reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]\r\n */\nfunction reflectAboutYAxis(p) {\n\tvar d = p.length - 1;\n\n\tvar result = p.slice();\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tif (i % 2) {\n\t\t\tresult[i] = -result[i];\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/** \r\n * Generates a sturm chain for the given polynomial.\r\n * \r\n * @see https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n * @param {number[]} p - The polynomial\r\n * @returns {number[][]} The sturm chain of polynomials\r\n * @example\r\n * FloPoly.sturmChain([-3,4,2,-2]); //=> [[-3, 4, 2, -2], [-9, 8, 2], [-2.5185185185185186, 1.7037037037037037], [-3.2932525951557086]]\r\n */\nfunction sturmChain(p) {\n\n\t/** \r\n  * Returns the negative of the remainder when dividing the first \r\n  * polynomial (the dividend) by the second (the divisor) provided \r\n  * that deg(p1) - deg(p2) === 1.\r\n  * \r\n  * @ignore\r\n  * @param {number[]} p1 - The first polynomial (dividend)\r\n  * @param {number[]} p2 - The second polynomial (divisor)\r\n  * @see https://en.wikipedia.org/wiki/Sturm%27s_theorem\r\n  */\n\tfunction negRemainder(p1, p2) {\n\t\tvar d1 = p1.length - 1;\n\t\tvar d2 = p2.length - 1;\n\t\tvar d = d1 - d2;\n\n\t\tvar a = p1[1] / p1[0] - p2[1] / p2[0];\n\t\tvar b = p1[0] / p2[0];\n\n\t\tvar p3 = multiply(multiplyByConst(b, p2), [1, a]);\n\n\t\treturn subtract(p3, p1);\n\t}\n\n\tvar m = []; // Sturm chain\n\tm.push(p);\n\tm.push(differentiate(p));\n\n\t//const δ = 10 * Number.EPSILON;\n\tvar i = 1;\n\twhile (m[i].length - 1 > 0) {\n\t\tvar pnext = negRemainder(m[i - 1], m[i]);\n\t\t//pnext = clip(pnext, δ);\n\t\t// If the polynomial degree was not reduced due to roundoff\n\t\t// such that the first 1 or more terms are very small.\n\t\twhile (m[i].length - pnext.length < 1) {\n\t\t\tpnext.shift();\n\t\t}\n\t\t/*\r\n  if (pnext.length === 0) {\r\n  \tbreak;\r\n  }\r\n  */\n\t\tm.push(pnext);\n\n\t\ti++;\n\t}\n\n\treturn m;\n}\n\n/**\r\n * If the highest power coefficient is small in the sense that the \r\n * highest power term has a negligible contribution (compared to the\r\n * other terms) at x = 1 then clip() can be called to remove all such \r\n * highest terms. A contribution of less than Number.EPSILON of the \r\n * highest coefficient will be considered negligible by default.\r\n * \r\n * \r\n * @param {number[]} p - The polynomial to be clipped.\r\n * @param {number} δ - The optional contribution tolerence else \r\n *        Number.EPSILON will be used by default.   \r\n * @returns {number[]} The clipped polynomial.\r\n * @example\r\n * FloPoly.clip([1e-18, 1e-10, 1e-5]); //=> [1e-18, 1e-10, 1e-5] \r\n * FloPoly.clip([1e-18, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\nfunction clip(p, δ) {\n\tδ = δ === undefined ? Number.EPSILON : δ;\n\n\tvar c = maxCoefficient(p);\n\tif (c === 0) {\n\t\treturn [];\n\t}\n\n\tif (Math.abs(p[0]) > δ * c) {\n\t\treturn p;\n\t}\n\n\tvar p_ = p.slice(1);\n\twhile (Math.abs(p_[0]) < δ * c) {\n\t\tp_ = p_.slice(1);\n\t}\n\n\treturn clip(p_, δ);\n}\n\n/**\r\n * If the highest power coefficient is 0 then clip() can be called to \r\n * remove all such highest terms so that the array is a valid \r\n * presentation of a polynomial.\r\n * \r\n * @param {number[]} p - The polynomial to be clipped.\r\n * @returns {number[]} The clipped polynomial.\r\n * @example\r\n * FloPoly.clip0([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]\r\n * FloPoly.clip0([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]\r\n */\nfunction clip0(p) {\n\treturn p[0] !== 0 ? p : clip0(p.slice(1));\n}\n\n/**\r\n * Returns the absolute value of the highest coefficient of the \r\n * polynomial.\r\n * \r\n * @param p {number[]} p - The polynomial.\r\n * @returns {number}\r\n * @example\r\n * FloPoly.maxCoefficient([-2, 0.1, 0.2]); //=> 2\r\n */\nfunction maxCoefficient(p) {\n\tvar max = 0;\n\tfor (var i = 0; i < p.length; i++) {\n\t\tvar c = Math.abs(p[i]);\n\t\tif (c > max) {\n\t\t\tmax = c;\n\t\t}\n\t}\n\n\treturn max;\n}\n\n/**\r\n * Returns a string representing the given polynomial that is readable \r\n * by a human or a CAS (Computer Algebra System).\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {string}\r\n * @example\r\n * FloPoly.toCasStr([5,4,3,2,1]); //=> \"x^4*5 + x^3*4 + x^2*3 + x*2 + 1\"\r\n */\nfunction toCasStr(p) {\n\tvar d = p.length - 1;\n\n\tvar str = '';\n\tfor (var i = 0; i < d + 1; i++) {\n\t\tvar cStr = p[i].toString();\n\t\tif (i === d) {\n\t\t\tstr += cStr;\n\t\t} else if (i === d - 1) {\n\t\t\tstr += 'x*' + cStr + ' + ';\n\t\t} else {\n\t\t\tstr += 'x^' + (d - i).toString() + '*' + cStr + ' + ';\n\t\t}\n\t}\n\n\treturn str;\n}\n\nmodule.exports = coreOperators;\n\n},{}],3:[function(_dereq_,module,exports){\n'use strict';\n\nvar coreOperators = _dereq_('./core-operators.js');\n\nvar errorAnalysis = {\n  hornerErrorBound: hornerErrorBound\n};\n\nvar evaluate = coreOperators.evaluate;\n\n/**\r\n * <p>\r\n * Approximate condition number for polynomial evaluation multiplied\r\n * by the exact value of the polynomial evaluation.\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">Compensated Horner Scheme - paragraph 1.1</a>\r\n * </p>\r\n * \r\n * @ignore\r\n * @param {number[]} p - The polynomial\r\n * @param {number} x - The evaluation point\r\n * @returns {number} The condition number multiplied exact polynomial \r\n * value at x\r\n */\n\nfunction conditionNumber(p, x) {\n  var d = p.length - 1;\n  var res = 0;\n\n  for (var i = 0; i < d; i++) {\n    res += Math.abs(p[i] * Math.pow(x, d - i));\n  }\n\n  return res;\n}\n\n/**\r\n * <p>\r\n * Classic rule of thumb approximate error bound when using Horner's \r\n * method to evaluate polynomials. \r\n * </p>\r\n * <p>\r\n * See for instance <a href=\"http://www-pequan.lip6.fr/~jmc/polycopies/Compensation-horner.pdf\">compensated horner evaluation</a>\r\n * </p>\r\n * @param p {number[]} - The polynomial\r\n * @param x {number} - Value at which polynomial is evaluated. \r\n * @returns {number} The error bound\r\n * @example\r\n * hornerErrorBound([1.1,2.2,-3.3], 1.5); //=> 5.1292303737682235e-15 \r\n */\nfunction hornerErrorBound(p, x) {\n  var δ = Number.EPSILON;\n\n  var d = p.length - 1;\n  return 2 * d * δ * conditionNumber(p, x);\n}\n\nmodule.exports = errorAnalysis;\n\n},{\"./core-operators.js\":2}],4:[function(_dereq_,module,exports){\n'use strict';\n\nvar coreOperators = _dereq_('./core-operators.js');\nvar rootOperators = _dereq_('./root-operators.js');\nvar rootBounds = _dereq_('./root-bounds.js');\n//let allRootsVAS       = require('./all-roots-vas.js');\nvar allRootsRecursive = _dereq_('./all-roots-recursive.js');\nvar random = _dereq_('./random.js');\nvar errorAnalysis = _dereq_('./error-analysis.js');\nvar fromRoots = _dereq_('./from-roots.js');\n\nvar multiply = coreOperators.multiply;\n\n/**\r\n* <p>\r\n* Simple & fast practical library functions for functional univariate \r\n* polynomials over the reals (actually ECMAScript numbers, i.e. double \r\n* floats).\r\n* </p>\r\n* <p>\r\n* All polinomials are represented as a simple array starting with the \r\n* highest non-zero power, e.g. \r\n*   3x^3 + 5x^2 + 7x + 2 -> [3,5,7,2]\r\n* </p>\r\n* @ignore\r\n*/\nvar FloPoly = Object.assign({}, coreOperators, rootOperators, rootBounds, { random: random }, { fromRoots: fromRoots }, {\n\t\tallRoots: allRootsRecursive\n\t\t//allRootsVAS,\n}, errorAnalysis);\n\nmodule.exports = exports = FloPoly;\n\n},{\"./all-roots-recursive.js\":1,\"./core-operators.js\":2,\"./error-analysis.js\":3,\"./from-roots.js\":5,\"./random.js\":6,\"./root-bounds.js\":7,\"./root-operators.js\":8}],5:[function(_dereq_,module,exports){\n'use strict';\n\nvar _require = _dereq_('./core-operators.js'),\n    multiply = _require.multiply;\n\n/**\r\n * <p>\r\n * Constructs a polynomial from the given roots by multiplying out the \r\n * factors (x - root1)(x - root2)... Note that the resulting polynomial \r\n * will not have any complex roots.\r\n * </p>\r\n * <p>\r\n * Mostly provided for testing purposes. Note that the real roots of the \r\n * constructed polynomial may not be exactly the same as the roots that\r\n * the polynomial has been constructed from due to floating-point \r\n * round-off.\r\n * </p>\r\n * \r\n * @param {number[]} roots - The roots\r\n * @returns {number[]} The constructed polynomial.\r\n * @example\r\n * FloPoly.fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]\r\n * FloPoly.allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]\r\n * // In the above note the rounding error. Also note the multiple root of 3 that has been missed but as stated previously this does not generally pose a problem for even multiple roots. See the examples below.\r\n * FloPoly.allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]\r\n * FloPoly.allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]\r\n */\n\n\nfunction fromRoots(roots) {\n  var p = [1];\n  for (var i = 0; i < roots.length; i++) {\n    p = multiply(p, [1, -roots[i]]);\n  }\n\n  return p;\n}\n\nmodule.exports = fromRoots;\n\n},{\"./core-operators.js\":2}],6:[function(_dereq_,module,exports){\n'use strict';\n\nvar fromRoots = _dereq_('./from-roots.js');\n\n/**\r\n * Some seed value for the simple random number generator.\r\n * @ignore\r\n */\nvar SEED = 123456789;\n\n/**\r\n * The range for the simple random number generator, i.e. the generated\r\n * numbers will be in [0,RANGE].\r\n * @ignore\r\n */\nvar RANGE = 4294967296;\n\n/**\r\n * Generates an array of random polynomials with parameters as specified \r\n * by flatRoots. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to \r\n * improve testability.\r\n *   \r\n * @memberof random\r\n * @param {number} n - The number of polynomials to generate.\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {number[][]} The array of random polynomials.\r\n * @example\r\n * FloPoly.random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n * FloPoly.random.flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]\r\n */\nvar flatRootsArr = createArrFunction(flatRoots);\n\n/**\r\n * Generates an array of random polynomials as specified by \r\n * flatCoefficients. The exact same polynomials will be created on each\r\n * call to this function if the same seed is used - this is by design to \r\n * improve testability.\r\n *   \r\n * @memberof random\r\n * @param {number} n - The number of polynomials to generate.\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @returns {number[][]} The array of random polynomials.\r\n * @example\r\n * FloPoly.random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n * FloPoly.random.flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]\r\n */\nvar flatCoefficientsArr = createArrFunction(flatCoefficients);\n\nvar random = {\n  flatRoots: flatRoots,\n  flatRootsArr: flatRootsArr,\n  flatCoefficients: flatCoefficients,\n  flatCoefficientsArr: flatCoefficientsArr\n\n  /**\r\n   * https://stackoverflow.com/questions/3062746/special-simple-random-number-generator\r\n   * \r\n   * @ignore\r\n   * @param {number} seed\r\n   * @returns {number} A quasi-random number to be used as the next input \r\n   * to this function.\r\n   */\n};function predictiveRandom(seed) {\n  var a = 134775813;\n\n  return (a * seed + 1) % RANGE;\n}\n\n/**\r\n * Generates a random array of numbers picked from a bounded flat \r\n * distribution (i.e. a rectangular distribution) with specified odds of \r\n * duplication of consecutive values.\r\n *   \r\n * @ignore\r\n * @param {number} n - The number of values to generate.\r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {number[]} - The random array.\r\n */\nfunction randomArray(n, a, b, seed, odds) {\n  seed = seed === undefined ? SEED : seed;\n  odds = odds === undefined ? 0 : odds;\n\n  var vs = [];\n  for (var i = 0; i < n; i++) {\n    seed = predictiveRandom(seed);\n    var v = seed / RANGE * (b - a) + a;\n    seed = push(seed, vs, v, odds);\n  }\n  vs = vs.slice(0, n);\n\n  return { vs: vs, seed: seed };\n}\n\n/**\r\n * Helper function that will add more numbers to the passed array - \r\n * modifies the values parameter.\r\n *\r\n * @ignore\r\n * @param {number[]} values - An existing array of values - will be \r\n * modified!\r\n * @param {number} x - The number that will be added (possibly\r\n * multiple times)\r\n * @param {number} odds - The odds that the number will be added\r\n * again (recursively). \r\n */\nfunction push(seed, values, x, odds) {\n  seed = predictiveRandom(seed);\n\n  values.push(x);\n  if (seed / RANGE < odds) {\n    seed = push(seed, values, x, odds);\n  }\n\n  return seed;\n}\n\n/**\r\n * Generates a random polynomial with roots picked from a bounded flat \r\n * distribution (i.e. a rectangular distribution) with specified odds of \r\n * duplication of consecutive values. Note that the resulting polynomial\r\n * won't have any complex roots.\r\n * \r\n * @memberof random\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to 0\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @param {number} odds - The odds that a root will be doubled (applied\r\n * recursively so that some roots will be tripled, etc. - defaults to 0\r\n * @returns {{p: number[], seed: number}} a random polynomial and the\r\n * last seed value to reuse.\r\n * @example\r\n * FloPoly.random.flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }\r\n */\nfunction flatRoots(d, a, b, seed, odds) {\n  a = a === undefined ? 0 : a;\n  b = b === undefined ? 1 : b;\n  seed = seed === undefined ? SEED : seed;\n  odds = odds === undefined ? 0 : odds;\n\n  var randArr = randomArray(d, a, b, seed, odds);\n  seed = randArr.seed;\n\n  var p = fromRoots(randArr.vs);\n\n  return { p: p, seed: seed };\n}\n\n/**\r\n * Generates a random polynomial with coefficients picked from a bounded \r\n * flat distribution (i.e. a rectangular distribution). \r\n * \r\n * @memberof random\r\n * @param {number} d - The degree of the polynomials \r\n * @param {number} a - The lower bound of the distribution - defaults \r\n * to -1\r\n * @param {number} b - The upper bound of the distribution - defaults \r\n * to 1\r\n * @param {number} seed - A seed value for generating random values (so\r\n * that the results are reproducable)\r\n * @returns {{p: number[], seed: number}} a random polynomial and the\r\n * last seed value to reuse.\r\n * @example\r\n * FloPoly.random.flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }\r\n */\nfunction flatCoefficients(d, a, b, seed) {\n  a = a === undefined ? -1 : a;\n  b = b === undefined ? +1 : b;\n  seed = seed === undefined ? SEED : seed;\n\n  var randArr = randomArray(d, a, b, seed);\n  seed = randArr.seed;\n\n  var p = randArr.vs;\n\n  return { p: p, seed: seed };\n}\n\n/**\r\n * Creates a function from the given function with parameters similar\r\n * to flatRoots but with an extra parameter in the beginning indicating\r\n * the length of the array generated by the original function.\r\n * \r\n * @ignore\r\n * @param {function} f\r\n * @returns {function}\r\n */\nfunction createArrFunction(f) {\n  return function (n, d, a, b, seed, odds) {\n    seed = seed === undefined ? SEED : seed;\n    var res = [];\n\n    for (var i = 0; i < n; i++) {\n      var v = f(d, a, b, seed, odds);\n      var p = v.p;\n      seed = v.seed;\n\n      res.push(p);\n    }\n\n    return res;\n  };\n}\n\nmodule.exports = random;\n\n},{\"./from-roots.js\":5}],7:[function(_dereq_,module,exports){\n'use strict';\n\nvar coreOperators = _dereq_('./core-operators.js');\n\nvar invert = coreOperators.invert,\n    negate = coreOperators.negate,\n    reflectAboutYAxis = coreOperators.reflectAboutYAxis;\n\n\nvar rootBounds = {\n\trootMagnitudeUpperBound_fujiwara: rootMagnitudeUpperBound_fujiwara,\n\tpositiveRootUpperBound_LMQ: positiveRootUpperBound_LMQ,\n\tpositiveRootLowerBound_LMQ: positiveRootLowerBound_LMQ,\n\tnegativeRootUpperBound_LMQ: negativeRootUpperBound_LMQ,\n\tnegativeRootLowerBound_LMQ: negativeRootLowerBound_LMQ,\n\trootMagnitudeUpperBound_rouche: rootMagnitudeUpperBound_rouche\n\n\t/**\r\n  * Returns the maximum magnitude value within the supplied array of \r\n  * numbers.\r\n  * @ignore \r\n  */\n};function maxAbs(ns) {\n\treturn Math.max.apply(null, ns.map(function (n) {\n\t\treturn Math.abs(n);\n\t}));\n}\n\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * (including complex roots) of the given polynomial using Rouche's \r\n * Theorem with k = n. This function is fast but the bound is not tight.\r\n * \r\n * @param p {number[]} p - The polynomial.\r\n * @returns {number} The bound.\r\n */\nfunction rootMagnitudeUpperBound_rouche(p) {\n\tvar d = p.length - 1;\n\tvar R = 1 + 1 / p[0] * maxAbs(p.slice(1));\n\treturn R;\n}\n\n/**\r\n * Finds an upper bound on the magnitude (absolute value) of the roots\r\n * of the given polynomial using the near-optimal Fujiwara bound. Note\r\n * that the bound includes complex roots. The bound is tight but slow \r\n * due to usage of Math.pow().\r\n * \r\n * @see https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#cite_note-Fujiwara1916-4\r\n * \r\n * @param {number[]} p - The polynomial.\r\n * @returns {number} The bound.\r\n * @example\r\n * FloPoly.rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361\r\n * FloPoly.allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]\r\n */\nfunction rootMagnitudeUpperBound_fujiwara(p) {\n\tvar d = p.length - 1;\n\n\tvar an = p[0];\n\tvar bs = [];\n\n\tfor (var i = 1; i < d; i++) {\n\t\tvar b = Math.pow(Math.abs(p[i] / an), 1 / i);\n\t\tbs.push(b);\n\t}\n\n\tbs.push(Math.pow(Math.abs(p[d] / 2 * an), 1 / d));\n\n\treturn 2 * Math.max.apply(undefined, bs);\n}\n\nvar POWERS = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152];\n/**\r\n * <p> \r\n * Returns an upper bound for the positive real roots of the given \r\n * polynomial.\r\n * </p>\r\n * <p>\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński, \r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * </p>  \r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n * @example\r\n * FloPoly.positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436 \r\n * FloPoly.positiveRootUpperBound_LMQ([2,3]);           //=> 0 \r\n * FloPoly.positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\nfunction positiveRootUpperBound_LMQ(p) {\n\tvar deg = p.length - 1;\n\tif (deg < 1) {\n\t\treturn 0;\n\t}\n\n\tif (p[0] < 0) {\n\t\tp = negate(p);\n\t}\n\n\tvar timesUsed = [];\n\tfor (var i = 0; i < deg; i++) {\n\t\ttimesUsed.push(1);\n\t}\n\n\tvar ub = 0;\n\n\tfor (var m = 0; m <= deg; m++) {\n\t\tif (p[m] >= 0) continue;\n\n\t\tvar tempub = Number.POSITIVE_INFINITY;\n\t\tvar any = false;\n\n\t\tfor (var k = 0; k < m; k++) {\n\t\t\tif (p[k] <= 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Table lookup is about 70% faster but both are\n\t\t\t// extemely fast anyway. \n\t\t\t// Result is at https://www.measurethat.net/Benchmarks/ShowResult/6610\n\t\t\tvar pow = timesUsed[k];\n\t\t\tvar powres = void 0;\n\t\t\tif (pow > 20) {\n\t\t\t\tpowres = Math.pow(2, pow);\n\t\t\t} else {\n\t\t\t\tpowres = POWERS[pow];\n\t\t\t}\n\t\t\tvar temp = Math.pow(-p[m] / (p[k] / powres), 1 / (m - k));\n\n\t\t\ttimesUsed[k]++;\n\n\t\t\tif (tempub > temp) {\n\t\t\t\ttempub = temp;\n\t\t\t}\n\n\t\t\tany = true;\n\t\t}\n\n\t\tif (any && ub < tempub) ub = tempub;\n\t}\n\n\treturn ub;\n}\n\n/**\r\n * <p> \r\n * Calculates a lower bound for the positive roots of the given \r\n * polynomial.\r\n * </p>\r\n * <p>\r\n * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński, \r\n * specifically the LocalMaxQuadratic algorithm hence LMQ.\r\n * </p>\r\n *  \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n * @example\r\n * FloPoly.positiveRootLowerBound_LMQ([2,-3,6,5,-130]); //=> 1.6883241876925903\r\n * FloPoly.positiveRootLowerBound_LMQ([2,3]);           //=> 0 \r\n * FloPoly.positiveRootLowerBound_LMQ([-2,-3,-4]);      //=> 0\r\n */\nfunction positiveRootLowerBound_LMQ(p) {\n\tvar ub = positiveRootUpperBound_LMQ(invert(p));\n\tif (ub === 0) {\n\t\treturn 0;\n\t}\n\treturn 1 / ub;\n}\n\n/**\r\n * See positiveRootUpperBound_LMQ\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} An upper bound.\r\n */\nfunction negativeRootUpperBound_LMQ(p) {\n\treturn -positiveRootLowerBound_LMQ(reflectAboutYAxis(p));\n}\n\n/**\r\n * See positiveRootLowerBound_LMQ\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @returns {number} A lower bound.\r\n */\nfunction negativeRootLowerBound_LMQ(p) {\n\treturn -positiveRootUpperBound_LMQ(reflectAboutYAxis(p));\n}\n\nmodule.exports = rootBounds;\n\n},{\"./core-operators.js\":2}],8:[function(_dereq_,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar coreOperators = _dereq_('./core-operators.js');\n\n/**\r\n * Operators (i.e. functions) directly related to roots and root \r\n * finding. \r\n * \r\n * @ignore\r\n */\nvar rootOperators = {\n  quadraticRoots: quadraticRoots,\n  //cubicRoots,\n  numRootsWithin: numRootsWithin,\n  brent: brent,\n  bisection: bisection\n};\n\nvar sturmChain = coreOperators.sturmChain,\n    evaluate = coreOperators.evaluate,\n    signChanges = coreOperators.signChanges;\n\n/**\r\n * <p>\r\n * Floating-point-stably calculates and returns the ordered quadratic \r\n * roots of the given quadratic polynomial.\r\n * </p>\r\n * <p>\r\n * This function is included only because it might be slightly faster\r\n * than calling allRoots due to allRoots first checking if the \r\n * polynomial is quadratic and checking if the roots are within the\r\n * given range.\r\n * </p>\r\n * @param {number[]} p - The 2nd order polynomial\r\n * @returns {number[]} The found quadratic roots.\r\n * @example \r\n * FloPoly.quadraticRoots([1, -3, 2]); //=> [1,2]\r\n */\n\nfunction quadraticRoots(p) {\n  var _p = _slicedToArray(p, 3),\n      a = _p[0],\n      b = _p[1],\n      c = _p[2];\n\n  var delta = b * b - 4 * a * c;\n\n  if (delta < 0) {\n    // No real roots;\n    return [];\n  }\n\n  if (delta === 0) {\n    return [-b / (2 * a)];\n  }\n\n  delta = Math.sqrt(delta);\n\n  var root1 = void 0;\n  var root2 = void 0;\n  if (b >= 0) {\n    root1 = (-b - delta) / (2 * a);\n    root2 = 2 * c / (-b - delta);\n  } else {\n    root1 = 2 * c / (-b + delta);\n    root2 = (-b + delta) / (2 * a);\n  }\n\n  if (root1 < root2) {\n    return [root1, root2];\n  }\n  return [root2, root1];\n}\n\n/**\r\n * Calculates the roots of the given cubic polynomial.\r\n * \r\n * This code is mostly from the Pomax guide found at\r\n * https://pomax.github.io/bezierinfo/#extremities\r\n * \r\n * @param {number[]} p - A cubic polynomial.\r\n * @returns {number[]} 1,2 or 3 roots.\r\n */\n// TODO - This function as it currently stands is very sensitive to\n// the first coefficient if it is very small, e.g. compare:\n// cubicRoots([1e-5, 1560,-1740,96]) = [1.1903631761670113, -156000001.1153846, -0.07497859001159668] \n// vs\n// quadraticRoots([1560,-1740,96]) = [0.05821032751613551, 1.0571742878684798]\n// It is completely useless in some ranges of its input domain:\n// the part of the function 'if (discriminant < 0) {}'\n// is highly problematic for numerical stability.\n// Simply use allRoots / allRootsRecursive instead.\n/*\r\nfunction cubicRoots(p) {\r\n\r\n\tfunction cuberoot(v) {\r\n\t\treturn v < 0 \r\n\t\t\t? -Math.pow(-v, 1/3)\r\n\t\t    : +Math.pow(v, 1/3);\r\n\t}\r\n\t\r\n\tlet cbrt = Math.cbrt || cuberoot;\r\n\t\r\n\tlet d = p[0];\r\n\tlet a = p[1] / d;\r\n\tlet b = p[2] / d;\r\n\tlet c = p[3] / d;\r\n\t\r\n\tlet s  = (3*b - a*a) / 9;\r\n\tlet q  = (2*a*a*a - 9*a*b + 27*c) / 54;\r\n\t\r\n\tlet s3 = s*s*s;\r\n\tlet q2 = q*q;\r\n\t\r\n\tlet discriminant = q2 + s3;\r\n\r\n\tif (!Number.isFinite(discriminant)) {\r\n\t\t\r\n\t\t// Overflow occured - in which case one root will be very large. \r\n\t\t// We might want to report such large roots as positive or\r\n\t\t// negative infinity but since they are rarely of interest we\r\n\t\t// report only the smaller roots.\r\n\t\t\r\n\t\t// Here q*q   === (729*c^2 - 486*a*b*c + 108*a^3*c + 81*a^2*b^2 - 36*a^4*b + 4*a^6) / (729*4)\r\n\t\t// and  s*s*s === (27*b^3 - 27*a^2*b^2 + 9*a^4*b - a^6) / (729*1)\r\n\t\t\r\n\t\treturn quadraticRoots(p.slice(1)); \r\n\t}\r\n\t\r\n\tif (discriminant < 0) {\r\n\t\t// three real roots\r\n\t\t\r\n\t\tlet r = Math.sqrt(-s3);\r\n\t\tlet t = -q / r;\r\n\t\t\r\n\t\tlet cosphi = t < -1 ? -1 : t > 1 ? 1 : t;\r\n\t\tlet phi    = Math.acos(cosphi);\r\n\t\tlet\tt1     = 2*cbrt(r);\r\n\t\t\r\n\t\tlet ao3 = a/3; \r\n\t\t\r\n\t\treturn [\r\n\t\t\tt1*Math.cos((phi            )/3) - ao3, \r\n\t\t\tt1*Math.cos((phi + 2*Math.PI)/3) - ao3, \r\n\t\t\tt1*Math.cos((phi + 4*Math.PI)/3) - ao3\r\n\t\t]\r\n\t} else if (discriminant === 0) {\r\n\t\t// three real roots, but two of them are equal\r\n\t\t\r\n\t\tlet u1 = q < 0 ? cbrt(-q) : -cbrt(q);\r\n\t\tlet ao3 = a/3;\r\n\t\t\r\n\t\treturn [\r\n\t\t\t2*u1 - ao3, \r\n\t\t\t-u1 - ao3\r\n\t\t];\r\n\t} else {\r\n\t\t// one real root, two complex roots\r\n\t\t\r\n\t\tlet sd = Math.sqrt(discriminant);\r\n\t\tlet u1 = cbrt(sd - q);\r\n\t\tlet v1 = cbrt(sd + q);\r\n\t\t\r\n\t\treturn [u1 - v1 - a/3];\r\n\t}\r\n}\r\n*/\n\n/** \r\n * Returns the number of real roots in the interval (a,b) of the given \r\n * polynomial.\r\n * \r\n * @param {number[]} p - The polynomial\r\n * @param {number} a - The lower bound\r\n * @param {number} b - The upper bound\r\n * @returns {number} The number of roots in the given interval\r\n * @example \r\n * let p = [1, 1, -64, 236, -240];\r\n * FloPoly.numRootsWithin(p,-20,-11); //=> 0\r\n * FloPoly.numRootsWithin(p,-11,-9);  //=> 1  \r\n * FloPoly.numRootsWithin(p,-11,3.5); //=> 3\r\n * FloPoly.numRootsWithin(p,-11,5);   //=> 4\r\n */\nfunction numRootsWithin(p, a, b) {\n  var ps = sturmChain(p);\n  var ev = evaluate(p);\n  var as = ps.map(function (p) {\n    return evaluate(p)(a);\n  });\n  var bs = ps.map(function (p) {\n    return evaluate(p)(b);\n  });\n\n  return signChanges(as) - signChanges(bs);\n}\n\n/**\r\n * <p>\r\n * Searches an interval (a,b) for a root (i.e. zero) of the \r\n * given function with respect to its first argument using the Bisection \r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed. \r\n * </p>\r\n * <p>\r\n * Note: This function has no advantages above the Brent method except\r\n * for its simpler implementation and can be much slower. Use brent \r\n * instead.\r\n * </p>\r\n * @param {function} f - The function for which the root is sought.\r\n * @param {number} a - The lower limit of the search interval.\r\n * @param {number} b - The upper limit of the search interval.\r\n * @returns {number} An estimate of the root to within δ (typically \r\n * about 1e-15 multiplied by the root magnitued).\r\n * @example\r\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = FloPoly.evaluate(p);\r\n * FloPoly.bisection(f,2.2,3.8); //=> 3\r\n * FloPoly.bisection(f,2.2,3.1); //=> 3.0000000000000044\r\n */\nfunction bisection(f, a, b) {\n  if (a === b) {\n    // Presumably the root is already found.\n    return a;\n  } else if (b < a) {\n    // Swap a and b \n    var _ref = [b, a];\n    a = _ref[0];\n    b = _ref[1];\n  }\n\n  var fa = f(a);\n  var fb = f(b);\n\n  if (fa === 0) {\n    return a;\n  }\n  if (fb === 0) {\n    return b;\n  }\n\n  if (fa * fb > 0) {\n    // Root is not bracketed - this is a precondition.\n    throw new Error('Root not bracketed');\n  }\n\n  while (true) {\n    var c = a + (b - a) / 2; // Take midpoint\n    var fc = f(c);\n\n    if (fc === 0) {\n      return c;\n    }\n\n    if (fa * fc < 0) {\n      b = c;\n    } else {\n      a = c;\n    }\n\n    // We don't add Number.EPSILON in the line below because we want\n    // accuracy to improve even below 1.\n    var δ = 2 * Number.EPSILON * Math.abs(b) /*+ Number.EPSILON*/;\n    if (Math.abs(a - b) <= δ) {\n      return b;\n    }\n  }\n}\n\n/**\r\n * <p>\r\n * Searches an interval (a,b) for a root (i.e. zero) of the \r\n * given function with respect to its first argument using the Brent's \r\n * Method root-finding algorithm. Any function can be supplied (it does\r\n * not even have to be continuous) as long as the root is bracketed. \r\n * </p>\r\n * <p>\r\n * Brent's Method is an excellent root-finding choice since it is\r\n * (1) guaranteed to converge (unlike the Newton and other so-called \r\n * single-point methods), (2) converges in a reasonable number of \r\n * iterations even for highly contrived functions (unlike Dekker's \r\n * Method) and (3) nearly always converges extremely fast, i.e. super-\r\n * linearly (unlike the Secant and Regula-Falsi methods).\r\n * </p>\r\n * <p>\r\n * The max error, δ, is set equal to 2*Number.EPSILON*Math.abs(b)\r\n * after each iteration where b is the max of the current 2 best \r\n * guesses.\r\n * </p>\r\n * <p> \r\n * See <a href=\"https://en.wikipedia.org/wiki/Brent%27s_method\">Wikipedia</a>\r\n * </p>\r\n * <p>\r\n * See <a href=\"https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf\">Brent (page 47)</a>\r\n * </p>\r\n * @param {function} f - The function for which the root is sought.\r\n * @param {number} a - The lower limit of the search interval.\r\n * @param {number} b - The upper limit of the search interval.\r\n * @returns {number} An estimate of the root to within δ (typically \r\n * about 1e-15 multiplied by the root magnitued).\r\n * @example\r\n * let p = FloPoly.fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]\r\n * let f = FloPoly.evaluate(p);\r\n * FloPoly.brent(f,2.2,3.8); //=> 3.000000000000003\r\n * FloPoly.brent(f,2.2,3.1); //=> 3.000000000000001\r\n */\nfunction brent(f, a, b) {\n  if (a === b) {\n    // Presumably the root is already found.\n    return a;\n  }\n\n  // We assume on the first iteration f(a) !== 0 && f(b) !== 0. \n  var fa = f(a);\n  var fb = f(b);\n\n  if (fa * fb > 0) {\n    // Root is not bracketed - this is a precondition.\n    throw new Error('Root not bracketed');\n  }\n\n  var c = void 0; // Value of previous guess - set to a initially \n  if (Math.abs(fa) < Math.abs(fb)) {\n    // Swap a,b\n    c = a;a = b;b = c;\n\n    // Swap fa,fb\n    var temp = fa;\n    fa = fb;\n    fb = temp;\n  }\n\n  c = a;\n\n  var mflag = true;\n  var d = void 0; // Value of guess before previous guess\n  while (true) {\n    var δ = 2 * Number.EPSILON * Math.abs(b); // + Number.EPSILON;\n\n    var fc = f(c);\n\n    // Calculate provisional interpolation value\n    var s = void 0;\n    if (fa !== fc && fb !== fc) {\n      // 3 points available - inverse quadratic interpolation\n      var fac = fa - fc;\n      var fab = fa - fb;\n      var fbc = fb - fc;\n\n      // The below has been multiplied out to speed up the algorithm.\n      /*s = ((a * fb * fc) / ( fab * fac)) +\r\n      \t  ((b * fa * fc) / (-fab * fbc)) +\r\n      \t  ((c * fa * fb) / ( fac * fbc));*/\n      s = ((a * fb * fbc - b * fa * fac) * fc + c * fa * fab * fb) / (fab * fac * fbc);\n    } else {\n      // only 2 points available - secant method\n      s = b - fb * ((b - a) / (fb - fa));\n    }\n\n    var t1 = (3 * a + b) / 4;\n    var b_c = Math.abs(b - c);\n    var s_b = Math.abs(s - b);\n    var c_d = Math.abs(c - d);\n\n    if (!( // condition 1\n    s > t1 && s < b || s < t1 && s > b) || mflag && (\n    // condition 2\n    s_b >= b_c / 2 ||\n    // condition 4\n    b_c < δ) || !mflag && (\n    // condition 3\n    s_b >= c_d / 2 ||\n    // condition 5\n    c_d < δ)) {\n      // Bisection\n      s = (a + b) / 2;\n      mflag = true;\n    } else {\n      mflag = false;\n    }\n\n    var fs = f(s);\n\n    d = c;\n    c = b;\n\n    if (fa * fs < 0) {\n      b = s;\n    } else {\n      a = s;\n    }\n\n    if (Math.abs(fa) < Math.abs(fb)) {\n      // Swap a,b\n      var _temp = a;a = b;b = _temp;\n    }\n\n    if (fb === 0) {\n      return b;\n    }\n    if (fs === 0) {\n      return s;\n    }\n\n    if (Math.abs(a - b) <= δ) {\n      return b;\n    }\n\n    fa = f(a);\n    fb = f(b);\n  }\n}\n\nmodule.exports = rootOperators;\n\n},{\"./core-operators.js\":2}]},{},[4])(4)\n});\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],6:[function(_dereq_,module,exports){\n'use strict';\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar DELTA = 1e-10;\n\n/** \r\n * Returns the dot (inner) product between two 2-vectors. \r\n * @param {number} a - The first vector\r\n * @param {number} b - The second vector\r\n * @returns {number}\r\n */\nfunction dot(a, b) {\n\treturn a[0] * b[0] + a[1] * b[1];\n}\n\n/** \r\n * Returns the cross product signed magnitude between two 2-vectors.\r\n * @param {number[]} a - The first vector\r\n * @param {number[]} b - The second vector\r\n * @returns {number}\r\n */\nfunction cross(a, b) {\n\treturn a[0] * b[1] - a[1] * b[0];\n}\n\n/**\r\n * Three 2d points are a counter-clockwise turn if ccw > 0, \r\n * clockwise if ccw < 0, and colinear if ccw = 0 because ccw is a \r\n * determinant that gives twice the signed area of the triangle formed \r\n * by p1, p2 and p3.\r\n * @param {number[]} p1 - The first point\r\n * @param {number[]} p2 - The second point\r\n * @param {number[]} p3 - The third point\r\n * @param {number} [delta] - The tolerance at which the three points are \r\n * considered colinear - defaults to 1e-10\r\n * @returns {number}\r\n */\nfunction ccw(p1, p2, p3, delta) {\n\tdelta = delta === undefined ? DELTA : delta;\n\n\tvar res = (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]);\n\n\treturn Math.abs(res) <= delta ? 0 : res;\n}\n\n/**\r\n * <p>\r\n * Finds the point where two 2d line segments intersect.\r\n * </p>\r\n * <p>\r\n * See <a href=\"http://algs4.cs.princeton.edu/91primitives\">Geometric primitves</a>\r\n * </p> \r\n * @param {number[][]} ab - The first line \r\n * @param {number[][]} cd - The second line\r\n * @param {number} [delta] - The tolerance at which the lines are considered \r\n * parallel - defaults to 1e-10\r\n * @returns {number[]} The point where the two line segments intersect  \r\n * or undefined if they don't intersect or a line if they intersect at \r\n * infinitely many points. \r\n */\nfunction segSegIntersection(ab, cd, delta) {\n\tdelta = delta === undefined ? DELTA : delta;\n\n\tvar _ab = _slicedToArray(ab, 2),\n\t    a = _ab[0],\n\t    b = _ab[1];\n\n\tvar _cd = _slicedToArray(cd, 2),\n\t    c = _cd[0],\n\t    d = _cd[1];\n\n\tvar denom = (b[0] - a[0]) * (d[1] - c[1]) - (b[1] - a[1]) * (d[0] - c[0]);\n\tvar rNumer = (a[1] - c[1]) * (d[0] - c[0]) - (a[0] - c[0]) * (d[1] - c[1]);\n\tvar sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]);\n\n\tif (Math.abs(denom) <= delta) {\n\t\t// parallel\n\t\tif (Math.abs(rNumer) <= delta) {\n\t\t\t// colinear\n\t\t\t// TODO Check if x-projections and y-projections intersect\n\t\t\t// and return the line of intersection if they do.\n\t\t\treturn undefined;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tvar r = rNumer / denom;\n\tvar s = sNumer / denom;\n\n\tif (0 <= r && r <= 1 && 0 <= s && s <= 1) {\n\t\treturn [a[0] + r * (b[0] - a[0]), a[1] + r * (b[1] - a[1])];\n\t}\n\n\treturn undefined;\n}\n\n/**\r\n * Returns true if the two given 2d line segments intersect, false otherwise.\r\n * @param {number[][]} a - A line segment\r\n * @param {number[][]} b - Another line segment\r\n * @returns {boolean}\r\n */\nfunction doesSegSegIntersect(a, b) {\n\tif (ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) > 0) {\n\t\treturn false;\n\t}\n\tif (ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) > 0) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/** \r\n * Returns the squared distance between two 2d points.\r\n * @param {number[]} p1 - A point\r\n * @param {number[]} p2 - Another point\r\n * @returns {number}\r\n */\nfunction squaredDistanceBetween(p1, p2) {\n\tvar x = p2[0] - p1[0];\n\tvar y = p2[1] - p1[1];\n\n\treturn x * x + y * y;\n}\n\n/**\r\n * Returns a scaled version of the given 2-vector.\r\n * @param {number[]} p - A vector\r\n * @param {number} factor - A scale factor\r\n * @returns {number[]}\r\n */\nfunction scale(p, factor) {\n\treturn [p[0] * factor, p[1] * factor];\n}\n\n/**\r\n * Returns the given 2-vector reversed.\r\n * @param {number[]} p \r\n * @returns {number[]}\r\n */\nfunction reverse(p) {\n\treturn [-p[0], -p[1]];\n}\n\n/**\r\n * Returns the given 2-vector scaled to a length of one.\r\n * @param {number[]} p\r\n * @returns {number[]}\r\n */\nfunction toUnitVector(p) {\n\tvar scaleFactor = 1 / length(p);\n\n\treturn [p[0] * scaleFactor, p[1] * scaleFactor];\n}\n\n/**\r\n * Returns the given 2-vector scaled to the given length.\r\n * @param {number[]} p \r\n * @param {number} length \r\n * @returns {number[]}\r\n */\nfunction toLength(p, len) {\n\tvar scaleFactor = len / length(p);\n\n\treturn [p[0] * scaleFactor, p[1] * scaleFactor];\n}\n\n/** \r\n * Returns the second 2-vector minus the first.\r\n * @param {number[]} p1 - The first vector\r\n * @param {number[]} p2 - The second vector\r\n * @returns {number[]}\r\n */\nfunction fromTo(p1, p2) {\n\treturn [p2[0] - p1[0], p2[1] - p1[1]];\n}\n\n/**\r\n * Performs linear interpolation between two 2d points and returns the resultant point.\r\n * @param {number[]} p1 - The first point.\r\n * @param {number[]} p2 - The second point.\r\n * @param {number} t - The interpolation fraction (usually in [0,1]).  \r\n * @returns {number[]}\r\n */\nfunction interpolate(p1, p2, t) {\n\treturn [p1[0] + (p2[0] - p1[0]) * t, p1[1] + (p2[1] - p1[1]) * t];\n}\n\n/**\r\n * Returns the mean point value of the provided array of two 2d points. \r\n * @param {number[][]} ps - The two points\r\n * @returns {number[]}\r\n */\nfunction mean(ps) {\n\tvar p1 = ps[0];\n\tvar p2 = ps[1];\n\n\treturn [(p1[0] + p2[0]) / 2, (p1[1] + p2[1]) / 2];\n}\n\n/** \r\n * Returns the distance between two 2d points.\r\n * @param {number[]} p1 - A point.\r\n * @param {number[]} p2 - Another point.\r\n * @returns {number}\r\n */\nfunction distanceBetween(p1, p2) {\n\treturn Math.sqrt(squaredDistanceBetween(p1, p2));\n}\n\n/** \r\n * Returns the length of the given 2-vector.\r\n * @param {number[]} p - A vector\r\n * @returns {number}\r\n */\nfunction length(p) {\n\treturn Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n}\n\n/**\r\n * Returns the squared length of the given 2-vector.\r\n * @param {number[]} p - A vector\r\n * @returns {number}\r\n */\nfunction lengthSquared(v) {\n\treturn v[0] * v[0] + v[1] * v[1];\n}\n\n/** \r\n * Returns the Manhattan distance between two 2d points.\r\n * @param {number[]} p1 - A point.\r\n * @param {number[]} p2 - Another point.\r\n * @returns {number}\r\n */\nfunction manhattanDistanceBetween(p1, p2) {\n\treturn Math.abs(p1[0] - p2[0]) + Math.abs(p1[1] - p2[1]);\n}\n\n/** \r\n * Returns the Manhattan length of the given 2-vector.\r\n * @param {number[]} p - A vector\r\n * @returns {number}\r\n */\nfunction manhattanLength(p) {\n\treturn Math.abs(p[0]) + Math.abs(p[1]);\n}\n\n/**\r\n * <p>\r\n * Returns the distance between the given point and line. \r\n * </p>\r\n * <p>\r\n * See <a href=\"https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points\">\r\n * this Wikipedia article</a>\r\n * </p>\r\n * @param {number[]} p - A point\r\n * @param {number[][]} l - A line\r\n * @returns {number}\r\n */\nfunction distanceBetweenPointAndLine(p, l) {\n\tvar _p = _slicedToArray(p, 2),\n\t    x0 = _p[0],\n\t    y0 = _p[1];\n\n\tvar _l = _slicedToArray(l, 2),\n\t    _l$ = _slicedToArray(_l[0], 2),\n\t    x1 = _l$[0],\n\t    y1 = _l$[1],\n\t    _l$2 = _slicedToArray(_l[1], 2),\n\t    x2 = _l$2[0],\n\t    y2 = _l$2[1];\n\n\tvar y = y2 - y1;\n\tvar x = x2 - x1;\n\n\tvar a = y * x0 - x * y0 + x2 * y1 - y2 * x1;\n\tvar b = Math.sqrt(x * x + y * y);\n\n\treturn Math.abs(a / b);\n}\n\n/**\r\n * Returns the squared distance between the given point and line segment. \r\n * @param {number[]} p - A point\r\n * @param {number[][]} l - A line\r\n * @returns {number}\r\n */\nfunction squaredDistanceBetweenPointAndLineSegment(p, l) {\n\tvar v = l[0];\n\tvar w = l[1];\n\n\tvar l2 = squaredDistanceBetween(v, w);\n\tif (l2 == 0) {\n\t\treturn squaredDistanceBetween(p, v);\n\t}\n\n\tvar t = ((p[0] - v[0]) * (w[0] - v[0]) + (p[1] - v[1]) * (w[1] - v[1])) / l2;\n\tt = Math.max(0, Math.min(1, t));\n\n\tvar d2 = squaredDistanceBetween(p, [v[0] + t * (w[0] - v[0]), v[1] + t * (w[1] - v[1])]);\n\n\treturn d2;\n}\n\n/**\r\n * Returns the circumcenter of the given 2d triangle (given as three 2d points).\r\n * @param {number[][]} triangle \r\n * @returns {number[]}\r\n */\nfunction circumCenter(triangle) {\n\t// See wikipedia\n\tvar p1 = triangle[0];\n\tvar p2 = triangle[1];\n\tvar p3 = triangle[2];\n\n\tvar Sx = 0.5 * det3([lengthSquared(p1), p1[1], 1], [lengthSquared(p2), p2[1], 1], [lengthSquared(p3), p3[1], 1]);\n\n\tvar Sy = 0.5 * det3([p1[0], lengthSquared(p1), 1], [p2[0], lengthSquared(p2), 1], [p3[0], lengthSquared(p3), 1]);\n\n\tvar a = det3([p1[0], p1[1], 1], [p2[0], p2[1], 1], [p3[0], p3[1], 1]);\n\n\tvar b = det3([p1[0], p1[1], lengthSquared(p1)], [p2[0], p2[1], lengthSquared(p2)], [p3[0], p3[1], lengthSquared(p3)]);\n\n\treturn [Sx / a, Sy / a];\n}\n\n/** \r\n * <p>\r\n * Returns the incenter of the given triangle.\r\n * </p>\r\n * <p>\r\n * See Wikipedia - https://en.wikipedia.org/wiki/Incenter \r\n * </p>\r\n * @param {number[][]} triangle \r\n * @returns {number[]}\r\n */\nfunction inCenter(triangle) {\n\tvar p1 = triangle[0];\n\tvar p2 = triangle[1];\n\tvar p3 = triangle[2];\n\n\tvar l1 = distanceBetween(p2, p3);\n\tvar l2 = distanceBetween(p1, p3);\n\tvar l3 = distanceBetween(p1, p2);\n\tvar lengthSum = l1 + l2 + l3;\n\treturn [(l1 * p1[0] + l2 * p2[0] + l3 * p3[0]) / lengthSum, (l1 * p1[1] + l2 * p2[1] + l3 * p3[1]) / lengthSum];\n}\n\n/**\r\n * Returns the centroid of the given polygon, e.g. triangle. The polygon\r\n * must be simple, i.e. not self-intersecting.\r\n * @param {number[][]} polygon \r\n * @returns {number[]}\r\n */\nfunction centroid(polygon) {\n\tif (polygon.length === 3) {\n\t\tvar p1 = polygon[0];\n\t\tvar p2 = polygon[1];\n\t\tvar p3 = polygon[2];\n\n\t\tvar x = p1[0] + p2[0] + p3[0];\n\t\tvar y = p1[1] + p2[1] + p3[1];\n\n\t\treturn [x / 3, y / 3];\n\t}\n\n\t// polygon.length assumed > 3 and assumed to be non-self-intersecting\n\t// See wikipedia\n\n\t// First calculate the area, A, of the polygon\n\tvar A = 0;\n\tfor (var i = 0; i < polygon.length; i++) {\n\t\tvar p0 = polygon[i];\n\t\tvar _p2 = i === polygon.length - 1 ? polygon[0] : polygon[i + 1];\n\n\t\tA = A + (p0[0] * _p2[1] - _p2[0] * p0[1]);\n\t}\n\tA = A / 2;\n\n\tvar C = [0, 0];\n\tfor (var _i = 0; _i < polygon.length; _i++) {\n\t\tvar _p3 = polygon[_i];\n\t\tvar _p4 = _i === polygon.length - 1 ? polygon[0] : polygon[_i + 1];\n\n\t\tC[0] = C[0] + (_p3[0] + _p4[0]) * (_p3[0] * _p4[1] - _p4[0] * _p3[1]);\n\t\tC[1] = C[1] + (_p3[1] + _p4[1]) * (_p3[0] * _p4[1] - _p4[0] * _p3[1]);\n\t}\n\n\treturn [C[0] / (6 * A), C[1] / (6 * A)];\n}\n\n/**\r\n * Calculate the determinant of three 3-vectors, i.e. 3x3 matrix\r\n * @ignore\r\n * @param {number[]} x \r\n * @param {number[]} y\r\n * @param {number[]} z\r\n * @returns {number}\r\n */\nfunction det3(x, y, z) {\n\treturn x[0] * (y[1] * z[2] - y[2] * z[1]) - x[1] * (y[0] * z[2] - y[2] * z[0]) + x[2] * (y[0] * z[1] - y[1] * z[0]);\n}\n\n/**\r\n * Returns the result of adding two 2-vectors. This function is curried.\r\n * @param {number[]} a - A vector\r\n * @param {number[]} b - Another vector\r\n * @param {number[]}\r\n */\nfunction translate(a, b) {\n\tfunction f(b) {\n\t\treturn [a[0] + b[0], a[1] + b[1]];\n\t}\n\n\t// Curry the function\n\treturn b === undefined ? f : f(b);\n}\n\n/**\r\n * Creates a transformation function that operates on multiple points from the \r\n * given arity two function.\r\n * @ignore\r\n */\nfunction createCurriedFunctionArity2(f) {\n\treturn function (a, ps) {\n\t\tvar f1 = f(a); // Cache for speed\n\t\tvar fPs = function fPs(ps) {\n\t\t\treturn ps.map(f1);\n\t\t};\n\n\t\t// Curry the function\n\t\treturn ps === undefined ? fPs : fPs(ps);\n\t};\n}\n\n/**\r\n * Creates a transformation function that operates on multiple points from the \r\n * given curried arity three function.\r\n * @ignore\r\n */\nfunction createCurriedFunctionArity3(f) {\n\treturn function (a, b, ps) {\n\t\tvar f2 = f(a, b); // Cache for speed\n\t\tvar fPs = function fPs(ps) {\n\t\t\treturn ps.map(f2);\n\t\t};\n\n\t\t// Curry the function\n\t\treturn ps === undefined ? fPs : fPs(ps);\n\t};\n}\n\n/**\r\n * Return the given 2d points translated by the given 2d vector. This function\r\n * is curried.\r\n * @param {number} sinθ\r\n * @param {number} cosθ\r\n * @param {number[][]} ps \r\n * @returns {number[][]}\r\n */\nvar rotatePs = createCurriedFunctionArity3(rotate);\n\n/**\r\n * Return the given 2d points translated by the given 2d vector. This function\r\n * is curried.\r\n * @param {number[]} v \r\n * @param {number[][]} ps \r\n * @returns {number[][]}\r\n */\nvar translatePs = createCurriedFunctionArity2(translate);\n\n/**\r\n * Returns a rotated version of the given 2-vector given the sine and cosine of the angle.\r\n * @param {number} sinθ\r\n * @param {number} cosθ\r\n * @param {number[]} p\r\n * @returns {number[]}\r\n */\nfunction rotate(sinθ, cosθ, p) {\n\tfunction rotateByθ(p) {\n\t\treturn [p[0] * cosθ - p[1] * sinθ, p[0] * sinθ + p[1] * cosθ];\n\t}\n\n\t// Curry the function\n\treturn p === undefined ? rotateByθ : rotateByθ(p);\n}\n\n/**\r\n * Returns true if two 2-vectors are identical, false otherwise.\r\n * @param {number[]} a\r\n * @param {number[]} b\r\n * @returns {boolean}\r\n */\nfunction equal(a, b) {\n\treturn a[0] === b[0] && a[1] === b[1];\n}\n\n/**\r\n * Returns a anti-clockwise rotated version of the given 2-vector given the sine \r\n * and cosine of the angle.\r\n * @param {number[]} p \r\n * @param {number} sinθ\r\n * @param {number} cosθ\r\n * @returns {number[]}\r\n */\nfunction reverseRotate(sinθ, cosθ, p) {\n\treturn [+p[0] * cosθ + p[1] * sinθ, -p[0] * sinθ + p[1] * cosθ];\n}\n\n/**\r\n * Returns a 90 degrees rotated version of the given 2-vector.\r\n * @param {number[]} p \r\n * @returns {number[]}\r\n */\nfunction rotate90Degrees(p) {\n\treturn [-p[1], p[0]];\n}\n\n/**\r\n * Returns a negative 90 degrees rotated version of the given 2-vector.\r\n * @param {number[]} p \r\n * @returns {number[]}\r\n */\nfunction rotateNeg90Degrees(p) {\n\treturn [p[1], -p[0]];\n}\n\n/**\r\n * Transforms the given 2-vector by applying the given function to each coordinate.\r\n * @param {number[]} p \r\n * @param {function} f \r\n * @returns {*[]}\r\n */\nfunction transform(p, f) {\n\treturn [f(p[0]), f(p[1])];\n}\n\n/**\r\n * Returns the closest point to the array of 2d points, optionally providing a distance function.\r\n * @param {number[]} p\r\n * @param {number[][]} ps\r\n * @param {function} f - Distance function - if undefined uses squaredDistanceBetween\r\n */\nfunction getClosestTo(p, ps, f) {\n\tf = f === undefined ? squaredDistanceBetween : f;\n\n\tvar cp = undefined; // Closest Point\n\tvar bestd = Number.POSITIVE_INFINITY;\n\tfor (var i = 0; i < ps.length; i++) {\n\t\tvar p_ = ps[i];\n\n\t\tvar d = f(p, p_);\n\t\tif (d < bestd) {\n\t\t\tcp = p_;\n\t\t\tbestd = d;\n\t\t}\n\t}\n\n\treturn cp;\n}\n\n/** \r\n * Returns an array of points by applying a translation and then rotation to the given points.\r\n * @param {number[]} v - The translation vector\r\n * @param {number} sinθ \r\n * @param {number} cosθ\r\n * @param {number[][]} ps - The input points\r\n * @returns {number[][]}\r\n **/\nfunction translateThenRotatePs(v, sinθ, cosθ, ps) {\n\treturn ps.map(function (p) {\n\t\treturn rotate(sinθ, cosθ, translate(v, p));\n\t});\n}\n\n/** \r\n * Returns an array of points by applying a rotation and then translation to the given points.\r\n * @param {number} sinθ \r\n * @param {number} cosθ\r\n * @param {number[]} v - The translation vector\r\n * @param {number[][]} ps - The input points\r\n * @returns {number[][]}\r\n **/\nfunction rotateThenTranslatePs(sinθ, cosθ, v, ps) {\n\treturn ps.map(function (p) {\n\t\treturn translate(v, rotate(sinθ, cosθ, p));\n\t});\n}\n\n/*\r\n * Purely functional 2d vector utilities.\r\n */\nvar Vector = {\n\tdot: dot,\n\tcross: cross,\n\tccw: ccw,\n\tsegSegIntersection: segSegIntersection,\n\tdoesSegSegIntersect: doesSegSegIntersect,\n\tsquaredDistanceBetween: squaredDistanceBetween,\n\tscale: scale,\n\treverse: reverse,\n\ttranslate: translate,\n\ttoUnitVector: toUnitVector,\n\ttoLength: toLength,\n\tfromTo: fromTo,\n\tinterpolate: interpolate,\n\tmean: mean,\n\tdistanceBetween: distanceBetween,\n\tlength: length,\n\tlengthSquared: lengthSquared,\n\tmanhattanDistanceBetween: manhattanDistanceBetween,\n\tmanhattanLength: manhattanLength,\n\tdistanceBetweenPointAndLine: distanceBetweenPointAndLine,\n\tsquaredDistanceBetweenPointAndLineSegment: squaredDistanceBetweenPointAndLineSegment,\n\tcircumCenter: circumCenter,\n\tinCenter: inCenter,\n\tcentroid: centroid,\n\tequal: equal,\n\trotate: rotate,\n\trotatePs: rotatePs,\n\treverseRotate: reverseRotate,\n\trotate90Degrees: rotate90Degrees,\n\trotateNeg90Degrees: rotateNeg90Degrees,\n\ttransform: transform,\n\tgetClosestTo: getClosestTo,\n\ttranslatePs: translatePs,\n\ttranslateThenRotatePs: translateThenRotatePs,\n\trotateThenTranslatePs: rotateThenTranslatePs\n};\n\nmodule.exports = Vector;\n\n},{}]},{},[1])(1)\n});"]}