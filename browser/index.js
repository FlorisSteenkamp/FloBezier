var FloBezier;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "areBeziersInSameKFamily": () => (/* reexport */ areBeziersInSameKFamily),
  "areBoxesIntersecting": () => (/* reexport */ areBoxesIntersecting),
  "bezier3Intersection": () => (/* reexport */ bezier3Intersection),
  "bezierBezierIntersection": () => (/* reexport */ bezierBezierIntersection),
  "bezierFromPart": () => (/* reexport */ bezierFromPart),
  "bezierSelfIntersection": () => (/* reexport */ bezierSelfIntersection),
  "circleBezierIntersection": () => (/* reexport */ circleBezierIntersection),
  "clone": () => (/* reexport */ clone),
  "closestPointOnBezier": () => (/* reexport */ closestPointOnBezier),
  "closestPointOnBezierCertified": () => (/* reexport */ closestPointOnBezierCertified),
  "cubicThroughPointGiven013": () => (/* reexport */ cubicThroughPointGiven013),
  "cubicToQuadratic": () => (/* reexport */ cubicToQuadratic),
  "curvature": () => (/* reexport */ curvature),
  "equal": () => (/* reexport */ simultaneous_properties_equal_equal),
  "evalDeCasteljau": () => (/* reexport */ evalDeCasteljau),
  "evalDeCasteljauError": () => (/* reexport */ evalDeCasteljauError),
  "evaluate": () => (/* reexport */ evaluate),
  "evaluateDdxy": () => (/* reexport */ evaluateDdxy),
  "evaluateDxy": () => (/* reexport */ evaluateDxy),
  "evaluateExact": () => (/* reexport */ evaluateExact),
  "flatness": () => (/* reexport */ flatness),
  "from0ToT": () => (/* reexport */ from0ToT),
  "fromPowerBasis": () => (/* reexport */ fromPowerBasis),
  "fromTTo1": () => (/* reexport */ fromTTo1),
  "fromTo": () => (/* reexport */ split_merge_clone_from_to_fromTo),
  "fromToPrecise": () => (/* reexport */ fromToPrecise),
  "generateCuspAtHalf3": () => (/* reexport */ generateCuspAtHalf3),
  "getBoundingBox": () => (/* reexport */ getBoundingBox),
  "getBoundingBoxTight": () => (/* reexport */ getBoundingBoxTight),
  "getBoundingHull": () => (/* binding */ getBoundingHull),
  "getBounds": () => (/* reexport */ getBounds),
  "getCoeffsBez1Bez1Dd": () => (/* reexport */ getCoeffsBez1Bez1Dd),
  "getCoeffsBez1Bez1Exact": () => (/* reexport */ getCoeffsBez1Bez1Exact),
  "getCoeffsBez1Bez2Dd": () => (/* reexport */ getCoeffsBez1Bez2Dd),
  "getCoeffsBez1Bez2Exact": () => (/* reexport */ getCoeffsBez1Bez2Exact),
  "getCoeffsBez1Bez3Dd": () => (/* reexport */ getCoeffsBez1Bez3Dd),
  "getCoeffsBez1Bez3Exact": () => (/* reexport */ getCoeffsBez1Bez3Exact),
  "getCoeffsBez2Bez1Dd": () => (/* reexport */ getCoeffsBez2Bez1Dd),
  "getCoeffsBez2Bez1Exact": () => (/* reexport */ getCoeffsBez2Bez1Exact),
  "getCoeffsBez2Bez2Dd": () => (/* reexport */ getCoeffsBez2Bez2Dd),
  "getCoeffsBez2Bez2Exact": () => (/* reexport */ getCoeffsBez2Bez2Exact),
  "getCoeffsBez2Bez3Dd": () => (/* reexport */ getCoeffsBez2Bez3Dd),
  "getCoeffsBez2Bez3Exact": () => (/* reexport */ getCoeffsBez2Bez3Exact),
  "getCoeffsBez3": () => (/* reexport */ getCoeffsBez3WithRunningError),
  "getCoeffsBez3Bez1Dd": () => (/* reexport */ getCoeffsBez3Bez1Dd),
  "getCoeffsBez3Bez1Exact": () => (/* reexport */ getCoeffsBez3Bez1Exact),
  "getCoeffsBez3Bez2Dd": () => (/* reexport */ getCoeffsBez3Bez2Dd),
  "getCoeffsBez3Bez2Exact": () => (/* reexport */ getCoeffsBez3Bez2Exact),
  "getCoeffsBez3Bez3Dd": () => (/* reexport */ getCoeffsBez3Bez3Dd),
  "getCoeffsBez3Bez3Exact": () => (/* reexport */ getCoeffsBez3Bez3Exact),
  "getCoeffsBez3Exact": () => (/* reexport */ getCoeffsBez3Exact),
  "getCoeffsBezBez": () => (/* reexport */ getCoeffsBezBez),
  "getControlPointBox": () => (/* reexport */ getControlPointBox),
  "getCurvatureExtrema": () => (/* reexport */ getCurvatureExtrema),
  "getDddxy": () => (/* reexport */ getDddxy),
  "getDdxy": () => (/* reexport */ getDdxy),
  "getDdxyAt0": () => (/* reexport */ getDdxyAt0),
  "getDdxyAt1": () => (/* reexport */ getDdxyAt1),
  "getDxy": () => (/* reexport */ getDxy),
  "getDxyAt0": () => (/* reexport */ getDxyAt0),
  "getDxyAt1": () => (/* reexport */ getDxyAt1),
  "getHodograph": () => (/* reexport */ getHodograph),
  "getImplicitForm1": () => (/* reexport */ getImplicitForm1),
  "getImplicitForm1DdWithRunningError": () => (/* reexport */ getImplicitForm1DdWithRunningError),
  "getImplicitForm1ErrorCounters": () => (/* reexport */ getImplicitForm1ErrorCounters),
  "getImplicitForm1Exact": () => (/* reexport */ getImplicitForm1Exact),
  "getImplicitForm2": () => (/* reexport */ getImplicitForm2),
  "getImplicitForm2DdWithRunningError": () => (/* reexport */ getImplicitForm2DdWithRunningError),
  "getImplicitForm2ErrorCounters": () => (/* reexport */ getImplicitForm2ErrorCounters),
  "getImplicitForm2Exact": () => (/* reexport */ getImplicitForm2Exact),
  "getImplicitForm3": () => (/* reexport */ getImplicitForm3),
  "getImplicitForm3DdWithRunningError": () => (/* reexport */ getImplicitForm3DdWithRunningError),
  "getImplicitForm3ErrorCounters": () => (/* reexport */ getImplicitForm3ErrorCounters),
  "getImplicitForm3Exact": () => (/* reexport */ getImplicitForm3Exact),
  "getInflections": () => (/* reexport */ getInflections),
  "getIntervalBox": () => (/* reexport */ getIntervalBox),
  "getIntervalBoxDd": () => (/* reexport */ getIntervalBoxDd),
  "getTAtLength": () => (/* reexport */ getTAtLength),
  "getXY": () => (/* reexport */ getXY),
  "getXYDdAnyBitlength3": () => (/* reexport */ get_xy_dd_with_running_error_getXY3DdWithRunningError),
  "hausdorffDistance": () => (/* reexport */ hausdorffDistance),
  "hausdorffDistanceCandidates": () => (/* reexport */ hausdorffDistanceCandidates),
  "intersectBoxes": () => (/* reexport */ intersectBoxes),
  "isCubicReallyQuad": () => (/* reexport */ isCubicReallyQuad),
  "isHorizontalLine": () => (/* reexport */ isHorizontalLine),
  "isLine": () => (/* reexport */ isLine),
  "isPointOnBezierExtension": () => (/* reexport */ isPointOnBezierExtension),
  "isQuadObtuse": () => (/* reexport */ isQuadObtuse),
  "isQuadReallyLine": () => (/* reexport */ isQuadReallyLine),
  "isSelfOverlapping": () => (/* reexport */ isSelfOverlapping),
  "isVerticalLine": () => (/* reexport */ isVerticalLine),
  "length": () => (/* reexport */ length_length),
  "lengthSquaredUpperBound": () => (/* reexport */ lengthSquaredUpperBound),
  "lengthUpperBound": () => (/* reexport */ lengthUpperBound),
  "normal": () => (/* reexport */ normal),
  "quadToPolyline": () => (/* reexport */ quadToPolyline),
  "reverse": () => (/* reexport */ reverse),
  "splitAt": () => (/* reexport */ splitAt),
  "splitAtPrecise": () => (/* reexport */ splitAtPrecise),
  "splitByCurvatureAndLength": () => (/* reexport */ splitByCurvatureAndLength),
  "splitByMaxCurvature": () => (/* reexport */ splitByMaxCurvature),
  "splitByMaxCurveLength": () => (/* reexport */ splitByMaxCurveLength),
  "tFromXY3": () => (/* reexport */ tFromXY3),
  "tangent": () => (/* reexport */ tangent),
  "toCubic": () => (/* reexport */ toCubic),
  "toEstimation": () => (/* reexport */ toEstimation),
  "toExpansion": () => (/* reexport */ toExpansion),
  "toHybridQuadratic": () => (/* reexport */ to_hybrid_quadratic_toHybridQuadratic),
  "toQuadraticFromCubic": () => (/* reexport */ toQuadraticFromCubic),
  "toString": () => (/* binding */ src_toString),
  "totalAbsoluteCurvature": () => (/* reexport */ totalAbsoluteCurvature),
  "totalCurvature": () => (/* reexport */ totalCurvature),
  "totalLength": () => (/* reexport */ totalLength),
  "κ": () => (/* reexport */ κ)
});

;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-sign.js
/**
 * Returns the sign of the given expansion.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * From Shewchuk: "A nonoverlapping expansion is desirable because it is easy to
 * determine its sign (take the sign of the largest component) ... "
 *
 * @param e A floating point expansion with zeroes eliminated.
 */
function e_sign_eSign(e) {
    return e[e.length - 1];
}

//# sourceMappingURL=e-sign.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-representation/double-to-octets.js
// Modified from https://github.com/bartaz/ieee754-visualization/
// under the MIT license
// Copyright 2013 Bartek Szopka (original author)
/**
 * Returns the ieee-574 8 bytes composing the given double, starting from the
 * sign bit and ending in the lsb of the significand.
 * e.g. 123.456 -> [64, 94, 221, 47, 26, 159, 190, 119]
 */
function doubleToOctets(number) {
    var buffer = new ArrayBuffer(8);
    new DataView(buffer).setFloat64(0, number, false);
    return Array.from(new Uint8Array(buffer));
}

//# sourceMappingURL=double-to-octets.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-representation/double-to-binary-string.js
// Modified from https://github.com/bartaz/ieee754-visualization/
// under the MIT license
// Copyright 2013 Bartek Szopka (original author)

function doubleToBinaryString(number) {
    return octetsToBinaryString(doubleToOctets(number));
}
/**
 * @param octets The 8 bytes composing a double (msb first)
 */
function octetsToBinaryString(octets) {
    return octets
        .map(int8ToBinaryString)
        .join('');
}
/**
 * intToBinaryString(8) -> "00001000"
 */
function int8ToBinaryString(i) {
    let iStr = i.toString(2);
    for (; iStr.length < 8; iStr = "0" + iStr)
        ;
    return iStr;
}

//# sourceMappingURL=double-to-binary-string.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-representation/parse-double.js
// Modified from https://github.com/bartaz/ieee754-visualization/
// under the MIT license
// Copyright 2013 Bartek Szopka (original author)


/**
 * Returns the relevant parts of the given IEEE-754 double. The returned
 * exponent has been normalized (i.e. 1023 ha been subtracted) and the
 * significand has the hidden bit added if appropriate.
 * See https://github.com/bartaz/ieee754-visualization
 */
function parseDouble(x) {
    let parts = doubleToOctets(x);
    let p0 = parts[0];
    let p1 = parts[1];
    let sign = p0 >> 7;
    let exponent_ = ((p0 & 127) << 4) + ((p1 & 0b11110000) >> 4);
    //---- Check for negative / positive zero / denormalized numbers.
    let hiddenMsb = exponent_ === 0 ? 0 : 16;
    // Note: exponent === 0 => 0 or denormalized number (a.k.a. subnormal number).
    let exponent = exponent_ === 0
        ? exponent_ - 1022 // Subnormals use a biased exponent of 1 (not 0!)
        : exponent_ - 1023;
    //---- Break up the significand into bytes
    let significand = parts.slice(1);
    significand[0] = (p1 & 15) + hiddenMsb;
    return {
        sign,
        exponent,
        significand
    };
}
/**
 * Returns the relevant parts of the given IEEE-754 double.
 * See https://github.com/bartaz/ieee754-visualization.
 * This is a slower version of parseDouble that gives binary string
 * representations of the components.
 */
function parseDoubleDetailed(x) {
    let str = doubleToBinaryString(x);
    // sign{1} exponent{11} fraction{52} === 64 bits (+1 hidden!)
    let [, sign, exponent, significand] = str.match(/^(.)(.{11})(.{52})$/);
    let exponent_ = parseInt(exponent, 2);
    let hidden = exponent_ === 0 ? "0" : "1";
    return {
        full: sign + exponent + hidden + significand,
        sign,
        exponent,
        hidden,
        significand
    };
}

//# sourceMappingURL=parse-double.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-representation/significand.js

/**
 * Return the significand of the given double with the hidden bit added (in case
 * a is not subnormal or 0, etc.)
 * @param a A double
 */
function significand(a) {
    return parseDouble(a).significand;
}

//# sourceMappingURL=significand.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-representation/get-max-set-bit.js

/**
 * Returns the lowest set bit of the given value in [1, (2**31)-1],
 * i.e. from 1 up to 2147483647 else if no bit is set (input === 0) returns
 * NaN, otherwise if the number is out of range returns a non-finite
 * number.
 * See https://stackoverflow.com/a/35190288/2010061
 */
function getLowestSetBit_(a) {
    return Math.log2(a & -a);
}
/**
 * Returns the lowest set bit of the given number's significand (where the lsb
 * is bit 0 and the msb is bit 52). If no bit is set (input === 0 or +-inf or
 * NaN) returns NaN.
 * See https://stackoverflow.com/a/35190288/2010061
 */
function getLowestSetBit(a) {
    if (a === 0 || !Number.isFinite(a)) {
        // There is no lowest set bit
        return NaN;
    }
    // Note: the significand includes the hidden bit!
    let s = significand(a);
    let len = s.length;
    for (let i = len - 1; i >= 0; i--) {
        if (s[i] === 0) {
            continue;
        }
        let l = getLowestSetBit_(s[i]);
        if (Number.isFinite(l)) {
            return (8 * (len - i - 1)) + l;
        }
    }
    return NaN;
}
/**
 * Returns the highest set bit of the given value in [1, 255], i.e. from 1 up
 * to 255. If the input number === 0 returns NaN.
 * See https://stackoverflow.com/a/35190288/2010061
 */
function getHighestSetBit_(a) {
    return a >= 128 ? 7
        : a >= 64 ? 6
            : a >= 32 ? 5
                : a >= 16 ? 4
                    : a >= 8 ? 3
                        : a >= 4 ? 2
                            : a >= 2 ? 1
                                : a >= 1 ? 0
                                    : NaN;
}
/**
 * Returns the highest set bit of the given double. If no bit is set (input
 * === 0 or +/-inf or NaN) returns NaN.
 * See https://stackoverflow.com/a/35190288/2010061
 */
function getHighestSetBit(a) {
    if (a === 0 || !Number.isFinite(a)) {
        // There is no lowest set bit
        return NaN;
    }
    // At this point there must be a highest set bit (always === 52 if the 
    // number is not a subnormal.
    let s = significand(a);
    let len = s.length;
    for (let i = 0; i < len; i++) {
        let l = getHighestSetBit_(s[i]);
        if (Number.isFinite(l)) {
            return (8 * (len - i - 1)) + l;
        }
    }
    return NaN;
}

//# sourceMappingURL=get-max-set-bit.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-representation/exponent.js

/**
 * Returns the normalized exponent of the given number.
 * @param a A double
 */
function exponent(a) {
    return parseDouble(a).exponent;
}

//# sourceMappingURL=exponent.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-representation/msb-exponent.js


/**
 * Returns the true exponent of the msb that is set of the given number or
 * NaN if a === 0 or +-inf or NaN.
 * @param a An array of numbers to check
 */
function msbExponent(a) {
    if (a === 0 || !Number.isFinite(a)) {
        return NaN;
    }
    let e = exponent(a);
    // Will return e for all but subnormal numbers
    return getHighestSetBit(a) - 52 + e;
}

//# sourceMappingURL=msb-exponent.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-compress.js
/**
 * Returns the result of compressing the given floating point expansion.
 *
 * * primarily for internal library use
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * Theorem 23 (Shewchuck): Let e = sum_(i=1)^m(e_i) be a nonoverlapping
 * expansion of m p-bit components, where m >= 3. Suppose that the components of
 * e are sorted in order of increasing magnitude, except that any of the e_i may
 * be zero. Then the following algorithm will produce a nonoverlapping expansion
 * (nonadjacent if round-to even tiebreaking is used) such that
 * h = sum_(i=1)^n(h_i) = e, where the components h_i are in order of increasing
 * magnitude. If h != 0, none of the h_i will be zero. Furthermore, the largest
 * component h_n approximates h with an error smaller than ulp(h_n).
 */
function e_compress_eCompress(e) {
    //return e;
    const e_ = e.slice();
    const m = e_.length;
    if (m === 1) {
        return e_;
    }
    let Q = e_[m - 1];
    let bottom = m;
    for (let i = m - 2; i >= 0; --i) {
        const a = Q;
        const b = e_[i];
        Q = a + b;
        const bv = Q - a;
        const q = b - bv;
        if (q) {
            e_[--bottom] = Q;
            Q = q;
        }
    }
    let top = 0;
    for (let i = bottom; i < m; ++i) {
        const a = e_[i];
        const b = Q;
        Q = a + b;
        const bv = Q - a;
        const q = b - bv;
        if (q) {
            e_[top++] = q;
        }
    }
    e_[top++] = Q;
    e_.length = top;
    return e_;
}

//# sourceMappingURL=e-compress.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/basic/reduce-significand.js
/**
 * Truncates a floating point value's significand and returns the result.
 * Similar to split, but with the ability to specify the number of bits to keep.
 *
 * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where
 * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the
 * following algorithm will produce a (p-s)-bit value a_hi and a
 * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and
 * a = a_hi + a_lo.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param a a double
 * @param bits the number of significand bits to leave intact
 */
function reduceSignificand(a, bits) {
    const s = 53 - bits;
    const f = 2 ** s + 1;
    const c = f * a;
    const r = c - (c - a);
    return r;
}

//# sourceMappingURL=reduce-significand.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-to-bitlength.js




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const sign = e_sign_eSign;
const compress = e_compress_eCompress;
/**
 * Returns a floating point expansion accurate to the given number of bits.
 * Extraneous bits are discarded.
 * @param a a floating point expansion
 * @param l the number of accurate bits to keep
 */
// TODO - make faster
function eToBitlength(a, l) {
    a = compress(a);
    if (sign(a) === 0) {
        return [0];
    }
    let maxMsb = msbExponent(a[a.length - 1]);
    let msb = maxMsb;
    let i = a.length - 1; // start at most significant byte
    while (i > 0) {
        let msb_ = msbExponent(a[i - 1]);
        if (maxMsb - msb_ > l) {
            break;
        }
        msb = msb_;
        i--;
    }
    let keepBits = Math.min(l - (maxMsb - msb), 53);
    let b = a[i];
    b = reduceSignificand(b, keepBits);
    let result = a.slice(i);
    result[0] = b;
    return result;
}

//# sourceMappingURL=e-to-bitlength.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-estimate.js
/**
 * Returns the result of the given floating point expansion rounded to a double
 * floating point number.
 *
 * The result is within 1 ulps of the actual value, e.g. imagine the worst case
 * situation where we add (in 4dot4) 1111.1000 + 0.000011111111... The result
 * will be 1111.1000 whereas as the correct result should be 1111.1001 and we
 * thus lost 1 ulp of accuracy. It does not matter that the expansion contain
 * several floats since none is overlapping.
 *
 * See Shewchuk https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 *
 * @param e a floating point expansion
 */
function e_estimate_eEstimate(e) {
    let Q = e[0];
    for (let i = 1; i < e.length; i++) {
        Q += e[i];
    }
    return Q;
}

//# sourceMappingURL=e-estimate.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/fast-expansion-sum.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const fast_expansion_sum_compress = (/* unused pure expression or super */ null && (eCompress));
/**
 * Returns the result of adding two expansions.
 *
 * Theorem 13: Let e = sum_(i=1)^m(e_i) and f = sum_(i=1)^n(f_i) be strongly
 * nonoverlapping expansions of m and n p-bit components, respectively, where
 * p >= 4. Suppose that the components of both e and f are sorted in order of
 * increasing magnitude, except that any of the e_i or f_i may be zero. On a
 * machine whose arithmetic uses the round-to-even rule, the following algorithm
 * will produce a strongly nonoverlapping expansion h such that
 * sum_(i=1)^(m+n)(e_i + f_i) = e + f, where the components of h are also in
 * order of increasing magnitude, except that any of the h_i may be zero.
 *
 * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 */
function fastExpansionSum(e, f) {
    //const g = merge(e,f);
    // inlined (above line)
    const lenE = e.length;
    const lenF = f.length;
    let i = 0;
    let j = 0;
    const g = [];
    while (i < lenE && j < lenF) {
        if (e[i] === 0) {
            i++;
            continue;
        }
        if (f[j] === 0) {
            j++;
            continue;
        }
        if (Math.abs(e[i]) <= Math.abs(f[j])) {
            g.push(e[i]);
            i++;
        }
        else {
            g.push(f[j]);
            j++;
        }
    }
    while (i < lenE) {
        g.push(e[i]);
        i++;
    }
    while (j < lenF) {
        g.push(f[j]);
        j++;
    }
    if (g.length === 0) {
        return [0];
    }
    // end inlined
    const len = g.length;
    if (len === 1) {
        return g;
    }
    //const h: number[] = new Array(len);
    const h = [];
    //const q: number;
    //[h[0], q] = fastTwoSum(g[1], g[0]);
    // inlined (above line)
    const a = g[1];
    const b = g[0];
    let q = a + b;
    //h[0] = b - (q - a);
    const hh = b - (q - a);
    if (hh !== 0) {
        h.push(hh);
    }
    ;
    //let j = 0;
    j = 0;
    for (let i = 2; i < len; i++) {
        //[h[i-1], q] = twoSum(q, g[i]);
        // inlined (above line)
        const b = g[i];
        const R = q + b;
        const _ = R - q;
        //h[i-1] = (q - (R - _)) + (b - _);
        const hh = (q - (R - _)) + (b - _);
        if (hh !== 0) {
            h.push(hh);
        }
        q = R;
    }
    //h[len-1] = q;
    //h.push(q);
    if (q !== 0 || h.length === 0) {
        h.push(q);
    }
    //return compress(h);
    return h;
}
/**
 * Returns the result of merging an expansion e and f into a single expansion,
 * in order of nondecreasing magnitude (possibly with interspersed zeros).
 * (This function is zero-eliminating)
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param e a floating point expansion
 * @param f another floating point expansion
 */
function merge(e, f) {
    const lenE = e.length;
    const lenF = f.length;
    let i = 0;
    let j = 0;
    const merged = [];
    while (i < lenE && j < lenF) {
        if (e[i] === 0) {
            i++;
            continue;
        }
        if (f[j] === 0) {
            j++;
            continue;
        }
        if (Math.abs(e[i]) <= Math.abs(f[j])) {
            merged.push(e[i]);
            i++;
        }
        else {
            merged.push(f[j]);
            j++;
        }
    }
    while (i < lenE) {
        merged.push(e[i]);
        i++;
    }
    while (j < lenF) {
        merged.push(f[j]);
        j++;
    }
    if (merged.length === 0) {
        return [0];
    }
    return merged;
}

//# sourceMappingURL=fast-expansion-sum.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/scale-expansion.js




const f = 134217729; // 2**27 + 1;
// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const tp = (/* unused pure expression or super */ null && (twoProduct));
const ts = (/* unused pure expression or super */ null && (twoSum));
const fts = (/* unused pure expression or super */ null && (fastTwoSum));
const scale_expansion_compress = (/* unused pure expression or super */ null && (eCompress));
/**
 * Returns the result of multiplying an expansion by a double.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * Theorem 19 (Shwechuk): Let e = sum_(i=1)^m(e_i) be a nonoverlapping expansion
 * of m p-bit components, and const b be a p-bit value where p >= 4. Suppose that
 * the components of e are sorted in order of increasing magnitude, except that
 * any of the e_i may be zero. Then the following algorithm will produce a
 * nonoverlapping expansion h such that h = sum_(i=1)^(2m)(h_i) = be, where the
 * components of h are also in order of increasing magnitude, except that any of
 * the h_i may be zero. Furthermore, if e is nonadjacent and round-to-even
 * tiebreaking is used, then h is non-adjacent.
 *
 * @param e a double floating point expansion
 * @param b a double
 */
function scaleExpansion(e, b) {
    const m = e.length;
    //const h: number[] = new Array(2*m);
    let q_;
    //[h[0], q] = tp(e[0], b);
    // inlined (above line)
    const a = e[0];
    let q = a * b;
    const c = f * a;
    const ah = c - (c - a);
    const al = a - ah;
    const d = f * b;
    const bh = d - (d - b);
    const bl = b - bh;
    const h = [];
    //h[0] = (al*bl) - ((q - (ah*bh)) - (al*bh) - (ah*bl));
    const hh = (al * bl) - ((q - (ah * bh)) - (al * bh) - (ah * bl));
    if (hh !== 0) {
        h.push(hh);
    }
    ;
    for (let i = 1; i < m; i++) {
        //const [t, T] = tp(e[i], b);
        // inlined (above line)
        const a = e[i];
        const T = a * b;
        const c = f * a;
        const ah = c - (c - a);
        const al = a - ah;
        const d = f * b;
        const bh = d - (d - b);
        const bl = b - bh;
        const t = (al * bl) - ((T - (ah * bh)) - (al * bh) - (ah * bl));
        //[h[2*i-1], q_] = ts(q, t);
        // inlined (above line)
        const x = q + t;
        const bv = x - q;
        //h[2*i-1] = (q - (x - bv)) + (t - bv);
        //h.push((q - (x - bv)) + (t - bv));
        const hh = (q - (x - bv)) + (t - bv);
        if (hh !== 0) {
            h.push(hh);
        }
        q_ = x;
        //[h[2*i], q] = fts(T, q_);
        // inlined (above line)
        const xx = T + q_;
        //h[2*i] = q_ - (xx - T);
        //h.push(q_ - (xx - T));
        const hhh = q_ - (xx - T);
        if (hhh !== 0) {
            h.push(hhh);
        }
        q = xx;
    }
    //h[2*m - 1] = q;
    //h.push(q);
    if (q !== 0 || h.length === 0) {
        h.push(q);
    }
    //return eCompress(h);
    return h;
}
/**
 * Returns the result of multiplying an expansion by a double.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * Theorem 19 (Shwechuk): Let e = sum_(i=1)^m(e_i) be a nonoverlapping expansion
 * of m p-bit components, and const b be a p-bit value where p >= 4. Suppose that
 * the components of e are sorted in order of increasing magnitude, except that
 * any of the e_i may be zero. Then the following algorithm will produce a
 * nonoverlapping expansion h such that h = sum_(i=1)^(2m)(h_i) = be, where the
 * components of h are also in order of increasing magnitude, except that any of
 * the h_i may be zero. Furthermore, if e is nonadjacent and round-to-even
 * tiebreaking is used, then h is non-adjacent.
 *
 * @param e a double floating point expansion
 * @param b a double
 */
function scale_expansion_scaleExpansion2(b, e) {
    const m = e.length;
    //const h: number[] = new Array(2*m);
    let q_;
    //[h[0], q] = tp(e[0], b);
    // inlined (above line)
    const a = e[0];
    let q = a * b;
    const c = f * a;
    const ah = c - (c - a);
    const al = a - ah;
    const d = f * b;
    const bh = d - (d - b);
    const bl = b - bh;
    const h = [];
    //h[0] = (al*bl) - ((q - (ah*bh)) - (al*bh) - (ah*bl));
    const hh = (al * bl) - ((q - (ah * bh)) - (al * bh) - (ah * bl));
    if (hh !== 0) {
        h.push(hh);
    }
    ;
    for (let i = 1; i < m; i++) {
        //const [t, T] = tp(e[i], b);
        // inlined (above line)
        const a = e[i];
        const T = a * b;
        const c = f * a;
        const ah = c - (c - a);
        const al = a - ah;
        const d = f * b;
        const bh = d - (d - b);
        const bl = b - bh;
        const t = (al * bl) - ((T - (ah * bh)) - (al * bh) - (ah * bl));
        //[h[2*i-1], q_] = ts(q, t);
        // inlined (above line)
        const x = q + t;
        const bv = x - q;
        //h[2*i-1] = (q - (x - bv)) + (t - bv);
        //h.push((q - (x - bv)) + (t - bv));
        const hh = (q - (x - bv)) + (t - bv);
        if (hh !== 0) {
            h.push(hh);
        }
        q_ = x;
        //[h[2*i], q] = fts(T, q_);
        // inlined (above line)
        const xx = T + q_;
        //h[2*i] = q_ - (xx - T);
        //h.push(q_ - (xx - T));
        const hhh = q_ - (xx - T);
        if (hhh !== 0) {
            h.push(hhh);
        }
        q = xx;
    }
    //h[2*m - 1] = q;
    //h.push(q);
    if (q !== 0 || h.length === 0) {
        h.push(q);
    }
    //return eCompress(h);
    return h;
}

//# sourceMappingURL=scale-expansion.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/expansion-product.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const multByDouble = scaleExpansion;
const add = fastExpansionSum;
const expansion_product_compress = (/* unused pure expression or super */ null && (eCompress));
/**
 * Returns the product of two double floating point expansions.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * As per Shewchuk in the above paper: "To find the product of two expansions
 * e and f, use SCALE-EXPANSION (with zero elimination) to form the expansions
 * ef_1, ef_2, ..., then sum these using a distillation tree."
 *
 * A distillation tree used with fastExpansionSum will give O(k*log k) vs O(k^2)
 * operations.
 *
 * Implemented naively and not as described by Shewchuk (i.e. the algorithm
 * takes O(k^2) operations).
 * @param e a double floating point expansion
 * @param f another double floating point expansion
 */
function expansion_product_expansionProduct(e, f) {
    let sum = [0];
    for (let i = 0; i < e.length; i++) {
        sum = add(sum, multByDouble(f, e[i]));
    }
    //return compress(sum);
    return sum;
}

//# sourceMappingURL=expansion-product.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-negative-of.js
/**
 * Returns the negative of the given floating point expansion.
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param e a floating point expansion
 */
function eNegativeOf(e) {
    const m = e.length;
    const h = new Array(m);
    for (let i = 0; i < m; i++) {
        h[i] = -e[i];
    }
    return h;
}

//# sourceMappingURL=e-negative-of.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-diff.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const negativeOf = eNegativeOf;
const e_diff_add = fastExpansionSum;
/**
 * Returns the difference between two floating point expansions, i.e. e - f.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param e a floating point expansion
 * @param f another floating point expansion
 */
function e_diff_eDiff(e, f) {
    const g = negativeOf(f);
    return e_diff_add(e, g);
}

//# sourceMappingURL=e-diff.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-representation/bit-length.js




/**
 * Returns the bit-length of the significand of the given number in such a way
 * that trailing zeros are not counted.
 * @param a A double precision floating point number
 */
function bitLength(a) {
    if (a === 0) {
        return 0;
    }
    return getHighestSetBit(a) - getLowestSetBit(a) + 1;
}
/**
 * Returns the bit-length of the significand of the given floating point
 * expansion in such a way that trailing zeros are not counted.
 * * precondition: subnormals not currently supported
 * @param a A double precision floating point expansion
 */
function expBitLength(a) {
    let a_ = e_compress_eCompress(a);
    if (e_sign_eSign(a_) === 0) {
        return 0;
    }
    let msbyte = a_[a_.length - 1];
    let lsbyte = a_[0];
    return exponent(msbyte) - exponent(lsbyte) + (53 - getLowestSetBit(lsbyte));
}

//# sourceMappingURL=bit-length.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-div.js





// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const mult = expansion_product_expansionProduct;
const toBitlength = eToBitlength;
const e_div_bitLength = expBitLength;
const diff = e_diff_eDiff;
const estimate = e_estimate_eEstimate;
/**
 * Returns the result of a/b using Goldschmidt division.
 *
 * The result will only be exact if b|a, i.e. if b divides a exactly, else the
 * result will be rounded to the longest bitlength between a and b.
 *
 * @param a the numerator
 * @param b the denominator
 *
 * @param expansionLength the bitlength/53 of the final result, e.g. 1 means
 * standard double precision, 2 means double-double, etc up to a max of about 20 at
 * which point underflow cease precision improvement. If the division is known
 * to be exact beforehand (such as in the pseudo remainder sequence algorithm)
 * then set expansionLength === 0 and an exact division will be done.
 */
// TODO - test this function properly or replace with a better one
function eDiv(N, D, expansionLength) {
    let D_ = D;
    let N_ = N;
    let exact = false;
    let resultBitlengthUpperBound = 0;
    if (!expansionLength) {
        let bitlengthN = e_div_bitLength(N_);
        let bitlengthD = e_div_bitLength(D_);
        // resultBitlengthUpperBound is only valid if the division is known
        // to be exact
        resultBitlengthUpperBound = bitlengthN - bitlengthD + 1;
        expansionLength = (resultBitlengthUpperBound / 53) + 1;
        exact = true;
    }
    let F = [1 / estimate(D_)]; // Initial guess - out by 1/2 upls
    let i = 1;
    while (true) {
        N_ = mult(N_, F);
        // The precision bitlength doubles on each iteration
        if (i > expansionLength) {
            // we now have roughly double the needed precision - we actually 
            // only require about the precision and then round properly - this
            // could be implemented in the future.
            if (exact) {
                // We must throw away bits known to be zero. 
                // Any bits > expansionLength * 53 must be thrown away as they
                // are wrong - all other bits are exact.
                N_ = toBitlength(N_, resultBitlengthUpperBound);
                // TODO - below is just for testing - remove later
                //if (compare(mult(D, N_), N) !== 0) {
                //    console.log(mult(D, N_))
                //    throw new Error(`division in-exact - probably due to underflow, N: ${N}, D: ${D}, Result: ${N_}, product: ${mult(D, N_)}`); 
                //} 
                return N_;
            }
            // Returning only significant bits helps with sign determination later on.
            return N_.slice(N_.length - expansionLength, N_.length);
        }
        D_ = mult(D_, F);
        F = diff([2], D_);
        i *= 2;
    }
}

//# sourceMappingURL=e-div.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/grow-expansion.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const grow_expansion_compress = (/* unused pure expression or super */ null && (eCompress));
/**
 * Returns the result of adding a double to an expansion.
 *
 * Let e be a nonoverlapping expansion of m p-bit components, and let b be a
 * p-bit value where p >= 3. Suppose that the components e_1, ..., e_m are
 * sorted in order of *increasing* magnitude, except that any of the ei may be
 * zero.
 * Then the following algorithm will produce a nonoverlapping expansion such
 * that h = sum_i(h_i) = e + b, where the components h_1, ..., h_(m+1) are also
 * in order of increasing magnitude, except that any of the h_i may be zero.
 * Furthermore, if e is nonadjacent and round-to-even tiebreaking is used, then
 * h is nonadjacent.
 * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 * @param e A floating point expansion
 * @param b Another floating point expansion
 */
function growExpansion(e, b) {
    const m = e.length;
    let q = b;
    //const h: number[] = new Array(m+1);
    const h = [];
    //let j = 0;
    for (let i = 0; i < m; i++) {
        // Note the use of twoSum and not fastTwoSum.
        //[h[i], q] = ts(q, e[i]);
        const ee = e[i];
        const x = q + ee;
        const bv = x - q;
        let hh = (q - (x - bv)) + (ee - bv);
        if (hh !== 0) {
            h.push(hh);
        }
        q = x;
    }
    //h[j] = q;
    if (q !== 0 || h.length === 0) {
        h.push(q);
    }
    //return compress(h);
    return h;
}

//# sourceMappingURL=grow-expansion.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/basic/two-sum.js
/**
 * Returns the exact result of adding two doubles.
 *
 * * the resulting array is the reverse of the standard twoSum in the literature.
 *
 * Theorem 7 (Knuth): Let a and b be p-bit floating-point numbers. Then the
 * following algorithm will produce a nonoverlapping expansion x + y such that
 * a + b = x + y, where x is an approximation to a + b and y is the roundoff
 * error in the calculation of x.
 *
 * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 */
function two_sum_twoSum(a, b) {
    const x = a + b;
    const bv = x - a;
    return [(a - (x - bv)) + (b - bv), x];
}
// inlined
//const R = a + b; const _ = R - a; const r = (a - (R - _)) + (b - _); return [r,R]

//# sourceMappingURL=two-sum.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-sum.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const e_sum_ts = two_sum_twoSum;
const addDouble = growExpansion;
const e_sum_add = fastExpansionSum;
/**
 * Returns the result of summing an array of floating point expansions.
 *
 * * The result is exact in the form of a non-overlapping floating point
 * expansion.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param terms An array of numbers to be summed; A term is represented by a
 * floating point expansion.
 */
// The terms parameter were chosen to always be expansions in order to keep the 
// function monomorhic, but whether it's really worth it I am not sure.
function eSum(terms) {
    let total = [0];
    for (let i = 0; i < terms.length; i++) {
        const term = terms[i];
        // add
        if (term.length === 1) {
            if (total.length === 1) {
                total = e_sum_ts(total[0], term[0]);
            }
            else {
                total = addDouble(total, term[0]);
            }
        }
        else {
            if (total.length === 1) {
                total = addDouble(term, total[0]);
            }
            else {
                total = e_sum_add(total, term);
            }
        }
    }
    return total;
}

//# sourceMappingURL=e-sum.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-long-divide.js







// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const e_long_divide_eNegativeOf = eNegativeOf;
const e_long_divide_fastExpansionSum = fastExpansionSum;
const e_long_divide_eCompress = e_compress_eCompress;
const e_long_divide_growExpansion = growExpansion;
const e_long_divide_eSum = eSum;
const e_long_divide_scaleExpansion = scaleExpansion;
const e_long_divide_eDiff = e_diff_eDiff;
const e_long_divide_sign = Math.sign;
function eLongDivide(N, D) {
    N = e_long_divide_eCompress(N);
    D = e_long_divide_eCompress(D);
    // get the most significant double
    // out by at most 1 ulp, exact if d < MAX_SAFE_INT
    let d = D[D.length - 1];
    // trivial cases
    if (D.length === 1) {
        if (d === 0) {
            throw new Error('division by zero');
        }
        if (d === 1) {
            return { div: N, rem: [0] };
        }
        if (d === -1) {
            return { div: e_long_divide_eNegativeOf(N), rem: [0] };
        }
    }
    const signN = e_long_divide_sign(N[N.length - 1]);
    if (signN === 0) {
        return { div: [0], rem: [0] };
    }
    let signD = e_long_divide_sign(d);
    let divs = [];
    let oldLen = 0;
    while (true) {
        let rems = [];
        // loop from big `n[i]` to small `n[i]`
        for (let i = N.length - 1; i >= 0; i--) {
            const n = N[i];
            // `n % d` is the exact rem (for rem < MAX_SAFE_INTEGER) but is preliminary 
            // as it is subject to round-off for rem > MAX_SAFE_INTEGER; thus out by at 
            // most 1/2 ulp
            // Due to roundoff (and the fact we'e using `d` and not `D`!), `_div` does 
            // not necessarily represent the exact quotient.
            let div = Math.round((n - (n % d)) / d);
            // get the remainder by calculating `rem = n - d*div`
            rems.push(e_long_divide_scaleExpansion(D, div)); // exact
            if (div === 0) {
                break;
            }
            divs.push(div);
        }
        N = e_long_divide_eCompress(e_long_divide_eDiff(N, e_long_divide_eSum(rems)));
        if (oldLen === divs.length) {
            break;
        }
        oldLen = divs.length;
    }
    let rem = N;
    let div = [0];
    for (let i = 0; i < divs.length; i++) {
        div = e_long_divide_growExpansion(div, divs[i]);
    }
    div = e_long_divide_eCompress(div);
    //----------------------
    // fix signs (possibly)
    //----------------------
    //const signDiv = sign(div[div.length-1]);
    const signRem = e_long_divide_sign(rem[rem.length - 1]);
    //const signND = signN * signD;
    // We must have:
    // sign(div) === sign(n) * sign(d)
    // sign(rem) === sign(n)
    // At this point: `signN !== 0` and `signD !== 0`
    if (signRem !== 0 && signRem !== signN) {
        if (signN > 0) {
            if (signD > 0) {
                // div = div - 1  (div is positive)
                // rem = rem + D
                div = e_long_divide_growExpansion(div, -1);
                rem = e_long_divide_fastExpansionSum(rem, D);
            }
            else {
                // div = div + 1  (div is positive)
                // rem = rem - D
                div = e_long_divide_growExpansion(div, +1);
                rem = e_long_divide_fastExpansionSum(rem, e_long_divide_eNegativeOf(D));
            }
        }
        else if (signN < 0) {
            if (signD > 0) {
                // div = div + 1 (div is negative)
                // rem = rem - D
                div = e_long_divide_growExpansion(div, +1);
                rem = e_long_divide_fastExpansionSum(rem, e_long_divide_eNegativeOf(D));
            }
            else {
                // div = div - 1  (div is positive)
                // rem = rem + D
                div = e_long_divide_growExpansion(div, -1);
                rem = e_long_divide_fastExpansionSum(rem, D);
            }
        }
    }
    return { div, rem };
}

//# sourceMappingURL=e-long-divide.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-int-div.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const e_int_div_eLongDivide = eLongDivide;
/**
 * Returns the result of the integer division a/b.
 *
 * * **precondition:** a and b must be integers, b !== 0
 */
function eIntDiv(a, b) {
    return e_int_div_eLongDivide(a, b).div;
}

//# sourceMappingURL=e-int-div.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-rem.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const e_rem_eLongDivide = eLongDivide;
/**
 * Returns a % b
 *
 * * **precondition:** a and b must be integers, b !== 0
 */
function eRem(a, b) {
    return e_rem_eLongDivide(a, b).rem;
}

//# sourceMappingURL=e-rem.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-compare.js


/**
 * Returns 0 if a === b, a +tive value if a > b or a negative value if a < b.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * "The easiest way to compare two expansions is to subtract one from the other,
 * and test the sign of the result. An expansion’s sign can be easily tested
 * because of the nonoverlapping property; simply check the sign of the
 * expansion's most significant nonzero component..."
 *
 * @param a a floating point expansion
 * @param b another floating point expansion
 */
function e_compare_eCompare(a, b) {
    return e_sign_eSign(e_diff_eDiff(a, b));
}

//# sourceMappingURL=e-compare.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-abs.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const e_abs_sign = (/* unused pure expression or super */ null && (eSign));
const e_abs_negativeOf = eNegativeOf;
/**
 * Returns the absolute value of the given floating point expansion.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param e a floating point expansion
 */
function e_abs_eAbs(e) {
    if (e[e.length - 1] < 0) {
        return e_abs_negativeOf(e);
    }
    return e;
}

//# sourceMappingURL=e-abs.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/basic/fast-two-diff.js
/**
 * Returns the difference and exact error of subtracting two floating point
 * numbers.
 * Uses an EFT (error-free transformation), i.e. a-b === x+y exactly.
 * The returned result is a non-overlapping expansion (smallest value first!).
 *
 * Precondition: abs(a) >= abs(b) - A fast test that can be used is
 * (a > b) === (a > -b)
 *
 * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 */
function fastTwoDiff(a, b) {
    const x = a - b;
    const y = (a - x) - b;
    return [y, x];
}

//# sourceMappingURL=fast-two-diff.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/basic/fast-two-sum.js
/**
 * Returns the sum and exact error of adding two floating point numbers.
 * Uses an EFT (error-free transformation), i.e. a+b === x+y exactly.
 * The returned sum is a non-overlapping expansion (smallest value first!).
 *
 * Precondition: abs(a) >= abs(b) - A fast test that can be used is
 * (a > b) === (a > -b)
 *
 * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 */
function fast_two_sum_fastTwoSum(a, b) {
    const x = a + b;
    return [b - (x - a), x];
}
// inlined
//const R = a + b; const r = b - (R - a); return [r, R];

//# sourceMappingURL=fast-two-sum.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-mult-by-2.js
/**
 * Returns the result of multiplying a floating point expansion by 2.
 * * **error free**
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param e a floating point expansion
 */
function eMultBy2(e) {
    const e_ = [];
    for (let i = 0; i < e.length; i++) {
        e_.push(2 * e[i]);
    }
    return e_;
}

//# sourceMappingURL=e-mult-by-2.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-mult-by-neg-2.js
/**
 * Multiply a floating point expansion by -2.
 * * **error free**
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param e a floating point expansion
 */
function eMultByNeg2(e) {
    const e_ = [];
    for (let i = 0; i < e.length; i++) {
        e_.push(-2 * e[i]);
    }
    return e_;
}

//# sourceMappingURL=e-mult-by-neg-2.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-div-by-2.js
/**
 * Returns the result of dividing a floating point expansion by 2.
 * * **error free**
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param e a floating point expansion
 */
function eDivBy2(e) {
    const e_ = [];
    for (let i = 0; i < e.length; i++) {
        e_.push(0.5 * e[i]);
    }
    return e_;
}

//# sourceMappingURL=e-div-by-2.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/basic/split.js
/**
 * === Math.ceil(p/2) where p is the # of significand bits in a double === 53.
 */
const split_f = 134217729; // 2**27 + 1;
/**
 * Returns the result of splitting a double into 2 26-bit doubles.
 *
 * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where
 * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the
 * following algorithm will produce a (p-s)-bit value a_hi and a
 * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and
 * a = a_hi + a_lo.
 *
 * see e.g. [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 * @param a A double floating point number
 */
function split(a) {
    const c = split_f * a;
    const a_h = c - (c - a);
    const a_l = a - a_h;
    return [a_h, a_l];
}
// inlined - input a, output a_h, a_l
// const c = f * a; const a_h = c - (c - a); const a_l = a - a_h; return [a_h, a_l];

//# sourceMappingURL=split.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/basic/two-diff.js
/**
 * Returns the exact result of subtracting b from a (as a floating point
 * expansion).
 * @param a
 * @param b
 */
function two_diff_twoDiff(a, b) {
    const x = a - b;
    const bvirt = a - x;
    const y = (a - (x + bvirt)) + (bvirt - b);
    return [y, x];
}

//# sourceMappingURL=two-diff.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/basic/two-product.js
const two_product_f = 134217729; // 2**27 + 1;
/**
 * Returns the exact result of multiplying two doubles.
 *
 * * the resulting array is the reverse of the standard twoSum in the literature.
 *
 * Theorem 18 (Shewchuk): Let a and b be p-bit floating-point numbers, where
 * p >= 6. Then the following algorithm will produce a nonoverlapping expansion
 * x + y such that ab = x + y, where x is an approximation to ab and y
 * represents the roundoff error in the calculation of x. Furthermore, if
 * round-to-even tiebreaking is used, x and y are non-adjacent.
 *
 * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 * @param a A double
 * @param b Another double
 */
function two_product_twoProduct(a, b) {
    const x = a * b;
    //const [ah, al] = split(a);
    const c = two_product_f * a;
    const ah = c - (c - a);
    const al = a - ah;
    //const [bh, bl] = split(b);
    const d = two_product_f * b;
    const bh = d - (d - b);
    const bl = b - bh;
    const y = (al * bl) - ((x - (ah * bh)) - (al * bh) - (ah * bl));
    //const err1 = x - (ah * bh);
    //const err2 = err1 - (al * bh);
    //const err3 = err2 - (ah * bl);
    //const y = (al * bl) - err3;
    return [y, x];
}

//# sourceMappingURL=two-product.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-representation/is-bit-aligned.js


/**
 * Returns true if the given number is bit-aligned in the sense that its a
 * multiple of a given power of 2, say e, and such that the number, say a,
 * conforms to: a/2^e < 2^(l-e), where l is the max allowed bit length.
 * This essentially means the numbers act somewhat like fixed-point numbers
 * which can drastically speed up some geometric algorithms and also reduce
 * their complexity.
 *
 * Visually:
 * These numbers (a,b and c) are bit aligned with e === 3 and max
 * bitlength === 6:
 *    a -> 00|101100|000
 *    b -> 00|000100|000
 *    c -> 00|110111|000
 * These are not
 *    a -> 01|101100|000
 *    b -> 00|000100|000
 * These are not
 *    a -> 00|101100|000
 *    b -> 00|000100|100
 * These are not
 *    a -> 00|101100|100
 *    b -> 00|000100|100
 * @param as An array of numbers to check
 * @param maxBitLength The max allowed bitlength
 * @param gridSpacingExponent The grid spacing === 1^gridSpacingExponent
 */
function isBitAligned(a, maxBitLength, gridSpacingExponent) {
    if (a === 0) {
        return true;
    }
    let e = exponent(a);
    let maxSetBit = getHighestSetBit(a) - 52 + e;
    let minSetBit = getLowestSetBit(a) - 52 + e;
    let minBitBigEnough = minSetBit >= gridSpacingExponent;
    let maxBitSmallEnough = maxSetBit <= maxBitLength - 1 + gridSpacingExponent;
    return minBitBigEnough && maxBitSmallEnough;
}

//# sourceMappingURL=is-bit-aligned.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-representation/lsb-exponent.js


/**
 * Returns the true exponent of the lsb that is set of the given number or
 * NaN if a === 0 or +-inf or NaN.
 * @param a An array of numbers to check
 */
function lsbExponent(a) {
    if (a === 0 || !Number.isFinite(a)) {
        return NaN;
    }
    let e = exponent(a);
    return getLowestSetBit(a) - 52 + e;
}

//# sourceMappingURL=lsb-exponent.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-calculate.js







// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const e_calculate_mult = expansion_product_expansionProduct;
const e_calculate_tp = two_product_twoProduct;
const e_calculate_multByDouble = scaleExpansion;
const e_calculate_ts = two_sum_twoSum;
const e_calculate_addDouble = growExpansion;
const e_calculate_add = fastExpansionSum;
const e_calculate_compress = (/* unused pure expression or super */ null && (eCompress));
/**
 * Return the result of summing an array of terms, each term being an array of
 * floating point expansions to be multiplied together.
 *
 * * The result is exact in the form of a non-overlapping floating point
 * expansion.
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param terms An array of terms to be summed; A term consists of an
 * array of floating point expansions to be multiplied together.
 */
// The terms parameter were chosen to always be expansions in order to keep the 
// function monomorhic, but whether it's really worth it I am not sure.
function eCalculate(terms) {
    let total = [0];
    for (let i = 0; i < terms.length; i++) {
        const term = terms[i];
        let product = term[0];
        for (let j = 1; j < term.length; j++) {
            const multiplicant = term[j];
            if (multiplicant.length == 1) {
                if (product.length === 1) {
                    product = e_calculate_tp(product[0], multiplicant[0]);
                }
                else {
                    product = e_calculate_multByDouble(product, multiplicant[0]);
                }
            }
            else if (product.length === 1) {
                product = e_calculate_multByDouble(multiplicant, product[0]);
            }
            else {
                product = e_calculate_mult(multiplicant, product);
            }
        }
        // add
        if (product.length === 1) {
            if (total.length === 1) {
                total = e_calculate_ts(total[0], product[0]);
            }
            else {
                total = e_calculate_addDouble(total, product[0]);
            }
        }
        else {
            if (total.length === 1) {
                total = e_calculate_addDouble(product, total[0]);
            }
            else {
                total = e_calculate_add(total, product);
            }
        }
    }
    //return compress(total);
    return total;
}

//# sourceMappingURL=e-calculate.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-product.js




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const e_product_mult = expansion_product_expansionProduct;
const e_product_tp = two_product_twoProduct;
const e_product_multByDouble = scaleExpansion;
const e_product_compress = e_compress_eCompress;
/**
 * Return the result of multiplying together an array of floating point
 * expansions.
 *
 * * The result is exact in the form of a non-overlapping floating point
 * expansion.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param terms an array of multiplicands
 */
function eProduct(term) {
    let product = term[0];
    for (let j = 1; j < term.length; j++) {
        const multiplicant = term[j];
        if (multiplicant.length == 1) {
            if (product.length === 1) {
                product = e_product_tp(product[0], multiplicant[0]);
            }
            else {
                product = e_product_multByDouble(product, multiplicant[0]);
            }
        }
        else if (product.length === 1) {
            product = e_product_multByDouble(multiplicant, product[0]);
        }
        else {
            product = e_product_mult(multiplicant, product);
        }
    }
    return e_product_compress(product);
    //return product;
}

//# sourceMappingURL=e-product.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-int-pow.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const e_int_pow_mult = expansion_product_expansionProduct;
const prod = eProduct;
/**
 * Returns a**i, where i is a non-negative integer.
 * @param a a floating point expansion
 */
// TODO - this algorithm's speed can easily be improved significantly using 'repeated squaring'
function eIntPow(a, p) {
    // a^0 === 1
    if (p === 0) {
        return [1];
    }
    // a^1 === a
    if (p === 1) {
        return a;
    }
    if (p === 2) {
        return e_int_pow_mult(a, a);
    }
    const as = [];
    for (let i = 0; i < p; i++) {
        as.push(a);
    }
    return prod(as);
}

//# sourceMappingURL=e-int-pow.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-to-double-double.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const e_to_double_double_compress = e_compress_eCompress;
/**
 * Returns the result of converting a floating point expansion to a
 * double-double precision floating point number.
 */
function eToDd(e) {
    e = e_to_double_double_compress(e);
    const len = e.length;
    if (len === 2) {
        return e; // already a double-double
    }
    else if (len === 1) {
        return [0, e[0]]; // double-doubles have a fixed length of 2
    }
    return [e[len - 2], e[len - 1]]; // return only most significant parts
}

//# sourceMappingURL=e-to-double-double.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/geometric-primitives/orient2d.js






let ccwerrboundA = 3.330669073875472e-16;
let ccwerrboundB = 2.220446049250315e-16;
let ccwerrboundC = 1.109335647967049e-31;
let resulterrbound = 3.330669073875471e-16;
/**
 * * Ported from [Shewchuk](http://docs.ros.org/kinetic/api/asr_approx_mvbb/html/Predicates_8cpp_source.html)
 * * see also https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 *
 * * Adaptive exact 2d orientation test.
 *
 * * Robust.
 *
 * Return a positive value if the points pa, pb, and pc occur in
 * counterclockwise order; a negative value if they occur in clockwise order;
 * and zero if they are collinear.  The result is also a rough approximation of
 * twice the signed area of the triangle defined by the three points.
 *
 * The result returned is the determinant of a matrix. This determinant is
 * computed adaptively, in the sense that exact arithmetic is used only to the
 * degree it is needed to ensure that the returned value has the correct sign.
 * Hence, orient2d() is usually quite fast, but will run more slowly when the
 * input points are collinear or nearly so.
 */
function orient2d_orient2d(A, B, C) {
    let detleft = (A[0] - C[0]) * (B[1] - C[1]);
    let detright = (A[1] - C[1]) * (B[0] - C[0]);
    let det = detleft - detright;
    let detsum;
    if (detleft > 0) {
        if (detright <= 0) {
            // Anti-clockwise
            return det;
        }
        else {
            detsum = detleft + detright;
        }
    }
    else if (detleft < 0) {
        if (detright >= 0) {
            // Clockwise
            return det;
        }
        else {
            detsum = -detleft - detright;
        }
    }
    else {
        // Anti-clockwise, clockwise or straight
        return det;
    }
    if (Math.abs(det) >= ccwerrboundA * detsum) {
        // Anti-clockwise or clockwise
        return det;
    }
    return orient2dAdapt(A, B, C, detsum);
}
function orient2dAdapt(A, B, C, detsum) {
    let acx = A[0] - C[0];
    let bcx = B[0] - C[0];
    let acy = A[1] - C[1];
    let bcy = B[1] - C[1];
    let b = e_diff_eDiff(two_product_twoProduct(acx, bcy), two_product_twoProduct(acy, bcx));
    let det = e_estimate_eEstimate(b);
    if (Math.abs(det) >= ccwerrboundB * detsum) {
        // Anti-clockwise or clockwise
        return det;
    }
    let acxtail = two_diff_twoDiff(A[0], C[0])[0];
    let bcxtail = two_diff_twoDiff(B[0], C[0])[0];
    let acytail = two_diff_twoDiff(A[1], C[1])[0];
    let bcytail = two_diff_twoDiff(B[1], C[1])[0];
    if (acxtail === 0 && acytail === 0 &&
        bcxtail === 0 && bcytail === 0) {
        // Straight
        return det;
    }
    let errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
    det += (acx * bcytail + bcy * acxtail) - (acy * bcxtail + bcx * acytail);
    if (Math.abs(det) >= errbound) {
        return det;
    }
    let a = e_diff_eDiff(two_product_twoProduct(acxtail, bcy), two_product_twoProduct(acytail, bcx));
    let c = fastExpansionSum(b, a);
    let d = e_diff_eDiff(two_product_twoProduct(acx, bcytail), two_product_twoProduct(acy, bcxtail));
    let e = fastExpansionSum(c, d);
    let f = e_diff_eDiff(two_product_twoProduct(acxtail, bcytail), two_product_twoProduct(acytail, bcxtail));
    let D = fastExpansionSum(e, f);
    D = e_compress_eCompress(D);
    return D[D.length - 1];
}

//# sourceMappingURL=orient2d.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/is-overlapping.js


/**
 * Returns true if a and b overlaps, false otherwise.
 *
 * Two floating-point values x and y are nonoverlapping if the least significant
 * nonzero bit of x is more significant than the most significant nonzero bit of
 * y.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * Implemented for testing purposes.
 * @param a a double
 * @param b another double
 */
function isOverlapping(a, b) {
    return !isNonOverlapping(a, b);
}
/**
 * Returns true if a and b does not overlap, false otherwise.
 *
 * Two floating-point values x and y are nonoverlapping if the least significant
 * nonzero bit of x is more significant than the most significant nonzero bit of
 * y.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * Implemented for testing purposes.
 *
 * @param a A double
 * @param b Another double
 */
function isNonOverlapping(a, b) {
    if (a === 0 || b === 0) {
        return true;
    }
    if (Math.abs(b) > Math.abs(a)) {
        [a, b] = [b, a];
    }
    // At this point abs(a) > abs(b)
    let l = getLowestSetBit(a);
    let h = getHighestSetBit(b);
    let shift = exponent(a) - exponent(b);
    return (l + shift) > h;
}
/**
 * Returns true if all components of the given floating point expansion is
 * non-overlapping, false otherwise.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param e a double floating point expansion
 */
function isNonOverlappingAll(e) {
    for (let i = 1; i < e.length; i++) {
        if (isOverlapping(e[i - 1], e[i])) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=is-overlapping.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/is-adjacent.js

/**
 * Returns true if x and y are adjacent, false otherwise.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 * for details
 *
 * @param x a double floating point number
 * @param y another double floating point number
 */
function isAdjacent(x, y) {
    return isOverlapping(x, y) ||
        isOverlapping(x, 2 * y) ||
        isOverlapping(2 * x, y);
}

//# sourceMappingURL=is-adjacent.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/double-expansion/e-is-integer.js

function eIsInteger(a) {
    a = e_compress_eCompress(a);
    for (let i = 0; i < a.length; i++) {
        if (a[i] % 1 !== 0) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=e-is-integer.js.map
;// CONCATENATED MODULE: ./node_modules/big-float-ts/node/index.js














































// Aliases for some functions which names were not changed due to them being
// used extensively in the literature with a particular recognizable name
const eAdd = fastExpansionSum;
const eAddDouble = growExpansion;
const eMult = expansion_product_expansionProduct;
const eMultDouble1 = scaleExpansion;
const eMultDouble2 = scale_expansion_scaleExpansion2;
const operators = {
    //---- basic ----//
    fastTwoDiff: fastTwoDiff,
    fastTwoSum: fast_two_sum_fastTwoSum,
    split: split,
    twoDiff: two_diff_twoDiff,
    twoProduct: two_product_twoProduct,
    twoSum: two_sum_twoSum,
    reduceSignificand: reduceSignificand,
    //---- double floating point expansions ----//
    fastExpansionSum: fastExpansionSum, eAdd,
    growExpansion: growExpansion, eAddDouble,
    expansionProduct: expansion_product_expansionProduct, eMult,
    scaleExpansion: scaleExpansion, eMultDouble1,
    scaleExpansion2: scale_expansion_scaleExpansion2, eMultDouble2,
    eDiv: eDiv,
    eLongDivide: eLongDivide,
    eIntDiv: eIntDiv,
    eRem: eRem,
    eCompress: e_compress_eCompress,
    eEstimate: e_estimate_eEstimate,
    eDiff: e_diff_eDiff,
    eNegativeOf: eNegativeOf,
    eMultBy2: eMultBy2,
    eMultByNeg2: eMultByNeg2,
    eDivBy2: eDivBy2,
    eSign: e_sign_eSign,
    eCompare: e_compare_eCompare,
    eAbs: e_abs_eAbs,
    eToBitlength: eToBitlength,
    eIntPow: eIntPow,
    eCalculate: eCalculate,
    eSum: eSum,
    eProduct: eProduct,
    eToDd: eToDd,
    //---- double floating point representation ----//
    parseDouble: parseDouble,
    parseDoubleDetailed: parseDoubleDetailed,
    isBitAligned: isBitAligned,
    msbExponent: msbExponent,
    lsbExponent: lsbExponent,
    bitLength: bitLength,
    expBitLength: expBitLength,
    doubleToBinaryString: doubleToBinaryString,
    doubleToOctets: doubleToOctets,
    getHighestSetBit: getHighestSetBit,
    getLowestSetBit: getLowestSetBit,
    exponent: exponent,
    significand: significand,
    //---- geometric primitives
    orient2d: orient2d_orient2d,
    //---- others
    isAdjacent: isAdjacent,
    isNonOverlappingAll: isNonOverlappingAll,
    eIsInteger: eIsInteger
};


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/flo-graham-scan/node/get-smallest-indx-y-then-x.js
/**
 * @internal
 */
function getSmallestIndxYThenX(ps) {
    let smallest = [
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
    ];
    let smallestI = undefined;
    for (let i = 0; i < ps.length; i++) {
        let y = ps[i][1];
        if ((y < smallest[1]) ||
            (y === smallest[1] && ps[i][0] < smallest[0])) {
            smallestI = i;
            smallest = ps[i];
        }
    }
    return smallestI;
}

//# sourceMappingURL=get-smallest-indx-y-then-x.js.map
;// CONCATENATED MODULE: ./node_modules/flo-graham-scan/node/swap.js
/**
 * In-place swap two elements in the given array.
 *
 * @internal
 */
function swap(arr, a, b) {
    if (a === b) {
        return;
    }
    let temp = arr[a];
    arr[a] = arr[b];
    arr[b] = temp;
}

//# sourceMappingURL=swap.js.map
;// CONCATENATED MODULE: ./node_modules/flo-graham-scan/node/index.js



/**
 * Finds the convex hull of the given set of 2d points using the
 * Graham Scan algorithm and returns the hull as an array of points.
 * See https://en.wikipedia.org/wiki/Graham_scan
 *
 * Robust: This algorithm is robust via adaptive infinite precision floating
 * point arithmetic.
 * @param ps A set of points
 * @param includeAllBoundaryPoints Set this to true to if all boundary points
 * should be returned, even redundant ones - defaults to false
 */
function grahamScan(ps, includeAllBoundaryPoints = false) {
    if (!ps.length) {
        return undefined;
    }
    function fail(p1, p2, p3) {
        let res = orient2d_orient2d(p1, p2, p3);
        return includeAllBoundaryPoints
            ? res < 0
            : res <= 0;
    }
    let ps_ = ps.slice();
    let n = ps_.length;
    let idx = getSmallestIndxYThenX(ps_);
    let [p] = ps_.splice(idx, 1);
    ps_.sort((a, b) => {
        let res = -orient2d_orient2d(p, a, b);
        if (res !== 0) {
            return res;
        }
        res = a[1] - b[1];
        if (res !== 0) {
            return res;
        }
        return a[0] - b[0];
    });
    ps_.unshift(p);
    let m = 1;
    for (let i = 2; i < n; i++) {
        while (fail(ps_[m - 1], ps_[m], ps_[i])) {
            if (m > 1) {
                m -= 1;
                continue;
            }
            else if (i === n - 1) {
                m -= 1;
                break;
            }
            else {
                i += 1;
            }
        }
        m += 1;
        swap(ps_, m, i);
    }
    return ps_.slice(0, m + 1);
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/flo-vector2d/node/dot.js
/**
 * Returns the dot (inner) product between two 2-vectors.
 * @param a the first vector
 * @param b the second vector
 */
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
}

//# sourceMappingURL=dot.js.map
;// CONCATENATED MODULE: ./node_modules/flo-vector2d/node/lines-and-segments/seg-seg-intersection.js

/**
* Returns the point where two line segments intersect or undefined if they
* don't intersect or if they intersect at infinitely many points.
* * see Geometric primitves http://algs4.cs.princeton.edu/91primitives
* * **certified**
* @param ab The first line
* @param cd The second line
*/
function segSegIntersection(ab, cd) {
    let [a, b] = ab;
    let [c, d] = cd;
    let [a0, a1] = a;
    let [b0, b1] = b;
    let [c0, c1] = c;
    let [d0, d1] = d;
    //let denom  = (b[0] - a[0])*(d[1] - c[1]) - (b[1] - a[1])*(d[0] - c[0]);
    let denom = eDiff(expansionProduct(twoDiff(b0, a0), twoDiff(d1, c1)), expansionProduct(twoDiff(b1, a1), twoDiff(d0, c0)));
    //let rNumer = (a[1] - c[1])*(d[0] - c[0]) - (a[0] - c[0])*(d[1] - c[1]);
    let rNumer = eDiff(expansionProduct(twoDiff(a1, c1), twoDiff(d0, c0)), expansionProduct(twoDiff(a0, c0), twoDiff(d1, c1)));
    //let sNumer = (a[1] - c[1]) * (b[0] - a[0]) - (a[0] - c[0]) * (b[1] - a[1]); 
    let sNumer = eDiff(expansionProduct(twoDiff(a1, c1), twoDiff(b0, a0)), expansionProduct(twoDiff(a0, c0), twoDiff(b1, a1)));
    if (denom[denom.length - 1] === 0) {
        // parallel
        if (rNumer[rNumer.length - 1] === 0) {
            // collinear
            // TODO Check if x-projections and y-projections intersect
            // and return the line of intersection if they do.
            return undefined;
        }
        return undefined;
    }
    //let r = rNumer / denom;
    //let s = sNumer / denom;
    // if (0 <= r && r <= 1 && 0 <= s && s <= 1)
    if (eSign(rNumer) * eSign(denom) >= 0 && eCompare(eAbs(denom), eAbs(rNumer)) >= 0 &&
        eSign(sNumer) * eSign(denom) >= 0 && eCompare(eAbs(denom), eAbs(sNumer)) >= 0) {
        let r = eEstimate(rNumer) / eEstimate(denom);
        //return [a0 + r*(b0 - a0), a1 + r*(b1 - a1)];
        return [
            eEstimate(twoSum(eEstimate(expansionProduct(twoDiff(b0, a0), rNumer)) / eEstimate(denom), a0)),
            eEstimate(twoSum(eEstimate(expansionProduct(twoDiff(b1, a1), rNumer)) / eEstimate(denom), a1))
        ];
    }
    return undefined;
}

//# sourceMappingURL=seg-seg-intersection.js.map
;// CONCATENATED MODULE: ./node_modules/flo-vector2d/node/lines-and-segments/does-seg-seg-intersect.js

/**
 * Returns true if the two given 2d line segments intersect, false otherwise.
 * * **robust** uses exact adaptive floating point arithmetic.
 * @param a a line segment
 * @param b another line segment
 */
function doesSegSegIntersect(a, b) {
    if ((orient2d(a[0], a[1], b[0]) * orient2d(a[0], a[1], b[1])) > 0) {
        return false;
    }
    if ((orient2d(b[0], b[1], a[0]) * orient2d(b[0], b[1], a[1])) > 0) {
        return false;
    }
    return true;
}

//# sourceMappingURL=does-seg-seg-intersect.js.map
;// CONCATENATED MODULE: ./node_modules/flo-vector2d/node/affine-transformations/translate/translate.js
// From: https://en.wikipedia.org/wiki/Affine_transformation
// "If X is the point set of an affine space, then every affine transformation 
// on X can be represented as the composition of a linear transformation on X 
// and a translation of X"
function translate(a, b) {
    function f(b) {
        return [a[0] + b[0], a[1] + b[1]];
    }
    // Curry the function
    return b === undefined ? f : f(b);
}

//# sourceMappingURL=translate.js.map
;// CONCATENATED MODULE: ./node_modules/flo-vector2d/node/affine-transformations/linear/rotate.js
function rotate(sinθ, cosθ, p) {
    function rotateByθ(p) {
        return [
            p[0] * cosθ - p[1] * sinθ,
            p[0] * sinθ + p[1] * cosθ
        ];
    }
    // Curry the function
    return p === undefined ? rotateByθ : rotateByθ(p);
}

//# sourceMappingURL=rotate.js.map
;// CONCATENATED MODULE: ./node_modules/flo-vector2d/node/distance-and-length/to-length.js
/**
 * Returns the given 2-vector scaled to the given length.
 * @param p a vector
 * @param length the length to scale to
 */
function toLength(p, length) {
    let c = length / Math.sqrt(p[0] * p[0] + p[1] * p[1]);
    return [c * p[0], c * p[1]];
}

//# sourceMappingURL=to-length.js.map
;// CONCATENATED MODULE: ./node_modules/flo-vector2d/node/distance-and-length/distance-between.js
/**
 * Returns the distance between two 2d points.
 * @param p a point
 * @param q another point
 */
function distanceBetween(p, q) {
    let x = q[0] - p[0];
    let y = q[1] - p[1];
    return Math.sqrt(x * x + y * y);
}

//# sourceMappingURL=distance-between.js.map
;// CONCATENATED MODULE: ./node_modules/flo-vector2d/node/distance-and-length/squared-distance-between.js
/**
 * Returns the squared distance between two 2d points.
 * @param p a point
 * @param q another point
 */
function squared_distance_between_squaredDistanceBetween(p, q) {
    let x = q[0] - p[0];
    let y = q[1] - p[1];
    return x * x + y * y;
}

//# sourceMappingURL=squared-distance-between.js.map
;// CONCATENATED MODULE: ./node_modules/flo-vector2d/node/index.js
//==================================
// 2d vector pure functions library
//==================================





























/**
 * Three 2d points are a counter-clockwise turn if ccw > 0, clockwise if
 * ccw < 0, and colinear if ccw === 0 because ccw is a determinant that gives
 * twice the signed area of the triangle formed by the points a, b and c.
 * * **certified**
 * @param A The first point
 * @param B The second point
 * @param C The third point
 */
const ccw = (/* unused pure expression or super */ null && (orient2d));
/**
 * Returns the second 2-vector minus the first.
 * @param p the first vector
 * @param q the second vector
  */
function fromTo(p, q) {
    return [q[0] - p[0], q[1] - p[1]];
}
/**
 * Performs linear interpolation between two 2d points and returns the
 * resulting point.
 * @param p the first point.
 * @param q the second point.
 * @param t the interpolation fraction (often in [0,1]).
 */
function interpolate(p, q, t) {
    return [
        p[0] + (q[0] - p[0]) * t,
        p[1] + (q[1] - p[1]) * t
    ];
}
/**
 * Returns the mean of two 2d points.
 * @param ps the two points
 */
function mean(ps) {
    let p = ps[0];
    let q = ps[1];
    return [(p[0] + q[0]) / 2, (p[1] + q[1]) / 2];
}
/**
* Returns true if two 2-vectors are identical (by value), false otherwise.
* @param a a 2d vector
* @param b another 2d vector
*/
function equal(a, b) {
    return (a[0] === b[0] && a[1] === b[1]);
}
/**
 * Returns the closest point to the array of 2d points or if the array is empty
 * returns undefined.
 * @param p
 * @param ps
 */
function getClosestTo(p, ps) {
    let closestPoint = undefined;
    let closestDistance = Number.POSITIVE_INFINITY;
    for (let i = 0; i < ps.length; i++) {
        let q = ps[i];
        let d = squaredDistanceBetween(p, q);
        if (d < closestDistance) {
            closestPoint = q;
            closestDistance = d;
        }
    }
    return closestPoint;
}
/**
 * Returns the closest point to the array of 2d points by providing a distance
 * function. If the given array is empty, returns undefined.
 * @param p
 * @param ps
 * @param f a function that takes the object and returns a point in order to
 * apply the Euclidian distance.
 */
function getObjClosestTo(p, ps, f) {
    let closestObj = undefined; // Closest Point
    let closestDistance = Number.POSITIVE_INFINITY;
    for (let i = 0; i < ps.length; i++) {
        let o = ps[i];
        let d = squaredDistanceBetween(p, f(o));
        if (d < closestDistance) {
            closestObj = o;
            closestDistance = d;
        }
    }
    return closestObj;
}

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./src/global-properties/length/length-bez1.ts

/**
 * @param interval
 * @param ps
 *
 * @internal
 */
function lengthBez1(interval, ps) {
    let [t1, t2] = interval;
    if (t1 === t2) {
        return 0;
    }
    let [[x0, y0], [x1, y1]] = ps;
    // Keep line below to ensure zero length curve returns zero!
    if (x0 === x1 && y0 === y1) {
        return 0;
    }
    let p1 = [x0 + t1 * (x1 - x0), y0 + t1 * (y1 - y0)];
    let p2 = [x0 + t2 * (x1 - x0), y0 + t2 * (y1 - y0)];
    return distanceBetween(p1, p2);
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-dxy/double/get-dxy.ts
/**
 * Returns the derivative of the power basis representation of a line, quadratic
 * or cubic bezier's.
 *
 * **bitlength**: If the coordinates of the control points are bit-aligned then
 * * max bitlength increase === max shift === 5 (for cubics)
 * * max bitlength increase === max shift === 3 (for quadratics)
 * * max bitlength increase === max shift === 1 (for lines)
 *
 * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getDxy(ps) {
    if (ps.length === 4) {
        return getDxy3(ps);
    }
    if (ps.length === 3) {
        return getDxy2(ps);
    }
    if (ps.length === 2) {
        return getDxy1(ps);
    }
    throw new Error('The bezier curve must be of order 1, 2 or 3.');
}
function getDxy3(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    return [[
            3 * ((x3 - x0) + 3 * (x1 - x2)),
            6 * ((x2 + x0) - 2 * x1),
            3 * (x1 - x0) // t^0 - max bitlength increase 3
        ], [
            3 * ((y3 - y0) + 3 * (y1 - y2)),
            6 * ((y2 + y0) - 2 * y1),
            3 * (y1 - y0) // t^0 - max bitlength increase 3
        ]];
}
function getDxy2(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    return [[
            2 * ((x2 + x0) - 2 * x1),
            2 * (x1 - x0), // t^0 - max bitlength increase 2
        ], [
            2 * ((y2 + y0) - 2 * y1),
            2 * (y1 - y0), // t^0 - max bitlength increase 2
        ]];
}
function getDxy1(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    return [[
            x1 - x0, // t^0 - max bitlength increase 1
        ], [
            y1 - y0, // t^0 - max bitlength increase 1
        ]];
}


;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/to-cas-str.js

/** @internal */
function isNumber(x) {
    return typeof x === 'number';
}
/** @internal */
function isShewchuk(x) {
    return Array.isArray(x);
}
/** @internal */
function isBigint(x) {
    return typeof x === 'bigint';
}
/**
 * Returns a string representing the given polynomial that is readable by a
 * human or a CAS (Computer Algebra System).
 *
 * * **note:** if the polynomial coefficients are given as Shewchuk expansions
 * then the coefficients are first down-converted to double precision
 *
 * @param p a polynomial (with coefficients given densely as an array of Shewchuk
 * floating point expansions **or** double precision floating point numbers **or**
 * bigints) from highest to lowest power, e.g. `[5,-3,0]` represents the
 * polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * toCasStr([5,4,3,2,1]); //=> "x^4*5 + x^3*4 + x^2*3 + x*2 + 1"
 * toCasStr([[5],[4],[3],[2],[1]]); //=> "x^4*5 + x^3*4 + x^2*3 + x*2 + 1"
 * toCasStr([5n,4n,3n,2n,1n]); //=> "x^4*5 + x^3*4 + x^2*3 + x*2 + 1"
 * ```
 *
 * @doc
 */
function toCasStr(p) {
    const d = p.length - 1;
    let str = '';
    for (let i = 0; i < d + 1; i++) {
        const _v = p[i];
        const v = isShewchuk(_v)
            ? e_estimate_eEstimate(_v)
            : _v; // bigint or number
        const absV = isBigint(v)
            ? (_v < 0n ? -v : v)
            : Math.abs(v);
        let cStr = nonNegativeNumberToString(absV);
        cStr = (v >= 0 ? ' + ' : ' - ') + cStr;
        if (i === d) {
            str += cStr;
        }
        else if (i === d - 1) {
            str += cStr + '*x';
        }
        else {
            str += cStr + '*x^' + (d - i).toString();
        }
    }
    return str;
}
/**
 * from https://stackoverflow.com/a/46545519/2010061
 *
 * @internal
 */
function nonNegativeNumberToString(num) {
    let numStr = num.toString();
    if (isBigint(num)) {
        return numStr;
    }
    if (Math.abs(num) < 1) {
        const e = parseInt(numStr.split('e-')[1]);
        if (e) {
            num *= 10 ** (e - 1);
            numStr = '0.' + (new Array(e)).join('0') + num.toString().substring(2);
        }
    }
    else {
        let e = parseInt(numStr.split('+')[1]);
        if (e > 20) {
            e -= 20;
            num /= 10 ** e;
            numStr = num.toString() + (new Array(e + 1)).join('0');
        }
    }
    return numStr;
}

//# sourceMappingURL=to-cas-str.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-abs-coeff.js
/**
 * Returns the polynomial with all coeffients the absolute value of the given
 * polynomial.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function bAbsCoeff(p) {
    const p_ = [];
    for (let i = 0; i < p.length; i++) {
        const v = p[i];
        p_.push(v < 0n ? -v : v);
    }
    return p_;
}

//# sourceMappingURL=b-abs-coeff.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-remove-leading-zeros.js
/**
 * If the highest power coefficient of the given polynomial is 0 then
 * removeLeadingZeros can be called to remove all such highest terms so that
 * the returned array is a valid presentation of a polynomial.
 * @param p a polynomial whose leading zeros should be removed
 *
 * @doc
 */
function bRemoveLeadingZeros(p) {
    // @ts-nocheck
    let lzCount = 0;
    for (let i = 0; i <= p.length - 1; i++) {
        if (p[i] !== 0n) {
            break;
        }
        lzCount++;
    }
    if (lzCount !== 0) {
        p = p.slice(lzCount);
    }
    return p;
}

//# sourceMappingURL=b-remove-leading-zeros.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-add.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_add_bRemoveLeadingZeros = bRemoveLeadingZeros;
/**
 * Returns the result of adding two polynomials with bigint coefficients.
 *
 * @param p1 a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 * @param p2 another polynomial
 *
 * @example
 * ```typescript
 * bAdd([1n,2n,3n],[3n,4n]); //=> [1n,5n,7n]
 * ```
 *
 * @doc
 */
function bAdd(p1, p2) {
    // Initialize result array  
    const d1 = p1.length - 1;
    const d2 = p2.length - 1;
    const Δd = d1 - d2;
    const Δd1 = Δd < 0 ? +Δd : 0;
    const Δd2 = Δd > 0 ? -Δd : 0;
    const d = Math.max(d1, d2);
    // Add coefficients
    const result = [];
    for (let i = 0; i < d + 1; i++) {
        const c1 = p1[i + Δd1] || 0n;
        const c2 = p2[i + Δd2] || 0n;
        result.push(c1 + c2);
    }
    // Ensure the result is a valid polynomial representation
    return b_add_bRemoveLeadingZeros(result);
}

//# sourceMappingURL=b-add.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-degree.js
/**
 * Returns the degree of the given polynomial - the zero polynomial degree is
 * returned as -1 (and not -∞ as is conventional).
 *
 * @param p a polynomial with coefficients given densely as an array of bigints
 * from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * bDegree([9n,8n,7n,6n,5n,4n,3n,2n,1n]); //=> 8
 * ```
 *
 * @doc
 */
function bDegree(p) {
    return p.length - 1;
}

//# sourceMappingURL=b-degree.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-divide-by-const.js
/**
 * Divides (using **integer division**) a polynomial by a constant.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 * @param c a constant
 *
 * @doc
 */
function bDivideByConst(p, c) {
    const d = p.length;
    const r = [];
    for (let i = 0; i < d; i++) {
        r.push(p[i] / c);
    }
    return r;
}

//# sourceMappingURL=b-divide-by-const.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-equal.js
/**
 * Returns true if two polynomials are exactly equal by comparing coefficients,
 * false otherwise.
 *
 * @param a a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 * @param b another polynomial
 *
 * @example
 * ```typescript
 * bEqual([1n,2n,3n,4n], [1n,2n,3n,4n]);   //=> true
 * bEqual([1n,2n,3n,4n], [1n,2n,3n,4n,5n]); //=> false
 * ```
 *
 * @doc
 */
function bEqual(a, b) {
    if (a.length !== b.length) {
        return false;
    }
    for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=b-equal.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-invert.js
/**
 * Inverts the given polynomial by reversing the order of the coefficients,
 * i.e. p(x) -> x^deg(p) * p(1/x)
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * bInvert([3n,2n,-5n]);  // => [-5n,2n,3n]
 * ```
 *
 * @doc
 */
function bInvert(p) {
    return p.slice().reverse();
}

//# sourceMappingURL=b-invert.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/gcd/bigint/b-integer-gcd.js
/**
 * Computes and returns the greatest common divisor of two integers a and b,
 * using the [Euclidean Algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm).
 *
 * @doc
 */
function bGcdInt(a, b) {
    a = a < 0n ? -a : a;
    b = b < 0n ? -b : b;
    // The below 2 commented lines represent Euclid's original algorithm.
    //if (a === b) { return a; }
    //return a > b ? gcdInt(a - b, b) : gcdInt(a, b - a);
    if (a === 0n) {
        return b;
    }
    if (b === 0n) {
        return a;
    }
    while (b !== 0n) {
        const t = b;
        b = a % b;
        a = t;
    }
    return a;
}
/**
 * Naively computes and returns the greatest common divisor of 2 or more
 * integers by taking each integer in turn and calculating the GCD of that
 * integer and the previously calculated GCD (where the first GCD is simply
 * taken as the first number).
 *
 * @param vals the integers for which the GCD is to be calculated
 *
 * @doc
 */
function bGcdInts(vals) {
    const vals_ = vals.slice();
    const len = vals_.length;
    // make array of numbers all positive
    for (let i = 0; i < len; i++) {
        vals_[i] = vals_[i] < 0n ? -vals_[i] : vals_[i];
    }
    let a = vals_[0];
    for (let i = 1; i < len; i++) {
        a = bGcdInt(a, vals_[i]);
    }
    return a;
}
/**
 * * ❗ don't use - too slow - use [[bGcdInts]] instead ❗
 *
 * Computes and returns the greatest common divisor of 2 or more integers by
 * calculating GCDs rescursively using a tree (Divide and Conquer).
 *
 * * It turns out this method is *slower* than the naive method
 */ /*
function bGcdIntsTree(vals: bigint[]): bigint {
   const vals_ = vals.slice();

   // make array of numbers all positive
   for (const i=0; i<vals_.length; i++) {
       vals_[i] = vals_[i] < 0n ? -vals_[i] : vals_[i];
   }
   
   // Divide and conquer
   while (vals_.length > 1) {
       const newVals = [];
       const len = vals_.length;
       for (const i=0; i<len-1; i += 2) {
           newVals.push(bGcdInt(vals_[i], vals_[i+1]));
       }
       if (len % 2 !== 0) {
           newVals.push(vals_[len-1]);
       }

       vals_ = newVals;
   }
   
   return vals_[0];
}
*/

//# sourceMappingURL=b-integer-gcd.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-is-rational-multiple-of.js

/**
 * Returns true if either polynomial is an exact rational multiple of the other.
 *
 * @param a a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 * @param b another polynomial
 *
 * @doc
 */
function bIsRationalMultipleOf(a, b) {
    // If either polynomial is zero
    if (a.length === 0 || b.length === 0) {
        return true;
    }
    if (a.length !== b.length) {
        return false;
    }
    // multiply by -1 if appropriate to make the leading coefficients positive
    const a_ = a[0] < 0n ? a.map(c => -c) : a;
    const b_ = b[0] < 0n ? b.map(c => -c) : b;
    /** leading coefficient of a */
    const lcA = a_[0];
    /** leading coefficient of b */
    const lcB = b_[0];
    const gcd = bGcdInt(lcA, lcB);
    const A = lcA / gcd; // this division is exact
    const B = lcB / gcd; // this division is exact
    for (let i = 0; i < a_.length; i++) {
        const Ab = A * b_[i];
        if (Ab % B !== 0n) {
            return false;
        }
        if (Ab / B !== a_[i]) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=b-is-rational-multiple-of.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-multiply.js
/**
 * Returns the result of multiplying 2 polynomials with bigint coefficients.
 *
 * * see [polynomial arithmetic](https://en.wikipedia.org/wiki/Polynomial_arithmetic)
 * * see [polynomial multiplication](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication)
 * * see [polynomial multiplication](http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf)
 *
 * @param a a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`
 * represents the polynomial `5x^2 - 3x`
 * @param b another polynomial.
 *
 * @example
 * ```typescript
 * bMultiply([1n,2n,3n], [2n,5n,3n,5n]); //=> [2n, 9n, 19n, 26n, 19n, 15n]
 * ```
 *
 * @doc
 */
function bMultiply(a, b) {
    const da = a.length - 1;
    const db = b.length - 1;
    // if either or both is the zero polynomial
    if (da < 0 || db < 0) {
        return [];
    }
    const d = da + db;
    const r = new Array(d + 1).fill(0n);
    for (let i = 0; i < da + 1; i++) {
        for (let j = 0; j < db + 1; j++) {
            r[d - (i + j)] += (a[da - i] * b[db - j]);
        }
    }
    return r;
}

//# sourceMappingURL=b-multiply.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-multiply-by-const.js
/**
 * Returns the result of multiplies a polynomial (with bigint coefficients) by
 * a constant.
 *
 * @param c a constant
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function bMultiplyByConst(c, p) {
    if (c === 0n) {
        return [];
    }
    const d = p.length;
    const r = [];
    for (let i = 0; i < d; i++) {
        r.push(c * p[i]);
    }
    return r;
}

//# sourceMappingURL=b-multiply-by-const.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-negate.js
/**
 * Returns the negative of the given polynomial (p -> -p).
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * bNegate([1n, -2n]); //=> [-1n, 2n]
 * ```
 *
 * @doc
 */
function bNegate(p) {
    const p_ = [];
    for (let i = 0; i < p.length; i++) {
        p_.push(-p[i]);
    }
    return p_;
}

//# sourceMappingURL=b-negate.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/bigint/b-subtract.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_subtract_bRemoveLeadingZeros = bRemoveLeadingZeros;
/**
 * Returns the result of subtracting the second polynomial from the first with
 * coefficients given as bigints; (p1 - p2).
 *
 * @param a minuend; the polynomial from which will be subtracted; a polynomial
 * with coefficients given densely as an array of bigints
 * from highest to lowest power, e.g. `[5,-3,0]` represents the
 * polynomial `5x^2 - 3x`
 * @param b subtrahend; the polynomial that will be subtracted
 *
 * @example
 * ```typescript
 * bSubtract([2n,3n],[4n,4n]); //=> [-2n, -1n]
 * ```
 *
 * @doc
 */
function bSubtract(a, b) {
    // Initialize result array  
    const da = a.length - 1;
    const db = b.length - 1;
    const Δd = da - db;
    const Δd2 = Δd > 0 ? -Δd : 0;
    const Δd1 = Δd < 0 ? +Δd : 0;
    const d = Math.max(da, db);
    // Add coefficients
    const result = [];
    for (let i = 0; i < d + 1; i++) {
        const c1 = a[i + Δd1] || 0n;
        const c2 = b[i + Δd2] || 0n;
        result.push(c1 - c2);
    }
    // Ensure the result is a valid polynomial representation
    return b_subtract_bRemoveLeadingZeros(result);
}

//# sourceMappingURL=b-subtract.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/abs-coeff.js
/**
 * Returns the polynomial with all coeffients the absolute value of the given
 * polynomial.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function absCoeff(p) {
    const p_ = [];
    for (let i = 0; i < p.length; i++) {
        p_.push(Math.abs(p[i]));
    }
    return p_;
}

//# sourceMappingURL=abs-coeff.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/remove-leading-zeros.js
/**
 * If the highest power coefficient of the given polynomial is 0 then
 * removeLeadingZeros can be called to remove all such highest terms so that
 * the returned array is a valid presentation of a polynomial.
 *
 * @param p a polynomial whose leading zeros should be removed
 *
 * @example
 * ```typescript
 * removeLeadingZeros([1e-18, 1e-10, 1e-1]); //=> [1e-18, 1e-10, 1e-1]
 * removeLeadingZeros([0, 1e-10, 1e-1]); //=> [1e-10, 1e-1]
 * ```
 *
 * @doc
 */
function removeLeadingZeros(p) {
    let lzCount = 0;
    for (let i = 0; i <= p.length - 1; i++) {
        if (p[i] !== 0) {
            break;
        }
        lzCount++;
    }
    if (lzCount !== 0) {
        p = p.slice(lzCount);
    }
    return p;
}

//# sourceMappingURL=remove-leading-zeros.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/add.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const add_removeLeadingZeros = removeLeadingZeros;
/**
 * Returns the result of adding two polynomials in double precision.
 *
 * @param p1 a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param p2 another polynomial
 *
 * @example
 * ```typescript
 * add([1,2,3],[3,4]); //=> [1,5,7]
 * ```
 *
 * @doc
 */
function add_add(p1, p2) {
    // Initialize result array  
    const d1 = p1.length - 1;
    const d2 = p2.length - 1;
    const Δd = d1 - d2;
    const Δd1 = Δd < 0 ? +Δd : 0;
    const Δd2 = Δd > 0 ? -Δd : 0;
    const d = Math.max(d1, d2);
    // Add coefficients
    const result = [];
    for (let i = 0; i < d + 1; i++) {
        const c1 = p1[i + Δd1] || 0;
        const c2 = p2[i + Δd2] || 0;
        result.push(c1 + c2);
    }
    // Ensure the result is a valid polynomial representation
    return add_removeLeadingZeros(result);
}

//# sourceMappingURL=add.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/degree.js
/**
 * Returns the degree of the given polynomial - the zero polynomial degree is
 * returned as -1 (and not -∞ as is conventional).
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * degree([9,8,7,6,5,4,3,2,1]); //=> 8
 * ```
 *
 * @doc
 */
function degree(p) {
    return p.length - 1;
}

//# sourceMappingURL=degree.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/divide-by-const.js
/**
 * Divides a polynomial by a constant in double precision.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param c a constant
 *
 * @doc
 */
function divideByConst(p, c) {
    const d = p.length;
    const r = [];
    for (let i = 0; i < d; i++) {
        r.push(p[i] / c);
    }
    return r;
}

//# sourceMappingURL=divide-by-const.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/equal.js
/**
 * Returns true if two polynomials are exactly equal by comparing coefficients,
 * false otherwise.
 *
 * @param p1 a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param p2 another polynomial
 * @example
 * ```typescript
 * equal([1,2,3,4], [1,2,3,4]);   //=> true
 * equal([1,2,3,4], [1,2,3,4,5]); //=> false
 * ```
 *
 * @doc
 */
function equal_equal(p1, p2) {
    if (p1.length !== p2.length) {
        return false;
    }
    for (let i = 0; i < p1.length; i++) {
        if (p1[i] !== p2[i]) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=equal.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/invert.js
/**
 * Inverts the given polynomial by reversing the order of the coefficients,
 * i.e. p(x) -> x^deg(p) * p(1/x)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * invert([3,2,-5]);  // => [-5,2,3]
 * ```
 *
 * @doc
 */
function invert(p) {
    return p.slice().reverse();
}

//# sourceMappingURL=invert.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/scale-to-int/scale-floats-to-ints.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const scale_floats_to_ints_exponent = exponent;
const scale_floats_to_ints_bitLength = bitLength;
/**
 * Returns the result of scaling the given floats by the *same* power of two
 * such that all floats become integers (bar overflow).
 *
 * * the result is exact (no round-off can occur, but overflow can)
 * * can be used to scale polynomials or Shewchuk expansions
 *
 * @param as an array of double precision floating point numbers
 *
 * @doc
 */
function scaleFloatsToInts(as) {
    let e = -1024;
    for (let i = 0; i < as.length; i++) {
        const a = as[i];
        if (a === 0) {
            continue;
        }
        const scaleFactor = -scale_floats_to_ints_exponent(a) + scale_floats_to_ints_bitLength(a) - 1;
        if (scaleFactor > e) {
            e = scaleFactor;
        }
    }
    return as.map(a => a * 2 ** e);
}

//# sourceMappingURL=scale-floats-to-ints.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/gcd/double/integer-gcd.js
/**
 * Computes the greatest common divisor of two integers a and b, using the
 * Euclidean Algorithm.
 *
 * **precondition** a, b must be integers
 *
 * @doc
 */
function gcdInt(a, b) {
    a = Math.abs(a);
    b = Math.abs(b);
    // The below 2 commented lines represent Euclid's original algorithm.
    //if (a === b) { return a; }
    //return a > b ? gcdInt(a - b, b) : gcdInt(a, b - a);
    if (a === 0) {
        return b;
    }
    if (b === 0) {
        return a;
    }
    while (b !== 0) {
        const t = b;
        b = a % b;
        a = t;
    }
    return a;
}
/**
 * Computes the greatest common divisor of two integers a and b, using the
 * binary GCD algorithm - probably slower than just using gcdInt that uses
 * the Euclidean Algorithm.
 */
function gcdIntBinary(a, b) {
    a = Math.abs(a);
    b = Math.abs(b);
    if (a === 0) {
        return b;
    }
    if (b === 0) {
        return a;
    }
    // Reduce a and/or b to odd numbers and keep track of the greatest power of 
    // 2 dividing both a and b.
    let k = 1;
    while (a % 2 === 0 && b % 2 === 0) {
        a = a / 2; // right shift
        b = b / 2; // right shift
        k = k * 2; // left shift
    }
    // Reduce a to an odd number...
    while (a % 2 === 0) {
        a = a / 2; // right shift
    }
    // Henceforth, a is always odd...
    while (b) {
        // Remove all factors of 2 in b as they are not common
        while (b % 2 === 0) {
            b = b / 2; // right shift
        }
        // a and b are both odd. Swap values such that it is the larger of the 
        // two values, and then set b to the difference (which is even)
        if (a > b) {
            [a, b] = [b, a];
        }
        b = b - a; // b=0 iff b=a
    }
    // Restore common factors of 2...
    return k * a;
}
/**
 * Naively computes and returns the greatest common divisor of 2 or more
 * integers by taking each integer in turn and calculating the GCD of that
 * integer and the previously calculated GCD (where the first GCD is simply
 * taken as the first number).
 *
 * @param vals the integers for which the GCD is to be calculated
 *
 * @doc
 */
function gcdInts(vals) {
    const vals_ = vals.slice();
    const len = vals_.length;
    // make array of numbers all positive
    for (let i = 0; i < len; i++) {
        vals_[i] = Math.abs(vals_[i]);
    }
    let a = vals_[0];
    for (let i = 1; i < len; i++) {
        a = gcdInt(a, vals_[i]);
    }
    return a;
}
/**
 * :::tip Heads up!
 * don't use - too slow - use [[gcdInts]] instead
 * :::
 *
 * Computes and returns the greatest common divisor of 2 or more integers by
 * calculating GCDs rescursively using a tree (Divide and Conquer).
 *
 * * It turns out this method is *slower* than the naive method
 *
 * @param vals the integers for which the GCD is to be calculated
 *
 * @internal
 */
function gcdIntsTree(vals) {
    let vals_ = vals.slice();
    // make array of numbers all positive
    for (let i = 0; i < vals_.length; i++) {
        vals_[i] = Math.abs(vals_[i]);
    }
    // Divide and conquer
    while (vals_.length > 1) {
        const newVals = [];
        const len = vals_.length;
        for (let i = 0; i < len - 1; i += 2) {
            newVals.push(gcdInt(vals_[i], vals_[i + 1]));
        }
        if (len % 2 !== 0) {
            newVals.push(vals_[len - 1]);
        }
        vals_ = newVals;
    }
    return vals_[0];
}

//export { gcdInt, gcdInts }
//# sourceMappingURL=integer-gcd.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/is-rational-multiple-of.js



/**
 * Returns true if either polynomial is an exact rational multiple of the other.
 *
 * @param a a polynomial with coefficients given densely as an array of
 * double precision floating point numbers from highest to lowest power,
 * e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`
 * @param b another polynomial
 *
 * @doc
 */
function isRationalMultipleOf(a, b) {
    // If either polynomial is zero
    if (a.length === 0 || b.length === 0) {
        return true;
    }
    if (a.length !== b.length) {
        return false;
    }
    // multiply by -1 if appropriate to make the leading coefficients positive
    // then scale floating point coefficients to integers
    const a_ = scaleFloatsToInts(a[0] < 0 ? a.map(c => -c) : a);
    const b_ = scaleFloatsToInts(b[0] < 0 ? b.map(c => -c) : b);
    /** leading coefficient of a */
    const lcA = a_[0];
    /** leading coefficient of b */
    const lcB = b_[0];
    const gcd = gcdInt(lcA, lcB);
    const A = lcA / gcd; // this division is exact
    const B = lcB / gcd; // this division is exact
    for (let i = 0; i < a_.length; i++) {
        const Ab = two_product_twoProduct(A, b_[i]);
        const { div, rem } = eLongDivide(Ab, [B]);
        if (e_sign_eSign(rem) !== 0) {
            return false;
        }
        if (e_compare_eCompare(div, [a_[i]]) !== 0) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=is-rational-multiple-of.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/multiply.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const multiply_removeLeadingZeros = removeLeadingZeros;
/**
 * Returns the result of multiplying 2 polynomials in double precision.
 *
 * * see [polynomial arithmetic](https://en.wikipedia.org/wiki/Polynomial_arithmetic)
 * * see [polynomial multiplication](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication)
 * * see [polynomial multiplication](http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf)
 *
 * @param p1 a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param p2 another polynomial.
 * @example
 * ```typescript
 * multiply([1,2,3], [2,5,3,5]); //=> [2, 9, 19, 26, 19, 15]
 * ```
 *
 * @doc
 */
function multiply(p1, p2) {
    const d1 = p1.length - 1;
    const d2 = p2.length - 1;
    // if either or both is the zero polynomial
    if (d1 < 0 || d2 < 0) {
        return [];
    }
    const d = d1 + d2;
    const r = new Array(d + 1).fill(0);
    for (let i = 0; i < d1 + 1; i++) {
        for (let j = 0; j < d2 + 1; j++) {
            r[d - (i + j)] += (p1[d1 - i] * p2[d2 - j]);
        }
    }
    return multiply_removeLeadingZeros(r);
}

//# sourceMappingURL=multiply.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/multiply-by-const.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const multiply_by_const_removeLeadingZeros = removeLeadingZeros;
/**
 * Returns the result of multiplies a polynomial by a constant in double
 * precision.
 *
 * @param c a constant
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * multiplyByConst(0.25, [3,2,1]); //=> [0.75, 0.5, 0.25]
 * ```
 *
 * @doc
 */
function multiplyByConst(c, p) {
    if (c === 0) {
        return [];
    }
    const d = p.length;
    const p_ = [];
    for (let i = 0; i < d; i++) {
        p_.push(c * p[i]);
    }
    // We *have* to clip due to possible floating point underflow
    return multiply_by_const_removeLeadingZeros(p_);
}

//# sourceMappingURL=multiply-by-const.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/negate.js
/**
 * Returns the negative of the given polynomial (p -> -p).
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @example
 * ```typescript
 * negate([0.1, -0.2]); //=> [-0.1, 0.2]
 * ```
 *
 * @doc
 */
function negate(p) {
    const p_ = [];
    for (let i = 0; i < p.length; i++) {
        p_.push(-p[i]);
    }
    return p_;
}

//# sourceMappingURL=negate.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/double/subtract.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const subtract_removeLeadingZeros = removeLeadingZeros;
/**
 * Returns the result of subtracting the second polynomial from the first in
 * double precision; (p1 - p2).
 *
 * @param p1 minuend; the polynomial from which will be subtracted; a polynomial
 * with coefficients given densely as an array of double floating point numbers
 * from highest to lowest power, e.g. `[5,-3,0]` represents the
 * polynomial `5x^2 - 3x`
 * @param p2 subtrahend; the polynomial that will be subtracted
 *
 * @example
 * ```typescript
 * subtract([2,3],[4,4]); //=> [-2, -1]
 * ```
 *
 * @doc
 */
function subtract(p1, p2) {
    // Initialize result array  
    const d1 = p1.length - 1;
    const d2 = p2.length - 1;
    const Δd = d1 - d2;
    const Δd1 = Δd < 0 ? +Δd : 0;
    const Δd2 = Δd > 0 ? -Δd : 0;
    const d = Math.max(d1, d2);
    // Add coefficients
    const result = [];
    for (let i = 0; i < d + 1; i++) {
        const c1 = p1[i + Δd1] || 0;
        const c2 = p2[i + Δd2] || 0;
        result.push(c1 - c2);
    }
    // Ensure the result is a valid polynomial representation
    return subtract_removeLeadingZeros(result);
}

//# sourceMappingURL=subtract.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-abs-coeff.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_abs_coeff_eAbs = e_abs_eAbs;
/**
 * Returns the polynomial with all coeffients the absolute value of the given
 * polynomial.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function eAbsCoeff(p) {
    const p_ = [];
    for (let i = 0; i < p.length; i++) {
        p_.push(e_abs_coeff_eAbs(p[i]));
    }
    return p_;
}

//# sourceMappingURL=e-abs-coeff.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-remove-leading-zeros.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_remove_leading_zeros_eSign = e_sign_eSign;
/**
 * If the highest power coefficient of the given polynomial is 0 then
 * removeLeadingZeros can be called to remove all such highest terms so that
 * the returned array is a valid presentation of a polynomial.
 *
 * @internal
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * eRemoveLeadingZeros([[1e-18], [1e-10], [1e-1]]); //=> [[1e-18], [1e-10], [1e-1]]
 * eRemoveLeadingZeros([[0], [1e-10], [1e-1]]); //=> [[1e-10], [1e-1]]
 * ```
 *
 * @doc
 */
function eRemoveLeadingZeros(p) {
    let lzCount = 0;
    for (let i = 0; i <= p.length - 1; i++) {
        if (e_remove_leading_zeros_eSign(p[i]) !== 0) {
            break;
        }
        lzCount++;
    }
    if (lzCount !== 0) {
        p = p.slice(lzCount);
    }
    return p;
}

//# sourceMappingURL=e-remove-leading-zeros.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-add.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_add_fastExpansionSum = fastExpansionSum;
const e_add_eRemoveLeadingZeros = eRemoveLeadingZeros;
/**
 * Returns the exact result (bar underflow / overflow) of adding two
 * polynomials with coefficients given as Shewchuk floating point expansions.
 *
 * @param p1 a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 * @param p2 another polynomial
 *
 * @example
 * ```typescript
 * eAdd([[1],[2],[3]],[[3],[4]]); //=> [[1],[5],[7]]
 * ```
 *
 * @doc
 */
function e_add_eAdd(p1, p2) {
    // Initialize result array  
    const d1 = p1.length - 1;
    const d2 = p2.length - 1;
    const Δd = d1 - d2;
    const Δd1 = Δd < 0 ? +Δd : 0;
    const Δd2 = Δd > 0 ? -Δd : 0;
    const d = Math.max(d1, d2);
    // Add coefficients
    const result = [];
    for (let i = 0; i < d + 1; i++) {
        const c1 = p1[i + Δd1] || [0];
        const c2 = p2[i + Δd2] || [0];
        result.push(e_add_fastExpansionSum(c1, c2));
    }
    // Ensure the result is a valid polynomial representation
    return e_add_eRemoveLeadingZeros(result);
}

//# sourceMappingURL=e-add.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-degree.js
/**
 * Returns the degree of the given polynomial - the zero polynomial degree is
 * returned as -1 (and not -∞ as is conventional).
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * eDegree([[9],[8],[7],[6],[5],[4],[3],[2],[1]]); //=> 8
 * ```
 *
 * @doc
 */
function eDegree(p) {
    return p.length - 1;
}

//# sourceMappingURL=e-degree.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-equal.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_equal_eCompare = e_compare_eCompare;
/**
 * Returns true if two polynomials (with coefficients given as Shewchuk floating
 * point expansions) are exactly equal by comparing coefficients, false otherwise.
 *
 * @param p1 a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 * @param p2 another polynomial
 *
 * @example
 * ```typescript
 * eEqual([[1],[2],[3],[0,4]], [[1],[2],[3],[4]]);   //=> true
 * eEqual([[1],[2],[3],[4]], [[1],[2],[3],[4],[5]]); //=> false
 * ```
 *
 * @doc
 */
function eEqual(p1, p2) {
    if (p1.length !== p2.length) {
        return false;
    }
    for (let i = 0; i < p1.length; i++) {
        if (e_equal_eCompare(p1[i], p2[i]) !== 0) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=e-equal.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-invert.js
/**
 * Inverts the given polynomial (with coefficients given as Shewchuk floating
 * point expansions) by reversing the order of the coefficients,
 * i.e. p(x) -> x^deg(p) * p(1/x)
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * eInvert([[3],[2],[-5]]);  // => [[-5],[2],[3]]
 * ```
 *
 * @doc
 */
function eInvert(p) {
    return p.slice().reverse();
}

//# sourceMappingURL=e-invert.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-is-const-or-zero.js
/**
 * Returns true if the given polynomial (with coefficients given as Shewchuk
 * floating point expansions) is a constant or the zero polynomial.
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function eIsConstOrZero(p) {
    return p.length <= 1;
}

//# sourceMappingURL=e-is-const-or-zero.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-intss.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const scale_floatss_to_intss_exponent = exponent;
const scale_floatss_to_intss_bitLength = bitLength;
/**
 * Returns the result of scaling the given array of array of floats by the
 * *same* power of two such that all floats become integers (bar overflow).
 *
 * * the result is exact (no round-off can occur, but overflow can)
 * * can be used to scale polynomials (with coefficients given as Shewchuk
 * expansions)
 *
 * @param ass an array of an array of double precision floating point numbers
 *
 * @doc
 */
function scaleFloatssToIntss(ass) {
    let e = -1024;
    for (let i = 0; i < ass.length; i++) {
        const c = ass[i];
        for (let j = 0; j < c.length; j++) {
            const a = c[j];
            if (a === 0) {
                continue;
            }
            const scaleFactor = -scale_floatss_to_intss_exponent(a) + scale_floatss_to_intss_bitLength(a) - 1;
            if (scaleFactor > e) {
                e = scaleFactor;
            }
        }
    }
    return ass.map(as => as.map(a => a * 2 ** e));
}

//# sourceMappingURL=scale-floatss-to-intss.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/gcd/expansion/e-integer-gcd.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_integer_gcd_eAbs = e_abs_eAbs;
const e_integer_gcd_eSign = e_sign_eSign;
const e_integer_gcd_eRem = eRem;
/**
 * Computes the greatest common divisor of two integers a and b, using the
 * Euclidean Algorithm.
 *
 * **precondition** a, b must be integers given as Shewchuk expansions
 *
 * @doc
 */
function eGcdInt(a, b) {
    a = e_integer_gcd_eAbs(a);
    b = e_integer_gcd_eAbs(b);
    // The below 2 commented lines represent Euclid's original algorithm.
    //if (a === b) { return a; }
    //return a > b ? gcdInt(a - b, b) : gcdInt(a, b - a);
    if (e_integer_gcd_eSign(a) === 0) {
        return b;
    }
    if (e_integer_gcd_eSign(b) === 0) {
        return a;
    }
    while (e_integer_gcd_eSign(b) !== 0) {
        const t = b;
        b = e_integer_gcd_eRem(a, b);
        a = t;
    }
    return a;
}
/**
 * Naively computes and returns the greatest common divisor of 2 or more
 * integers by taking each integer in turn and calculating the GCD of that
 * integer and the previously calculated GCD (where the first GCD is simply
 * taken as the first number).
 *
 * @param vals the integers (given as Shewchuk expansions) for which the GCD is
 * to be calculated
 */
function eGcdInts(vals) {
    const vals_ = vals.slice();
    const len = vals_.length;
    // make array of numbers all positive
    for (let i = 0; i < len; i++) {
        vals_[i] = e_integer_gcd_eAbs(vals_[i]);
    }
    let a = vals_[0];
    for (let i = 1; i < len; i++) {
        a = eGcdInt(a, vals_[i]);
    }
    return a;
}

//# sourceMappingURL=e-integer-gcd.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-is-rational-multiple-of.js



/**
 * Returns true if either polynomial is an exact rational multiple of the other.
 *
 * @param a a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`
 * @param b another polynomial
 *
 * @doc
 */
function eIsRationalMultipleOf(a, b) {
    // If either polynomial is zero
    if (a.length === 0 || b.length === 0) {
        return true;
    }
    if (a.length !== b.length) {
        return false;
    }
    // multiply by -1 if appropriate to make the leading coefficients positive
    // then scale floating point coefficients to integers
    const a_ = scaleFloatssToIntss(e_sign_eSign(a[0]) < 0 ? a.map(c => eNegativeOf(c)) : a);
    const b_ = scaleFloatssToIntss(e_sign_eSign(b[0]) < 0 ? b.map(c => eNegativeOf(c)) : b);
    /** leading coefficient of a */
    const lcA = a_[0];
    /** leading coefficient of b */
    const lcB = b_[0];
    const gcd = eGcdInt(lcA, lcB);
    const A = eIntDiv(lcA, gcd); // this division is exact
    const B = eIntDiv(lcB, gcd); // this division is exact
    for (let i = 0; i < a_.length; i++) {
        const Ab = expansion_product_expansionProduct(A, b_[i]);
        const { div, rem } = eLongDivide(Ab, B);
        if (e_sign_eSign(rem) !== 0) {
            return false;
        }
        if (e_compare_eCompare(div, a_[i]) !== 0) {
            return false;
        }
    }
    return true;
}

//# sourceMappingURL=e-is-rational-multiple-of.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-is-unit.js
/**
 * Returns true if the given polynomial (with coefficients given as Shewchuk
 * floating point expansions) is the unit polynomial, i.e. === 1.
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function eIsUnit(p) {
    return p.length === 1 && p[0].length === 1 && p[0][0] === 1;
}

//# sourceMappingURL=e-is-unit.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-multiply.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_multiply_eRemoveLeadingZeros = eRemoveLeadingZeros;
const e_multiply_expansionProduct = expansion_product_expansionProduct;
const e_multiply_fastExpansionSum = fastExpansionSum;
/**
 * Returns the exact result (bar underflow / overflow) of multiplying two
 * polynomials (with coefficients given as Shewchuk floating point expansions).
 *
 * * see [polynomial arithmetic](https://en.wikipedia.org/wiki/Polynomial_arithmetic)
 * * see [polynomial multiplication](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication)
 * * see [polynomial multiplication](http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf)
 *
 * @param a a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 * @param b another polynomial.
 *
 * @example
 * ```typescript
 * eMultiply([[1],[2],[3]], [[2],[5],[3],[5]]); //=> [[2], [9], [19], [26], [19], [15]]
 * ```
 *
 * @doc
 */
function eMultiply(a, b) {
    const da = a.length - 1;
    const db = b.length - 1;
    // if either or both is the zero polynomial
    if (da < 0 || db < 0) {
        return [];
    }
    const d = da + db;
    const result = new Array(d + 1).fill([0]);
    for (let i = 0; i < da + 1; i++) {
        for (let j = 0; j < db + 1; j++) {
            result[d - (i + j)] = e_multiply_fastExpansionSum(result[d - (i + j)], e_multiply_expansionProduct(a[da - i], b[db - j]));
        }
    }
    return e_multiply_eRemoveLeadingZeros(result);
}

//# sourceMappingURL=e-multiply.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-multiply-by-const.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_multiply_by_const_eSign = e_sign_eSign;
const e_multiply_by_const_expansionProduct = expansion_product_expansionProduct;
/**
 * Returns the exact result (bar underflow / overflow) of multiplying a
 * polynomial (with coefficients given as Shewchuk floating point expansions)
 * by a constant (given as a Shewchuk floating point expansion)
 *
 * @param c a constant (given as a Shewchuk floating point expansion)
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * eMultiplyByConst([0.25], [[3],[2],[1]]); //=> [[0.75], [0.5], [0.25]]
 * ```
 *
 * @doc
 */
function eMultiplyByConst(c, p) {
    if (e_multiply_by_const_eSign(c) === 0) {
        return [];
    }
    const d = p.length - 1;
    const result = [];
    for (let i = 0; i < d + 1; i++) {
        result.push(e_multiply_by_const_expansionProduct(c, p[i]));
    }
    return result;
}

//# sourceMappingURL=e-multiply-by-const.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-negate.js
// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗

const e_negate_eNegativeOf = eNegativeOf;
/**
 * Returns the negative of the given polynomial (with coefficients given as
 * Shewchuk floating point expansions), i.e. (p -> -p).
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * eNegate([[0.1], [-0.2]]); //=> [[-0.1], [0.2]]
 * ```
 *
 * @doc
 */
function eNegate(p) {
    const result = [];
    for (let i = 0; i < p.length; i++) {
        result.push(e_negate_eNegativeOf(p[i]));
    }
    return result;
}

//# sourceMappingURL=e-negate.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-product.js

/**
 * Returns the exact result (bar underflow / overflow) of the product of 0 or
 * more polynomials.
 *
 * * see [polynomial arithmetic](https://en.wikipedia.org/wiki/Polynomial_arithmetic)
 * * see [polynomial multiplication](https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Polynomial_multiplication)
 * * see [polynomial multiplication](http://web.cs.iastate.edu/~cs577/handouts/polymultiply.pdf)
 *
 * @param ps an array of polynomials each with coefficients given densely as an
 * array of Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * eProduct([[[1],[2],[3]], [[2],[5],[3],[5]]]); //=> [[2], [9], [19], [26], [19], [15]]
 * ```
 *
 * @doc
 */
function e_product_eProduct(ps) {
    if (ps.length === 0) {
        return [[1]];
    }
    let p = ps[0];
    for (let i = 1; i < ps.length; i++) {
        p = eMultiply(p, ps[i]);
    }
    return p;
}

//# sourceMappingURL=e-product.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/basic/expansion/e-subtract.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_subtract_eDiff = e_diff_eDiff;
const e_subtract_eRemoveLeadingZeros = eRemoveLeadingZeros;
/**
 * Returns the exact result (bar underflow / overflow) of subtracting the
 * second polynomial from the first (both with coefficients given as Shewchuk
 * floating point expansions); (p1 - p2).
 *
 * @param p1 minuend; the polynomial from which will be subtracted; a polynomial
 * with coefficients given densely as Shewchuk floating point expansions
 * from highest to lowest power, e.g. `[[5],[-3],[0]]` represents the
 * polynomial `5x^2 - 3x`
 * @param p2 subtrahend; the polynomial that will be subtracted
 *
 * @example
 * ```typescript
 * eSubtract([[2],[3]],[[4],[4]]); //=> [[-2], [-1]]
 * ```
 *
 * @doc
 */
function eSubtract(p1, p2) {
    // Initialize result array  
    const d1 = p1.length - 1;
    const d2 = p2.length - 1;
    const Δd = d1 - d2;
    const Δd1 = Δd < 0 ? +Δd : 0;
    const Δd2 = Δd > 0 ? -Δd : 0;
    const d = Math.max(d1, d2);
    // Add coefficients
    const result = [];
    for (let i = 0; i < d + 1; i++) {
        const c1 = p1[i + Δd1] || [0];
        const c2 = p2[i + Δd2] || [0];
        result.push(e_subtract_eDiff(c1, c2));
    }
    // Ensure the result is a valid polynomial representation
    return e_subtract_eRemoveLeadingZeros(result);
}

//# sourceMappingURL=e-subtract.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/calculus/bigint/b-differentiate.js
/**
 * Returns the result of differentiating the given polynomial.
 *
 * @param p a polynomial with coefficients given densely as an array of bigints
 * from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * bDifferentiate([5n, 4n, 3n, 2n, 1n]); //=> [20n, 12n, 6n, 2n]
 * ```
 *
 * @doc
 */
function bDifferentiate(p) {
    const r = [];
    const d = p.length - 1;
    for (let i = 0; i < d; i++) {
        r.push(BigInt((d - i)) * p[i]);
    }
    return r;
}

//# sourceMappingURL=b-differentiate.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/calculus/double/differentiate.js
/**
 * Returns the result of differentiating the given polynomial in double
 * precision.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * differentiate([5, 4, 3, 2, 1]); //=> [20, 12, 6, 2]
 * ```
 *
 * @doc
 */
function differentiate(p) {
    const result = [];
    const d = p.length - 1;
    for (let i = 0; i < d; i++) {
        result.push((d - i) * p[i]);
    }
    return result;
}

//# sourceMappingURL=differentiate.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/binary/dd-diff-dd.js
/**
 * Returns the result of subtracting the second given double-double-precision
 * floating point number from the first.
 *
 * * relative error bound: 3u^2 + 13u^3, i.e. fl(a-b) = (a-b)(1+ϵ),
 * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON
 * * the error bound is not sharp - the worst case that could be found by the
 * authors were 2.25u^2
 *
 * ALGORITHM 6 of https://hal.archives-ouvertes.fr/hal-01351529v3/document
 * @param x a double-double precision floating point number
 * @param y another double-double precision floating point number
 */
function ddDiffDd(x, y) {
    const xl = x[0];
    const xh = x[1];
    const yl = y[0];
    const yh = y[1];
    //const [sl,sh] = twoSum(xh,yh);
    const sh = xh - yh;
    const _1 = sh - xh;
    const sl = (xh - (sh - _1)) + (-yh - _1);
    //const [tl,th] = twoSum(xl,yl);
    const th = xl - yl;
    const _2 = th - xl;
    const tl = (xl - (th - _2)) + (-yl - _2);
    const c = sl + th;
    //const [vl,vh] = fastTwoSum(sh,c)
    const vh = sh + c;
    const vl = c - (vh - sh);
    const w = tl + vl;
    //const [zl,zh] = fastTwoSum(vh,w)
    const zh = vh + w;
    const zl = w - (zh - vh);
    return [zl, zh];
}

//# sourceMappingURL=dd-diff-dd.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/binary/dd-min.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
/** @internal */
const dd_min_diff = ddDiffDd;
/**
 * Returns the minimum of a and b.
 * @param a a double-double precision floating point number
 * @param b another double-double precision floating point number
 */
function ddMin(a, b) {
    const res = dd_min_diff(a, b)[1];
    return res > 0 ? b : a;
}

//# sourceMappingURL=dd-min.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/binary/dd-max.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
/** @internal */
const dd_max_diff = ddDiffDd;
/**
 * Returns the maximum of a and b.
 * @param a a double-double precision floating point number
 * @param b another double-double precision floating point number
 */
function ddMax(a, b) {
    const res = dd_max_diff(a, b)[1];
    return res > 0 ? a : b;
}

//# sourceMappingURL=dd-max.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/unary/dd-sqrt.js
/** @internal */
const dd_sqrt_f = 134217729; // 2**27 + 1;
// Taken from https://github.com/munrocket/double.js/blob/master/src/double.ts
// Unfortunately no error bound given
/**
 * Returns the square root of a double-double as a double-double.
 * * no error bound is returned
 *
 * @param x a double-double precision floating point number
 */
// TODO - calculate an error bound and add to function description
function ddSqrt(x) {
    const xl = x[0];
    const xh = x[1];
    if (xh === 0) {
        return [0, 0];
    }
    const s = Math.sqrt(xh);
    //const [tl,th] = twoSquare(s);
    const th = s * s;
    const c = dd_sqrt_f * s;
    const ah = c - (c - s);
    const al = s - ah;
    const tl = (al * al) - ((th - (ah * ah)) - 2 * (ah * al));
    const e = (xh - th - tl + xl) * 0.5 / s;
    return [e - ((s + e) - s), s + e];
}

//# sourceMappingURL=dd-sqrt.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-mixed-double-double/double-sqrt.js
/** @internal */
const double_sqrt_f = 134217729; // 2**27 + 1;
// Taken from https://github.com/munrocket/double.js/blob/master/src/double.ts
// Unfortunately no error bound given
/**
 * Returns the square root of a double as a double-double.
 * * no error bound is returned
 */
// TODO - calculate an error bound and add to function description
function doubleSqrt(x) {
    if (x === 0) {
        return [0, 0];
    }
    const s = Math.sqrt(x);
    //const [tl,th] = twoSquare(s);
    const th = s * s;
    const c = double_sqrt_f * s;
    const ah = c - (c - s);
    const al = s - ah;
    const tl = (al * al) - ((th - (ah * ah)) - 2 * (ah * al));
    const e = (x - th - tl) * 0.5 / s;
    x = s + e;
    const xl = e - (x - s);
    return [xl, x];
}

//# sourceMappingURL=double-sqrt.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-with-err/sqrt-with-err.js
/** @internal */
const eps = Number.EPSILON;
/**
 * Returns the result of the square root of a double floating point number
 * together with an absolute error bound where x_ is an absolute error
 * bound on the input value.
 * * see also "A Reduced Product of Absolute and Relative Error Bounds for Floating-point Analysis"
 * by Maxime Jacquemin, Sylvie Putot, and Franck Vedrine
 * @param x numerator
 * @param x_ absolute value error bound in numerator
 */
function sqrtWithErr(x, x_) {
    // Note: it is assumed x + x_ >= 0, else the error in x_ was wrong in the
    // first place (since we can't have a negative input to the square root)
    // estimate the result of the square root
    if (x - x_ <= 0) {
        const est = x > 0 ? Math.sqrt(x) : 0;
        return {
            est,
            err: Math.max(Math.sqrt(x + x_) - est, est)
        };
    }
    const est = Math.sqrt(x);
    const minSqrt = Math.sqrt(x - x_);
    const maxSqrt = Math.sqrt(x + x_);
    const err = Math.max(Math.abs(minSqrt - est), Math.abs(maxSqrt - est));
    //err += eps*abs(est + err);
    //err = eps*abs(est + err);
    // approx relative input error
    //const rel = x_/abs(x);
    // propogated error bound
    //const err = est*(Math.sqrt(1 + rel) - 1) + u*abs(est);
    return { est, err };
}

//# sourceMappingURL=sqrt-with-err.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/unary/dd-abs.js
/**
 * Returns the absolute value of the given double-double precision floating
 * point number.
 * @param f a double-double precision floating point number
 */
function ddAbs(f) {
    const Q = f[1];
    return (Q < 0) ? [-f[0], -Q] : f;
}

//# sourceMappingURL=dd-abs.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-mixed-double-double/dd-add-double.js
/**
 * Returns the result of adding a double to a double-double precision floating
 * point number.
 *
 * * relative error bound: 2u^2, i.e. fl(a+b) = (a+b)(1+ϵ),
 * where ϵ <= 2u^2, u = 0.5 * Number.EPSILON
 * * the error bound is sharp
 *
 * ALGORITHM 4 of https://hal.archives-ouvertes.fr/hal-01351529v3/document
 * @param x a double-double precision floating point number
 * @param y a double precision floating point number
 */
function ddAddDouble(x, y) {
    const xl = x[0];
    const xh = x[1];
    //const [sl,sh] = twoSum(xh, y);
    const sh = xh + y;
    const c = sh - xh;
    const sl = (xh - (sh - c)) + (y - c);
    const v = xl + sl;
    //const [zl,zh] = fastTwoSum(sh,v);
    const zh = sh + v;
    const zl = v - (zh - sh);
    return [zl, zh];
}

//# sourceMappingURL=dd-add-double.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/binary/dd-add-dd.js
/**
 * Returns the result of adding two double-double-precision floating point
 * numbers.
 *
 * * relative error bound: 3u^2 + 13u^3, i.e. fl(a+b) = (a+b)(1+ϵ),
 * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON
 * * the error bound is not sharp - the worst case that could be found by the
 * authors were 2.25u^2
 *
 * ALGORITHM 6 of https://hal.archives-ouvertes.fr/hal-01351529v3/document
 * @param x a double-double precision floating point number
 * @param y another double-double precision floating point number
 */
function ddAddDd(x, y) {
    const xl = x[0];
    const xh = x[1];
    const yl = y[0];
    const yh = y[1];
    //const [sl,sh] = twoSum(xh,yh);
    const sh = xh + yh;
    const _1 = sh - xh;
    const sl = (xh - (sh - _1)) + (yh - _1);
    //const [tl,th] = twoSum(xl,yl);
    const th = xl + yl;
    const _2 = th - xl;
    const tl = (xl - (th - _2)) + (yl - _2);
    const c = sl + th;
    //const [vl,vh] = fastTwoSum(sh,c)
    const vh = sh + c;
    const vl = c - (vh - sh);
    const w = tl + vl;
    //const [zl,zh] = fastTwoSum(vh,w)
    const zh = vh + w;
    const zl = w - (zh - vh);
    return [zl, zh];
}

//# sourceMappingURL=dd-add-dd.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/binary/dd-mult-dd.js
/** @internal */
const dd_mult_dd_f = 2 ** 27 + 1;
/**
 * Returns the product of two double-double-precision floating point numbers.
 *
 * * relative error bound: 7u^2, i.e. fl(a+b) = (a+b)(1+ϵ),
 * where ϵ <= 7u^2, u = 0.5 * Number.EPSILON
 * the error bound is not sharp - the worst case that could be found by the
 * authors were 5u^2
 *
 * * ALGORITHM 10 of https://hal.archives-ouvertes.fr/hal-01351529v3/document
 * @param x a double-double precision floating point number
 * @param y another double-double precision floating point number
 */
function ddMultDd(x, y) {
    //const xl = x[0];
    const xh = x[1];
    //const yl = y[0];
    const yh = y[1];
    //const [cl1,ch] = twoProduct(xh,yh);
    const ch = xh * yh;
    const c = dd_mult_dd_f * xh;
    const ah = c - (c - xh);
    const al = xh - ah;
    const d = dd_mult_dd_f * yh;
    const bh = d - (d - yh);
    const bl = yh - bh;
    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));
    //return fastTwoSum(ch,cl1 + (xh*yl + xl*yh));
    const b = cl1 + (xh * y[0] + x[0] * yh);
    const xx = ch + b;
    return [b - (xx - ch), xx];
}

//# sourceMappingURL=dd-mult-dd.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/multi/dd-product.js

/**
 * Returns the result of multiplying together an array of double-double-precision
 * floating point numbers naively (i.e. not using pairwise addition to reduce
 * error a bit).
 *
 * * an error bound is given by: (n-1)(1+ϵ),
 * where ϵ <= 7u^2, u = 0.5 * Number.EPSILON
 */
function ddProduct(qs) {
    let q = qs[0];
    for (let i = 1; i < qs.length; i++) {
        q = ddMultDd(q, qs[i]);
    }
    return q;
}

//# sourceMappingURL=dd-product.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/multi/dd-sum.js

/**
 * Returns the result of summing an array of double-double-precision floating
 * point numbers naively (i.e. not using pairwise addition to reduce error a bit).
 *
 * * an error bound is given by: (n-1)(1+ϵ),
 * where ϵ <= 3u^2 + 13u^3, u = 0.5 * Number.EPSILON
 */
function ddSum(qs) {
    let q = qs[0];
    for (let i = 1; i < qs.length; i++) {
        q = ddAddDd(q, qs[i]);
    }
    return q;
}

//# sourceMappingURL=dd-sum.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/binary/dd-compare.js
/**
 * Returns 0 if a === b, a +tive value if a > b or a negative value if a < b.
 *
 * @param x a double-double precision floating point number
 * @param y another double-double precision floating point number
 */
function ddCompare(x, y) {
    //return ddDiffDd(x,y)[1];
    const xl = x[0];
    const xh = x[1];
    const yl = y[0];
    const yh = y[1];
    //const [sl,sh] = twoSum(xh,yh);
    const sh = xh - yh;
    const _1 = sh - xh;
    const sl = (xh - (sh - _1)) + (-yh - _1);
    //const [tl,th] = twoSum(xl,yl);
    const th = xl - yl;
    const _2 = th - xl;
    const tl = (xl - (th - _2)) + (-yl - _2);
    const c = sl + th;
    //const [vl,vh] = fastTwoSum(sh,c)
    const vh = sh + c;
    const vl = c - (vh - sh);
    const w = tl + vl;
    //const [zl,zh] = fastTwoSum(vh,w)
    const zh = vh + w;
    return zh;
}

//# sourceMappingURL=dd-compare.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-mixed-double-double/dd-mult-double.js
/** @internal */
const dd_mult_double_f = 134217729; // 2**27 + 1;
/**
 * Returns the product of a double-double-precision floating point number and a
 * double.
 *
 * * slower than ALGORITHM 8 (one call to fastTwoSum more) but about 2x more
 * accurate
 * * relative error bound: 1.5u^2 + 4u^3, i.e. fl(a+b) = (a+b)(1+ϵ),
 * where ϵ <= 1.5u^2 + 4u^3, u = 0.5 * Number.EPSILON
 * * the bound is very sharp
 * * probably prefer `ddMultDouble2` due to extra speed
 *
 * * ALGORITHM 7 of https://hal.archives-ouvertes.fr/hal-01351529v3/document
 * @param y a double
 * @param x a double-double precision floating point number
 */
function ddMultDouble1(y, x) {
    const xl = x[0];
    const xh = x[1];
    //const [cl1,ch] = twoProduct(xh,y);
    const ch = xh * y;
    const c = dd_mult_double_f * xh;
    const ah = c - (c - xh);
    const al = xh - ah;
    const d = dd_mult_double_f * y;
    const bh = d - (d - y);
    const bl = y - bh;
    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));
    const cl2 = xl * y;
    //const [tl1,th] = fastTwoSum(ch,cl2);
    const th = ch + cl2;
    const tl1 = cl2 - (th - ch);
    const tl2 = tl1 + cl1;
    //const [zl,zh] = fastTwoSum(th,tl2);
    const zh = th + tl2;
    const zl = tl2 - (zh - th);
    return [zl, zh];
}
/**
 * Returns the product of a double-double-precision floating point number and a double.
 *
 * * faster than ALGORITHM 7 (one call to fastTwoSum less) but about 2x less
 * accurate
 * * relative error bound: 3u^2, i.e. fl(a*b) = (a*b)(1+ϵ),
 * where ϵ <= 3u^2, u = 0.5 * Number.EPSILON
 * * the bound is sharp
 * * probably prefer this algorithm due to extra speed
 *
 * * ALGORITHM 8 of https://hal.archives-ouvertes.fr/hal-01351529v3/document
 * @param y a double
 * @param x a double-double precision floating point number
 */
function dd_mult_double_ddMultDouble2(y, x) {
    const xl = x[0];
    const xh = x[1];
    //const [cl1,ch] = twoProduct(xh,y);
    const ch = xh * y;
    const c = dd_mult_double_f * xh;
    const ah = c - (c - xh);
    const al = xh - ah;
    const d = dd_mult_double_f * y;
    const bh = d - (d - y);
    const bl = y - bh;
    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));
    const cl2 = xl * y;
    const cl3 = cl1 + cl2;
    //return fastTwoSum(ch,cl3);
    const xx = ch + cl3;
    return [cl3 - (xx - ch), xx];
}

//# sourceMappingURL=dd-mult-double.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/unary/dd-mult-by-2.js
/**
 * Returns the result of multiplying the given double-double by 2.
 * * The result is exact
 * @param f a double-double precision floating point number
 */
function ddMultBy2(f) {
    return [2 * f[0], 2 * f[1]];
}

//# sourceMappingURL=dd-mult-by-2.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/unary/dd-mult-by-4.js
/**
 * Returns the result of multiplying the given double-double by 4.
 * * The result is exact
 * @param f a double-double precision floating point number
 */
function ddMultBy4(f) {
    return [4 * f[0], 4 * f[1]];
}

//# sourceMappingURL=dd-mult-by-4.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/unary/dd-div-by-2.js
/**
 * Returns the result of dividing the given double-double by 2.
 * @param f a double-double precision floating point number
 */
function ddDivBy2(f) {
    return [f[0] / 2, f[1] / 2];
}

//# sourceMappingURL=dd-div-by-2.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-2.js
/**
 * Returns the result of multiplying the given double-double by -2.
 * * The result is exact
 * @param f a double-double precision floating point number
 */
function dd_mult_by_neg_2_ddMultByNeg2(f) {
    return [-2 * f[0], -2 * f[1]];
}

//# sourceMappingURL=dd-mult-by-neg-2.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/unary/dd-mult-by-neg-4.js
/**
 * Returns the result of multiplying the given double-double by -4.
 * * The result is exact
 * @param f a double-double precision floating point number
 */
function ddMultByNeg4(f) {
    return [-4 * f[0], -4 * f[1]];
}

//# sourceMappingURL=dd-mult-by-neg-4.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-mixed-double-double/dd-div-double.js
/** @internal */
const dd_div_double_f = 134217729; // 2**27 + 1;
/**
 * Returns the result of dividing a double-double-precision floating point
 * number by a double.
 *
 * * relative error bound: 3u^2, i.e. fl(a/b) = (a/b)(1+ϵ), where ϵ <= 3u^2,
 * u = 0.5 * Number.EPSILON
 * * the bound is very sharp
 *
 * * ALGORITHM 15 of https://hal.archives-ouvertes.fr/hal-01351529v3/document
 * @param x a double-double precision floating point number
 * @param y the double-precision divisor
 */
function ddDivDouble(x, y) {
    const xl = x[0];
    const xh = x[1];
    const th = xh / y;
    //const [πl,πh] = twoProduct(th,y);
    const πh = th * y;
    const c = dd_div_double_f * th;
    const ah = c - (c - th);
    const al = th - ah;
    const d = dd_div_double_f * y;
    const bh = d - (d - y);
    const bl = y - bh;
    const πl = (al * bl) - ((πh - (ah * bh)) - (al * bh) - (ah * bl));
    const δh = xh - πh; // exact operation
    const δt = δh - πl; // exact operation
    const δ = δt + xl;
    const tl = δ / y;
    //return fastTwoSum(th,tl);
    const rl = th + tl;
    return [tl - (rl - th), rl];
}

//# sourceMappingURL=dd-div-double.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/binary/dd-div-dd.js
/** @internal */
const dd_div_dd_f = 134217729; // 2**27 + 1;
/**
 * Returns the result of dividing two double-double-precision floating point
 * numbers, i.e. returns x/y.
 *
 * * relative error bound: 15u^2 + 56u^3, i.e. fl(a/b) = (a/b)(1+ϵ),
 * where ϵ <= 15u^2 + 56u^3, u = 0.5 * Number.EPSILON
 * * the largest error found was 8.465u^2
 *
 * * ALGORITHM 17 of https://hal.archives-ouvertes.fr/hal-01351529v3/document
 * @param x a double-double precision floating point number
 * @param y another double-double precision floating point number
 */
function ddDivDd(x, y) {
    const xl = x[0];
    const xh = x[1];
    const yl = y[0];
    const yh = y[1];
    const th = xh / yh;
    // approximation to th*(yh + yl) using Algorithm 7
    //const [rl,rh] = ddMultDouble1(th,[yl,yh]);  
    const ch = yh * th;
    const c = dd_div_dd_f * yh;
    const ah = c - (c - yh);
    const al = yh - ah;
    const d = dd_div_dd_f * th;
    const bh = d - (d - th);
    const bl = th - bh;
    const cl1 = (al * bl) - ((ch - (ah * bh)) - (al * bh) - (ah * bl));
    const cl2 = yl * th;
    const th_ = ch + cl2;
    const tl1 = cl2 - (th_ - ch);
    const tl2 = tl1 + cl1;
    const rh = th_ + tl2;
    const rl = tl2 - (rh - th_);
    const πh = xh - rh; // exact operation
    const δl = xl - rl;
    const δ = πh + δl;
    const tl = δ / yh;
    //return fastTwoSum(th,tl);
    const xx = th + tl;
    return [tl - (xx - th), xx];
}

//# sourceMappingURL=dd-div-dd.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/unary/dd-negative-of.js
/**
 * Returns the negative of the given double-double precision floating point
 * number.
 * * the result is exact
 * @param f a double-double precision floating point number
 */
function ddNegativeOf(f) {
    return [-f[0], -f[1]];
}

//# sourceMappingURL=dd-negative-of.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double/unary/dd-sign.js
/**
 * Returns the sign of the given double-double-precision floating point number.
 * * a positive or negative double or zero is returned - not necessarily +1, 0
 * or -1
 * * prefer inlining this - it is really only here for reference
 */
function ddSign(f) {
    return f[1];
}

//# sourceMappingURL=dd-sign.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/basic/fast-two-diff.js
/**
 * Returns the difference and exact error of subtracting two floating point
 * numbers.
 * Uses an EFT (error-free transformation), i.e. `a-b === x+y` exactly.
 * The returned result is a non-overlapping expansion (smallest value first!).
 *
 * * **precondition:** `abs(a) >= abs(b)` - A fast test that can be used is
 * `(a > b) === (a > -b)`
 *
 * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 */
function fast_two_diff_fastTwoDiff(a, b) {
    const x = a - b;
    const y = (a - x) - b;
    return [y, x];
}

//# sourceMappingURL=fast-two-diff.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/basic/fast-two-sum.js
/**
 * Returns the sum and exact error of adding two floating point numbers.
 * Uses an EFT (error-free transformation), i.e. a+b === x+y exactly.
 * The returned sum is a non-overlapping expansion (smallest value first!).
 *
 * Precondition: abs(a) >= abs(b) - A fast test that can be used is
 * (a > b) === (a > -b)
 *
 * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 */
function basic_fast_two_sum_fastTwoSum(a, b) {
    const x = a + b;
    return [b - (x - a), x];
}
// inlined
//const R = a + b; const r = b - (R - a); return [r, R];

//# sourceMappingURL=fast-two-sum.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/basic/split.js
/**
 * === 2^Math.ceil(p/2) + 1 where p is the # of significand bits in a double === 53.
 * @internal
 */
const basic_split_f = 134217729; // 2**27 + 1;
/**
 * Returns the result of splitting a double into 2 26-bit doubles.
 *
 * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where
 * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the
 * following algorithm will produce a (p-s)-bit value a_hi and a
 * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and
 * a = a_hi + a_lo.
 *
 * see e.g. [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 * @param a A double floating point number
 */
function split_split(a) {
    const c = basic_split_f * a;
    const a_h = c - (c - a);
    const a_l = a - a_h;
    return [a_h, a_l];
}
// inlined - input a, output a_h, a_l
// const c = f * a; const a_h = c - (c - a); const a_l = a - a_h; return [a_h, a_l];

//# sourceMappingURL=split.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/basic/two-diff.js
/**
 * Returns the exact result of subtracting b from a.
 *
 * @param a minuend - a double-double precision floating point number
 * @param b subtrahend - a double-double precision floating point number
 */
function basic_two_diff_twoDiff(a, b) {
    const x = a - b;
    const bvirt = a - x;
    const y = (a - (x + bvirt)) + (bvirt - b);
    return [y, x];
}

//# sourceMappingURL=two-diff.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/basic/two-product.js
/** @internal */
const basic_two_product_f = 134217729; // 2**27 + 1;
/**
 * Returns the exact result of multiplying two doubles.
 *
 * * the resulting array is the reverse of the standard twoSum in the literature.
 *
 * Theorem 18 (Shewchuk): Let a and b be p-bit floating-point numbers, where
 * p >= 6. Then the following algorithm will produce a nonoverlapping expansion
 * x + y such that ab = x + y, where x is an approximation to ab and y
 * represents the roundoff error in the calculation of x. Furthermore, if
 * round-to-even tiebreaking is used, x and y are non-adjacent.
 *
 * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 * @param a A double
 * @param b Another double
 */
function basic_two_product_twoProduct(a, b) {
    const x = a * b;
    //const [ah, al] = split(a);
    const c = basic_two_product_f * a;
    const ah = c - (c - a);
    const al = a - ah;
    //const [bh, bl] = split(b);
    const d = basic_two_product_f * b;
    const bh = d - (d - b);
    const bl = b - bh;
    const y = (al * bl) - ((x - (ah * bh)) - (al * bh) - (ah * bl));
    //const err1 = x - (ah * bh);
    //const err2 = err1 - (al * bh);
    //const err3 = err2 - (ah * bl);
    //const y = (al * bl) - err3;
    return [y, x];
}

//# sourceMappingURL=two-product.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-mixed-double-double/double-div-double.js
/** @internal */
const double_div_double_f = 134217729; // 2**27 + 1;
/**
 * Returns the result of dividing a double-precision floating point
 * number by a double with the result given as a double-double.
 * This is a slight modification of ddDivDd.
 *
 * * **!! NOT an error-free transformation !!**
 * * relative error bound: 3u^2, i.e. fl(a/b) = (a/b)(1+ϵ), where ϵ <= 3u^2,
 * u = 0.5 * Number.EPSILON
 *
 * * ALGORITHM 15 of https://hal.archives-ouvertes.fr/hal-01351529v3/document
 * (slightly modified)
 * @param x dividend
 * @param y divisor
 */
function doubleDivDouble(x, y) {
    const th = x / y;
    //const [πl,πh] = twoProduct(th,y);
    const πh = th * y;
    const c = double_div_double_f * th;
    const ah = c - (c - th);
    const al = th - ah;
    const d = double_div_double_f * y;
    const bh = d - (d - y);
    const bl = y - bh;
    const πl = (al * bl) - ((πh - (ah * bh)) - (al * bh) - (ah * bl));
    const δh = x - πh; // exact operation
    const δt = δh - πl; // exact operation
    const tl = δt / y;
    //return fastTwoSum(th,tl);
    const xx = th + tl;
    return [tl - (xx - th), xx];
}

//# sourceMappingURL=double-div-double.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/basic/two-sum.js
/**
 * Returns the exact result of adding two doubles.
 *
 * * the resulting array is the reverse of the standard twoSum in the literature.
 *
 * Theorem 7 (Knuth): Let a and b be p-bit floating-point numbers. Then the
 * following algorithm will produce a nonoverlapping expansion x + y such that
 * a + b = x + y, where x is an approximation to a + b and y is the roundoff
 * error in the calculation of x.
 *
 * See https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf
 */
function basic_two_sum_twoSum(a, b) {
    const x = a + b;
    const bv = x - a;
    return [(a - (x - bv)) + (b - bv), x];
}
// inlined
//const R = a + b; const _ = R - a; const r = (a - (R - _)) + (b - _); return [r,R]

//# sourceMappingURL=two-sum.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/basic/reduce-significand.js
/**
 * Truncates a floating point value's significand and returns the result.
 * Similar to split, but with the ability to specify the number of bits to keep.
 *
 * Theorem 17 (Veltkamp-Dekker): Let a be a p-bit floating-point number, where
 * p >= 3. Choose a splitting point s such that p/2 <= s <= p-1. Then the
 * following algorithm will produce a (p-s)-bit value a_hi and a
 * nonoverlapping (s-1)-bit value a_lo such that abs(a_hi) >= abs(a_lo) and
 * a = a_hi + a_lo.
 *
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param a a double
 * @param bits the number of significand bits to leave intact
 */
function reduce_significand_reduceSignificand(a, bits) {
    const s = 53 - bits;
    const f = 2 ** s + 1;
    const c = f * a;
    const r = c - (c - a);
    return r;
}

//# sourceMappingURL=reduce-significand.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-representation/double-to-octets.js
// Modified from https://github.com/bartaz/ieee754-visualization/
// under the MIT license
// Copyright 2013 Bartek Szopka (original author)
/**
 * Returns the ieee-574 8 bytes composing the given double, starting from the
 * sign bit and ending in the lsb of the significand.
 * e.g. 123.456 -> [64, 94, 221, 47, 26, 159, 190, 119]
 * @internal
 */
function double_to_octets_doubleToOctets(number) {
    var buffer = new ArrayBuffer(8);
    new DataView(buffer).setFloat64(0, number, false);
    return Array.from(new Uint8Array(buffer));
}

//# sourceMappingURL=double-to-octets.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-representation/double-to-binary-string.js
// Modified from https://github.com/bartaz/ieee754-visualization/
// under the MIT license
// Copyright 2013 Bartek Szopka (original author)

/** @internal */
function double_to_binary_string_doubleToBinaryString(number) {
    return double_to_binary_string_octetsToBinaryString(double_to_octets_doubleToOctets(number));
}
/**
 * @param octets The 8 bytes composing a double (msb first)
 * @internal
 */
function double_to_binary_string_octetsToBinaryString(octets) {
    return octets
        .map(double_to_binary_string_int8ToBinaryString)
        .join('');
}
/**
 * intToBinaryString(8) -> "00001000"
 * @internal
 */
function double_to_binary_string_int8ToBinaryString(i) {
    let iStr = i.toString(2);
    for (; iStr.length < 8; iStr = "0" + iStr)
        ;
    return iStr;
}

//# sourceMappingURL=double-to-binary-string.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-representation/parse-double.js
// Modified from https://github.com/bartaz/ieee754-visualization/
// under the MIT license
// Copyright 2013 Bartek Szopka (original author)


/**
 * Returns the relevant parts of the given IEEE-754 double. The returned
 * exponent has been normalized (i.e. 1023 ha been subtracted) and the
 * significand has the hidden bit added if appropriate.
 * See https://github.com/bartaz/ieee754-visualization
 */
function parse_double_parseDouble(x) {
    let parts = double_to_octets_doubleToOctets(x);
    let p0 = parts[0];
    let p1 = parts[1];
    let sign = p0 >> 7;
    let exponent_ = ((p0 & 127) << 4) + ((p1 & 0b11110000) >> 4);
    //---- Check for negative / positive zero / denormalized numbers.
    let hiddenMsb = exponent_ === 0 ? 0 : 16;
    // Note: exponent === 0 => 0 or denormalized number (a.k.a. subnormal number).
    let exponent = exponent_ === 0
        ? exponent_ - 1022 // Subnormals use a biased exponent of 1 (not 0!)
        : exponent_ - 1023;
    //---- Break up the significand into bytes
    let significand = parts.slice(1);
    significand[0] = (p1 & 15) + hiddenMsb;
    return {
        sign,
        exponent,
        significand
    };
}
/**
 * Returns the relevant parts of the given IEEE-754 double.
 * See https://github.com/bartaz/ieee754-visualization.
 * This is a slower version of parseDouble that gives binary string
 * representations of the components.
 */
function parse_double_parseDoubleDetailed(x) {
    let str = double_to_binary_string_doubleToBinaryString(x);
    // sign{1} exponent{11} fraction{52} === 64 bits (+1 hidden!)
    let [, sign, exponent, significand] = str.match(/^(.)(.{11})(.{52})$/);
    let exponent_ = parseInt(exponent, 2);
    let hidden = exponent_ === 0 ? "0" : "1";
    return {
        full: sign + exponent + hidden + significand,
        sign,
        exponent,
        hidden,
        significand
    };
}

//# sourceMappingURL=parse-double.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-representation/significand.js

/**
 * Return the significand of the given double with the hidden bit added (in case
 * a is not subnormal or 0, etc.)
 *
 * @param a A double
 */
function significand_significand(a) {
    return parse_double_parseDouble(a).significand;
}

//# sourceMappingURL=significand.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-representation/get-max-set-bit.js

/**
 * Returns the lowest set bit of the given value in [1, (2**31)-1],
 * i.e. from 1 up to 2147483647 else if no bit is set (input === 0) returns
 * NaN, otherwise if the number is out of range returns a non-finite
 * number.
 * See https://stackoverflow.com/a/35190288/2010061
 * @internal
 */
function get_max_set_bit_getLowestSetBit_(a) {
    return Math.log2(a & -a);
}
/**
 * Returns the lowest set bit of the given number's significand (where the lsb
 * is bit 0 and the msb is bit 52). If no bit is set (input === 0 or +-inf or
 * NaN) returns NaN.
 * See https://stackoverflow.com/a/35190288/2010061
 */
function get_max_set_bit_getLowestSetBit(a) {
    if (a === 0 || !Number.isFinite(a)) {
        // There is no lowest set bit
        return NaN;
    }
    // Note: the significand includes the hidden bit!
    let s = significand_significand(a);
    let len = s.length;
    for (let i = len - 1; i >= 0; i--) {
        if (s[i] === 0) {
            continue;
        }
        let l = get_max_set_bit_getLowestSetBit_(s[i]);
        if (Number.isFinite(l)) {
            return (8 * (len - i - 1)) + l;
        }
    }
    return NaN;
}
/**
 * Returns the highest set bit of the given value in [1, 255], i.e. from 1 up
 * to 255. If the input number === 0 returns NaN.
 * See https://stackoverflow.com/a/35190288/2010061
 * @internal
 */
function get_max_set_bit_getHighestSetBit_(a) {
    return a >= 128 ? 7
        : a >= 64 ? 6
            : a >= 32 ? 5
                : a >= 16 ? 4
                    : a >= 8 ? 3
                        : a >= 4 ? 2
                            : a >= 2 ? 1
                                : a >= 1 ? 0
                                    : NaN;
}
/**
 * Returns the highest set bit of the given double. If no bit is set (input
 * === 0 or +/-inf or NaN) returns NaN.
 * See https://stackoverflow.com/a/35190288/2010061
 */
function get_max_set_bit_getHighestSetBit(a) {
    if (a === 0 || !Number.isFinite(a)) {
        // There is no lowest set bit
        return NaN;
    }
    // At this point there must be a highest set bit (always === 52 if the 
    // number is not a subnormal.
    let s = significand_significand(a);
    let len = s.length;
    for (let i = 0; i < len; i++) {
        let l = get_max_set_bit_getHighestSetBit_(s[i]);
        if (Number.isFinite(l)) {
            return (8 * (len - i - 1)) + l;
        }
    }
    return NaN;
}

//# sourceMappingURL=get-max-set-bit.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-representation/exponent.js

/**
 * Returns the normalized exponent of the given number.
 * @param a A double
 */
function exponent_exponent(a) {
    return parse_double_parseDouble(a).exponent;
}

//# sourceMappingURL=exponent.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-representation/is-bit-aligned.js


/**
 * Returns true if the given number is bit-aligned in the sense that its a
 * multiple of a given power of 2, say e, and such that the number, say a,
 * conforms to: a/2^e < 2^(l-e), where l is the max allowed bit length.
 * This essentially means the numbers act somewhat like fixed-point numbers
 * which can drastically speed up some geometric algorithms and also reduce
 * their complexity.
 *
 * Visually:
 * These numbers (a,b and c) are grid aligned with e === 3 and max
 * bitlength === 6:
 *   a -> 00|101100|000
 *   b -> 00|000100|000
 *   c -> 00|110111|000
 * These are not
 *   a -> 01|101100|000
 *   b -> 00|000100|000
 * These are not
 *   a -> 00|101100|000
 *   b -> 00|000100|100
 * These are not
 *   a -> 00|101100|100
 *   b -> 00|000100|100
 * @param as An array of numbers to check
 * @param maxBitLength The max allowed bitlength
 * @param gridSpacingExponent The grid spacing === 1^gridSpacingExponent
 */
function is_bit_aligned_isBitAligned(a, maxBitLength, gridSpacingExponent) {
    if (a === 0) {
        return true;
    }
    let e = exponent_exponent(a);
    let maxSetBit = get_max_set_bit_getHighestSetBit(a) - 52 + e;
    let minSetBit = get_max_set_bit_getLowestSetBit(a) - 52 + e;
    let minBitBigEnough = minSetBit >= gridSpacingExponent;
    let maxBitSmallEnough = maxSetBit <= maxBitLength - 1 + gridSpacingExponent;
    return minBitBigEnough && maxBitSmallEnough;
}

//# sourceMappingURL=is-bit-aligned.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-representation/msb-exponent.js


/**
 * Returns the true exponent of the msb that is set of the given number or
 * NaN if a === 0 or +-inf or NaN.
 * @param a An array of numbers to check
 */
function msb_exponent_msbExponent(a) {
    if (a === 0 || !Number.isFinite(a)) {
        return NaN;
    }
    let e = exponent_exponent(a);
    // Will return e for all but subnormal numbers
    return get_max_set_bit_getHighestSetBit(a) - 52 + e;
}

//# sourceMappingURL=msb-exponent.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-representation/lsb-exponent.js


/**
 * Returns the true exponent of the lsb that is set of the given number or
 * NaN if a === 0 or +-inf or NaN.
 * @param a An array of numbers to check
 */
function lsb_exponent_lsbExponent(a) {
    if (a === 0 || !Number.isFinite(a)) {
        return NaN;
    }
    let e = exponent_exponent(a);
    return get_max_set_bit_getLowestSetBit(a) - 52 + e;
}

//# sourceMappingURL=lsb-exponent.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-representation/bit-length.js

/**
 * Returns the bit-length of the significand of the given number in such a way
 * that trailing zeros are not counted.
 * @param a a double precision floating point number
 */
function bit_length_bitLength(a) {
    if (a === 0) {
        return 0;
    }
    return get_max_set_bit_getHighestSetBit(a) - get_max_set_bit_getLowestSetBit(a) + 1;
}

//# sourceMappingURL=bit-length.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-double-with-error/dd-div-dd-with-error.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
/** @internal */
const div = ddDivDd;
/** @internal */
const dd_div_dd_with_error_eps = Number.EPSILON;
/** @internal */
const u = dd_div_dd_with_error_eps / 2;
/** @internal */
const uu = u * u;
/**
 * Returns the result of dividing two double-double-precision floating point
 * numbers together with an absolute error bound where nE and dE are absolute
 * error bounds on the *input* values.
 *
 * @param numer numerator - a double-double-precision float
 * @param denom denominator - a double-double-precision float
 * @param nE absolute value error bound in numerator
 * @param dE absolute value error bound in denominator
 */
function ddDivDdWithError(numer, denom, nE, dE) {
    const n = numer[0];
    const N = numer[1];
    const d = denom[0];
    const D = denom[1];
    // estimate the result of the division
    const est = div(numer, denom);
    const _n = Math.abs(n + N); // absolute value of estimate of n accurate to within 1/2 ulp
    const _d = Math.abs(d + D); // absolute value of estimate of d accurate to within 1/2 ulp
    const δd = u * _d; // the max error in the rounding to _d
    // if the error in the denominator is too high the error can be 
    // arbitrarily high
    const minD = _d - δd - dE;
    // maxErr is only valid if minD > 0
    if (minD <= 0) {
        // the error can be arbitrarily high; est is mostly irrelevant
        return { est, err: Number.POSITIVE_INFINITY };
    }
    const err = ((_d * nE + _n * dE) / minD ** 2) + 9 * uu * Math.abs(_n / _d);
    return { est, err };
}

//# sourceMappingURL=dd-div-dd-with-error.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/double-with-err/div-with-err.js
/** @internal */
const div_with_err_u = Number.EPSILON / 2;
/**
 * Returns the result of dividing two double floating point numbers
 * together with an absolute error bound where nE and dE are absolute error
 * bounds on the input values.
 * @param n numerator
 * @param d denominator
 * @param nE absolute value error bound in numerator
 * @param dE absolute value error bound in denominator
 */
function divWithErr(n, d, nE, dE) {
    // estimate the result of the division
    const est = n / d;
    const _n = Math.abs(n);
    const _d = Math.abs(d);
    // if the error in the denominator is too high the error can be 
    // arbitrarily high
    const minD = _d - dE;
    // maxErr is only valid if minD > 0
    if (minD <= 0) {
        // the error can be arbitrarily high; est is mostly irrelevant
        return { est, err: Number.POSITIVE_INFINITY };
    }
    const err = ((_d * nE + _n * dE) / minD ** 2) + div_with_err_u * Math.abs(_n / _d);
    return { est, err };
}

//# sourceMappingURL=div-with-err.js.map
;// CONCATENATED MODULE: ./node_modules/double-double/node/index.js











































const node_ddMultDouble2 = dd_mult_double_ddMultDouble2;
const node_parseDoubleDetailed = parse_double_parseDoubleDetailed;
const node_getLowestSetBit = get_max_set_bit_getLowestSetBit;
const node_ddMin = ddMin;
const node_ddMax = ddMax;
const node_ddSqrt = ddSqrt;
const node_doubleSqrt = doubleSqrt;
const node_sqrtWithErr = sqrtWithErr;
const node_ddAbs = ddAbs;
const node_ddAddDouble = ddAddDouble;
const node_ddAddDd = ddAddDd;
const node_ddProduct = ddProduct;
const node_ddSum = ddSum;
const node_ddCompare = ddCompare;
const node_ddDiffDd = ddDiffDd;
const node_ddMultDouble1 = ddMultDouble1;
const node_ddMultBy2 = ddMultBy2;
const node_ddMultBy4 = ddMultBy4;
const node_ddDivBy2 = ddDivBy2;
const node_ddMultByNeg2 = dd_mult_by_neg_2_ddMultByNeg2;
const node_ddMultByNeg4 = ddMultByNeg4;
const node_ddMultDd = ddMultDd;
const node_ddDivDouble = ddDivDouble;
const node_ddDivDd = ddDivDd;
const node_ddNegativeOf = ddNegativeOf;
const node_ddSign = ddSign;
const node_fastTwoDiff = fast_two_diff_fastTwoDiff;
const node_fastTwoSum = basic_fast_two_sum_fastTwoSum;
const node_split = split_split;
const node_twoDiff = basic_two_diff_twoDiff;
const node_twoProduct = basic_two_product_twoProduct;
const node_doubleDivDouble = doubleDivDouble;
const node_twoSum = basic_two_sum_twoSum;
const node_reduceSignificand = reduce_significand_reduceSignificand;
const node_parseDouble = parse_double_parseDouble;
const node_isBitAligned = is_bit_aligned_isBitAligned;
const node_msbExponent = msb_exponent_msbExponent;
const node_lsbExponent = lsb_exponent_lsbExponent;
const node_bitLength = bit_length_bitLength;
const node_exponent = exponent_exponent;
const node_significand = significand_significand;
const node_doubleToBinaryString = double_to_binary_string_doubleToBinaryString;
const node_doubleToOctets = double_to_octets_doubleToOctets;
const node_getHighestSetBit = get_max_set_bit_getHighestSetBit;
const node_ddDivDdWithError = ddDivDdWithError;
const node_divWithErr = divWithErr;
const node_operators = {
    //---- basic ----//
    fastTwoDiff: node_fastTwoDiff,
    fastTwoSum: node_fastTwoSum,
    split: node_split,
    twoDiff: node_twoDiff,
    twoProduct: node_twoProduct,
    doubleDivDouble: node_doubleDivDouble,
    twoSum: node_twoSum,
    reduceSignificand: node_reduceSignificand,
    //---- double-double precision ----//
    doubleSqrt: node_doubleSqrt,
    ddSqrt: node_ddSqrt,
    ddAbs: node_ddAbs,
    ddAddDouble: node_ddAddDouble,
    ddAddDd: node_ddAddDd,
    ddProduct: node_ddProduct,
    ddSum: node_ddSum,
    ddCompare: node_ddCompare,
    ddDiffDd: node_ddDiffDd,
    ddMultDouble1: node_ddMultDouble1,
    ddMultDouble2: node_ddMultDouble2,
    ddMultDd: node_ddMultDd,
    ddDivDouble: node_ddDivDouble,
    ddDivDd: node_ddDivDd,
    ddNegativeOf: node_ddNegativeOf,
    ddSign: node_ddSign,
    ddMultBy2: node_ddMultBy2,
    ddMultBy4: node_ddMultBy4,
    ddDivBy2: node_ddDivBy2,
    ddMultByNeg2: node_ddMultByNeg2,
    ddMultByNeg4: node_ddMultByNeg4,
    ddMin: node_ddMin,
    ddMax: node_ddMax,
    //---- double-double precision error propagation - with error bound on input parameters
    ddDivDdWithError: node_ddDivDdWithError,
    //---- double precision error propagation - with error bound on input parameters
    divWithErr: node_divWithErr,
    sqrtWithErr: node_sqrtWithErr,
    //---- double floating point representation ----//
    parseDouble: node_parseDouble,
    parseDoubleDetailed: node_parseDoubleDetailed,
    isBitAligned: node_isBitAligned,
    msbExponent: node_msbExponent,
    lsbExponent: node_lsbExponent,
    bitLength: node_bitLength,
    doubleToBinaryString: node_doubleToBinaryString,
    doubleToOctets: node_doubleToOctets,
    getHighestSetBit: node_getHighestSetBit,
    getLowestSetBit: node_getLowestSetBit,
    exponent: node_exponent,
    significand: node_significand
};


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/calculus/double-double/dd-differentiate.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const dd_differentiate_ddMultDouble2 = node_ddMultDouble2;
/**
 * Returns the result of differentiating the given polynomial (with coefficients
 * given in double-double precision) in double-double precision.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * ddDifferentiate([[0,5], [0,4], [0,3], [0,2], [0,1]]); //=> [[0,20], [0,12], [0,6], [0,2]]
 * ```
 *
 * @doc
 */
function ddDifferentiate(p) {
    const result = [];
    const d = p.length - 1;
    for (let i = 0; i < d; i++) {
        result.push(dd_differentiate_ddMultDouble2((d - i), p[i]));
    }
    return result;
}

//# sourceMappingURL=dd-differentiate.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/error-analysis/gamma.js
const gamma_u = Number.EPSILON / 2;
const gamma_uu = gamma_u * gamma_u;
/**
 * The canonical floating point error function, γ.
 *
 * * roughly `=== n * (Number.EPSILON / 2)`
 * * see e.g. [Algorithms for Accurate, Validated and Fast Polynomial Evaluation](https://hal.archives-ouvertes.fr/hal-00285603/document)
 * @param n the parameter - typically a small positive integer, e.g. for
 * polynomial evaluation this === 2*d + 1, where d is the degree of the
 * polynomial
 *
 * @doc
 */
function γ(n) {
    const nu = n * gamma_u;
    return nu / (1 - nu);
}
/**
 * The canonical, once compensated (implying double-double precision),
 * floating point error function.
 *
 * * roughly `=== n * (Number.EPSILON / 2)**2`
 * * see e.g. [Algorithms for Accurate, Validated and Fast Polynomial Evaluation](https://hal.archives-ouvertes.fr/hal-00285603/document)
 * @param n the parameter - typically a small positive integer, e.g. for
 * polynomial evaluation this === 2*d + 1, where d is the degree of the
 * polynomial
 *
 * @doc
 */
function γγ(n) {
    const nuu = n * gamma_uu;
    return nuu / (1 - nuu);
}

//# sourceMappingURL=gamma.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/calculus/double-double/dd-differentiate-with-err.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const dd_differentiate_with_err_ddMultDouble2 = node_ddMultDouble2;
const dd_differentiate_with_err_eEstimate = e_estimate_eEstimate;
const γγ3 = γγ(3);
/**
 * Returns the result (and resulting coefficient-wise error bound) of
 * differentiating the given polynomial (with coefficients given in
 * double-double precision) in double-double precision.
 *
 * @param pWithErr an object with 2 properties: `p`: a polynomial with
 * coefficients given densely as an array of double-double precision floating
 * point numbers from highest to lowest power, e.g. `[[5],[-3],[0]]` represents
 * the polynomial `5x^2 - 3x` **and** `pE`: the coefficient-wise error bound of
 * the input polynomial
 *
 * @doc
 */
function ddDifferentiateWithError(pWithErr) {
    const { p, pE } = pWithErr;
    const dp = [];
    const dpE = [];
    const d = p.length - 1;
    for (let i = 0; i < d; i++) {
        const deg = d - i;
        const c = dd_differentiate_with_err_ddMultDouble2(deg, p[i]);
        dp.push(c);
        // if 1,2,4 or 8, etc. then no additional error occurs on multiply
        // if 3,5,7 or 9, etc. then additional error occurs
        // deg is a power of 2 <=> (deg & deg-1) === 0
        const extraErr = (deg & deg - 1) === 0 ? 0 : γγ3;
        const $c = dd_differentiate_with_err_eEstimate(c);
        dpE.push(
        //deg * (pE[i] + Math.abs($c)*extraErr)
        deg * pE[i] + Math.abs($c) * extraErr);
    }
    return { p: dp, pE: dpE };
}

//# sourceMappingURL=dd-differentiate-with-err.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/calculus/expansion/e-differentiate.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_differentiate_scaleExpansion = scaleExpansion;
/**
 * Returns the exact result (bar underflow / overflow) of differentiating the
 * given polynomial (with Shewchuk expansion coefficients).
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * eDifferentiate([[5], [4], [3], [2], [1]]); //=> [[20], [12], [6], [2]]
 * ```
 *
 * @doc
 */
function eDifferentiate(p) {
    const result = [];
    const d = p.length - 1;
    for (let i = 0; i < d; i++) {
        result.push(e_differentiate_scaleExpansion(p[i], d - i));
    }
    return result;
}

//# sourceMappingURL=e-differentiate.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-linear.js
/**
 * Returns the result of performing a change of variables of the
 * form: p(x) <- p(ax + b).
 *
 * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 * @param a the `a` in `ax + b`
 * @param b the `b` in `ax + b`
 *
 * @example
 * ```typescript
 * bChangeVariablesLinear([1n,2n,7n], 3n, 4n); //=> [9n, 30n, 31n]
 * ```
 *
 * @doc
 */
function bChangeVariablesLinear(p, a, b) {
    // We let the coefficients of p(ax + b) be denoted by d_i in the 
    // code below. 
    // d_i is calculated as d = T*c, where c are the original 
    // coefficients.
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    // Initialize a zero matrix
    const t = [];
    for (let i = 0; i < d + 1; i++) {
        t.push(new Array(d + 1).fill(0n));
    }
    // Calculate the triangular matrix T
    t[0][0] = 1n;
    for (let j = 1; j <= d; j++) {
        t[0][j] = b * t[0][j - 1];
        for (let i = 1; i <= j; i++) {
            t[i][j] = b * t[i][j - 1] + a * t[i - 1][j - 1];
        }
    }
    // Multiply
    const res = new Array(d + 1).fill(0n);
    for (let i = 0; i <= d; i++) {
        res[d - i] = 0n;
        for (let j = i; j <= d; j++) {
            res[d - i] += t[i][j] * p[d - j];
        }
    }
    return res;
}

//# sourceMappingURL=b-change-variables-linear.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-scale.js
/**
 * Returns the result of performing a change of variables of the
 * form: p(x) <- p(ax).
 *
 * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 * @param a a scaling factor, i.e. the `a` in `p(x) <- p(ax)`
 *
 * @example
 * ```typescript
 * bChangeVariablesScale([1n,2n,7n], 3n); //=> [9n, 6n, 7n]
 * ```
 *
 * @doc
 */
function bChangeVariablesScale(p, a) {
    // We let the coefficients of `p(ax)` be denoted by `d_i` in the code below. 
    // `d_i` is calculated as `d = T*c`, where `c` is the original coefficient
    // vector.
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    // Initialize a zero matrix
    const t = [];
    for (let i = 0; i < d + 1; i++) {
        t.push(new Array(d + 1).fill(0n));
    }
    // Calculate the triangular matrix T
    t[0][0] = 1n;
    for (let j = 1; j <= d; j++) {
        t[0][j] = 0n;
        for (let i = 1; i <= j; i++) {
            t[i][j] = a * t[i - 1][j - 1];
        }
    }
    // Multiply
    const res = new Array(d + 1).fill(0n);
    for (let i = 0; i <= d; i++) {
        res[d - i] = 0n;
        for (let j = i; j <= d; j++) {
            res[d - i] += t[i][j] * p[d - j];
        }
    }
    return res;
}

//# sourceMappingURL=b-change-variables-scale.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/bigint/b-change-variables-translate-x.js
/**
 * Returns the result of performing a change of variables of the
 * form: p(x) <- p(x + b).
 *
 * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 * @param b the `b` in `x + b`
 *
 * @example
 * ```typescript
 * bChangeVariablesTranslateX([1n,2n,7n], 3n); //=> [1n, 8n, 22n]
 * ```
 *
 * @doc
 */
function bChangeVariablesTranslateX(p, b) {
    // We let the coefficients of p(x + b) be denoted by d_i in the code below. 
    // d_i is calculated as d = T*c, where c are the original coefficients.
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    // Initialize a zero matrix
    const t = [];
    for (let i = 0; i < d + 1; i++) {
        t.push(new Array(d + 1).fill(0n));
    }
    // Calculate the triangular matrix T
    t[0][0] = 1n;
    for (let j = 1; j <= d; j++) {
        t[0][j] = b * t[0][j - 1];
        for (let i = 1; i <= j; i++) {
            t[i][j] = b * t[i][j - 1] + t[i - 1][j - 1];
        }
    }
    // Multiply
    const res = new Array(d + 1).fill(0n);
    for (let i = 0; i <= d; i++) {
        res[d - i] = 0n;
        for (let j = i; j <= d; j++) {
            const acc = t[i][j] * p[d - j];
            res[d - i] += acc;
        }
    }
    return res;
}

//# sourceMappingURL=b-change-variables-translate-x.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/bigint/b-reflect-about-y-axis.js
/**
 * Returns the result of reflecting the given polynomial about the Y-axis, i.e.
 * perform the change of variables: p(x) <- p(-x).
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * bReflectAboutYAxis([5n, 4n, 3n, 2n, 1n]); //=> [5n, -4n, 3n, -2n, 1n]
 * ```
 *
 * @doc
 */
function bReflectAboutYAxis(p) {
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    const result = p.slice();
    for (let i = 0; i < d + 1; i++) {
        if (i % 2) {
            result[i] = -result[i];
        }
    }
    return result;
}

//# sourceMappingURL=b-reflect-about-y-axis.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/double/change-variables-linear.js
/**
 * Returns the result of performing a change of variables of the
 * form: p(x) <- p(ax + b) in double precision.
 *
 * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param a the `a` in `ax + b`
 * @param b the `b` in `ax + b`
 *
 * @example
 * ```typescript
 * changeVariablesLinear([1,2,7], 3, 4); //=> [9, 30, 31]
 * ```
 *
 * @doc
 */
function changeVariablesLinear(p, a, b) {
    // We let the coefficients of p(ax + b) be denoted by d_i in the 
    // code below. 
    // d_i is calculated as d = T*c, where c are the original 
    // coefficients.
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    // Initialize a zero matrix
    const t = [];
    for (let i = 0; i < d + 1; i++) {
        t.push(new Array(d + 1).fill(0));
    }
    // Calculate the triangular matrix T
    t[0][0] = 1;
    for (let j = 1; j <= d; j++) {
        t[0][j] = b * t[0][j - 1];
        for (let i = 1; i <= j; i++) {
            t[i][j] = b * t[i][j - 1] + a * t[i - 1][j - 1];
        }
    }
    // Multiply
    const res = new Array(d + 1).fill(0);
    for (let i = 0; i <= d; i++) {
        res[d - i] = 0;
        for (let j = i; j <= d; j++) {
            res[d - i] += t[i][j] * p[d - j];
        }
    }
    return res;
}

//# sourceMappingURL=change-variables-linear.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/double/change-variables-scale.js
/**
 * Returns the result of performing a change of variables of the
 * form: p(x) <- p(ax) in double precision.
 *
 * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param a a scaling factor, i.e. the `a` in `p(x) <- p(ax)`
 *
 * @example
 * ```typescript
 * changeVariablesScale([1,2,7], 3); //=> [9, 6, 7]
 * ```
 *
 * @doc
 */
function changeVariablesScale(p, a) {
    // We let the coefficients of `p(ax)` be denoted by `d_i` in the code below. 
    // `d_i` is calculated as `d = T*c`, where `c` is the original coefficient
    // vector.
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    // Initialize a zero matrix
    const t = [];
    for (let i = 0; i < d + 1; i++) {
        t.push(new Array(d + 1).fill(0));
    }
    // Calculate the triangular matrix T
    t[0][0] = 1;
    for (let j = 1; j <= d; j++) {
        t[0][j] = 0;
        for (let i = 1; i <= j; i++) {
            t[i][j] = a * t[i - 1][j - 1];
        }
    }
    // Multiply
    const res = new Array(d + 1).fill(0);
    for (let i = 0; i <= d; i++) {
        res[d - i] = 0;
        for (let j = i; j <= d; j++) {
            res[d - i] += t[i][j] * p[d - j];
        }
    }
    return res;
}

//# sourceMappingURL=change-variables-scale.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/double/change-variables-translate-x.js
/**
 * Returns the result of performing a change of variables of the
 * form: p(x) <- p(x + b) in double precision.
 *
 * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param b the `b` in `x + b`
 *
 * @example
 * ```typescript
 * changeVariablesTranslateX([1,2,7], 3); //=> [1, 8, 22]
 * ```
 *
 * @doc
 */
function changeVariablesTranslateX(p, b) {
    // We let the coefficients of p(x + b) be denoted by d_i in the code below. 
    // d_i is calculated as d = T*c, where c are the original coefficients.
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    // Initialize a zero matrix
    const t = [];
    for (let i = 0; i < d + 1; i++) {
        t.push(new Array(d + 1).fill(0));
    }
    // Calculate the triangular matrix T
    t[0][0] = 1;
    for (let j = 1; j <= d; j++) {
        t[0][j] = b * t[0][j - 1];
        for (let i = 1; i <= j; i++) {
            t[i][j] = b * t[i][j - 1] + t[i - 1][j - 1];
        }
    }
    // Multiply
    const res = new Array(d + 1).fill(0);
    for (let i = 0; i <= d; i++) {
        res[d - i] = 0;
        for (let j = i; j <= d; j++) {
            res[d - i] += t[i][j] * p[d - j];
        }
    }
    return res;
}

//# sourceMappingURL=change-variables-translate-x.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/double/reflect-about-y-axis.js
/**
 * Returns the result of reflecting the given polynomial about the Y-axis, i.e.
 * perform the change of variables: p(x) <- p(-x).
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * reflectAboutYAxis([5,4,3,2,1]); //=> [5, -4, 3, -2, 1]
 * ```
 *
 * @doc
 */
function reflectAboutYAxis(p) {
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    const result = p.slice();
    for (let i = 0; i < d + 1; i++) {
        if (i % 2) {
            result[i] = -result[i];
        }
    }
    return result;
}

//# sourceMappingURL=reflect-about-y-axis.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-linear.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_change_variables_linear_expansionProduct = expansion_product_expansionProduct;
const e_change_variables_linear_fastExpansionSum = fastExpansionSum;
const e_change_variables_linear_scaleExpansion2 = scale_expansion_scaleExpansion2;
/**
 * Returns the exact result (bar underflow / overflow) of performing a change
 * of variables of the form: p(x) <- p(ax + b) on the given polynomial (with
 * coefficients given as Shewchuk expansions).
 *
 * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 * @param a the `a` in `ax + b`
 * @param b the `b` in `ax + b`
 *
 * @example
 * ```typescript
 * eChangeVariablesLinear([[1],[2],[7]], 3, 4); //=> [[9], [30], [31]]
 * ```
 *
 * @doc
 */
function eChangeVariablesLinear(p, a, b) {
    // We let the coefficients of p(ax + b) be denoted by d_i in the code below. 
    // d_i is calculated as d = T*c, where c are the original coefficients.
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    // Initialize a zero matrix
    const t = [];
    for (let i = 0; i < d + 1; i++) {
        t.push(new Array(d + 1).fill([0]));
    }
    // Calculate the triangular matrix T
    t[0][0] = [1];
    for (let j = 1; j <= d; j++) {
        t[0][j] = e_change_variables_linear_scaleExpansion2(b, t[0][j - 1]);
        for (let i = 1; i <= j; i++) {
            t[i][j] = e_change_variables_linear_fastExpansionSum(e_change_variables_linear_scaleExpansion2(b, t[i][j - 1]), e_change_variables_linear_scaleExpansion2(a, t[i - 1][j - 1]));
        }
    }
    // Multiply
    const res = new Array(d + 1).fill([0]);
    for (let i = 0; i <= d; i++) {
        res[d - i] = [0];
        for (let j = i; j <= d; j++) {
            const acc = e_change_variables_linear_expansionProduct(t[i][j], p[d - j]);
            res[d - i] = e_change_variables_linear_fastExpansionSum(res[d - i], acc);
        }
    }
    return res;
}

//# sourceMappingURL=e-change-variables-linear.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-scale.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_change_variables_scale_expansionProduct = expansion_product_expansionProduct;
const e_change_variables_scale_fastExpansionSum = fastExpansionSum;
const e_change_variables_scale_scaleExpansion2 = scale_expansion_scaleExpansion2;
/**
 * Returns the exact result (bar underflow / overflow) of performing a change
 * of variables of the form: p(x) <- p(ax).
 *
 * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 * @param a a scaling factor, i.e. the `a` in `p(x) <- p(ax)`
 *
 * @example
 * ```typescript
 * eChangeVariablesScale([[1],[2],[7]], 3); //=> [[9], [6], [7]]
 * ```
 *
 * @doc
 */
function eChangeVariablesScale(p, a) {
    // We let the coefficients of `p(ax)` be denoted by `d_i` in the code below. 
    // `d_i` is calculated as `d = T*c`, where `c` is the original coefficient
    // vector.
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    // Initialize a zero matrix
    const t = [];
    for (let i = 0; i < d + 1; i++) {
        t.push(new Array(d + 1).fill([0]));
    }
    // Calculate the triangular matrix T
    t[0][0] = [1];
    for (let j = 1; j <= d; j++) {
        t[0][j] = [0];
        for (let i = 1; i <= j; i++) {
            t[i][j] = e_change_variables_scale_scaleExpansion2(a, t[i - 1][j - 1]);
        }
    }
    // Multiply
    const res = new Array(d + 1).fill([0]);
    for (let i = 0; i <= d; i++) {
        res[d - i] = [0];
        for (let j = i; j <= d; j++) {
            res[d - i] = e_change_variables_scale_fastExpansionSum(res[d - i], e_change_variables_scale_expansionProduct(t[i][j], p[d - j]));
        }
    }
    return res;
}

//# sourceMappingURL=e-change-variables-scale.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/expansion/e-change-variables-translate-x.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_change_variables_translate_x_expansionProduct = expansion_product_expansionProduct;
const e_change_variables_translate_x_fastExpansionSum = fastExpansionSum;
const e_change_variables_translate_x_scaleExpansion2 = scale_expansion_scaleExpansion2;
/**
 * Returns the exact result (bar undeflow / overflow) of performing a change of
 * variables of the form: p(x) <- p(x + b) on the given polynomial (with
 * coefficients given as Shewchuk expansions).
 *
 * * see [this stackoverflow question](http://stackoverflow.com/questions/141422/how-can-a-transform-a-polynomial-to-another-coordinate-system)
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 * @param b the `b` in `x + b`
 *
 * @doc
 */
function eChangeVariablesTranslateX(p, b) {
    // We let the coefficients of p(x + b) be denoted by d_i in the code below. 
    // d_i is calculated as d = T*c, where c are the original coefficients.
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    // Initialize a zero matrix
    const t = [];
    for (let i = 0; i < d + 1; i++) {
        t.push(new Array(d + 1).fill([0]));
    }
    // Calculate the triangular matrix T
    t[0][0] = [1];
    for (let j = 1; j <= d; j++) {
        t[0][j] = e_change_variables_translate_x_scaleExpansion2(b, t[0][j - 1]);
        for (let i = 1; i <= j; i++) {
            t[i][j] = e_change_variables_translate_x_fastExpansionSum(e_change_variables_translate_x_scaleExpansion2(b, t[i][j - 1]), t[i - 1][j - 1]);
        }
    }
    // Multiply
    const res = new Array(d + 1).fill([0]);
    for (let i = 0; i <= d; i++) {
        res[d - i] = [0];
        for (let j = i; j <= d; j++) {
            const acc = e_change_variables_translate_x_expansionProduct(t[i][j], p[d - j]);
            res[d - i] = e_change_variables_translate_x_fastExpansionSum(res[d - i], acc);
        }
    }
    return res;
}

//# sourceMappingURL=e-change-variables-translate-x.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/change-variables/expansion/e-reflect-about-y-axis.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_reflect_about_y_axis_eNegativeOf = eNegativeOf;
/**
 * Returns the result of reflecting the given polynomial about the Y-axis, i.e.
 * perform the change of variables: p(x) <- p(-x).
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * eReflectAboutYAxis([[5],[4],[3],[2],[1]]); //=> [[5], [-4], [3], [-2], [1]]
 * ```
 *
 * @doc
 */
function eReflectAboutYAxis(p) {
    const d = p.length - 1;
    if (d < 0) {
        return [];
    }
    const result = p.slice();
    for (let i = 0; i < d + 1; i++) {
        if (i % 2) {
            result[i] = e_reflect_about_y_axis_eNegativeOf(result[i]);
        }
    }
    return result;
}

//# sourceMappingURL=e-reflect-about-y-axis.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/vec-sum.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const vec_sum_twoSum = two_sum_twoSum;
/**
 * * helper function
 *
 * see http://www.ti3.tuhh.de/paper/rump/OgRuOi05.pdf
 *
 * @param x
 * @param K
 *
 * @internal
 */
function vecSum(p_) {
    const p = p_.slice();
    for (let i = 1; i < p.length; i++) {
        [p[i - 1], p[i]] = vec_sum_twoSum(p[i], p[i - 1]);
    }
    return p;
}

//# sourceMappingURL=vec-sum.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/sum-k.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const sum_k_vecSum = vecSum;
/**
 * * helper function - K compensated vector sum
 *
 * see http://www.ti3.tuhh.de/paper/rump/OgRuOi05.pdf
 *
 * @param x
 * @param K
 *
 * @internal
 */
function SumK(p, K) {
    for (let i = 1; i < K; i++) {
        p = sum_k_vecSum(p);
    }
    let res = p[0];
    for (let i = 1; i < p.length; i++) {
        res += p[i];
    }
    return res;
}

//# sourceMappingURL=sum-k.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/eft-horner.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const eft_horner_twoSum = two_sum_twoSum;
const eft_horner_twoProduct = two_product_twoProduct;
/**
 * Returns an EFT (error free transformation) for the Horner evaluation of a
 * polymial at a specified x. The result is returned as an object with
 * properties: r̂ -> the calculated evaluation, pπ and pσ -> two polynomials
 * with coefficients around 2^53 times smaller than the input polynomial.
 *
 * * r̂ + pπ(x) + pσ(x) = the *exact* evaluation (no error)
 *
 * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)
 * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)
 * * see also [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 *
 * @doc
 */
function EFTHorner(p, x) {
    const pπ = []; // A polynomial containing part of the error
    const pσ = []; // Another polynomial containing part of the error
    let σ;
    let r̂ = p[0];
    for (let i = 1; i < p.length; i++) {
        const [π, pi] = eft_horner_twoProduct(r̂, x);
        [σ, r̂] = eft_horner_twoSum(pi, p[i]);
        // inlined
        //r̂ = pi + p[i]; const bv = r̂ - pi; σ = (pi - (x-bv)) + (p[i]-bv);
        pπ.push(π);
        pσ.push(σ);
    }
    return { r̂, pπ, pσ };
}
// inlined
//const pπ: number[] = []; const pσ: number[] = []; const σ: number; const r̂ = p[0];	for (const i=1; i<p.length; i++) { const [π,pi] = twoProduct(r̂,x); [σ,r̂] = twoSum(pi, p[i]); pπ.push(π); pσ.push(σ); } return { r̂, pπ, pσ }

//# sourceMappingURL=eft-horner.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/eft-horner-k.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const eft_horner_k_EFTHorner = EFTHorner;
/**
 * @param p
 * @param x
 * @param K
 *
 * @internal
 */
function EFTHornerK(p, x, K) {
    const ps = [p];
    const hs = [];
    const card = (2 ** K) - 1; // size of the tree, i.e. cardinality of the nodes
    for (let i = 0; i < card; i++) {
        const { r̂, pπ, pσ } = eft_horner_k_EFTHorner(ps[i], x);
        hs.push(r̂);
        ps.push(pπ);
        ps.push(pσ);
    }
    return { hs, ps: ps.slice(2 ** (K - 1)) };
}

//# sourceMappingURL=eft-horner-k.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/horner.js
/**
 * Returns the result of evaluating a univariate polynomial using
 * Horner's method in double precision floating point arithmetic.
 *
 * * see [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 *
 * @doc
 */
function Horner(p, x) {
    let q = 0;
    for (let i = 0; i < p.length; i++) {
        q = q * x + p[i];
    }
    return q;
}
// inlined (with q => E, p => p0)
//let E = p0[0]; for (let i=1; i<p0.length; i++) {E = E*x + p0[i]; }

//# sourceMappingURL=horner.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/comp-horner-k.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const comp_horner_k_SumK = SumK;
const comp_horner_k_EFTHornerK = EFTHornerK;
const comp_horner_k_Horner = Horner;
/**
 * Returns a result of evaluating a univariate polynomial using K times compensated
 * Horner's method.
 *
 * * K times compensated means the error in the evaluation is reduced by roughly
 * `(1 / Number.EPSILON)**K` which is again roughly `2^(53*K)` - it is the same as using
 * double-double-.... (K times) precision in a normal Horner evaluation
 * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, `Stef Graillat, Philippe Langlois, Nicolas Louvet`](https://hal.archives-ouvertes.fr/hal-00285603/document)
 * * for K-times compensated with K <= 4 this is the fastest known method, but
 * the running time grows exponentially with K.
 *
 * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)
 * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)
 * * see also [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 * @param K (K - 1) === the number of compensations to do
 *
 * @doc
 */
function CompHornerK(p, x, K) {
    K = Math.min(p.length - 1, K);
    const { hs, ps } = comp_horner_k_EFTHornerK(p, x, K);
    const leafStart = 2 ** (K - 1); // cardinality and start of the leaves
    for (let i = 0; i < leafStart; i++) {
        hs.push(comp_horner_k_Horner(ps[leafStart + i], x));
    }
    const r̄ = comp_horner_k_SumK(hs, K);
    return r̄;
}

//# sourceMappingURL=comp-horner-k.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/error-analysis/condition-number.js


/**
 * Returns an accurate estimate (K === 4 => double-double-double-double
 * precision) of the condition number of the given polynomial when evaluated at
 * a given point.
 *
 * * **for testing purposes**
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function conditionNumber(p, x) {
    const pN = absCoeff(p);
    const pD = p;
    const N = CompHornerK(pN, x, 4);
    const D = Math.abs(CompHornerK(pD, x, 4));
    return Math.abs(N / D);
}

//# sourceMappingURL=condition-number.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/bigint/b-elevate-degree.js
/**
 * Returns the result of elevating the given polynomial by the given degree.
 *
 * @param p
 * @param deg
 *
 * @internal
 */
function bElevateDegree(p, deg) {
    const p_ = p.slice();
    for (let i = 0; i < deg; i++) {
        p_.push(0n);
    }
    return p_;
}

//# sourceMappingURL=b-elevate-degree.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-internal.js





// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_pdiv_internal_bDegree = bDegree;
const b_pdiv_internal_bElevateDegree = bElevateDegree;
const b_pdiv_internal_bAdd = bAdd;
const b_pdiv_internal_bMultiply = bMultiply;
const b_pdiv_internal_bSubtract = bSubtract;
/**
 * Returns the `quotient` and `remainder` of the pseudo division of `a/b` (a, b
 * both being polynomials) naively, i.e. in such a way that all intermediate
 * calculations and the final result are **not** guaranteed to be in ℤ, i.e.
 * performs Euclidean (i.e. long) division on the two given polynomials, a/b,
 * and returns `q` and `r` in the formula `a = bq + r`,
 * where `degree(r) < degree(b)`. `q` is called the quotient and `r` the
 * remainder.
 *
 * * **precondition:** the coefficients must be integers; if they are not they
 * can easily be scaled from floating point numbers to integers by calling
 * [[scaleFloatssToBigintss]] before calling this function (recall that all floating
 * point numbers are rational).
 *
 * * **precondition:** b !== [], i.e. unequal to the zero polynomial.
 *
 * * see [Polynomial long division](https://en.wikipedia.org/wiki/Polynomial_long_division)
 *
 * @param a the polynomial a in the formula a = bq + r; the polynomial is given
 * with coefficients as a dense array of bigints from highest to lowest
 * power, e.g. `[5n,-3n,0n]` represents the  polynomial `5x^2 - 3x`
 * @param b the polynomial b in the formula a = bq + r
 *
 * @internal
 */
function bPdivInternal(a, b) {
    let q = [];
    const d = b_pdiv_internal_bDegree(b);
    const c = b[0];
    let r = a;
    while (true) {
        const deg = b_pdiv_internal_bDegree(r) - d;
        if (deg < 0) {
            return { q, r };
        }
        // The division below is guaranteed to be exact
        const s = b_pdiv_internal_bElevateDegree([r[0] / c], deg);
        q = b_pdiv_internal_bAdd(q, s);
        r = b_pdiv_internal_bSubtract(r, b_pdiv_internal_bMultiply(s, b));
    }
}

//# sourceMappingURL=b-pdiv-internal.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/bigint/b-pdiv-trivial.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_pdiv_trivial_bDegree = bDegree;
const b_pdiv_trivial_bMultiplyByConst = bMultiplyByConst;
const b_pdiv_trivial_bPdivInternal = bPdivInternal;
const abs = (n) => n >= 0 ? n : -n;
/**
 * Performs a **trivial pseudo-division** and returns the `quotient` and `remainder`
 * of the pseudo division of `a/b` (a, b both being polynomials) in such a way
 * that all intermediate calculations and the final result are done in ℤ, i.e.
 * performs Euclidean (i.e. long) division on the two given polynomials, a/b,
 * and returns a scaled `r` and `q` in the formula `a = bq + r`, where
 * `degree(r) < degree(b)`. `q` is called the quotient and `r` the remainder.
 *
 * * **precondition:** the coefficients must be bigints; if they are not they
 * can easily be scaled from floating point numbers to bigints by calling
 * [[scaleFloatsToBigints]] or similar before calling this function (recall that
 * all floating point numbers are rational).
 *
 * * **precondition:** b !== [0], i.e. unequal to the zero polynomial.
 *
 * * see [trivial pseudo-remainder sequence](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Trivial_pseudo-remainder_sequence)
 * * see also [Polynomial long division](https://en.wikipedia.org/wiki/Polynomial_long_division)
 *
 * @param a the polynomial a in the formula a = bq + r; the polynomial is given
 * with coefficients as a dense array of bigints from highest to lowest
 * power, e.g. `[5n,-3n,0n]` represents the  polynomial `5x^2 - 3x`
 * @param b the polynomial b in the formula a = bq + r
 * @param positiveMultiplier defaults to false - if set to true then the
 * multiplier (of the coefficients of the dividend)
 * `leadingCoeff(b)^(deg(a)-deg(b)+1)` will be
 * modified to `abs(leadingCoeff(b)^(deg(a)-deg(b)+1))`
 *
 * @doc
 */
function bPdivTrivial(a, b, positiveMultiplier = false) {
    const d = b_pdiv_trivial_bDegree(a) - b_pdiv_trivial_bDegree(b) + 1;
    if (d < 1) {
        return { q: [], r: a };
    }
    let m = b[0] ** BigInt(d);
    m = positiveMultiplier
        ? abs(m)
        : m;
    const a_ = b_pdiv_trivial_bMultiplyByConst(m, a);
    return b_pdiv_trivial_bPdivInternal(a_, b);
}

//# sourceMappingURL=b-pdiv-trivial.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/factor/bigint/b-content.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_content_bGcdInts = bGcdInts;
// for some reason the tests fails if not done like below likely because Node
// and TypeScript and BigInt doesn't work perfectly together yet
const b1 = 1n;
/**
 * Returns cont(p), i.e. the content of the given polynomial defined as the
 * greatest common divisor of its coefficients.
 *
 * * the sign is chosen such that dividing the polynomial by cont(p) will
 * always result in a positive leading coefficient
 *
 * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)
 *
 * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the
 * content of `p` and `2x² - x - 1` is its primitive part.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 *
 * @doc
 */
function bContent(p) {
    if (p.length === 0) {
        // the zero polynomial
        return b1;
    }
    return p[0] < 0n ? -b_content_bGcdInts(p) : b_content_bGcdInts(p);
}

//# sourceMappingURL=b-content.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/factor/bigint/b-primitive-part.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_primitive_part_bContent = bContent;
/**
 * Returns the primitive part of the given polynomial.
 *
 * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)
 *
 * * the sign is chosen such that the leading term coefficient is positive
 *
 * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the
 * content of `p` and `2x² - x - 1` is its primitive part.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 *
 * @doc
 */
function bPrimitivePart(p) {
    const c = b_primitive_part_bContent(p);
    const p_ = [];
    for (let i = 0; i < p.length; i++) {
        p_.push(p[i] / c);
    }
    return p_;
}

//# sourceMappingURL=b-primitive-part.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-primitive.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_prem_sequence_primitive_bPdivTrivial = bPdivTrivial;
const bGetPrimitivePart = bPrimitivePart;
/**
 * Returns the primitive pseudo remainder sequence of a/b.
 *
 * * **precondition:** g !== [], i.e. unequal to the zero polynomial.
 *
* * see [Primitive Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Primitive_pseudo-remainder_sequence)
 *
 * @param f the polynomial a in the formula a = bq + r; the polynomial is given
 * with coefficients as a dense array of bigints from highest to lowest
 * power, e.g. `[5n,-3n,0n]` represents the  polynomial `5x^2 - 3x`
 * @param g the polynomial b in the formula a = bq + r;
 *
 * @doc
 */
function bPremSequencePrimitive(f, g) {
    const r = [f, g]; // Initialize the PRS
    let i = 1;
    while (true) {
        let r_ = b_prem_sequence_primitive_bPdivTrivial(r[i - 1], r[i]).r;
        r_ = bGetPrimitivePart(r_);
        if (r_.length === 0) {
            return r;
        }
        r.push(r_);
        if (r_.length === 1) {
            // the remainder is a constant so the next remainder 
            // will be 0 anyway
            return r;
        }
        i++;
    }
}

//# sourceMappingURL=b-prem-sequence-primitive.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-subresultant.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_prem_sequence_subresultant_bDegree = bDegree;
const b_prem_sequence_subresultant_bPdivTrivial = bPdivTrivial;
/**
 * Returns the subresultant pseudo remainder sequence of a/b.
 *
 * * **precondition:** g !== [], i.e. unequal to the zero polynomial.
 *
 * * see [*The subresultant polynomial remainder sequence algorithm* by Ruiyuan (Ronnie) Chen, p.10](https://pdfs.semanticscholar.org/2e6b/95ba84e2160748ba8fc310cdc408fc9bbade.pdf)
 *
 * @param f the polynomial a in the formula a = bq + r; the polynomial is given
 * with coefficients as a dense array of bigints from highest to lowest
 * power, e.g. `[5n,-3n,0n]` represents the  polynomial `5x^2 - 3x`
 * @param g the polynomial b in the formula a = bq + r;
 * @param sturm if set to true then calculate a Sturm sequence instead
 *
 * @doc
 */
function bPremSequenceSubresultant(f, g, sturm = false) {
    const r = [f, g]; // Initialize the PRS
    const d = [b_prem_sequence_subresultant_bDegree(f), b_prem_sequence_subresultant_bDegree(g)];
    const a = [1n]; // a_1 === 1
    const c = [1n]; // c_1 === 1
    let i = 1;
    while (true) {
        a.push(r[i][0]); // leading coefficient of r[i-1]
        const d_ = d[i - 1] - d[i];
        const bD_ = BigInt(d_);
        const sgn = sturm
            ? -1
            : (d_ + 1) % 2 === 0 ? +1 : -1;
        const D = a[i - 1] * c[i - 1] ** bD_;
        const exp = -bD_ + 1n;
        const cTerm1 = a[i] ** bD_;
        const cTerm2 = c[i - 1] ** (exp < 0n ? -exp : exp);
        c.push(exp < 0
            ? cTerm1 / cTerm2
            : cTerm1 * cTerm2);
        let r_ = b_prem_sequence_subresultant_bPdivTrivial(r[i - 1], r[i], sturm).r
            .map(coeff => coeff / D);
        r_ = sgn > 0 ? r_ : r_.map(c => -c);
        d.push(b_prem_sequence_subresultant_bDegree(r_));
        if (r_.length === 0) {
            return r;
        }
        r.push(r_);
        if (r_.length === 1) {
            // the remainder is a constant so the next remainder 
            // will be 0 anyway
            return r;
        }
        i++;
    }
}

//# sourceMappingURL=b-prem-sequence-subresultant.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/bigint/b-prem-sequence-trivial.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_prem_sequence_trivial_bPdivTrivial = bPdivTrivial;
/**
 * ❗ DON'T USE - coefficients grow way too big, making it slow - use
 * [[bPremSequenceSubresultant]] instead. ❗
 *
 * Returns the trivial pseudo remainder sequence of a/b.
 *
 * * **precondition:** g !== [], i.e. unequal to the zero polynomial.
 *
* * see [Trivial Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Trivial_pseudo-remainder_sequence)
 *
 * @param f the polynomial a in the formula a = bq + r; the polynomial is given
 * with coefficients as a dense array of bigints from highest to lowest
 * power, e.g. `[5n,-3n,0n]` represents the  polynomial `5x^2 - 3x`
 * @param g the polynomial b in the formula a = bq + r;
 *
 * @doc
 */
function bPremSequenceTrivial(f, g) {
    const r = [f, g]; // Initialize the PRS
    let i = 1;
    while (true) {
        const r_ = b_prem_sequence_trivial_bPdivTrivial(r[i - 1], r[i]).r;
        if (r_.length === 0) {
            return r;
        }
        r.push(r_);
        if (r_.length === 1) {
            // the remainder is a constant so the next remainder 
            // will be 0 anyway
            return r;
        }
        i++;
    }
}

//# sourceMappingURL=b-prem-sequence-trivial.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/bigint/b-sturm-chain.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_sturm_chain_bDifferentiate = bDifferentiate;
const b_sturm_chain_bPremSequenceSubresultant = bPremSequenceSubresultant;
/**
 * Returns the Sturm Chain for the given polynomial using pseudo remainders.
 *
 * * see [Sturm's Theorem](https://en.wikipedia.org/wiki/Sturm%27s_theorem)
 * * see [Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Pseudo-remainder_sequences)
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * bSturmChain([-3n,4n,2n,-2n]); //=> [[-3n, 4n, 2n, -2n], [-9n, 8n, 2n], [-204n, 138n], [-1692n]]
 * ```
 *
 * @doc
 */
function bSturmChain(p) {
    const dp = b_sturm_chain_bDifferentiate(p);
    return b_sturm_chain_bPremSequenceSubresultant(p, dp, true);
}

//# sourceMappingURL=b-sturm-chain.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/expansion/e-elevate-degree.js
/**
 * Returns the result of elevating the given polynomial by the given degree.
 *
 * @param p
 * @param deg
 *
 * @internal
 */
function eElevateDegree(p, deg) {
    const p_ = p.slice();
    for (let i = 0; i < deg; i++) {
        p_.push([0]);
    }
    return p_;
}

//# sourceMappingURL=e-elevate-degree.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/expansion/e-pdiv-internal.js






// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_pdiv_internal_eDiv = eDiv;
const e_pdiv_internal_eDegree = eDegree;
const e_pdiv_internal_eElevateDegree = eElevateDegree;
const e_pdiv_internal_eAdd = e_add_eAdd;
const e_pdiv_internal_eMultiply = eMultiply;
const subtractExact = eSubtract;
/**
 * Returns the `quotient` and `remainder` of the pseudo division of `a/b` (a, b
 * both being polynomials) naively, i.e. in such a way that all intermediate
 * calculations and the final result are **not** guaranteed to be in ℤ, i.e.
 * performs Euclidean (i.e. long) division on the two given polynomials, a/b,
 * and returns `q` and `r` in the formula `a = bq + r`,
 * where `degree(r) < degree(b)`. `q` is called the quotient and `r` the
 * remainder.
 *
 * * **precondition:** the coefficients must be integers; if they are not they
 * can easily be scaled from floating point numbers to integers by calling
 * [[scaleFloatsToBigints]] or similar before calling this function (recall that
 * all floating point numbers are rational).
 *
 * * **precondition:** b !== [], i.e. unequal to the zero polynomial.
 *
 * * see [Polynomial long division](https://en.wikipedia.org/wiki/Polynomial_long_division)
 *
 * @param a the polynomial a in the formula a = bq + r
 * @param b the polynomial b in the formula a = bq + r
 *
 * @internal
 */
function ePdivInternal(a, b) {
    let q = [];
    const d = e_pdiv_internal_eDegree(b);
    const c = b[0];
    let r = a;
    while (true) {
        const deg = e_pdiv_internal_eDegree(r) - d;
        if (deg < 0) {
            return { q, r };
        }
        // The division below is guaranteed to be exact
        let s = [e_pdiv_internal_eDiv(r[0], c, 0)];
        s = e_pdiv_internal_eElevateDegree(s, deg);
        q = e_pdiv_internal_eAdd(q, s);
        r = subtractExact(r, e_pdiv_internal_eMultiply(s, b));
    }
}

//# sourceMappingURL=e-pdiv-internal.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/expansion/e-pdiv-trivial.js





// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_pdiv_trivial_eDegree = eDegree;
const e_pdiv_trivial_eAbs = e_abs_eAbs;
const e_pdiv_trivial_eIntPow = eIntPow;
/**
 * Performs a **trivial pseudo-division** and returns the `quotient` and `remainder`
 * of the pseudo division of `a/b` (a, b both being polynomials) in such a way
 * that all intermediate calculations and the final result are done in ℤ, i.e.
 * performs Euclidean (i.e. long) division on the two given polynomials, a/b,
 * and returns a scaled `r` and `q` in the formula `a = bq + r`, where
 * `degree(r) < degree(b)`. `q` is called the quotient and `r` the remainder.
 *
 * * **precondition:** the coefficients must integers (and also Shewchuk
 * floating point expansions); if they are not they can easily be scaled from
 * floating point numbers to Shewchuk expansions by calling [[scaleFloatsToInts]]
 * or similar before calling this function (recall that all floating point
 * numbers are rational).
 *
 * * Intermediate calculations (and the input coefficients) are done in
 * infinite precision up to overlow (meaning integers can be represented
 * *exactly* up to `2^1024 === 1797...(300 more digits)...37216`) and may
 * thus not be applicable to very high degree polynomials (in which case it is
 * better to use [[bPdivTrivial]])
 *
 * * **precondition:** b !== [], i.e. unequal to the zero polynomial.
 *
 * * see [trivial pseudo-remainder sequence](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Trivial_pseudo-remainder_sequence)
 * * see also [Polynomial long division](https://en.wikipedia.org/wiki/Polynomial_long_division)
 * * see [*The subresultant polynomial remainder sequence algorithm* by Ruiyuan (Ronnie) Chen, p.10](https://pdfs.semanticscholar.org/2e6b/95ba84e2160748ba8fc310cdc408fc9bbade.pdf)
 * * see also [subresultant pseudo-remainder sequence](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Subresultant_pseudo-remainder_sequence)
 *
 * @param a the polynomial a in the formula a = bq + r; the polynomial is given
 * with coefficients as a dense array of integer Shewchuk expansions from
 * highest to lowest power, e.g. `[[5],[-3],[0]]` represents the
 * polynomial `5x^2 - 3x`
 * @param b the polynomial b in the formula a = bq + r
 * @param positiveMultiplier defaults to false - if set to true then the
 * multiplier (of the coefficients of the dividend)
 * `leadingCoeff(b)^(deg(a)-deg(b)+1)` will be
 * modified to `abs(leadingCoeff(b)^(deg(a)-deg(b)+1))`
 *
 * @doc
 */
function ePdivTrivial(a, b, positiveMultiplier = false) {
    // change to pseudo-remainder, i.e. not simply r = a; this allows the 
    // remainders to stay in 'Z', i.e. let m = leadingCoeff(b)^(deg(a)-deg(b)+1)
    const d = e_pdiv_trivial_eDegree(a) - e_pdiv_trivial_eDegree(b) + 1;
    if (d < 1) {
        return { q: [], r: a };
    }
    let m = e_pdiv_trivial_eIntPow(b[0], d);
    m = positiveMultiplier
        ? e_pdiv_trivial_eAbs(m)
        : m;
    const a_ = eMultiplyByConst(m, a);
    return ePdivInternal(a_, b);
}

//# sourceMappingURL=e-pdiv-trivial.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-subresultant.js







// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_prem_sequence_subresultant_ePdivTrivial = ePdivTrivial;
const e_prem_sequence_subresultant_eIsConstOrZero = eIsConstOrZero;
const e_prem_sequence_subresultant_expansionProduct = expansion_product_expansionProduct;
const e_prem_sequence_subresultant_eIntPow = eIntPow;
const e_prem_sequence_subresultant_eDiv = eDiv;
const e_prem_sequence_subresultant_eNegativeOf = eNegativeOf;
const e_prem_sequence_subresultant_eDegree = eDegree;
/**
 * Returns the subresultant pseudo remainder sequence of a/b.
 *
 * * **precondition:** g !== [], i.e. unequal to the zero polynomial.
 *
 * * **precondition:** the coefficients must be integer Shewchuk floating point
 * expansions; if they are not they can easily be scaled from
 * floating point numbers to Shewchuk expansions by calling [[scaleFloatsToInts]]
 * or similar before calling this function (recall that all floating point
 * numbers are rational).
 *
 * * Intermediate calculations (and the input coefficients) are done in
 * infinite precision up to overlow (meaning integers can be represented
 * *exactly* up to `2^1024 === 1797...(300 more digits)...37216`) and may
 * thus not be applicable to very high degree polynomials (in which case it is
 * better to use [[bPremSequenceSubresultant]])
 *
 * * see [*The subresultant polynomial remainder sequence algorithm* by Ruiyuan (Ronnie) Chen, p.10](https://pdfs.semanticscholar.org/2e6b/95ba84e2160748ba8fc310cdc408fc9bbade.pdf)
 *
 * @param f the polynomial a in the formula a = bq + r; the polynomial is given
 * with coefficients as a dense array of integer Shewchuk expansions from
 * highest to lowest power, e.g. `[[5],[-3],[0]]` represents the
 * polynomial `5x^2 - 3x`
 * @param g the polynomial b in the formula a = bq + r
 * @param sturm if set to true then calculate a Sturm sequence instead
 *
 * @doc
 */
function ePremSequenceSubresultant(f, g, sturm = false) {
    const r = [f, g]; // Initialize the PRS
    const d = [e_prem_sequence_subresultant_eDegree(f), e_prem_sequence_subresultant_eDegree(g)];
    const a = [[1]]; // a_1 === 1
    const c = [[1]]; // c_1 === 1
    let i = 2;
    while (true) {
        a.push(r[i - 1][0]); // leading coefficient of r[i-1]
        const d_ = d[i - 2] - d[i - 1];
        const sgn = sturm
            ? -1
            : (d_ + 1) % 2 === 0 ? +1 : -1;
        const D = e_prem_sequence_subresultant_expansionProduct(a[i - 2], e_prem_sequence_subresultant_eIntPow(c[i - 2], d_));
        const exp = -d_ + 1;
        const cTerm1 = e_prem_sequence_subresultant_eIntPow(a[i - 1], d_);
        const cTerm2 = e_prem_sequence_subresultant_eIntPow(c[i - 2], Math.abs(exp));
        c.push(exp < 0
            ? e_prem_sequence_subresultant_eDiv(cTerm1, cTerm2, 0)
            : e_prem_sequence_subresultant_expansionProduct(cTerm1, cTerm2));
        let r_ = e_prem_sequence_subresultant_ePdivTrivial(r[i - 2], r[i - 1], sturm).r
            .map(coeff => e_prem_sequence_subresultant_eDiv(coeff, D, 0));
        r_ = sgn > 0 ? r_ : r_.map(e_prem_sequence_subresultant_eNegativeOf);
        d.push(e_prem_sequence_subresultant_eDegree(r_));
        if (r_.length === 0) {
            return r;
        }
        r.push(r_);
        if (e_prem_sequence_subresultant_eIsConstOrZero(r_)) {
            // the remainder is a constant so the next remainder 
            // will be 0 anyway
            return r;
        }
        i++;
    }
}

//# sourceMappingURL=e-prem-sequence-subresultant.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/double/prem-sequence-subresultant.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const prem_sequence_subresultant_ePremSequenceSubresultant = ePremSequenceSubresultant;
/**
 * Returns the subresultant pseudo remainder sequence of a/b with the resulting
 * polynomials given with coefficients as Shewchuk expansions.
 *
 * * **precondition:** g !== [], i.e. unequal to the zero polynomial.
 *
 * * Intermediate calculations are done in infinite precision up to
 * overlow (meaning integers can be represented *exactly* up to
 * `2^1024 === 1797...(300 more digits)...37216`) and may
 * thus not be applicable to very high degree polynomials (in which case it is
 * better to use [[bPremSequenceSubresultant]])
 *
 * * see [*The subresultant polynomial remainder sequence algorithm* by Ruiyuan (Ronnie) Chen, p.10](https://pdfs.semanticscholar.org/2e6b/95ba84e2160748ba8fc310cdc408fc9bbade.pdf)
 *
 * @param f the polynomial a in the formula a = bq + r; the polynomial is given
 * with coefficients as a dense array of double precision floating point numbers
 * from highest to lowest power, e.g. `[5,-3,0]` represents the
 * polynomial `5x^2 - 3x`
 * @param g the polynomial b in the formula a = bq + r;
 * @param sturm if set to true then calculate a Sturm sequence instead
 *
 * @doc
 */
function premSequenceSubresultant(f, g, sturm = false) {
    return prem_sequence_subresultant_ePremSequenceSubresultant(f.map(c => [c]), g.map(c => [c]), sturm);
}

//# sourceMappingURL=prem-sequence-subresultant.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/double/sturm-chain.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const sturm_chain_eDifferentiate = eDifferentiate;
const sturm_chain_ePremSequenceSubresultant = ePremSequenceSubresultant;
/**
 * Returns the Sturm chain for the given polynomial using pseudo remainders
 * with the resulting polynomials given with coefficients as Shewchuk
 * expansions.
 *
 * * intermediate calculations use Shewchuk expansions and the final result is
 * given as an array of polynomials with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * * see [Sturm's Theorem](https://en.wikipedia.org/wiki/Sturm%27s_theorem)
 * * see [Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Pseudo-remainder_sequences)
 *
 * @param p a polynomial with coefficients given densely as an array of
 * double precision floating point numbers from highest to lowest power,
 * e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * sturmChain([-3,4,2,-2]); //=> [[[-3],[4],[2],[-2]],[[-9],[8],[2]],[[-204],[138]],[[-1692]]]
 * ```
 *
 * @doc
 */
function sturmChain(p) {
    // convert from double precision to Shewchuk expansion
    const p_ = p.map(c => [c]);
    const dp = sturm_chain_eDifferentiate(p_);
    return sturm_chain_ePremSequenceSubresultant(p_, dp, true);
}

//# sourceMappingURL=sturm-chain.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/factor/expansion/e-content.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_content_eGcdInts = eGcdInts;
const e_content_eSign = e_sign_eSign;
const e_content_eNegativeOf = eNegativeOf;
/**
 * Returns cont(p), i.e. the content of the given polynomial defined as the
 * greatest common divisor of its coefficients.
 *
 * * the sign is chosen such that dividing the polynomial by cont(p) will
 * always result in a positive leading coefficient
 *
 * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)
 *
 * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the
 * content of `p` and `2x² - x - 1` is its primitive part.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function eContent(p) {
    if (p.length === 0) {
        // the zero polynomial
        return [1];
    }
    return e_content_eSign(p[0]) < 0 ? e_content_eNegativeOf(e_content_eGcdInts(p)) : e_content_eGcdInts(p);
}

//# sourceMappingURL=e-content.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/factor/expansion/e-primitive-part.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_primitive_part_eContent = eContent;
const e_primitive_part_eDiv = eDiv;
/**
 * Returns the primitive part of the given polynomial.
 *
 * * the sign is chosen such that the leading term coefficient is positive
 *
 * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)
 *
 * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the
 * content of `p` and `2x² - x - 1` is its primitive part.
 *
 * @param a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function ePrimitivePart(p) {
    let c = e_primitive_part_eContent(p);
    let p_ = [];
    for (let i = 0; i < p.length; i++) {
        p_.push(e_primitive_part_eDiv(p[i], c, 0));
    }
    return p_;
}

//# sourceMappingURL=e-primitive-part.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/expansion/e-prem-sequence-primitive.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_prem_sequence_primitive_ePdivTrivial = ePdivTrivial;
const eGetPrimitivePart = ePrimitivePart;
/**
 * Returns the primitive pseudo remainder sequence of a/b.
 *
 * * **precondition:** g !== [], i.e. unequal to the zero polynomial.
 *
* * see [Primitive Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Primitive_pseudo-remainder_sequence)
 *
 * @param f the polynomial a in the formula a = bq + r; the polynomial is given
 * with coefficients as a dense array of Shewchuk expansions from highest to
 * lowest power, e.g. `[[5],[-3],[0]]` represents the  polynomial `5x^2 - 3x`
 * @param g the polynomial b in the formula a = bq + r;
 *
 * @doc
 */
function ePremSequencePrimitive(f, g) {
    const r = [f, g]; // Initialize the PRS
    let i = 1;
    while (true) {
        let r_ = e_prem_sequence_primitive_ePdivTrivial(r[i - 1], r[i]).r;
        r_ = eGetPrimitivePart(r_);
        if (r_.length === 0) {
            return r;
        }
        r.push(r_);
        if (r_.length === 1) {
            // the remainder is a constant so the next remainder 
            // will be 0 anyway
            return r;
        }
        i++;
    }
}

//# sourceMappingURL=e-prem-sequence-primitive.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/euclidean-division-related/expansion/e-sturm-chain.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_sturm_chain_eDifferentiate = eDifferentiate;
const e_sturm_chain_ePremSequenceSubresultant = ePremSequenceSubresultant;
const e_sturm_chain_scaleFloatssToIntss = scaleFloatssToIntss;
/**
 * Returns the Sturm chain for the given polynomial using pseudo remainders.
 *
 * * see [Sturm's Theorem](https://en.wikipedia.org/wiki/Sturm%27s_theorem)
 * * see [Pseudo-remainder sequences](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Pseudo-remainder_sequences)
 *
 * @param p a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * eSturmChain([[-3],[4],[2],[-2]]); //=> [[[-3],[4],[2],[-2]],[[-9],[8],[2]],[[-204],[138]],[[-1692]]]
 * ```
 *
 * @doc
 */
function eSturmChain(p) {
    p = e_sturm_chain_scaleFloatssToIntss(p);
    const dp = e_sturm_chain_eDifferentiate(p);
    return e_sturm_chain_ePremSequenceSubresultant(p, dp, true);
}

//# sourceMappingURL=e-sturm-chain.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/bigint/b-horner.js
/**
 * Returns the result of evaluating (at an integer value) a univariate
 * polynomial with bigint coefficients using Horner's method.
 *
 * * see [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 *
 * @doc
 */
function bHorner(p, x) {
    let q = 0n;
    for (let i = 0; i < p.length; i++) {
        q = q * x + p[i];
    }
    return q;
}

//# sourceMappingURL=b-horner.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/bigint/b-evaluate-at-0.js
/**
 * Returns the constant term of the given polynomial.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * bEvaluateAt0([3n,2n,99n]); //=> 99n
 * ```
 *
 * @doc
 */
function bEvaluateAt0(p) {
    return p.length === 0 ? 0n : p[p.length - 1];
}

//# sourceMappingURL=b-evaluate-at-0.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/bigint/b-evaluate-at-1.js
/**
 * Returns the exact result of evaluating the given polynomial at 1.
 *
 * * faster than at an arbitrary point.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function bEvaluateAt1(p) {
    let res = 0n;
    for (let i = 0; i < p.length; i++) {
        res += p[i];
    }
    return res;
}

//# sourceMappingURL=b-evaluate-at-1.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/abs-horner.js
const abs_horner_abs = Math.abs;
/**
 * Returns the result of evaluating a univariate polynomial using
 * Horner's method and where the absolute value of each coefficient is taken.
 *
 * * intermediate calculations are done in double precision
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which `p` should be evaluated
 *
 * @doc
 */
function AbsHorner(p, x) {
    let q = 0;
    for (let i = 0; i < p.length; i++) {
        q = q * x + abs_horner_abs(p[i]);
    }
    return q;
}
// inlined (with q => e2, p => p0)
//let e2 = abs(p0[0]); for (let i=1; i<p0.length; i++) { e2 = e2*x + abs(p0[i]); }

//# sourceMappingURL=abs-horner.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/horner-sum.js
/**
 * * helper function
 *
 * @param p1
 * @param p2
 *
 * @internal
 */
function HornerSum(p1, p2, a) {
    let result = 0;
    for (let i = 0; i < p1.length; i++) {
        result = p1[i] + p2[i] + result * a;
    }
    return result;
}

//# sourceMappingURL=horner-sum.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/comp-horner.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const comp_horner_EFTHorner = EFTHorner;
const comp_horner_HornerSum = HornerSum;
/**
 * Returns a result of evaluating a univariate polynomial using once compensated
 * Horner's method.
 *
 * * once compensated means the error in the evaluation is reduced by roughly
 * `1 / Number.EPSILON` which is again roughly `2^53` - it is equivalent as using
 * double-double precision in a normal Horner evaluation
 *
 * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)
 * * see [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)
 * * see [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 *
 * @doc
 */
function compHorner(p, x) {
    const { r̂, pπ, pσ } = comp_horner_EFTHorner(p, x);
    const ĉ = comp_horner_HornerSum(pπ, pσ, x);
    return r̂ + ĉ;
}

//# sourceMappingURL=comp-horner.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/horner-abs-sum.js
/**
 * @param p1
 * @param p2
 *
 * @internal
 */
function HornerAbsSum(p1, p2, x) {
    let q = 0;
    for (let i = 0; i < p1.length; i++) {
        // TODO - Math.abs(p1[i] + p2[i]) <-- should this be Math.abs(p1[i]) + Math.abs(p2[i]) ??
        q = Math.abs(p1[i] + p2[i]) + q * x;
    }
    return q;
}

//# sourceMappingURL=horner-abs-sum.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/gammas.js
const gammas_u = Number.EPSILON / 2;
// cache standard error bound units
const _γs = [];
/** @internal */
function γs(n) {
    return _γs[n] || ((1 + gammas_u) * (n * gammas_u / (1 - n * gammas_u)));
}

//# sourceMappingURL=gammas.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/comp-horner-is-faithful.js





// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const comp_horner_is_faithful_twoSum = two_sum_twoSum;
const comp_horner_is_faithful_HornerSum = HornerSum;
const comp_horner_is_faithful_EFTHorner = EFTHorner;
const comp_horner_is_faithful_HornerAbsSum = HornerAbsSum;
const comp_horner_is_faithful_s = γs;
const comp_horner_is_faithful_u = Number.EPSILON;
/**
 * Returns the result of evaluating a univariate polynomial using once compensated
 * Horner's method, including a dynamic check for faithfull rounding and a
 * certified running error bound.
 *
 * * once compensated means the error in the evaluation is reduced by roughly
 * `1 / Number.EPSILON` which is again roughly `2^53` - it is the same as using
 * double-double precision in a normal Horner evaluation
 *
 * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)
 * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)
 * * see also [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 *
 * @doc
 */
function compHornerIsFaithful(p, x) {
    const n = p.length - 1;
    const { r̂, pπ, pσ } = comp_horner_is_faithful_EFTHorner(p, x);
    const ĉ = comp_horner_is_faithful_HornerSum(pπ, pσ, x);
    const [e, r̄] = comp_horner_is_faithful_twoSum(r̂, ĉ);
    const b̂ = comp_horner_is_faithful_HornerAbsSum(pπ, pσ, Math.abs(x));
    const α̂ = (comp_horner_is_faithful_s(2 * n - 1) * b̂) / ((1 - 2 * (n + 1) * comp_horner_is_faithful_u));
    const β̂ = (α̂ + Math.abs(e)) / (1 - 2 * comp_horner_is_faithful_u);
    return {
        isFaithful: α̂ < (comp_horner_is_faithful_u / 2) * Math.abs(r̄),
        errBound: β̂,
        r̄
    };
}

//# sourceMappingURL=comp-horner-is-faithful.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/comp-horner-with-running-error.js





// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const comp_horner_with_running_error_twoSum = two_sum_twoSum;
const comp_horner_with_running_error_EFTHorner = EFTHorner;
const comp_horner_with_running_error_HornerSum = HornerSum;
const comp_horner_with_running_error_HornerAbsSum = HornerAbsSum;
const comp_horner_with_running_error_s = γs;
const comp_horner_with_running_error_u = Number.EPSILON / 2;
/**
 * Returns the result of evaluating a univariate polynomial using once compensated
 * Horner's method, including a certified running error bound as an array in the
 * form: [result, absolute error].
 *
 * * Exactly the same as compHornerIsFaithful, except that it does not include
 * a faithfully rounded check.
 *
 * * once compensated means the error in the evaluation is reduced by roughly
 * `1 / Number.EPSILON` which is again roughly `2^53` - it is the same as using
 * double-double precision in a normal Horner evaluation
 *
 * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)
 * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)
 * * see also [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 *
 * @doc
 */
function compHornerWithRunningError(p, x) {
    const n = p.length - 1;
    const { r̂, pπ, pσ } = comp_horner_with_running_error_EFTHorner(p, x);
    // inlined
    //const pπ: number[] = []; const pσ: number[] = []; const σ: number; const r̂ = p[0];	for (const i=1; i<p.length; i++) { const [π,pi] = twoProduct(r̂,x); [σ,r̂] = twoSum(pi, p[i]); pπ.push(π); pσ.push(σ); }
    const ĉ = comp_horner_with_running_error_HornerSum(pπ, pσ, x);
    const [e, r̄] = comp_horner_with_running_error_twoSum(r̂, ĉ);
    const b̂ = comp_horner_with_running_error_HornerAbsSum(pπ, pσ, Math.abs(x));
    const α̂ = (comp_horner_with_running_error_s(2 * n - 1) * b̂) / ((1 - 2 * (n + 1) * comp_horner_with_running_error_u));
    const β̂ = (α̂ + Math.abs(e)) / (1 - 2 * comp_horner_with_running_error_u);
    return [r̄, β̂];
}

//# sourceMappingURL=comp-horner-with-running-error.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/horner-with-running-error.js
const horner_with_running_error_abs = Math.abs;
const horner_with_running_error_u = Number.EPSILON / 2;
/**
 * Returns the result of evaluating a polyniomial at a point x, including a
 * running error bound as an array in the form `[r,e]` where `r` is the result
 * of the evaluation and `e` is the error.
 *
 * * see e.g. page 95 (at bottom) of [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 *
 * @doc
 */
function hornerWithRunningError(p, x) {
    let r̂ = p[0];
    let e = horner_with_running_error_abs(r̂) * 0.5;
    for (let i = 1; i < p.length; i++) {
        r̂ = r̂ * x + p[i];
        e = e * horner_with_running_error_abs(x) + horner_with_running_error_abs(r̂);
    }
    e = horner_with_running_error_u * (2 * e - horner_with_running_error_abs(r̂));
    return [r̂, e];
}
// inlined (where r̂ => r, e => e1, p => p0)
//let r = p0[0]; let e1 = Math.abs(r) / 2; for (let i=1; i<p0.length; i++) { r = r*x + p0[i]; e1 = Math.abs(x)*e1 + Math.abs(r); } e1 = Number.EPSILON * (2*e1 - Math.abs(r));

//# sourceMappingURL=horner-with-running-error.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/eval-certified.js





// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const eval_certified_ = γ;
const eval_certified_EFTHorner = EFTHorner;
const eval_certified_hornerWithRunningError = hornerWithRunningError;
const eval_certified_Horner = Horner;
const eval_certified_AbsHorner = AbsHorner;
const γ1 = eval_certified_(1);
const γ2 = eval_certified_(2);
/**
 * Returns the result of evaluating the given polynomial (with specified
 * coefficient-wise error bounds) at x such that the sign is correct when
 * positive or negative and undecided when 0 - an additional `multiplier`
 * parameter can enforce additional bits (beyond the sign) to be correct.
 *
 * * designed to be fast in 'easy' cases (say condition number < 2^53) and
 * harder cases (condition number < 2^106) since nearly all typical
 * calculations will have condition number < 2^106
 * * a staggered approach is used - first double precision, then simulated
 * double-double precision (i.e. once compensated Horner evluation) is tried
 * before giving up and returning 0 - see point below
 * * if zero is returned then the calculated result is too close to 0 to
 * determine the sign; the caller of this function can then resort to a more
 * accurate (possibly exact) evaluation
 *
 * @param p an array of 2 polynomials with coefficients given densely as an
 * array of double precision floating point numbers from highest to
 * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`;
 * the first polynomial's coefficients represent the 'high part' (a double) of a
 * double-double precision value, while the second polynomial's coefficients
 * represent the 'low part', i.e. designating `hp` for high part and `lp` for
 * low part it must be that they are non-overlapping -> `twoSum(lp,hp)` will
 * equal `[lp,hp]`; put another way, if the given polynomial is given as e.g. a
 * linear polynomial with coefficients in double precision,
 * e.g. `[[1.7053025658242404e-13, 2354.33721613], [-7.105427357601002e-15,284.5673337]]`
 * then this parameter, `p`, should be `[[2354.33721613], 284.5673337], [1.7053025658242404e-13, -7.105427357601002e-15]]`
 * which is simply the result of transposing the original polynomial if it is
 * seen as a matrix
 * @param pE defaults to `undefined`; an error polynomial that provides a
 * coefficient-wise error bound on the input polynomial; all coefficients must
 * be positive; if `undefined` then the input polynomial will be assumed exact
 * @param x the value at which to evaluate the polynomial
 * @param multiplier defaults to 1; the final calculation error needs to be a
 * multiple of this number smaller than the evaluated value, otherwise zero is
 * returned - useful if not only the sign is important but also some bits, e.g.
 * if multiplier = 8 then 3 bits will have to be correct otherwise 0 is returned
 *
 * @doc
 */
function evalCertified(p, x, pE = undefined, multiplier = 1) {
    const absX = Math.abs(x);
    const p0 = p[0];
    // first do a fast evaluation
    const [r, e1] = eval_certified_hornerWithRunningError(p0, x);
    // inlined above line:
    //const r = p0[0]; const e1 = Math.abs(r) / 2; for (const i=1; i<p0.length; i++) { r = r*x + p0[i]; e1 = Math.abs(x)*e1 + Math.abs(r); } e1 = Number.EPSILON * (2*e1 - Math.abs(r));
    /** the error due to not considering p[1] */
    // the line below was changed due to negative values of x now also allowed
    const e2 = γ2 * eval_certified_AbsHorner(p0, absX);
    // inlined above line:
    //const e2 = abs(p0[0]); for (const i=1; i<p0.length; i++) { e2 = e2*x + abs(p0[i]); }
    /** error due to imprecision in coefficients */
    // the line below was changed due to negative values of x now also allowed
    const E = pE !== undefined ? eval_certified_Horner(pE, absX) : 0;
    //const E = p0[0]; for (const i=1; i<p0.length; i++) {E = E*x + p0[i]; }
    const ee = e1 + e2 + E; // in difficult cases E can be larger than e1+e2
    if (ee * multiplier < Math.abs(r)) {
        // we are within bounds
        return r;
    }
    // error is too large - do a more precise evaluation (i.e. once compensated
    // with K === 2)
    let { r̂, pπ, pσ } = eval_certified_EFTHorner(p0, x);
    const [C1, c1] = eval_certified_hornerWithRunningError(pπ, x);
    const [C2, c2] = eval_certified_hornerWithRunningError(pσ, x);
    const [C3, c3] = eval_certified_hornerWithRunningError(p[1], x);
    // typically: c1,c2 < c3 < E
    let e = (c1 + c2 + c3) + E;
    // typically: C1,C2 < C3 < r̂ and (C1 + C2 + C3 < r̂)
    r̂ = (C1 + C2 + C3) + r̂;
    e += γ1 * r̂;
    if (e * multiplier < Math.abs(r̂)) {
        return r̂;
    }
    // error is still too large to return the correct sign (if multiplier === 1)
    return 0;
}

//# sourceMappingURL=eval-certified.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/eval-certified-incl-error.js





// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const eval_certified_incl_error_ = γ;
const eval_certified_incl_error_EFTHorner = EFTHorner;
const eval_certified_incl_error_hornerWithRunningError = hornerWithRunningError;
const eval_certified_incl_error_Horner = Horner;
const eval_certified_incl_error_AbsHorner = AbsHorner;
const eval_certified_incl_error_1 = eval_certified_incl_error_(1);
const eval_certified_incl_error_2 = eval_certified_incl_error_(2);
/**
 * Returns the result of evaluating the given polynomial (with specified
 * coefficient-wise error bounds) at `x` such that the sign is correct when
 * positive or negative and undecided when 0 - an additional `multiplier`
 * parameter can enforce additional bits (beyond the sign bit) to be correct.
 *
 * * designed to be fast in 'easy' cases (say condition number < 2^53) and
 * harder cases (condition number < 2^106) since nearly all typical
 * calculations will have condition number < 2^106
 * * a staggered approach is used - first double precision, then simulated
 * double-double precision (i.e. once compensated Horner evluation) is tried
 * before giving up and returning 0 - see point below
 * * if zero is returned then the calculated result is too close to 0 to
 * determine the sign; the caller of this function can then resort to a more
 * accurate (possibly exact) evaluation
 *
 * @param p an array of 2 polynomials with coefficients given densely as an
 * array of double precision floating point numbers from highest to
 * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`;
 * the first polynomial's coefficients represent the 'high part' (a double) of a
 * double-double precision value, while the second polynomial's coefficients
 * represent the 'low part', i.e. designating `hp` for high part and `lp` for
 * low part it must be that they are non-overlapping -> `twoSum(lp,hp)` will
 * equal `[lp,hp]`; put another way, if the given polynomial is given as e.g. a
 * linear polynomial with coefficients in double precision,
 * e.g. `[[1.7053025658242404e-13, 2354.33721613], [-7.105427357601002e-15,284.5673337]]`
 * then this parameter, `p`, should be `[[2354.33721613], 284.5673337], [1.7053025658242404e-13, -7.105427357601002e-15]]`
 * which is simply the result of transposing the original polynomial if it is
 * seen as a matrix
 * @param pE defaults to `undefined`; an error polynomial that provides a
 * coefficient-wise error bound on the input polynomial; all coefficients must
 * be positive; if `undefined` then the input polynomial will be assumed exact
 * @param x the value at which to evaluate the polynomial
 * @param multiplier defaults to 1; the final calculation error needs to be a
 * multiple of this number smaller than the evaluated value, otherwise zero is
 * returned - useful if not only the sign is important but also some bits, e.g.
 * if multiplier = 8 then 3 bits will have to be correct otherwise 0 is returned
 *
 * @doc
 */
function evalCertifiedInclError(p, x, pE = undefined, multiplier = 1) {
    const absX = Math.abs(x);
    // first do a fast evaluation
    const [r, e1] = eval_certified_incl_error_hornerWithRunningError(p[0], x);
    // the line below was changed due to negative values of x now also allowed
    const e2 = eval_certified_incl_error_2 * eval_certified_incl_error_AbsHorner(p[0], absX); // the error due to not considering p[1]
    // error due to imprecision in coefficients
    // the line below was changed due to negative values of x now also allowed
    //const E = pE ? Horner(pE, x) : 0; 
    const E = pE !== undefined
        ? eval_certified_incl_error_Horner(pE, absX)
        : 0;
    const ee = e1 + e2 + E; // in difficult cases E can be larger than e1+e2
    if (ee * multiplier < Math.abs(r)) {
        // we are within bounds
        return { r̂: r, e: ee };
    }
    // error is too large - do a more precise evaluation
    let { r̂, pπ, pσ } = eval_certified_incl_error_EFTHorner(p[0], x);
    const [C1, c1] = eval_certified_incl_error_hornerWithRunningError(pπ, x);
    const [C2, c2] = eval_certified_incl_error_hornerWithRunningError(pσ, x);
    const [C3, c3] = eval_certified_incl_error_hornerWithRunningError(p[1], x);
    let e = (c1 + c2 + c3) + E; // typically: c1,c2 < c3 < E
    r̂ = (C1 + C2 + C3) + r̂; // typically: C1,C2 < C3 < r̂ and (C1 + C2 + C3 < r̂)
    e += eval_certified_incl_error_1 * r̂;
    if (e * multiplier < Math.abs(r̂)) {
        return { r̂, e };
    }
    // error is still too large to return the correct sign (if multiplier === 1)
    return { r̂: 0, e };
}

//# sourceMappingURL=eval-certified-incl-error.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/eval-k.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const eval_k_hornerWithRunningError = hornerWithRunningError;
const eval_k_CompHornerK = CompHornerK;
const eval_k_compHornerWithRunningError = compHornerWithRunningError;
/**
 * Returns the result of evaluating the given polynomial at `x` such that at least
 * the sign bit is correct *up to 3-times compensated evaluation (K = 4)*, i.e.
 * as if evaluating in double-double-double-double precision.
 *
 * * uses a staggered algorithm, first trying in double precision, then in
 * double-double and finally in double-double-double-double
 *
 * * see [Algorithms for Accurate, Validated and Fast Polynomial Evaluation, *Stef Graillat, Philippe Langlois and Nicolas Louvet*](https://projecteuclid.org/download/pdf_1/euclid.jjiam/1265033778)
 * * see also [*Philippe Langlois, Nicolas Louvet.* Faithful Polynomial Evaluation with Compensated Horner Algorithm. ARITH18: 18th IEEE International Symposium on Computer Arithmetic, Jun 2007, Montpellier, France. pp.141–149. ffhal-00107222f](https://hal.archives-ouvertes.fr/hal-00107222/document)
 * * see also [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 *
 * @doc
 */
function evalK(p, x) {
    const [r̂, e] = eval_k_hornerWithRunningError(p, x);
    // inlined 
    //const r̂ = p[0]; const e = Math.abs(r̂) / 2; for (const i=1; i<p.length; i++) { r̂ = r̂*x + p[i]; e = Math.abs(x)*e + Math.abs(r̂); } e = Number.EPSILON * (2*e - Math.abs(r̂));
    if (Math.abs(r̂) - e < 0) {
        return evalK2(p, x);
        // inlined
        //[r̂, e] = compHornerWithRunningError(p, x); if (Math.abs(r̂) - e < 0) { return evalK4(p, x); } return { r̂, level: 2 }
    }
    return r̂;
}
function evalK2(p, x) {
    const [r̂, e] = eval_k_compHornerWithRunningError(p, x);
    if (Math.abs(r̂) - e < 0) {
        return evalK4(p, x);
    }
    return r̂;
}
// inlined
//[r̂, e] = compHornerWithRunningError(p, x); if (Math.abs(r̂) - e < 0) { return evalK4(p, x); } return { r̂, level: 2 }
function evalK4(p, x) {
    const r̂ = eval_k_CompHornerK(p, x, 4);
    return r̂;
}

//# sourceMappingURL=eval-k.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/evaluate-at-0.js
/**
 * Returns the constant term of the given polynomial.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * evaluateAt0([3,2,99]); //=> 99
 * ```
 *
 * @doc
 */
function evaluateAt0(p) {
    return p.length === 0 ? 0 : p[p.length - 1];
}

//# sourceMappingURL=evaluate-at-0.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/double/evaluate-at-1.js
/**
 * Returns the result of evaluating the given polynomial at 1 using double
 * precision for intermediate calculations.
 *
 * * faster than at an arbitrary point.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function evaluateAt1(p) {
    let res = 0;
    for (let i = 0; i < p.length; i++) {
        res += p[i];
    }
    return res;
}

//# sourceMappingURL=evaluate-at-1.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/expansion/e-e-horner.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_e_horner_fastExpansionSum = fastExpansionSum;
const e_e_horner_expansionProduct = expansion_product_expansionProduct;
/**
 * Returns the exact result (bar underflow / overflow) of evaluating a
 * univariate polynomial at a point given as a Shewchuk expansion using
 * Horner's method - the result is returned as a Shewchuk expansion.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 *
 * @doc
 */
function eeHorner(p, x) {
    let result = [0];
    for (let i = 0; i < p.length; i++) {
        result = e_e_horner_fastExpansionSum(p[i], e_e_horner_expansionProduct(result, x));
    }
    return result;
}

//# sourceMappingURL=e-e-horner.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/expansion/e-evaluate-at-0.js
/**
 * Returns the constant term of the given polynomial.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * evaluateAt0([[3],[2],[99]]); //=> [99]
 * ```
 *
 * @doc
 */
function eEvaluateAt0(p) {
    return p.length === 0 ? [0] : p[p.length - 1];
}

//# sourceMappingURL=e-evaluate-at-0.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/expansion/e-evaluate-at-1.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_evaluate_at_1_fastExpansionSum = fastExpansionSum;
/**
 * Returns the exact result (bar underflow / overflow) of evaluating the given
 * polynomial at 1.
 *
 * * faster than at an arbitrary point.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function eEvaluateAt1(p) {
    let res = [0];
    for (let i = 0; i < p.length; i++) {
        res = e_evaluate_at_1_fastExpansionSum(res, p[i]);
    }
    return res;
}

//# sourceMappingURL=e-evaluate-at-1.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/evaluate/expansion/e-horner.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const fes = fastExpansionSum;
const sce = scaleExpansion;
/**
 * Returns the exact result (bar underflow / overflow) of evaluating a
 * univariate polynomial using Horner's method - the result is returned as a
 * Shewchuk expansion.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 * @param x the value at which to evaluate the polynomial
 *
 * @doc
 */
function eHorner(p, x) {
    let q = [0];
    for (let i = 0; i < p.length; i++) {
        q = fes(p[i], sce(q, x));
    }
    return q;
}

//# sourceMappingURL=e-horner.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/factor/double/content.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const content_gcdInts = gcdInts;
/**
 * Returns cont(p), i.e. the content of the given polynomial defined as the
 * greatest common divisor of its coefficients.
 *
 * * the sign is chosen such that dividing the polynomial by cont(p) will
 * always result in a positive leading coefficient
 *
 * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)
 *
 * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the
 * content of `p` and `2x² - x - 1` is its primitive part.
 *
 * * **precondition** p must have integer coefficients, else use e.g. [[scaleFloatsToInts]]
 *
 * @param p a polynomial with coefficients given densely as an array of
 * double precision floating point numbers from highest to lowest power, e.g.
 * `[5,-3,0]` represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function content(p) {
    if (p.length === 0) {
        // the zero polynomial
        return 1;
    }
    return Math.sign(p[0]) * content_gcdInts(p);
}

//# sourceMappingURL=content.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/factor/double/primitive-part.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const getContent = content;
/**
 * Returns the primitive part of the given polynomial.
 *
 * * the sign is chosen such that the leading term coefficient is positive
 *
 * * see e.g. [Factorization of polynomials](https://en.wikipedia.org/wiki/Factorization_of_polynomials)
 *
 * * example: let `p = -10x² + 5x + 5 = (-5)(2x² - x - 1)` so that `-5` is the
 * content of `p` and `2x² - x - 1` is its primitive part.
 *
 * * **precondition** p must have integer coefficients, else use e.g. [[scaleFloatsToInts]]
 *
 * @param p a polynomial with coefficients given densely as an array of
 * double precision floating point numbers from highest to lowest power, e.g.
 * `[5,-3,0]` represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function primitivePart(p) {
    const c = getContent(p);
    const p_ = [];
    for (let i = 0; i < p.length; i++) {
        p_.push(p[i] / c);
    }
    return p_;
}

//# sourceMappingURL=primitive-part.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/gcd/bigint/b-gcd-prs.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_gcd_prs_bPremSequenceSubresultant = bPremSequenceSubresultant;
/**
 * :::tip Heads up!
 * Use the modular gcd algorithm, [[gcdModular]] (still to be implemented 😢), instead - it is faster.
 * :::
 *
 * Returns the GCD (Greatest Common Divisor) of the two given polynomials using
 * Pseudo Remainder Sequences (PRSs) (bar overflow). The returned GCD is a
 * polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`.
 *
 * @param a a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 * @param b another polynomial
 *
 * @doc
 */
function bGcdPrs(a, b) {
    if (a.length === 0) {
        return b;
    }
    else if (b.length === 0) {
        return a;
    }
    const seq = b_gcd_prs_bPremSequenceSubresultant(a, b, false);
    return seq[seq.length - 1];
}

//# sourceMappingURL=b-gcd-prs.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/norm/bigint/b-p-1-norm.js
/**
 * Returns the `p-1 norm`, a.k.a. `Taxicab norm`, i.e. the sum of the absolute
 * values of the given array of bigints.
 *
 * * if the array of bigints represent polynomial coefficients then the p-1
 * norm is known as the `length` of the polynomial
 *
 * @param p an array of bigints
 *
 * @doc
 */
function bP1Norm(p) {
    let s = 0n;
    for (let i = 0; i < p.length; i++) {
        const n = p[i];
        s += n < 0n ? -n : n;
    }
    return s;
}

//# sourceMappingURL=b-p-1-norm.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/norm/bigint/b-p-2-norm-squared.js
/**
 * Returns the `p-2 norm` squared, i.e. the square of the `Euclidean norm` of
 * the given array of bigints.
 *
 * @param p an array of bigints; can represent an array of polynomial
 * coefficients
 *
 * @doc
 */
function bP2NormSquared(p) {
    let s = 0n;
    for (let i = 0; i < p.length; i++) {
        s += p[i] ** 2n;
    }
    return s;
}

//# sourceMappingURL=b-p-2-norm-squared.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/norm/bigint/b-p-inf-norm.js
/**
 * Returns the `p-infinity norm`, i.e. the maximum magnitude absolute value
 * within the given array of bigints / coefficients.
 *
 * @param p an array of bigints; can represent an array of polynomial
 * coefficients
 *
 * @doc
 */
function bPInfNorm(p) {
    let max = 0n;
    for (let i = 0; i < p.length; i++) {
        let v = p[i];
        v = v < 0n ? -v : v;
        if (v > max) {
            max = v;
        }
    }
    return max;
}

//# sourceMappingURL=b-p-inf-norm.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/norm/double/p-1-norm.js
/**
 * Returns the `p-1 norm`, a.k.a. `Taxicab norm`, i.e. the sum of the absolute
 * values of the given array of numbers (with intermediate calculations done
 * in double precision).
 *
 * * if the array of numbers represent polynomial coefficients then the p-1
 * norm is known as the `length` of the polynomial
 *
 * @param p an array of numbers
 *
 * @doc
 */
function p1Norm(p) {
    let s = 0;
    for (let i = 0; i < p.length; i++) {
        s += Math.abs(p[i]);
    }
    return s;
}

//# sourceMappingURL=p-1-norm.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/norm/double/p-2-norm.js
/**
 * Returns the `p-2 norm`, i.e. `Euclidean norm` of the given array of numbers
 * (with intermediate calculations done in double precision).
 *
 * @param p an array of numbers; can represent an array of polynomial
 * coefficients
 *
 * @doc
 */
function p2Norm(p) {
    let s = 0;
    for (let i = 0; i < p.length; i++) {
        s += p[i] ** 2;
    }
    return Math.sqrt(s);
}

//# sourceMappingURL=p-2-norm.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/norm/double/p-inf-norm.js
/**
 * Returns the `p-infinity norm`, i.e. the maximum magnitude absolute value
 * within the given array of numbers / coefficients (with intermediate
 * calculations done in double precision).
 *
 * @param p an array of numbers; can represent an array of polynomial
 * coefficients
 *
 * @doc
 */
function pInfNorm(p) {
    let max = 0;
    for (let i = 0; i < p.length; i++) {
        const v = Math.abs(p[i]);
        if (v > max) {
            max = v;
        }
    }
    return max;
}

//# sourceMappingURL=p-inf-norm.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/norm/expansion/e-p-1-norm.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_p_1_norm_eEstimate = e_estimate_eEstimate;
/**
 * Returns the `p-1 norm`, a.k.a. `Taxicab norm`, i.e. the sum of the absolute
 * values of the given array of Shewchuk expansions (with intermediate
 * calculations (and the final result) done in double precision).
 *
 * * if the array of expansions represent polynomial coefficients then the p-1
 * norm is known as the `length` of the polynomial
 *
 * @param p an array of Shewchuk expansions
 *
 * @doc
 */
function eP1Norm(p) {
    let s = 0;
    for (let i = 0; i < p.length; i++) {
        s += Math.abs(e_p_1_norm_eEstimate(p[i]));
    }
    return s;
}

//# sourceMappingURL=e-p-1-norm.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/norm/expansion/e-p-2-norm.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_p_2_norm_eEstimate = e_estimate_eEstimate;
/**
 * Returns the `p-2 norm`, i.e. `Euclidean norm` of the given array of Shewchuk
 * expansions (with intermediate calculations (and the final result) done in
 * double precision).
 *
 * @param p an array of Shewchuk expansions; can represent an array of polynomial
 * coefficients
 *
 * @doc
 */
function eP2Norm(p) {
    let s = 0;
    for (let i = 0; i < p.length; i++) {
        s += e_p_2_norm_eEstimate(p[i]) ** 2;
    }
    return Math.sqrt(s);
}

//# sourceMappingURL=e-p-2-norm.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/norm/expansion/e-p-inf-norm.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_p_inf_norm_eEstimate = e_estimate_eEstimate;
/**
 * Returns the `p-infinity norm`, i.e. the maximum magnitude absolute value
 * within the given array of numbers / coefficients (with intermediate
 * calculations (and the final result) done in double precision).
 *
 * @param p an array of numbers; can represent an array of polynomial
 * coefficients
 *
 * @doc
 */
function ePInfNorm(p) {
    let max = 0;
    for (let i = 0; i < p.length; i++) {
        const v = Math.abs(e_p_inf_norm_eEstimate(p[i]));
        if (v > max) {
            max = v;
        }
    }
    return max;
}

//# sourceMappingURL=e-p-inf-norm.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/from-roots/double/from-roots.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const from_roots_multiply = multiply;
/**
 * Constructs a polynomial from the given roots by multiplying out the
 * factors (x - root1)(x - root2) in double precision
 *
 * * the resulting polynomial may have complex roots close to zero due to
 * round-off caused by working in double precision.
 *
 * * mostly for testing purposes.
 *
 * * the real roots of the constructed polynomial is unlikely to be exactly
 * the same as the roots that the polynomial has been constructed from due to
 * floating-point round-off.
 *
 * @param roots an array of roots
 *
 * @example
 * ```typescript
 * fromRoots([1,2,3,3]); //=> [1, -9, 29, -39, 18]
 * allRoots([1, -9, 29, -39, 18]); //=> [1.0000000000000007, 2.000000000000004]
 *
 * // In the above note the rounding error. Also note the multiple root of 3 that has been missed.
 * allRoots([1, -9, 29, -39, 17.99999999999999]); //=> [0.9999999999999973, 2.00000000000002, 2.9999999999999982]
 * allRoots([1, -9, 29, -39, 17.9999999999999]); //=> [0.999999999999975, 2.0000000000000986, 2.9999997898930832, 3.0000002095475775]
 * ```
 *
 * @doc
 */
function fromRoots(roots) {
    let p = [1];
    for (let i = 0; i < roots.length; i++) {
        p = from_roots_multiply(p, [1, -roots[i]]);
    }
    return p;
}

//# sourceMappingURL=from-roots.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/predictive-random/double/random.js

/**
 * Arbitrary seed value for the simple random number generator.
 *
 * @internal
 */
const SEED = 123456789;
/**
 * The range for the simple random number generator, i.e. the generated
 * numbers will be in [0,RANGE].
 *
 * @internal
 */
const RANGE = 4294967296;
/**
 * Creates a function from the given function with parameters similar
 * to flatRoots but with an extra parameter in the beginning indicating
 * the length of the array generated by the original function.
 *
 * @param f
 *
 * @internal
 */
function createArrFunction(f) {
    return function (n, d, a, b, seed = SEED, odds = 0) {
        const res = [];
        for (let i = 0; i < n; i++) {
            const v = f(d, a, b, seed, odds);
            const p = v.p;
            seed = v.seed;
            res.push(p);
        }
        return res;
    };
}
/**
 * Generates and returns an array of polynomials with random **roots** (with coefficients
 * given densely as an array of double floating point numbers from highest to
 * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).
 *
 * * all roots will approximate real values so is not at all representative of
 * a natural random root distribution
 *
 * * the exact same polynomials will be created on each call to this function
 * if the same seed is used; this is by design to improve testing.
 *
 * @param n the number of polynomials to generate.
 * @param d the degree of the polynomials
 * @param a defaults to 0; the lower bound of the coefficients
 * @param b defaults to 1; the upper bound of the coefficients
 * @param seed defaults to 123456789; a seed value in [0,4294967296]
 * @param odds defaults to 0; the odds that a root will be doubled (applied
 * recursively so that some roots could be tripled, etc.
 *
 * @example
 * ```typescript
 * flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]
 * flatRootsArr(2,3,0,10); //=> [[1, -17.27247918024659, 97.33487287168995, -179.34094494147305], [1, -14.934967160224915, 57.624514485645406, -14.513933300587215]]
 * ```
 *
 * @doc
 */
const flatRootsArr = createArrFunction(flatRoots);
/**
 * Generates and returns an array of polynomials with random **coefficients** (with coefficients
 * given densely as an array of double floating point numbers from highest to
 * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).
 *
 * * the exact same polynomials will be created on each call to this function
 * if the same seed is used; this is by design to improve testing.
 *
 * @param n the number of polynomials to generate.
 * @param d the length of the polynomial coefficients array
 * @param a defaults to 0; the lower bound of the coefficients
 * @param b defaults to 1; the upper bound of the coefficients
 * @param seed defaults to 123456789; a seed value in [0,4294967296]
 * @param odds defaults to 0; the odds that a root will be doubled (applied
 * recursively so that some roots could be tripled, etc.
 *
 * @example
 * ```typescript
 * flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]
 * flatCoefficientsArr(2,3,-2,2); //=> [[0.1749166026711464, -0.20349335670471191, 0.9375684261322021], [1.0617692470550537, -1.8918039798736572, 0.8040215969085693]]
 * ```
 *
 * @doc
 */
const flatCoefficientsArr = createArrFunction(flatCoefficients);
/**
 * Returns a quasi-random number to be used as the next input to this function.
 *
 * * see [stackoverflow](https://stackoverflow.com/questions/3062746/special-simple-random-number-generator)
 *
 * @param seed
 *
 * @internal
 */
function predictiveRandom(seed) {
    const a = 134775813;
    return (a * seed + 1) % RANGE;
}
/**
 * Generates a random array of numbers picked from a bounded flat
 * distribution (i.e. a rectangular distribution) with specified odds of
 * duplication of consecutive values.
 *
 * @param n the number of values to generate
 * @param a defaults to 0; the lower bound of the distribution
 * @param b defaults to 1; the upper bound of the distribution
 * @param seed defaults to 123456789; a seed
 * @param odds defaults to 0; the odds that a number will be doubled (applied
 * recursively so that some numbers will be tripled, etc.
 *
 * @internal
 */
function randomArray(n, a, b, seed, odds = 0) {
    let vs = [];
    for (let i = 0; i < n; i++) {
        seed = predictiveRandom(seed);
        const v = ((seed / RANGE) * (b - a)) + a;
        seed = push(seed, vs, v, odds);
    }
    vs = vs.slice(0, n);
    return { vs, seed };
}
/**
 * Helper function that will add more numbers to the passed array - modifies the
 * values parameter.
 *
 * @param seed
 * @param values an existing array of values - will be modified!
 * @param x the number that will be added (possibly multiple times)
 * @param odds the odds that the number will be added again (recursively).
 *
 * @internal
 */
function push(seed, values, x, odds) {
    seed = predictiveRandom(seed);
    values.push(x);
    if ((seed / RANGE) < odds) {
        seed = push(seed, values, x, odds);
    }
    return seed;
}
/**
 * Generates and returns an array of polynomials with random **roots** (with coefficients
 * given densely as an array of double floating point numbers from highest to
 * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).
 *
 * * also returns a new seed value that can be used as the input to the next
 * call to a predictive random function
 *
 * * all roots will approximate real values so is not at all representative of
 * a natural random root distribution
 *
 * * the exact same polynomial will be created on each call to this function
 * if the same seed is used; this is by design to improve testing.
 *
 * @param d the degree of the polynomials
 * @param a defaults to 0; the lower bound of the coefficients
 * @param b defaults to 1; the upper bound of the coefficients
 * @param seed defaults to 123456789; a seed value in [0,4294967296]
 * @param odds defaults to 0; the odds that a root will be doubled (applied
 * recursively so that some roots could be tripled, etc.
 *
 * @example
 * ```typescript
 * flatRoots(3,0,10); //=> { p: [1, -17.27247918024659, 97.33487287168995, -179.34094494147305], seed: 939629312 }
 * ```
 *
 * @doc
 */
function flatRoots(d, a = 0, b = 1, seed = SEED, odds = 0) {
    const randArr = randomArray(d, a, b, seed, odds);
    seed = randArr.seed;
    const p = fromRoots(randArr.vs);
    return { p, seed };
}
/**
 * Generates and returns an array of polynomials with random **coefficients** (with coefficients
 * given densely as an array of double floating point numbers from highest to
 * lowest power, e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`).
 *
 * * also returns a new seed value that can be used as the input to the next
 * call to a predictive random function
 *
 * * the exact same polynomial will be created on each call to this function
 * if the same seed is used; this is by design to improve testing.
 *
 * @param d the length of the polynomial coefficients array
 * @param a defaults to 0; the lower bound of the coefficients
 * @param b defaults to 1; the upper bound of the coefficients
 * @param seed defaults to 123456789; a seed value in [0,4294967296]
 * @param odds defaults to 0; the odds that a root will be doubled (applied
 * recursively so that some roots could be tripled, etc.
 *
 * @example
 * ```typescript
 * flatCoefficients(3,-5,5); //=> { p: [0.437291506677866, -0.5087333917617798, 2.3439210653305054], seed: 939629312 }
 * ```
 *
 * @doc
 */
function flatCoefficients(d, a = -1, b = +1, seed = SEED) {
    const randArr = randomArray(d, a, b, seed);
    seed = randArr.seed;
    const p = randArr.vs;
    return { p, seed };
}

//# sourceMappingURL=random.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/scale-to-int/scale-floats-to-bigints.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const scale_floats_to_bigints_exponent = exponent;
const scale_floats_to_bigints_bitLength = bitLength;
const b0 = 0n; // so tests are not tripped up - awaiting better support
/**
 * Returns the result of scaling the given array of floats by the *same* power
 * of two such that all floats become bigints.
 *
 * * can be used to scale polynomials
 *
 * @param as an array of double precision floating point numbers
 *
 * @doc
 */
function scaleFloatsToBigints(as) {
    let e = -1024;
    for (let i = 0; i < as.length; i++) {
        const a = as[i];
        if (a === 0) {
            continue;
        }
        const scalePower = -scale_floats_to_bigints_exponent(a) + scale_floats_to_bigints_bitLength(a) - 1;
        if (scalePower > e) {
            e = scalePower;
        }
    }
    // check for the trivial case
    if (e === 0) {
        return as.map(a => BigInt(a));
    }
    if (e > 0) {
        return as.map(a => {
            if (a === 0) {
                return b0;
            }
            const scalePower = -scale_floats_to_bigints_exponent(a) + scale_floats_to_bigints_bitLength(a) - 1;
            // we first scale `a` to an integer without overflow and then
            // convert it to a bigint before multiplying
            return BigInt(a * 2 ** scalePower) * 2n ** BigInt(e - scalePower);
        });
    }
    // overflow / underflow cannot occur
    return as.map(a => BigInt(a * 2 ** e));
}

//# sourceMappingURL=scale-floats-to-bigints.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/predictive-random/bigint/b-random.js


/**
 * Some seed value for the simple random number generator.
 *
 * @internal
 */
const b_random_SEED = 123456789;
/**
 * Generates and returns a polynomial with random **roots** (with coefficients
 * given densely as an array of bigints from highest to
 * lowest power, e.g. `[5n,-3n,0n]` represents the polynomial `5x^2 - 3x`).
 *
 * * all roots will approximate real values so is not at all representative of
 * a natural random root distribution
 *
 * * the exact same polynomial will be created on each call to this function
 * if the same seed is used; this is by design to improve testing.
 *
 * @param d the degree of the polynomials
 * @param a defaults to 0; the lower bound of the coefficients
 * @param b defaults to 1; the upper bound of the coefficients
 * @param seed defaults to 123456789; a seed value in [0,4294967296]
 * @param odds defaults to 0; the odds that a root will be doubled (applied
 * recursively so that some roots could be tripled, etc.
 *
 * @doc
 */
function bFlatRoots(d, a = 0, b = 1, seed = b_random_SEED, odds = 0) {
    const res = flatRoots(d, a, b, seed, odds);
    return { p: scaleFloatsToBigints(res.p), seed: res.seed };
}
/**
 * Generates and returns an array of polynomials with random **roots** (with
 * coefficients given densely as an array of bigints from highest to
 * lowest power, e.g. `[5n,-3n,0n]` represents the polynomial `5x^2 - 3x`).
 *
 * * all roots will approximate real values so is not at all representative of
 * a natural random root distribution
 *
 * * the exact same polynomials will be created on each call to this function
 * if the same seed is used; this is by design to improve testing.
 *
 * @param n the number of polynomials to generate.
 * @param d the degree of the polynomials
 * @param a defaults to 0; the lower bound of the coefficients
 * @param b defaults to 1; the upper bound of the coefficients
 * @param seed defaults to 123456789; a seed value in [0,4294967296]
 * @param odds defaults to 0; the odds that a root will be doubled (applied
 * recursively so that some roots could be tripled, etc.
 *
 * @doc
 */
function bFlatRootsArr(n, d, a = 0, b = 1, seed = b_random_SEED, odds = 0) {
    return flatRootsArr(n, d, a, b, seed, odds).map(scaleFloatsToBigints);
}
/**
 * Generates and returns a polynomial with random **coefficients**
 * (with coefficients given densely as an array of bigints from highest to
 * lowest power, e.g. `[5n,-3n,0n]` represents the polynomial `5x^2 - 3x`).
 *
 * * the exact same polynomials will be created on each call to this function
 * if the same seed is used; this is by design to improve testing.
 *
 * @param d the length of the polynomial coefficients array
 * @param a defaults to 0; the lower bound of the coefficients
 * @param b defaults to 1; the upper bound of the coefficients
 * @param seed defaults to 123456789; a seed value in [0,4294967296]
 * @param odds defaults to 0; the odds that a root will be doubled (applied
 * recursively so that some roots could be tripled, etc.
 *
 * @doc
 */
function bFlatCoefficients(d, a = 0, b = 1, seed = b_random_SEED) {
    const res = flatCoefficients(d, a, b, seed);
    return { p: scaleFloatsToBigints(res.p), seed: res.seed };
}
/**
 * Generates and returns an array of polynomials with random **coefficients**
 * (with coefficients given densely as an array of bigints from highest to
 * lowest power, e.g. `[5n,-3n,0n]` represents the polynomial `5x^2 - 3x`).
 *
 * * the exact same polynomials will be created on each call to this function
 * if the same seed is used; this is by design to improve testing.
 *
 * @param n the number of polynomials to generate.
 * @param d the length of the polynomial coefficients array
 * @param a defaults to 0; the lower bound of the coefficients
 * @param b defaults to 1; the upper bound of the coefficients
 * @param seed defaults to 123456789; a seed value in [0,4294967296]
 * @param odds defaults to 0; the odds that a root will be doubled (applied
 * recursively so that some roots could be tripled, etc.
 *
 * @doc
 */
function bFlatCoefficientsArr(n, d, a = 0, b = 1, seed = b_random_SEED, odds = 0) {
    return flatCoefficientsArr(n, d, a, b, seed, odds).map(scaleFloatsToBigints);
}

//# sourceMappingURL=b-random.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/certified/transpose-poly.js
/**
 * Transposes the given polynomial (given with multi-precision coefficients)
 * into multiple polynomials with each consecutive polynomial 'adjusting'
 * the prior one to higher precision.
 *
 * @param p
 *
 * @internal
 */
function transposePoly(p) {
    // transpose the polynomial coefficients into multiple polynomials
    const len = p[0].length;
    const p_ = [];
    for (let i = 0; i < len; i++) {
        const _p = [];
        for (let j = 0; j < p.length; j++) {
            _p.push(p[j][len - (i + 1)]); // from highest to lowest
        }
        p_.push(_p);
    }
    return p_;
}

//# sourceMappingURL=transpose-poly.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/certified/eval-adaptive.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const eval_adaptive_evalCertified = evalCertified;
const eval_adaptive_eHorner = eHorner;
const eval_adaptive_eEstimate = e_estimate_eEstimate;
/**
 * Returns the result of evaluating the given polynomial (with double-double
 * precision coefficients) at the given value, where the coefficient-wise error
 * is also given.
 *
 * * **the sign of the returned result is guaranteed to be correct**
 * * the evaluation is done adaptively, i.e. if the evaluation cannot be done
 * accurately enough then an exact precision polynomial is requested
 *
 * @param p a polynomial given as an array with each consecutive element of
 * the array having more accurate coefficients than the previous (by adding
 * consecutive double precision coefficients to prior coefficients)
 * @param pE a coefficientwise error bound
 * @param x the point of evaluation
 * @param psExact an object holding the exact polynomial and all its exact
 * derivatives - this object may be modified!
 * @param getPsExact a function to retrieve the exact polynomial and all its
 * exact derivatives
 * @param diffCount the number of differentiations done up to this point
 *
 * @internal
 */
function evalAdaptive(p, pE, x, getPolyExact) {
    const r = eval_adaptive_evalCertified(p, x, pE, 4);
    if (r !== 0) {
        return r;
    }
    // condition number is too high - request higher precision
    return eval_adaptive_eEstimate(eval_adaptive_eHorner(getPolyExact(), x));
}

//# sourceMappingURL=eval-adaptive.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/certified/refine-certified.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const refine_certified_evalCertified = evalCertified;
const refine_certified_eHorner = eHorner;
const refine_certified_eEstimate = e_estimate_eEstimate;
const refine_certified_eps = Number.EPSILON;
const refine_certified_abs = Math.abs;
const max = Math.max;
/**
 * Returns a refined root given a root bracketed in the interval (a,b) of the
 * given polynomial using Brent's Method - modified slightly to allow for
 * error certified bounds.
 *
 * * near exact implementation of the original Brent Dekker Method (also known
 * as Brent's Method), except that it is specialzed to polynomial evaluation
 *
 * * Brent's Method is an excellent root-refinement choice since:
 *  * guaranteed converge (unlike the Newton and other so-called single-point
 * methods),
 *  * converges in a reasonable number of iterations even for highly contrived
 * functions (unlike Dekker's Method) and
 *  * nearly always converges fast, i.e. super-linearly (unlike the Secant and
 * Regula-Falsi methods).
 * * unfortunately the algorithm given on [Wikipedia](https://en.wikipedia.org/wiki/Brent%27s_method)
 * works but is not precisely Brent's method and runs about 2x or more slower
 * due to it not implementing the critically important 'micro-step' (Aug 2020).
 *
 * * see [Brent (page 47)](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf)
 * * [c++ implementation of Brent's Method](https://people.sc.fsu.edu/~jburkardt/cpp_src/brent/brent.cpp)
 *
 * @param p A polynomial with coefficients given densely as an array of double-double
 * floating point numbers from highest to lowest power, e.g. `[[0,5],[0,-3],[0,0]]`
 * represents the polynomial `5x^2 - 3x`. If `exact` is `true` then this is allowed
 * to be `undefined`.
 * @param pE An error polynomial that provides a coefficientwise error bound on
 * the input polynomial; all coefficients must be positive. If `exact` is `true`
 * then this is allowed to be `undefined`.
 * @param lb the lower limit of the search interval.
 * @param ub the upper limit of the search interval.
 * @param fa the result of evaluating the input polynomial at `a`
 * @param fb the result of evaluating the input polynomial at `b`
 * @param psExact
 * @param getPsExact
 * @param diffCount
 * @param exact set to true if you need to do exact evaluations from the start
 *
 * @internal
 */
function refineCertified(p, pE, lb, ub, fa, fb, getPolyExact, exact) {
    //---- Make local copies of a and b.
    let a = lb;
    let b = ub;
    let c = a;
    let fc = fa;
    let e = b - a;
    let d = e;
    while (true) {
        // update delta
        if (refine_certified_abs(fc) < refine_certified_abs(fb)) {
            a = b;
            b = c;
            c = a;
            fa = fb;
            fb = fc;
            fc = fa;
        }
        // Original c++ code had the line below but with us t === 0 and b is 
        // taken as 1 and 2.0 * macheps is taken as 2*u === Number.EPSILON (eps)
        // or can also be taken as 4*u === 2*Number.EPSILON (2*eps)
        // adaptive tolerance
        //let δ = 2 * eps * max(1,abs(b));
        //let δ = 2 * u * max(1,abs(b));
        let δ;
        const mm = max(refine_certified_abs(a), refine_certified_abs(b));
        if (mm <= 1) {
            δ = refine_certified_eps;
        }
        else {
            // keep δ = eps * a power of 2
            //δ = eps * 2**Math.ceil(Math.log2(Math.ceil(mm)));  // may be faster to get log2 of an integer
            δ = refine_certified_eps * 2 ** Math.ceil(Math.log2(mm));
        }
        //tol = 2.0 * macheps * abs ( b ) + t;
        const m = 0.5 * (c - b);
        //if (abs(m) <= δ || fb === 0) {
        // modified from the original since we dont need the fb === 0 check here
        if (refine_certified_abs(m) <= δ) {
            // TODO - could potentially make b - c a power of 2 here δ
            return b < c ? [b, c] : [c, b];
        }
        if (refine_certified_abs(e) < δ || refine_certified_abs(fa) <= refine_certified_abs(fb)) {
            e = m;
            d = e;
        }
        else {
            let s = fb / fa;
            let p;
            let q;
            if (a === c) {
                p = 2 * m * s;
                q = 1 - s;
            }
            else {
                q = fa / fc;
                const r = fb / fc;
                p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));
                q = (q - 1) * (r - 1) * (s - 1);
            }
            if (0 < p) {
                q = -q;
            }
            else {
                p = -p;
            }
            s = e;
            e = d;
            if (2 * p < 3 * m * q - refine_certified_abs(δ * q) && p < refine_certified_abs(0.5 * s * q)) {
                d = p / q;
            }
            else {
                e = m;
                d = e;
            }
        }
        a = b;
        fa = fb;
        if (δ < refine_certified_abs(d)) {
            b = b + d;
        }
        else if (0 < m) {
            b = b + δ;
        }
        else {
            //b = b - eps;
            b = b - δ;
        }
        fb = exact
            ? refine_certified_eEstimate(refine_certified_eHorner(getPolyExact(), b))
            // keep TypeScript happy; neither `p` nor `pE` can be `undefined` 
            // here by a precondition
            : refine_certified_evalCertified(p, b, pE);
        if (fb === 0) {
            // Since `evalCertified` returns zero if undecided the zero result
            // cannot be fully trusted at this point.
            // if we are already doing exact evaluations this is an exact root
            if (exact) {
                return [b, b];
            }
            // We need to calculate δ/2 to the left and right of b to get 
            // results that should usually be !== 0. 
            // It is a pre-filter. If the result === 0 we need to sharpen the
            // ability of the evaluation by somehow reducing the error bound
            const sL = Math.max(lb, b - δ); // dont overstep bounds
            const sR = Math.min(ub, b + δ); // dont overstep bounds
            // Note: sR - sL <= 2*δ provided lb, ub are in [-1..1] - usually 
            // (when sL === s - δ and sR === s + δ) sR - sL === 2*δ. Also δ > 0
            // keep TypeScript happy; neither `p` nor `pE` can be `undefined` 
            // here by a precondition
            const fsL = refine_certified_evalCertified(p, sL, pE);
            const fsR = refine_certified_evalCertified(p, sR, pE);
            // if the evaluation method is strong enough return the result
            if (fsL * fsR !== 0) {
                return [sL, sR];
            }
            // At this point either fsL or fsR === 0 so we need to sharpen the
            // evaluation method
            exact = true;
            // get and cache the exact polynomial (we cache this since getting
            // an exact polynomial takes about 15 times more time than getting
            // a double-double polynomial and we very rarely expect to get to 
            // this point)
            fb = refine_certified_eEstimate(refine_certified_eHorner(getPolyExact(), b));
            // if the exact evaluation returns 0 we have an exact root
            if (fb === 0) {
                return [b, b];
            }
            // else we've got a new value for fb and from here on we use exact
            // evaluations
        }
        if ((0 < fb && 0 < fc) || (fb <= 0 && fc <= 0)) {
            c = a;
            fc = fa;
            e = b - a;
            d = e;
        }
    }
}

//# sourceMappingURL=refine-certified.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/root-bounds/upper-to-lower-bound.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const upper_to_lower_bound_invert = invert;
/**
 * Returns a function that returns a positive lower root bound given a function
 * that returns a positive upper root bound.
 *
 * @param positiveUpperBoundFunction
 *
 * @internal
 */
function upperToLowerBound(positiveUpperBoundFunction) {
    return (p) => {
        return 1 / positiveUpperBoundFunction(upper_to_lower_bound_invert(p));
    };
}

//# sourceMappingURL=upper-to-lower-bound.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/root-bounds/positive-to-negative-bound.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const positive_to_negative_bound_reflectAboutYAxis = reflectAboutYAxis;
/**
 * Returns a function that returns a negative root bound given a function that
 * returns a positive root bound.
 *
 * @param positiveBoundFunction
 *
 * @internal
 */
function positiveToNegativeBound(positiveBoundFunction) {
    return (p) => {
        return -positiveBoundFunction(positive_to_negative_bound_reflectAboutYAxis(p));
    };
}

//# sourceMappingURL=positive-to-negative-bound.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/root-bounds/root-bounds-lmq.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const root_bounds_lmq_negate = negate;
const root_bounds_lmq_upperToLowerBound = upperToLowerBound;
const root_bounds_lmq_positiveToNegativeBound = positiveToNegativeBound;
/**
 * Returns an upper bound for the positive real roots of the given polynomial.
 *
 * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,
 * specifically the LocalMaxQuadratic algorithm hence LMQ.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * positiveRootUpperBound_LMQ([2,-3,6,5,-130]); //=> 4.015534272870436
 * positiveRootUpperBound_LMQ([2,3]);           //=> 0
 * positiveRootUpperBound_LMQ([-2,-3,-4]);      //=> 0
 * ```
 *
 * @doc
 */
function positiveRootUpperBound_LMQ(p) {
    const deg = p.length - 1;
    if (deg < 1) {
        return 0;
    }
    if (p[0] < 0) {
        p = root_bounds_lmq_negate(p);
    }
    const timesUsed = [];
    for (let i = 0; i < deg; i++) {
        timesUsed.push(1);
    }
    let ub = 0;
    for (let m = 0; m <= deg; m++) {
        if (p[m] >= 0) {
            continue;
        }
        let tempub = Number.POSITIVE_INFINITY;
        let any = false;
        for (let k = 0; k < m; k++) {
            if (p[k] <= 0) {
                continue;
            }
            const temp = (-p[m] / (p[k] / 2 ** timesUsed[k])) ** (1 / (m - k));
            timesUsed[k]++;
            if (tempub > temp) {
                tempub = temp;
            }
            any = true;
        }
        if (any && ub < tempub)
            ub = tempub;
    }
    return ub;
}
/**
 * Returns a positive lower bound of the real roots of the given polynomial
 *
 * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,
 * specifically the LocalMaxQuadratic algorithm hence LMQ.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
const positiveRootLowerBound_LMQ = root_bounds_lmq_upperToLowerBound(positiveRootUpperBound_LMQ);
/**
 * Returns a negative lower (further from zero) bound of the real roots of the
 * given polynomial.
 *
 * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,
 * specifically the LocalMaxQuadratic algorithm hence LMQ.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
const negativeRootLowerBound_LMQ = root_bounds_lmq_positiveToNegativeBound(positiveRootUpperBound_LMQ);
/**
 * Returns a negative upper (closer to zero) bound of the real roots of the
 * given polynomial.
 *
 * See algoritm 6 of the paper by Vigklas, Akritas and Strzeboński,
 * specifically the LocalMaxQuadratic algorithm hence LMQ.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
const negativeRootUpperBound_LMQ = root_bounds_lmq_upperToLowerBound(negativeRootLowerBound_LMQ);

//# sourceMappingURL=root-bounds-lmq.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/certified/all-roots-certified.js











// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const all_roots_certified_ddDifferentiateWithError = ddDifferentiateWithError;
const all_roots_certified_evalCertified = evalCertified;
const all_roots_certified_eHorner = eHorner;
const all_roots_certified_transposePoly = transposePoly;
const all_roots_certified_evalAdaptive = evalAdaptive;
const all_roots_certified_refineCertified = refineCertified;
const all_roots_certified_negativeRootUpperBound_LMQ = negativeRootLowerBound_LMQ;
const all_roots_certified_positiveRootUpperBound_LMQ = positiveRootUpperBound_LMQ;
const all_roots_certified_eDifferentiate = eDifferentiate;
const all_roots_certified_eEstimate = e_estimate_eEstimate;
const all_roots_certified_hornerWithRunningError = hornerWithRunningError;
const all_roots_certified_eSign = e_sign_eSign;
const all_roots_certified_max = Math.max;
const min = Math.min;
const all_roots_certified_abs = Math.abs;
const all_roots_certified_eps = Number.EPSILON;
const onePlusEps = 1 + all_roots_certified_eps;
function allRootsCertified(p, lb = 0, ub = 1, pE, getPExact, returnUndefinedForZeroPoly) {
    // if `getPExact` is not specified then assume the given double-double 
    // precision coefficient polynomial is exact
    if (!getPExact) {
        getPExact = () => p;
    }
    //const δ = 2*Number.EPSILON * max(1, max(abs(lb), abs(ub)));
    // if `pE` is not specified then assume there is no error
    pE = pE || new Array(p.length).fill(0); // no error
    // set `diffCount` to 0 so `getPolyExact` can be accurate
    let diffCount = 0;
    // lazy loaded array of the given polynomial and its derivatives
    let psExact = undefined;
    //----------------------------------------------------------------------
    // Remove leading zero coefficients 
    // (the case of leading zero coefficients can now be handled)
    // `p` and `getPExact()` *must* be of same length
    //----------------------------------------------------------------------
    let polyExact = undefined; // lazy loaded
    // while the leading coefficient is smaller then the error bound 
    // i.e. possibly zero	
    while (p.length > 0 && all_roots_certified_abs(p[0][1]) <= pE[0]) {
        polyExact = polyExact || getPExact();
        // if leading coefficient really is zero
        if (all_roots_certified_eSign(polyExact[0]) === 0) {
            // shift the leading coefficient and error out without altering the 
            // given polynomial and error bound (shift is destructive, slice is not)
            p = p.slice();
            p.shift();
            pE = pE.slice();
            pE.shift();
            // also shift out the exact polynomial's leading coefficient
            polyExact.shift();
            continue;
        }
        break;
    }
    if (p.length === 0) {
        // return `undefined` for the zero polynomial?
        return returnUndefinedForZeroPoly ? undefined : [];
    }
    else if (p.length === 1) {
        // return `[]` for a degree 1 polynomial (a non-zero constant)
        return [];
    }
    if (lb === Number.NEGATIVE_INFINITY || ub === Number.POSITIVE_INFINITY) {
        const pDoubleCoeffs = p.map(c => c[1]);
        if (lb === Number.NEGATIVE_INFINITY) {
            lb = all_roots_certified_negativeRootUpperBound_LMQ(pDoubleCoeffs);
        }
        if (ub === Number.POSITIVE_INFINITY) {
            ub = all_roots_certified_positiveRootUpperBound_LMQ(pDoubleCoeffs);
        }
    }
    const p_ = all_roots_certified_transposePoly(p);
    let bCount;
    let exact;
    const deg = p.length - 1;
    bCount = 0;
    exact = false;
    let LB; // evaluation at lb
    do {
        LB = exact
            ? all_roots_certified_eEstimate(all_roots_certified_eHorner(getPolyExact(), lb))
            : all_roots_certified_evalCertified(p_, lb, pE);
        if (LB === 0) {
            bCount++;
            // the max bCount is empirically selected for max performance
            if (bCount >= 3 && !exact) {
                exact = true;
                continue;
            }
            lb -= 2 * Number.EPSILON * all_roots_certified_max(1, all_roots_certified_abs(lb));
        }
    } while (LB === 0);
    bCount = 0;
    exact = false;
    let UB; // evaluation at ub
    do {
        UB = exact
            ? all_roots_certified_eEstimate(all_roots_certified_eHorner(getPolyExact(), ub))
            : all_roots_certified_evalCertified(p_, ub, pE);
        if (UB === 0) {
            bCount++;
            if (bCount >= 3 && !exact) { // the max bCount is empirically selected for max performance
                exact = true;
                continue;
            }
            ub += 2 * Number.EPSILON * all_roots_certified_max(1, all_roots_certified_abs(ub));
        }
    } while (UB === 0);
    // Get all derivatives with their coefficient-wise error bounds, i.e. 
    // ps === [p, dp, ddp, ..., constant]
    //        [0,  1,   2, ..., deg     ]
    const ps = [{ p, pE }];
    const ps_ = [all_roots_certified_transposePoly(p)]; // the transposed versions
    for (let i = 1; i <= deg; i++) {
        const dP = all_roots_certified_ddDifferentiateWithError(ps[i - 1]);
        ps.push(dP);
        ps_.push(all_roots_certified_transposePoly(dP.p)); // the transposed versions
    }
    let is = [];
    let curPE;
    let curP_;
    diffCount = deg - 1; // update diffcount
    for (; diffCount >= 0; diffCount--) {
        curPE = ps[diffCount].pE;
        // on first iteration curP_ is linear, 
        // on second it is quadratic, etc. ...
        curP_ = ps_[diffCount];
        is = getRootsWithin();
    }
    // depends externally on `diffCount` and `psExact`
    function getPolyExact() {
        // cache
        if (psExact !== undefined) {
            return psExact[diffCount];
        }
        // keep TypeScript happy; `getPExact` cannot be `undefined` here
        let poly = polyExact || getPExact();
        psExact = [poly];
        while (poly.length > 1) {
            poly = all_roots_certified_eDifferentiate(poly);
            psExact.push(poly);
        }
        return psExact[diffCount];
    }
    return is;
    // All cases:
    // ----------
    // Note: [_a,a_] denotes a micro-interval, whereas [b_,_a], [a_,_b] denotes a
    // normal interval.
    // Note: In all iterations we check [_a,a_] and [a_,_b]. In the final
    // iteration we check [_b,b_], then we've checked all intervals.
    // 
    // ⇑ represents +pos (above x-axis) and ⇓ represents -neg
    // (the symmetric cases also applies where + and - are interchanged)
    // ? means does not matter
    // -----------------------------------------------------------------
    // CASE 1A:
    // _A⇑ | A_⇑ | _B⇑
    //  - [_a,a_] → 
    //    - _a === a_
    //        ? no root 
    //        : A_/_A close enough to zero
    //            ? close even root 
    //            : no roots
    //  - [a_,_b] → no root (curve is monotone increasing or decreasing)
    // CASE 1B:
    // _A⇑ | A_⇑ | _B⇓  
    //  - [_a,a_] → 
    //    - _a === a_
    //        ? no root 
    //        : A_/_A close enough to zero ? close even root : no roots
    //  - [a_,_b] → single root (curve is monotone increasing or decreasing)
    // CASE 2A:
    // _A⇑ | A_⇓ | _B⇑
    //  - [_a,a_] → odd root(s)
    //  - [a_,_b] → single root (curve is monotone increasing or decreasing)
    // CASE 2B:
    // _A⇑ | A_⇓ | _B⇓
    //  - [_a,a_] → odd root(s)
    //  - [a_,_b] → no root (curve is monotone increasing or decreasing)
    // CASE 3A: 
    // A_0 | A_? | _B? | B_?  
    // CASE 3B: 
    // A_? | A_0 | _B? | B_?  
    /**
     * Finds and returns all roots of the given polynomial within the given
     * intervals, starting from the lower bound (lb) and ending at the upper
     * bound (ub) as fetched from the closure.
     *
     * * **precondition** intervals should be disjoint, i.e endpoints are not allowed
     * to be equal - it must be that a_ !== _b
     * * **precondition** the curve must be monotone increasing or decreasing between
     * b_ and _a AND a_ and _b
     * * **precondition** the value at the lower bound (LB) and upper bound (UB)
     * must !== 0
     *
     * @internal
     *
     * @param curP_ a polynomial given as an array with each consecutive element of
     * the array having more accurate coefficients than the previous (by adding
     * consecutive double precision coefficients to prior coefficients)
     * @param is the micro-intervals
     */
    function getRootsWithin() {
        const roots = [];
        // If there are no micro-intervals then check the interval between lb and ub.
        const LB = all_roots_certified_evalAdaptive(curP_, curPE, lb, getPolyExact);
        if (!is.length) {
            // close even root not possible
            const UB = all_roots_certified_evalAdaptive(curP_, curPE, ub, getPolyExact);
            if (LB * UB >= 0) {
                return [];
            }
            const [tS, tE] = all_roots_certified_refineCertified(curP_, curPE, lb, ub, LB, UB, getPolyExact /*, δ*/);
            return [{ tS, tE, multiplicity: 1 }];
        }
        //---- First check from lb to the left side of the first micro-interval.
        let _a = is[0].tS;
        let _A = all_roots_certified_evalAdaptive(curP_, curPE, _a, getPolyExact);
        if (LB * _A > 0) {
            // no roots possible (curve is monotone increasing or decreasing)
        }
        else if (LB * _A < 0) {
            // recall LB must !== 0 as a precondition
            const [tS, tE] = all_roots_certified_refineCertified(curP_, curPE, lb, _a, LB, _A, getPolyExact /*, δ*/);
            roots.push({ tS, tE, multiplicity: 1 });
        } //else {
        // _A === 0
        // no roots possible in [lb,_a]
        //}
        let a_ = lb;
        let A_ = LB;
        let _b = _a;
        let _B = _A;
        let a;
        for (let i = 0; i < is.length; i++) {
            const i_ = is[i + 1]; // right micro-interval
            a = is[i];
            _a = _b;
            a_ = is[i].tE;
            _b = i_ ? i_.tS : ub;
            const B_ = A_;
            _A = _B;
            A_ = all_roots_certified_evalAdaptive(curP_, curPE, a_, getPolyExact);
            _B = all_roots_certified_evalAdaptive(curP_, curPE, _b, getPolyExact);
            if (_A * A_ > 0) {
                //---- CASE 1: _A⇑ | A_⇑   OR   _A⇓ | A_⇓
                if (A_ * _B > 0) {
                    //---- CASE 1A: _A⇑ | A_⇑ | _B⇑   OR   _A⇓ | A_⇓ | _B⇓
                    //console.log('CASE 1A');
                    if (a_ !== _a && a.multiplicity % 2 === 1) {
                        checkEvenAA();
                    }
                    // [a_,_b] → no root
                }
                else if (A_ * _B < 0) {
                    //---- CASE 1B: _A⇑ | A_⇑ | _B⇓   OR   _A⇓ | A_⇓ | _B⇑
                    //console.log('CASE 1B');
                    // we cannot exclude this case as their may be even 
                    // multiplicity >= 4 roots; we would've been able if we
                    // knew that a.multiplicity === 1 exactly and thus the code
                    // could still be improved slightly
                    if (a_ !== _a && a.multiplicity % 2 === 1) {
                        checkEvenAA();
                    }
                    // [a_,_b] → single root (curve is monotone increasing or decreasing)
                    const [tS, tE] = all_roots_certified_refineCertified(curP_, curPE, a_, _b, A_, _B, getPolyExact /*, δ*/);
                    roots.push({ tS, tE, multiplicity: 1 });
                }
                else { // _B === 0
                    //---- CASE 1C: _A⇑ | A_⇑ | _B0   OR   _A⇓ | A_⇓ | _B0
                    //console.log('CASE 1C');
                    // we cannot exclude this case as their may be even 
                    // multiplicity >= 4 roots; we would've been able if we
                    // knew that a.multiplicity === 1 exactly and thus the code
                    // could still be improved slightly
                    if (a_ !== _a && a.multiplicity % 2 === 1) {
                        checkEvenAA();
                    }
                    // [a_,_b] → no root
                }
            }
            else if (_A * A_ < 0) {
                //---- CASE 2 _A⇑ | A_⇓   OR   _A⇓ | A_⇑
                //console.log('CASE 2');
                // - [_a,a_] → odd root(s)
                roots.push({ tS: a.tS, tE: a.tE, multiplicity: 3 });
                if (A_ * _B < 0) {
                    //---- CASE 2A: _A⇑ | A_⇓ | _B⇑   OR   _A⇓ | A_⇑ | _B⇓
                    //console.log('CASE 2A');
                    // [a_,_b] → single root
                    const [tS, tE] = all_roots_certified_refineCertified(curP_, curPE, a_, _b, A_, _B, getPolyExact /*, δ*/);
                    roots.push({ tS, tE, multiplicity: 1 });
                }
                else if (A_ * _B > 0) {
                    //---- CASE 2B: _A⇑ | A_⇓ | _B⇓   OR   _A⇓ | A_⇑ | _B⇑
                    //console.log('CASE 2B');
                    // [a_,_b] → no roots
                }
                else { // _B === 0
                    //console.log('CASE 2C');
                    // [a_,_b] → no roots
                }
            }
            else if (A_ === 0) {
                //---- CASE 3A A_0
                //console.log('CASE 3A');
                // [_a,a_] → rational root at a_
                // There cannot be a root between a_ and _b since _B !== 0
                if ( /*_a === a_ ||*/_A === 0) {
                    // multiple rational root at a_ OR both _A and A_ is 0
                    // so update multiplicity parity
                    roots.push({ tS: a.tS, tE: a.tE, multiplicity: a.multiplicity + 1 });
                }
                else {
                    // now _A and _B are both !== 0
                    if (_A * _B > 0) {
                        roots.push({ tS: a.tS, tE: a.tE, multiplicity: 2 });
                    }
                    else {
                        roots.push({ tS: a.tS, tE: a.tE, multiplicity: 3 });
                    }
                }
            }
            else { // _A === 0
                //---- CASE 3B _A0
                //console.log('CASE 3B');
                // A_ !== 0 here and _a !== a_
                // [_a,a_] → rational root at _a
                if (A_ * _B < 0) {
                    // [a_,_b] → single root
                    const [tS, tE] = all_roots_certified_refineCertified(curP_, curPE, a_, _b, A_, _B, getPolyExact /*, δ*/);
                    roots.push({ tS, tE, multiplicity: 1 });
                }
                else if (A_ * _B > 0) {
                    // [a_,_b] → no roots
                }
                // - [_a,a_] → 
                // B_ and A_ are both !== 0
                if (B_ * A_ > 0) {
                    roots.push({ tS: a.tS, tE: a.tE, multiplicity: 2 });
                }
                else {
                    roots.push({ tS: a.tS, tE: a.tE, multiplicity: 3 });
                }
            }
        }
        // Combine the root intervals if they are adjacent (they are not 
        // allowed to overlap)
        for (let i = 0; i < roots.length - 1; i++) {
            const r = roots[i];
            const r_ = roots[i + 1];
            if (r.tE >= r_.tS) {
                return joinRoots(roots);
            }
        }
        return roots;
        /**
         * Calculates and returns max 2nd derivative - calculated using something
         * akin to a Taylor expansion - could be improved by not taking absolute
         * values, but rather minimum mins. and maximum max values of f(s)?.
         * maxDdP = |f(s)| + δ|f'(s)| + δ^2|f''(s)| + ..., where δ = (a_ - _a),
         * s = _a and f is the second derivative of the current polynomial. We can
         * also potentially short circuit the maxDdP calculation after some terms,
         * the point being there are very likely many optimizations that can still
         * be done.
         *
         * @internal
         */
        function checkEvenAA() {
            //This was the old method when the function only supported lb = 0, ub = 1
            //-----------------------------------------------------------------------
            //const ddP0 = diffCount+2 > deg ? undefined : ps_[diffCount+2][0];
            //const maxDdP2 = 0;
            //for (const j=0; j<ddP0.length; j++) {
            //	// evaluate at 1
            //	maxDdP2 += abs(ddP0[j]);  // this is valid only if |lb| and |ub| <= 1
            //}
            const d = (a_ - _a) * onePlusEps;
            let mult = 1;
            let maxDdP = 0;
            for (let ddDiffCount = diffCount + 2; ddDiffCount <= deg; ddDiffCount++) {
                const p = ps_[ddDiffCount][0];
                const h = all_roots_certified_hornerWithRunningError(p, _a);
                const fs = all_roots_certified_abs(h[0]) + h[1];
                maxDdP += fs * mult;
                mult *= d * onePlusEps;
            }
            // maxDdP is now calculated
            const AMinMax = A_ > 0 ? min(_A, A_) : all_roots_certified_max(_A, A_);
            const δ = 2 * Number.EPSILON * all_roots_certified_max(1, all_roots_certified_abs(a_));
            const dMax = maxDdP * (2 * δ); // since the first derivative === 0 somewhere in [_a,a_]
            const yShift = A_ > 0 ? -dMax * 2 * δ : dMax * 2 * δ;
            const y = AMinMax + yShift;
            if (y * A_ < 0) {
                // possible even multiplicity root
                //console.log('A_, yShift', A_, yShift);
                //console.log(toCasStr(ps_[0][0]));
                //console.log('possible even multiplicty root: ', _a, a_);
                // The below multiplicity can really be any non-negative 
                // multiple of 2
                roots.push({ tS: a.tS, tE: a.tE, multiplicity: 2 });
            }
        }
    }
}
function joinRoots(rs) {
    const newRs = [];
    const r = rs[0];
    // make a clone of the first interval
    let curR = { tS: r.tS, tE: r.tE, multiplicity: r.multiplicity };
    for (let i = 0; i < rs.length - 1; i++) {
        const r = rs[i];
        const r_ = rs[i + 1];
        if (r.tE < r_.tS) {
            // they don't stick together
            newRs.push(curR);
            // make a clone of the next interval
            curR = { tS: r_.tS, tE: r_.tE, multiplicity: r_.multiplicity };
        }
        else {
            // they stick together - expand
            curR.tE = r_.tE;
            curR.multiplicity = r.multiplicity + r_.multiplicity;
        }
    }
    newRs.push(curR);
    return newRs;
}

//# sourceMappingURL=all-roots-certified.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/certified/all-roots-certified-simplified.js

function allRootsCertifiedSimplified(p, lb = Number.NEGATIVE_INFINITY, ub = Number.POSITIVE_INFINITY, returnUndefinedForZeroPoly) {
    return allRootsCertified(p.map(c => [0, c]), lb, ub, undefined, undefined, returnUndefinedForZeroPoly);
}

//# sourceMappingURL=all-roots-certified-simplified.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/certified/refine-k1.js




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const refine_k1_eChangeVariablesLinear = eChangeVariablesLinear;
const refine_k1_allRootsCertified = allRootsCertified;
const refine_k1_eToDd = eToDd;
const refine_k1_twoSum = two_sum_twoSum;
const refine_k1_eps = Number.EPSILON;
/**
 * Returns once compensated root(s) (bar underflow / overflow) given a root
 * interval previously calculated using [[allRootsCertified]].
 *
 * * 'once-compensated' here means that the typical root interval, `W`,
 * (`= Number.EPSILON` at `1`) is reduced to `W**2`; if multiple roots were
 * present in the original interval they may be resolved to individual
 * intervals
 *
 * @param ri a root interval previously calculated
 * @param p the exact polynomial with coefficients given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function refineK1(ri, p) {
    const tS = ri.tS;
    // scale is exact by the precondition put on `RootInterval`
    const δ = ri.tE - tS;
    // Translate the polynomial such that the root is within δ from 0, then
    // scale it such that the roots stay <= 1, i.e. is in [0,1]
    const pExactK1 = refine_k1_eChangeVariablesLinear(p, δ, tS);
    // reduce the polynomial to double-double precision for faster root finding
    const pDdK1 = pExactK1.map(refine_k1_eToDd);
    // update the double-double precision error bound - it is simply the error 
    // in rounding the exact coefficients to double-double precision
    const errBoundK1 = pDdK1.map(c => refine_k1_eps * refine_k1_eps * c[1]);
    const getPExactK1 = () => pExactK1;
    // keep TypeScript happy; `allRootsCertified` can safely be assumed not to
    // return `undefined`
    const risLo = refine_k1_allRootsCertified(pDdK1, 0, 1, errBoundK1, getPExactK1);
    const ris = [];
    for (let riLo of risLo) {
        ris.push({
            tS: refine_k1_twoSum(tS, riLo.tS * δ),
            tE: refine_k1_twoSum(tS, riLo.tE * δ),
            multiplicity: riLo.multiplicity
        });
    }
    return ris;
}

//# sourceMappingURL=refine-k1.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/certified/root-interval.js
/**
 * Simple function that creates and returns an exact root (with a bracketing
 * interval width of 0 and multiplicity 1)
 *
 * @param t
 *
 * @doc
 */
function createRootExact(t) {
    return { tS: t, tE: t, multiplicity: 1 };
}
/**
 * Simple function that returns the middle of the root bracketing interval - can
 * be used to estimate the root
 *
 * @param ri a root interval
 *
 * @doc
 */
function mid(ri) {
    return (ri.tS + ri.tE) / 2;
}

//# sourceMappingURL=root-interval.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/certified/root-interval-to-exp.js
/**
 * Returns the result of converting a double precision root interval to a
 * double-double precision one
 *
 * @param ri a root interval
 *
 * @doc
 */
function rootIntervalToExp(ri) {
    return {
        tS: [0, ri.tS],
        tE: [0, ri.tE],
        multiplicity: ri.multiplicity
    };
}

//# sourceMappingURL=root-interval-to-exp.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/bigint/b-sign-changes.js
/**
 * Returns the number of sign changes in the polynomial coefficents when
 * ordered in descending order; zeros are ignored.
 *
 * * Descartes' rule of signs states (quoted from Wikipedia):
 * "if the terms of a polynomial are ordered by descending variable
 * exponent, then the number of positive roots of the polynomial is
 * either equal to the number of sign differences between consecutive
 * nonzero coefficients, or is less than it by an even number. Multiple
 * roots of the same value are counted separately."
 *
 * * see [Descartes' rule of signs](https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs)
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * bSignChanges([1n,2n,-3n,0n,0n,3n,-1n]); //=> 3
 * ```
 *
 * @doc
 */
function bSignChanges(p) {
    const d = p.length - 1;
    let result = 0;
    let prevSign = p[0] === 0n ? 0 : p[0] < 0n ? -1 : +1;
    for (let i = 1; i < d + 1; i++) {
        const sign = p[i] === 0n ? 0 : p[i] < 0n ? -1 : +1;
        if (sign !== prevSign && sign !== 0) {
            result++;
            prevSign = sign;
        }
    }
    return result;
}

//# sourceMappingURL=b-sign-changes.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_num_roots_bSturmChain = bSturmChain;
const b_num_roots_bDegree = bDegree;
const b_num_roots_bSignChanges = bSignChanges;
/**
 * Returns the *exact* number of *distinct* real roots in the interval (-∞,+∞)
 * of the given polynomial.
 *
 * * From Wikipedia: "In the case of a non-square-free polynomial,
 * if neither a nor b is a multiple root of p, then V(a) − V(b) is the number
 * of distinct real roots of P".
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * const p = [n1, 1n, -64n, 236n, -240n];
 * bNumRoots(p); //=> 4
 * ```
 *
 * @doc
 */
function bNumRoots(p) {
    const ps = b_num_roots_bSturmChain(p);
    const as = ps.map(p => b_num_roots_bDegree(p) % 2 === 0 ? p[0] : -p[0]);
    const bs = ps.map(p => p[0]);
    return b_num_roots_bSignChanges(as) - b_num_roots_bSignChanges(bs);
}

//# sourceMappingURL=b-num-roots.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots-0-1.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_num_roots_0_1_bSturmChain = bSturmChain;
const b_num_roots_0_1_bSignChanges = bSignChanges;
const b_num_roots_0_1_bEvaluateAt1 = bEvaluateAt1;
/**
 * Returns the *exact* number of *distinct* real roots in the open
 * interval (0,1) of the given polynomial.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]` represents the
 * polynomial `5x^2 - 3x`
 *
 * @doc
 */
function bNumRootsIn01(p) {
    const ps = b_num_roots_0_1_bSturmChain(p);
    const as = ps.map(p => p[p.length - 1]); // evaluate at 0
    const bs = ps.map(p => b_num_roots_0_1_bEvaluateAt1(p)); // evaluate at 1
    return b_num_roots_0_1_bSignChanges(as) - b_num_roots_0_1_bSignChanges(bs);
}

//# sourceMappingURL=b-num-roots-0-1.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/bigint/b-num-roots-in-range.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_num_roots_in_range_bSturmChain = bSturmChain;
const b_num_roots_in_range_bHorner = bHorner;
const b_num_roots_in_range_bSignChanges = bSignChanges;
/**
 * Returns the *exact* number of *distinct* real roots in the open
 * interval (a,b) of the given polynomial.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * bigints from highest to lowest power, e.g. `[5n,-3n,0n]`
 * represents the polynomial `5x^2 - 3x`
 * @param a a lower bound
 * @param b an upper bound
 *
 * @example
 * ```typescript
 * const p = [1n, 1n, -64n, 236n, -240n];
 * bNumRootsInRange(p,-20,-11);  //=> 0
 * bNumRootsInRange(p,-11,-9);   //=> 1
 * bNumRootsInRange(p,-11,3.5);  //=> 3
 * bNumRootsInRange(p,-11,5);    //=> 4
 * ```
 *
 * @doc
 */
function bNumRootsInRange(p, a, b) {
    const ps = b_num_roots_in_range_bSturmChain(p);
    const as = ps.map(p => b_num_roots_in_range_bHorner(p, a));
    const bs = ps.map(p => b_num_roots_in_range_bHorner(p, b));
    return b_num_roots_in_range_bSignChanges(as) - b_num_roots_in_range_bSignChanges(bs);
}

//# sourceMappingURL=b-num-roots-in-range.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/double/sign-changes.js
/**
 * Returns the number of sign changes in the polynomial coefficents when
 * ordered in descending order; zeros are ignored.
 *
 * * Descartes' rule of signs states (quoted from Wikipedia):
 * "if the terms of a polynomial are ordered by descending variable
 * exponent, then the number of positive roots of the polynomial is
 * either equal to the number of sign differences between consecutive
 * nonzero coefficients, or is less than it by an even number. Multiple
 * roots of the same value are counted separately."
 *
 * * see [Descartes' rule of signs](https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * signChanges([1,2,-3,0,0,3,-1]); //=> 3
 * ```
 *
 * @doc
 */
function signChanges(p) {
    const d = p.length - 1;
    let result = 0;
    let prevSign = Math.sign(p[0]);
    for (let i = 1; i < d + 1; i++) {
        const sign = Math.sign(p[i]);
        if (sign !== prevSign && sign !== 0) {
            result++;
            prevSign = sign;
        }
    }
    return result;
}

//# sourceMappingURL=sign-changes.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/double/num-roots.js




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const num_roots_signChanges = signChanges;
const num_roots_eSign = e_sign_eSign;
const num_roots_eDegree = eDegree;
const num_roots_eSturmChain = eSturmChain;
/**
 * Returns the *exact* number of *distinct* real roots in the interval (-∞,+∞)
 * of the given polynomial - subject to floating point underflow / overflow of
 * intermediate calculations.
 *
 * * From Wikipedia: "In the case of a non-square-free polynomial,
 * if neither a nor b is a multiple root of p, then V(a) − V(b) is the number
 * of distinct real roots of P".
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * const p = [1, 1, -64, 236, -240];
 * numRoots(p); //=> 4
 * ```
 *
 * @doc
 */
function numRoots(p) {
    const p_ = p.map(c => [c]);
    const ps = num_roots_eSturmChain(p_);
    const as = ps.map(p_ => num_roots_eDegree(p_) % 2 === 0 ? num_roots_eSign(p_[0]) : -num_roots_eSign(p_[0]));
    const bs = ps.map(p_ => num_roots_eSign(p_[0]));
    return num_roots_signChanges(as) - num_roots_signChanges(bs);
}

//# sourceMappingURL=num-roots.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/double/num-roots-in-0-1.js




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const num_roots_in_0_1_eEvaluateAt1 = eEvaluateAt1;
const num_roots_in_0_1_eSturmChain = eSturmChain;
const num_roots_in_0_1_signChanges = signChanges;
const num_roots_in_0_1_eSign = e_sign_eSign;
/**
 * Returns the *exact* number of *distinct* real roots in the open
 * interval (0,1) of the given polynomial - subject to floating point
 * underflow / overflow of intermediate calculations.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * precision floating point numbers from highest to lowest power,
 * e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function numRootsIn01(p) {
    const p_ = p.map(c => [c]);
    const ps = num_roots_in_0_1_eSturmChain(p_);
    const as = ps.map(p_ => num_roots_in_0_1_eSign(p_[p_.length - 1])); // evaluate at 0
    const bs = ps.map(p_ => num_roots_in_0_1_eSign(num_roots_in_0_1_eEvaluateAt1(p_))); // evaluate at 1
    return num_roots_in_0_1_signChanges(as) - num_roots_in_0_1_signChanges(bs);
}

//# sourceMappingURL=num-roots-in-0-1.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/expansion/e-sign-changes.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_sign_changes_eSign = e_sign_eSign;
/**
 * Returns the number of sign changes in the polynomial coefficents when
 * ordered in descending order; zeros are ignored.
 *
 * * this function is often called `Descartes` in the literature
 *
 * * returns an upper bound of the number of *positive* real roots of the given
 * polynomial
 *
 * * the upper bound returned is always a non-negative multiple of two
 * (i.e. 0, 2, etc) higher than the actual number of real roots
 *
 * * the polynomial need not be square free
 *
 * * Descartes' rule of signs states (quoted from Wikipedia):
 * "if the terms of a polynomial are ordered by descending variable
 * exponent, then the number of positive roots of the polynomial is
 * either equal to the number of sign differences between consecutive
 * nonzero coefficients, or is less than it by an even number. Multiple
 * roots of the same value are counted separately."
 *
 * * see [Descartes' rule of signs](https://en.wikipedia.org/wiki/Descartes%27_rule_of_signs)
 *
 * @param p a polynomial with coefficients given densely as an array of Shewchuk
 * floating point expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * eSignChanges([[1],[2],[-3],[0],[0],[3],[-1]]); //=> 3
 * ```
 *
 * @doc
 */
function eSignChanges(p) {
    const d = p.length - 1;
    if (d < 1) {
        return 0;
    }
    let result = 0;
    let prevSign = Math.sign(e_sign_changes_eSign(p[0]));
    for (let i = 1; i < d + 1; i++) {
        const sign_ = Math.sign(e_sign_changes_eSign(p[i]));
        if (sign_ !== prevSign && sign_ !== 0) {
            result++;
            prevSign = sign_;
        }
    }
    return result;
}

//# sourceMappingURL=e-sign-changes.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/double/num-roots-in-range.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const num_roots_in_range_sturmChain = sturmChain;
const num_roots_in_range_eHorner = eHorner;
const num_roots_in_range_eSignChanges = eSignChanges;
/**
 * Returns the *exact* number of *distinct* real roots in the open
 * interval (a,b) of the given polynomial - subject to floating point
 * underflow / overflow of intermediate calculations.
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param a a lower bound
 * @param b an upper bound
 *
 * @example
 * ```typescript
 * const p = [1, 1, -64, 236, -240];
 * numRootsInRange(p,-20,-11);  //=> 0
 * numRootsInRange(p,-11,-9);   //=> 1
 * numRootsInRange(p,-11,3.5);  //=> 3
 * numRootsInRange(p,-11,5);    //=> 4
 * ```
 *
 * @doc
 */
function numRootsInRange(p, a, b) {
    const ps = num_roots_in_range_sturmChain(p);
    const as = ps.map(p => num_roots_in_range_eHorner(p, a));
    const bs = ps.map(p => num_roots_in_range_eHorner(p, b));
    return num_roots_in_range_eSignChanges(as) - num_roots_in_range_eSignChanges(bs);
}

//# sourceMappingURL=num-roots-in-range.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots.js




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_num_roots_signChanges = signChanges;
const e_num_roots_eSign = e_sign_eSign;
const e_num_roots_eDegree = eDegree;
const e_num_roots_eSturmChain = eSturmChain;
/**
 * Returns the *exact* number of *distinct* real roots in the interval (-∞,+∞)
 * of the given polynomial - subject to floating point underflow / overflow of
 * intermediate calculations.
 *
 * * From Wikipedia: "In the case of a non-square-free polynomial,
 * if neither a nor b is a multiple root of p, then V(a) − V(b) is the number
 * of distinct real roots of P".
 *
 * @param p a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * const p = [[1], [1], [-64], [236], [-240]];
 * eNumRoots(p); //=> 4
 * ```
 *
 * @doc
 */
function eNumRoots(p) {
    const ps = e_num_roots_eSturmChain(p);
    const as = ps.map(p => e_num_roots_eDegree(p) % 2 === 0 ? e_num_roots_eSign(p[0]) : -e_num_roots_eSign(p[0]));
    const bs = ps.map(p => e_num_roots_eSign(p[0]));
    return e_num_roots_signChanges(as) - e_num_roots_signChanges(bs);
}

//# sourceMappingURL=e-num-roots.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots-0-1.js




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_num_roots_0_1_eEvaluateAt1 = eEvaluateAt1;
const e_num_roots_0_1_eSturmChain = eSturmChain;
const e_num_roots_0_1_signChanges = signChanges;
const e_num_roots_0_1_eSign = e_sign_eSign;
/**
 * Returns the *exact* number of *distinct* real roots in the open
 * interval (0,1) of the given polynomial - subject to floating point
 * underflow / overflow of intermediate calculations.
 *
 * @param p a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function eNumRootsIn01(p) {
    const ps = e_num_roots_0_1_eSturmChain(p);
    const as = ps.map(p => e_num_roots_0_1_eSign(p[p.length - 1])); // evaluate at 0
    const bs = ps.map(p => e_num_roots_0_1_eSign(e_num_roots_0_1_eEvaluateAt1(p))); // evaluate at 1
    return e_num_roots_0_1_signChanges(as) - e_num_roots_0_1_signChanges(bs);
}

//# sourceMappingURL=e-num-roots-0-1.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/descartes/expansion/e-num-roots-in-range.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_num_roots_in_range_eeHorner = eeHorner;
const e_num_roots_in_range_eSturmChain = eSturmChain;
const e_num_roots_in_range_eSignChanges = eSignChanges;
/**
 * Returns the *exact* number of *distinct* real roots in the open
 * interval (a,b) of the given polynomial - subject to floating point
 * underflow / overflow of intermediate calculations.
 *
 * * From Wikipedia: "In the case of a non-square-free polynomial, if
 * neither a nor b is a multiple root of p, then V(a) − V(b) is the number of
 * distinct real roots of P".
 *
 * @param p a polynomial with coefficients given densely as an array of
 * Shewchuk expansions from highest to lowest power, e.g. `[[5],[-3],[0]]`
 * represents the polynomial `5x^2 - 3x`
 * @param a a lower bound given as a Shewchuk expansion
 * @param b an upper bound
 *
 * @example
 * ```typescript
 * const p = [[1], [1], [-64], [236], [-240]];
 * eNumRootsInRange(p,-20,-11); //=> 0
 * eNumRootsInRange(p,-11,-9);  //=> 1
 * eNumRootsInRange(p,-11,3.5); //=> 3
 * eNumRootsInRange(p,-11,5);   //=> 4
 * ```
 *
 * @doc
 */
function eNumRootsInRange(p, a, b) {
    const ps = e_num_roots_in_range_eSturmChain(p);
    const as = ps.map(p => e_num_roots_in_range_eeHorner(p, a));
    const bs = ps.map(p => e_num_roots_in_range_eeHorner(p, b));
    return e_num_roots_in_range_eSignChanges(as) - e_num_roots_in_range_eSignChanges(bs);
}

//# sourceMappingURL=e-num-roots-in-range.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/from-roots/bigint/b-from-roots.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const b_from_roots_bMultiply = bMultiply;
/**
 * Constructs a polynomial from the given roots by multiplying out the
 * factors (x - root1)(x - root2)
 *
 * * currently, only integer roots are allowed
 *
 * @param roots an array of roots
 *
 * @example
 * ```typescript
 * fromRoots([1n,2n,3n,3n]); //=> [1n, -9n, 29n, -39n, 18n]
 * ```
 *
 * @doc
 */
function bFromRoots(roots) {
    let p = [1n];
    for (let i = 0; i < roots.length; i++) {
        p = b_from_roots_bMultiply(p, [1n, -roots[i]]);
    }
    return p;
}

//# sourceMappingURL=b-from-roots.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/from-roots/expansion/e-from-roots.js



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const e_from_roots_eMultiply = eMultiply;
const e_from_roots_eNegativeOf = eNegativeOf;
const e_from_roots_eToDd = eToDd;
/**
 * Constructs a double-double precision polynomial from the given roots by
 * multiplying out the factors (x - root1)(x - root2) in infinite precision
 * (bar overflow) and rounding back to double-double precision; also returns
 * a coefficient-wise error polynomial and a function that returns the exact
 * polynomial.
 *
 * * mostly for testing purposes.
 *
 * @param roots an array of roots
 *
 * @doc
 */
function eFromRoots(roots) {
    let p = [[1]];
    for (let i = 0; i < roots.length; i++) {
        p = e_from_roots_eMultiply(p, [[1], e_from_roots_eNegativeOf(roots[i])]);
    }
    const pE = p.map(c => Math.abs(c[c.length - 1] * Number.EPSILON));
    const getPExact = () => p;
    return {
        pDd: p.map(e_from_roots_eToDd),
        pE,
        getPExact
    };
}

//# sourceMappingURL=e-from-roots.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/naive/brent-poly.js

const brent_poly_Horner = Horner;
const brent_poly_eps = Number.EPSILON;
const brent_poly_u = brent_poly_eps / 2;
const brent_poly_abs = Math.abs;
const brent_poly_max = Math.max;
/**
 * Returns a refined root given a root bracketed in the interval (a,b) of the
 * given polynomial using Brent's Method.
 *
 * * near exact implementation of the original Brent Dekker Method (also known
 * as Brent's Method), except that it is specialzed to polynomial evaluation
 *
 * * the algorithm stops once the interval width becomes equal or less than
 * `2 * Number.EPSILON/2 * max(1,abs(a),abs(b))` where `a` and `b` are the current
 * lower and upper interval limits
 *
 * * Brent's Method is an excellent root-refinement choice since:
 *  * guaranteed converge (unlike the Newton and other so-called single-point
 * methods),
 *  * converges in a reasonable number of iterations even for highly contrived
 * functions (unlike Dekker's Method) and
 *  * nearly always converges fast, i.e. super-linearly (unlike the Secant and
 * Regula-Falsi methods).
 * * unfortunately the algorithm given on [Wikipedia](https://en.wikipedia.org/wiki/Brent%27s_method)
 * works but is not precisely Brent's method and runs about 2x or more slower
 * due to it not implementing the critically important 'micro-step' (Aug 2020).
 *
 * * see [Brent (page 47)](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param lb the lower limit of the search interval.
 * @param ub the upper limit of the search interval.
 * @param fa (may be left out - will be calculated automatically) the result of
 * evaluating the input polynomial at `a`
 * @param fb (may be left out - will be calculated automatically) the result of
 * evaluating the input polynomial at `b`
 *
 * @example
 * ```typescript
 * const p = fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]
 * const a = 2.2;
 * const b = 3.8;
 * brent(p,a,b); //=> 3.000000000000003
 * b = 3.1;
 * brent(p,a,b); //=> 3.000000000000001
 * ```
 *
 * @doc
 */
function brentPoly(p, lb, ub, fa = brent_poly_Horner(p, lb), fb = brent_poly_Horner(p, ub)) {
    // Precondition: fa, fb !== 0
    //---- Make local copies of a and b.
    let a = lb;
    let b = ub;
    let c = a;
    let fc = fa;
    let e = b - a;
    let d = e;
    while (true) {
        if (brent_poly_abs(fc) < brent_poly_abs(fb)) {
            a = b;
            b = c;
            c = a;
            fa = fb;
            fb = fc;
            fc = fa;
        }
        const δ = 2 * brent_poly_u * brent_poly_max(1, brent_poly_abs(a), brent_poly_abs(b));
        const m = 0.5 * (c - b);
        //if (abs(m) <= δ || fb === 0) {
        if (brent_poly_abs(m) <= δ) {
            // uncomment below if range to be returned
            //return b < c ? [b,c] : [c,b];
            // uncomment below if leftmost guess to be returned
            //return b < c ? b : c;
            // uncomment below if rightmost guess to be returned
            //return b < c ? b : c;
            // uncomment below if any guess to be returned
            return b;
        }
        if (brent_poly_abs(e) < δ || brent_poly_abs(fa) <= brent_poly_abs(fb)) {
            e = m;
            d = e;
        }
        else {
            let s = fb / fa;
            let p;
            let q;
            if (a === c) {
                p = 2 * m * s;
                q = 1 - s;
            }
            else {
                q = fa / fc;
                const r = fb / fc;
                p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));
                q = (q - 1) * (r - 1) * (s - 1);
            }
            if (0 < p) {
                q = -q;
            }
            else {
                p = -p;
            }
            s = e;
            e = d;
            if (2 * p < 3 * m * q - brent_poly_abs(δ * q) && p < brent_poly_abs(0.5 * s * q)) {
                d = p / q;
            }
            else {
                e = m;
                d = e;
            }
        }
        a = b;
        fa = fb;
        if (δ < brent_poly_abs(d)) {
            b = b + d;
        }
        else if (0 < m) {
            b = b + δ;
        }
        else {
            //b = b - eps;
            b = b - δ;
        }
        fb = brent_poly_Horner(p, b);
        // inlined above line:
        //fb = p[0]; for (let i=1; i<p.length; i++) { fb = fb*b + p[i]; }
        if (fb === 0) {
            return b;
        }
        if (fb * fc > 0) {
            c = a;
            fc = fa;
            e = b - a;
            d = e;
        }
    }
}

//# sourceMappingURL=brent-poly.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/naive/all-roots.js






// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const all_roots_differentiate = differentiate;
const all_roots_Horner = Horner;
const all_roots_brentPoly = brentPoly;
const all_roots_negativeRootUpperBound_LMQ = negativeRootLowerBound_LMQ;
const all_roots_positiveRootUpperBound_LMQ = positiveRootUpperBound_LMQ;
const all_roots_removeLeadingZeros = removeLeadingZeros;
/**
 * Find and return all roots of the given polynomial in the given interval.
 *
 * * an empty array is returned for a constant or the zero polynomial
 *
 * * **non-exact:** roots are found 'naively' using double-precision arithmetic
 * and accuracy will thus depend on the condition number around the root - use
 * [[allRootsCertifiedSimplified]] or [[allRootsCertified]] instead if certified
 * root bounds are required (it is about 3x slower, but still very fast!)
 *
 * * close (where the definition of closeness depends on the condition
 * number) or multiple *even* roots can be returned as 0, 1 or more close
 * roots, whereas close or multiple *odd* roots are guaranteed to return *at
 * least 1 root*
 *
 * * optimized for polynomials of degree 1 to about 30
 *
 * * roots are refined using the celebrated Brent's Method (and evaluated using
 * Horner's Method) until a root interval is found with
 * width `<= eps * max(1, 2^⌈log₂r⌉)`, where `eps = Number.EPSILON` and
 * `r` is a root
 *
 * * **ordered:** the returned roots are ordered from lowest to highest
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param lb defaults to `Number.NEGATIVE_INFINITY`; lower bound of roots to be
 * returned
 * @param ub defaults to `Number.POSITIVE_INFINITY`; upper bound of roots to be
 * returned
 *
 * @doc
 */
function allRoots(p, lb = Number.NEGATIVE_INFINITY, ub = Number.POSITIVE_INFINITY) {
    // return an empty array for a constant or the zero polynomial
    if (p.length <= 1) {
        return [];
    }
    if (lb === Number.NEGATIVE_INFINITY) {
        lb = all_roots_negativeRootUpperBound_LMQ(p);
    }
    if (ub === Number.POSITIVE_INFINITY) {
        ub = all_roots_positiveRootUpperBound_LMQ(p);
    }
    p = all_roots_removeLeadingZeros(p);
    //---- count and remove roots at zero
    let numZerosAtZero = 0;
    while (p[p.length - 1] === 0) {
        p = p.slice(0, -1);
        numZerosAtZero++;
    }
    //------------------------
    // Get all derivatives, i.e. 
    // ps === [p, dp, ddp, ..., constant]
    //        [0,  1,   2, ..., deg     ]
    const ps = [p];
    for (let i = 1; i <= p.length - 1; i++) {
        ps.push(all_roots_differentiate(ps[i - 1]));
    }
    //const δ = Math.max(2*eps, 2*eps * Math.max(Math.abs(lb), Math.abs(ub)));
    /** root intervals */
    let is = [];
    // loop: ps[diffCount] === [linear, quadratic, ..., deg]
    for (let diffCount = p.length - 2; diffCount >= 0; diffCount--) {
        // Get roots within intervals:
        // ---------------------------
        // Finds and returns all roots of the given polynomial within the given 
        // intervals, starting from the lower bound (lb) and ending at the upper
        // bound (ub)
        const p = ps[diffCount];
        const roots = [];
        let _a_ = lb;
        let _A_ = all_roots_Horner(p, _a_);
        // if lower bound value is zero and this is the last iteration with 
        // p === the original polynomial then push the root at the lower bound
        if (_A_ === 0 && diffCount === 0) {
            roots.push(lb);
        }
        for (let i = 0; i < is.length; i++) {
            const _b_ = is[i];
            const _B_ = all_roots_Horner(p, _b_);
            // if there is a root at the right interval then add it
            if (_B_ === 0) {
                roots.push(_b_);
            }
            else if (_A_ * _B_ < 0) {
                roots.push(all_roots_brentPoly(p, _a_, _b_, _A_, _B_));
            }
            _a_ = _b_;
            _A_ = _B_;
        }
        const _B_ = all_roots_Horner(p, ub);
        if (_A_ * _B_ < 0) {
            roots.push(all_roots_brentPoly(p, _a_, ub, _A_, _B_));
        }
        // if upper bound value is zero and this is the last iteration with 
        // p === the original polynomial then push the root at the upper bound
        if (_B_ === 0 && diffCount === 0) {
            roots.push(ub);
        }
        is = roots;
    }
    if (numZerosAtZero > 0 && lb <= 0 && ub >= 0) {
        // at this point the existing intervals, `is`, are sorted
        // find the insertion spot and insert the zero roots to keep the roots
        // sorted
        let isWithZeroRoots = [];
        let zerosInserted = false;
        for (let i = 0; i < is.length; i++) {
            if (!zerosInserted && is[i] >= 0) {
                // push the zero roots
                for (let j = 0; j < numZerosAtZero; j++) {
                    isWithZeroRoots.push(0);
                }
                zerosInserted = true;
            }
            isWithZeroRoots.push(is[i]);
        }
        return isWithZeroRoots;
    }
    return is;
}

//# sourceMappingURL=all-roots.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/naive/bisection.js
const bisection_abs = Math.abs;
const bisection_max = Math.max;
/**
 * Returns a refined root given a root bracketed in the interval (a,b) of the
 * given function using the
 * [Bisection Method](https://en.wikipedia.org/wiki/Bisection_method) algorithm.
 *
 * * any function can be supplied (it does not even have to be continuous) as
 * long as the root is bracketed.
 *
 * * this function has no advantages above Brent's method except for its
 * simpler implementation and can be slower. Use [[brentPoly]] or [[brent]]
 * instead.
 *
 * * the algorithm stops once the interval width becomes equal or less than
 * `2 * Number.EPSILON * max(1,abs(a),abs(b))` where `a` and `b` are the current
 * lower and upper interval limits
 *
 * @param f the function for which the root is sought
 * @param a the lower limit of the search interval
 * @param b the upper limit of the search interval
 *
 * @example
 * ```typescript
 * const p = fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]
 * const f = t => Horner(p,t);
 * bisection(f,2.2,3.8); //=> 3
 * bisection(f,2.2,3.1); //=> 3.0000000000000044
 * ```
 *
 * @doc
 */
function bisection(f, a, b) {
    if (b < a) {
        [a, b] = [b, a]; // Swap a and b 
    }
    const fa = f(a);
    const fb = f(b);
    if (a === b) {
        if (fa !== 0) {
            // Root is not bracketed - this is a precondition.
            throw new Error('Root not bracketed');
        }
        // the root is already found.
        return a;
    }
    if (fa === 0) {
        return a;
    }
    if (fb === 0) {
        return b;
    }
    if (fa * fb > 0) {
        // Root is not bracketed - this is a precondition.
        throw new Error('Root not bracketed');
    }
    while (true) {
        const c = a + (b - a) / 2; // Take midpoint
        const fc = f(c);
        if (fc === 0) {
            return c;
        }
        if (fa * fc < 0) {
            b = c;
        }
        else {
            a = c;
        }
        const δ = 2 * Number.EPSILON * bisection_max(1, bisection_abs(a), bisection_abs(b));
        if (Math.abs(a - b) <= δ) {
            return b;
        }
    }
}

//# sourceMappingURL=bisection.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/naive/brent.js
const brent_eps = Number.EPSILON;
const brent_abs = Math.abs;
const brent_max = Math.max;
/**
 * Returns a refined root given a root bracketed in the interval (a,b) of the
 * given function using Brent's Method. Any function can be supplied (it
 * does not even have to be continuous) as long as the root is bracketed.
 *
 * * near exact implementation of the original Brent Dekker Method (also known
 * as Brent's Method)
 *
 * * Brent's Method is an excellent root-refinement choice since:
 *   * guaranteed converge (unlike the Newton and other so-called single-point
 * methods),
 *   * converges in a reasonable number of iterations even for highly contrived
 * functions (unlike Dekker's Method) and
 *   * nearly always converges fast, i.e. super-linearly (unlike the Secant and
 * Regula-Falsi methods).
 * * unfortunately the algorithm given on [Wikipedia](https://en.wikipedia.org/wiki/Brent%27s_method)
 * works but is not precisely Brent's method and runs about 2x or more slower
 * due to it not implementing the critically important 'micro-step' (Aug 2020).
 *
 * * the algorithm stops once the interval width becomes equal or less than
 * `2 * Number.EPSILON * max(1,abs(a),abs(b))` where `a` and `b` are the current
 * lower and upper interval limits
 *
 * * see [Brent (page 47)](https://maths-people.anu.edu.au/~brent/pd/rpb011i.pdf)
 *
 * @param f the function for which the root is sought.
 * @param lb the lower limit of the search interval.
 * @param ub the upper limit of the search interval.
 *
 * @example
 * ```typescript
 * let p = fromRoots([-10,2,3,4]);  //=> [1, 1, -64, 236, -240]
 * let f = t => Horner(p,t);
 * brent(f,2.2,3.8); //=> 3.000000000000003
 * brent(f,2.2,3.1); //=> 3.000000000000001
 * ```
 *
 * @doc
 */
function brent(f, lb, ub) {
    // Precondition: fa, fb !== 0
    //---- Make local copies of a and b.
    let a = lb;
    let b = ub;
    let fa = f(a);
    let fb = f(b);
    let c = a;
    let fc = fa;
    let e = b - a;
    let d = e;
    while (true) {
        if (brent_abs(fc) < brent_abs(fb)) {
            a = b;
            b = c;
            c = a;
            fa = fb;
            fb = fc;
            fc = fa;
        }
        const δ = 2 * brent_eps * brent_max(1, brent_abs(a), brent_abs(b));
        const m = 0.5 * (c - b);
        //if (abs(m) <= δ || fb === 0) {
        if (brent_abs(m) <= δ) {
            // uncomment below if range to be returned
            //return b < c ? [b,c] : [c,b];
            // uncomment below if leftmost guess to be returned
            //return b < c ? b : c;
            // uncomment below if rightmost guess to be returned
            //return b < c ? b : c;
            // uncomment below if any guess to be returned
            return b;
        }
        if (brent_abs(e) < δ || brent_abs(fa) <= brent_abs(fb)) {
            e = m;
            d = e;
        }
        else {
            let s = fb / fa;
            let p;
            let q;
            if (a === c) {
                p = 2 * m * s;
                q = 1 - s;
            }
            else {
                q = fa / fc;
                const r = fb / fc;
                p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));
                q = (q - 1) * (r - 1) * (s - 1);
            }
            if (0 < p) {
                q = -q;
            }
            else {
                p = -p;
            }
            s = e;
            e = d;
            if (2 * p < 3 * m * q - brent_abs(δ * q) && p < brent_abs(0.5 * s * q)) {
                d = p / q;
            }
            else {
                e = m;
                d = e;
            }
        }
        a = b;
        fa = fb;
        if (δ < brent_abs(d)) {
            b = b + d;
        }
        else if (0 < m) {
            b = b + δ;
        }
        else {
            //b = b - eps;
            b = b - δ;
        }
        fb = f(b);
        // inlined above line:
        //fb = p[0]; for (let i=1; i<p.length; i++) { fb = fb*b + p[i]; }
        if (fb === 0) {
            return b;
        }
        if (fb * fc > 0) {
            c = a;
            fc = fa;
            e = b - a;
            d = e;
        }
    }
}

//# sourceMappingURL=brent.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/naive/dd-deflate.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const qmd = node_ddMultDouble2;
const qaq = node_ddAddDd;
/**
 * Deflates the given polynomial *approximately* by removing a factor (x - r),
 * where r is a root of the polynomial.
 *
 * * **non-exact:** the deflation is done in double-double precision - it is not
 * possible to deflate a root exactly in most cases and round-off will thus
 * occur - use only if approximate deflation is acceptable
 *
 * @param p a polynomial with coefficients given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`
 * @param root a root of the polynomial.
 *
 * @example
 * ```typescript
 * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2
 * ddDeflate([[0,1], [0,-5], [0,8], [0,-4]], [0,2]); //=> [[0,1], [0,-3], [0,2]]
 * ddDeflate([[0,1], [0,-3], [0,2], [0,2]);          //=> [[0,1], [0,-1]]
 * ddDeflate([[0,1], [0,-1]], [0,1]);                //=> [[0,1]]
 * ```
 *
 * @doc
 */
function ddDeflate(p, root) {
    const d = p.length - 1;
    const bs = [p[0]];
    for (let i = 1; i < d; i++) {
        bs.push(qaq(p[i], qmd(root, bs[i - 1])));
    }
    return bs;
}

//# sourceMappingURL=dd-deflate.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/naive/deflate.js
/**
 * Deflates the given polynomial *approximately* by removing a factor (x - r),
 * where r is a root of the polynomial.
 *
 * * **non-exact:** the deflation is done in double precision - it is not
 * possible to deflate a root exactly in most cases and round-off will thus
 * occur - use only if approximate deflation is acceptable
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 * @param root a root of the polynomial.
 *
 * @example
 * ```typescript
 * // The polynomial x^3 - 5x^2 + 8x - 4 has a root at 1 and a double root at 2
 * deflate([1, -5, 8, -4], 2);  //=> [1, -3, 2]
 * deflate([1, -3, 2], 2);      //=> [1,-1]
 * deflate([1, -1], 1);         //=> [1]
 * ```
 *
 * @doc
 */
function deflate(p, root) {
    const d = p.length - 1;
    const bs = [p[0]];
    for (let i = 1; i < d; i++) {
        bs.push(p[i] + root * bs[i - 1]);
    }
    return bs;
}

//# sourceMappingURL=deflate.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/naive/quadratic-roots.js
/**
 * Floating-point-stably calculates and returns the ordered quadratic roots of
 * the given quadratic polynomial.
 *
 * * **precondition:** the input polynomial must be quadratic (given as an array
 * of exactly 3 values with the first value *unequal* to zero)
 * * **non-exact:** it is important to note that even though the roots are
 * calculated in a stable way they are still subject to round-off
 * * might be slightly faster than calling [[allRoots]].
 *
 * @param p a quadratic polynomial with coefficients given as an array
 * of double floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the quadratic `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * quadraticRoots([1, -3, 2]); //=> [1,2]
 * ```
 *
 * @doc
 */
function quadraticRoots(p) {
    const [a, b, c] = p;
    const _D = b * b - 4 * a * c;
    if (_D < 0) {
        // No real roots;
        return [];
    }
    if (_D === 0) {
        return [-b / (2 * a)];
    }
    const D = Math.sqrt(_D);
    if (b >= 0) {
        const root1 = (-b - D) / (2 * a);
        const root2 = (2 * c) / (-b - D);
        return root1 < root2
            ? [root1, root2]
            : [root2, root1];
    }
    const root1 = (2 * c) / (-b + D);
    const root2 = (-b + D) / (2 * a);
    return root1 < root2
        ? [root1, root2]
        : [root2, root1];
}

//# sourceMappingURL=quadratic-roots.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-fujiwara.js
/**
 * Returns an upper bound on the magnitude (absolute value) of the complex
 * roots of the given polynomial using the near-optimal Fujiwara bound.
 *
 * * the bound includes complex roots.
 * * the bound is quite tight
 *
 * * see [Wikipedia](https://en.wikipedia.org/wiki/Properties_of_polynomial_roots#Other_bounds)
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * rootMagnitudeUpperBound_fujiwara([2,-3,6,5,-130]); //=> 6.753296750770361
 * allRoots([2,-3,6,5,-130]); //=> [-2.397918624065303, 2.8793785310848383]
 * ```
 *
 * @doc
 */
function rootMagnitudeUpperBound_fujiwara(p) {
    if (p.length <= 1) {
        return 0;
    }
    const d = p.length - 1;
    const an = p[0];
    const bs = [];
    for (let i = 1; i < d; i++) {
        bs.push((Math.abs(p[i] / an)) ** (1 / i));
    }
    bs.push((Math.abs(p[d] / 2 * an)) ** (1 / d));
    return 2 * Math.max(...bs);
}

//# sourceMappingURL=root-magnitude-upper-bound-fujiwara.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/roots/root-bounds/root-magnitude-upper-bound-rouche.js

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const root_magnitude_upper_bound_rouche_pInfNorm = pInfNorm;
/**
 * Finds an upper bound on the magnitude (absolute value) of the roots
 * (including complex roots) of the given polynomial using Rouche's Theorem
 * with k = n.
 *
 * * fast but the bound is not very tight
 *
 * @param p a polynomial with coefficients given densely as an array of double
 * floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the polynomial `5x^2 - 3x`
 *
 * @doc
 */
function rootMagnitudeUpperBound_rouche(p) {
    if (p.length <= 1) {
        return 0;
    }
    return 1 + (root_magnitude_upper_bound_rouche_pInfNorm(p.slice(1)) / p[0]);
}

//# sourceMappingURL=root-magnitude-upper-bound-rouche.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/scale-to-int/scale-float-to-int.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const scale_float_to_int_exponent = exponent;
const scale_float_to_int_bitLength = bitLength;
/**
 * Returns the result of scaling the given float by a power of two such that
 * it becomes an integer (overflow not possible) - the smallest such integer is
 * returned.
 *
 * * the result is exact (no round-off can occur)
 *
 * @param a a double precision floating point number
 *
 * @doc
 */
function scaleFloatToInt(a) {
    if (a === 0) {
        return 0;
    }
    return a * 2 ** (-scale_float_to_int_exponent(a) + scale_float_to_int_bitLength(a) - 1);
}

//# sourceMappingURL=scale-float-to-int.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/scale-to-int/scale-float-to-bigint.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const scale_float_to_bigint_exponent = exponent;
const scale_float_to_bigint_bitLength = bitLength;
const scale_float_to_bigint_b0 = 0n; // temp until support is better otherwise test fails
/**
 * Returns the result of scaling the given float by a power of two such that
 * it becomes a bigint - the smallest such integer is returned.
 *
 * @param a a double precision floating point number
 *
 * @doc
 */
function scaleFloatToBigint(a) {
    if (a === 0) {
        return scale_float_to_bigint_b0;
    }
    return BigInt(a * 2 ** (-scale_float_to_bigint_exponent(a) + scale_float_to_bigint_bitLength(a) - 1));
}

//# sourceMappingURL=scale-float-to-bigint.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/scale-to-int/scale-floatss-to-bigintss.js


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const scale_floatss_to_bigintss_exponent = exponent;
const scale_floatss_to_bigintss_bitLength = bitLength;
const scale_floatss_to_bigintss_b0 = 0n; // so tests are not tripped up - awaiting better support
/**
 * Returns the result of scaling the given array of array of floats by the
 * *same* power of two such that all floats become bigints.
 *
 * * can be used to scale polynomials (with coefficients given as Shewchuk
 * expansions)
 *
 * @param ass an array of an array of double precision floating point numbers
 *
 * @doc
 */
function scaleFloatssToBigintss(ass) {
    let e = -1024;
    for (let i = 0; i < ass.length; i++) {
        const c = ass[i];
        for (let j = 0; j < c.length; j++) {
            const a = c[j];
            if (a === 0) {
                continue;
            }
            const scaleFactor = -scale_floatss_to_bigintss_exponent(a) + scale_floatss_to_bigintss_bitLength(a) - 1;
            if (scaleFactor > e) {
                e = scaleFactor;
            }
        }
    }
    // check for the trivial case
    if (e === 0) {
        return ass.map(as => as.map(a => BigInt(a)));
    }
    if (e > 0) {
        return ass.map(as => as.map(a => {
            if (a === 0) {
                return scale_floatss_to_bigintss_b0;
            }
            const scalePower = -scale_floatss_to_bigintss_exponent(a) + scale_floatss_to_bigintss_bitLength(a) - 1;
            // we first scale `a` to an integer without overflow and then
            // convert it to a bigint before multiplying
            return BigInt(a * 2 ** scalePower) * 2n ** BigInt(e - scalePower);
        }));
    }
    // overflow / underflow cannot occur
    return ass.map(as => as.map(a => BigInt(a * 2 ** e)));
}

//# sourceMappingURL=scale-floatss-to-bigintss.js.map
;// CONCATENATED MODULE: ./node_modules/flo-poly/node/index.js
// basic

// basic bigint












// basic double












// basic expansion














// calculus bigint

// calculus double

// calculus double-double


// calculus expansion

// change variables bigint




// change variables double




// change variables expansion




// error analysis



// euclidean division related bigint





// euclidean division related double


// euclidean division related expansion




// evaluate bigint



// evaluate double













// evaluate expansion




// factor bigint


// factor double


// factor expansion


// gcd bigint



// gcd double
//import { gcdPrs } from './gcd/double/gcd-prs.js';


// gcd expansion
//import { eGcdPrs } from './gcd/expansion/e-gcd-prs.js';


// norm bigint



// norm double



// norm expansion



// predictive random double





// predictive random bigint




// roots certified






// roots descartes bigint




// roots descartes double




// roots descartes expansion




// roots from roots



// roots naive







// roots root bounds






// scale to int






const flo_poly_node_operators = {
    // basic
    toCasStr: toCasStr,
    // basic bigint
    bAbsCoeff: bAbsCoeff,
    bAdd: bAdd,
    bDegree: bDegree,
    bDivideByConst: bDivideByConst,
    bEqual: bEqual,
    bInvert: bInvert,
    bIsRationalMultipleOf: bIsRationalMultipleOf,
    bMultiply: bMultiply,
    bMultiplyByConst: bMultiplyByConst,
    bNegate: bNegate,
    bRemoveLeadingZeros: bRemoveLeadingZeros,
    bSubtract: bSubtract,
    // basic double
    absCoeff: absCoeff,
    add: add_add,
    degree: degree,
    divideByConst: divideByConst,
    equal: equal_equal,
    invert: invert,
    isRationalMultipleOf: isRationalMultipleOf,
    multiply: multiply,
    multiplyByConst: multiplyByConst,
    negate: negate,
    removeLeadingZeros: removeLeadingZeros,
    subtract: subtract,
    // basic expansion
    eAbsCoeff: eAbsCoeff,
    eAdd: e_add_eAdd,
    eDegree: eDegree,
    eEqual: eEqual,
    eInvert: eInvert,
    eIsConstOrZero: eIsConstOrZero,
    eIsRationalMultipleOf: eIsRationalMultipleOf,
    eIsUnit: eIsUnit,
    eMultiply: eMultiply,
    eMultiplyByConst: eMultiplyByConst,
    eNegate: eNegate,
    eProduct: e_product_eProduct,
    eRemoveLeadingZeros: eRemoveLeadingZeros,
    eSubtract: eSubtract,
    // calculus bigint
    bDifferentiate: bDifferentiate,
    // calculus double
    differentiate: differentiate,
    // calculus double-double
    ddDifferentiate: ddDifferentiate,
    ddDifferentiateWithError: ddDifferentiateWithError,
    // calculus expansion
    eDifferentiate: eDifferentiate,
    // change variables bigint
    bChangeVariablesLinear: bChangeVariablesLinear,
    bChangeVariablesScale: bChangeVariablesScale,
    bChangeVariablesTranslateX: bChangeVariablesTranslateX,
    bReflectAboutYAxis: bReflectAboutYAxis,
    // change variables double
    changeVariablesLinear: changeVariablesLinear,
    changeVariablesScale: changeVariablesScale,
    changeVariablesTranslateX: changeVariablesTranslateX,
    reflectAboutYAxis: reflectAboutYAxis,
    // change variables expansion
    eChangeVariablesLinear: eChangeVariablesLinear,
    eChangeVariablesScale: eChangeVariablesScale,
    eChangeVariablesTranslateX: eChangeVariablesTranslateX,
    eReflectAboutYAxis: eReflectAboutYAxis,
    // error analysis
    conditionNumber: conditionNumber,
    γ: γ,
    γγ: γγ,
    // euclidean division related bigint
    bPdivTrivial: bPdivTrivial,
    bPremSequencePrimitive: bPremSequencePrimitive,
    bPremSequenceSubresultant: bPremSequenceSubresultant,
    bPremSequenceTrivial: bPremSequenceTrivial,
    bSturmChain: bSturmChain,
    // euclidean division related double
    premSequenceSubresultant: premSequenceSubresultant,
    sturmChain: sturmChain,
    // euclidean division related expansion
    ePdivTrivial: ePdivTrivial,
    ePremSequencePrimitive: ePremSequencePrimitive,
    ePremSequenceSubresultant: ePremSequenceSubresultant,
    eSturmChain: eSturmChain,
    // evaluate bigint
    bHorner: bHorner,
    bEvaluateAt0: bEvaluateAt0,
    bEvaluateAt1: bEvaluateAt1,
    // evaluate double
    AbsHorner: AbsHorner,
    compHorner: compHorner,
    compHornerIsFaithful: compHornerIsFaithful,
    CompHornerK: CompHornerK,
    compHornerWithRunningError: compHornerWithRunningError,
    EFTHorner: EFTHorner,
    evalCertified: evalCertified,
    evalCertifiedInclError: evalCertifiedInclError,
    evalK: evalK,
    evaluateAt0: evaluateAt0,
    evaluateAt1: evaluateAt1,
    Horner: Horner,
    hornerWithRunningError: hornerWithRunningError,
    // evaluate expansion
    eeHorner: eeHorner,
    eEvaluateAt0: eEvaluateAt0,
    eEvaluateAt1: eEvaluateAt1,
    eHorner: eHorner,
    // factor bigint
    bContent: bContent,
    bPrimitivePart: bPrimitivePart,
    // factor double
    content: content,
    primitivePart: primitivePart,
    // factor expansion
    eContent: eContent,
    ePrimitivePart: ePrimitivePart,
    // norm bigint
    bP1Norm: bP1Norm,
    bP2NormSquared: bP2NormSquared,
    bPInfNorm: bPInfNorm,
    // norm double
    p1Norm: p1Norm,
    p2Norm: p2Norm,
    pInfNorm: pInfNorm,
    // norm expansion
    eP1Norm: eP1Norm,
    eP2Norm: eP2Norm,
    ePInfNorm: ePInfNorm,
    // predictive random double
    flatRoots: flatRoots,
    flatRootsArr: flatRootsArr,
    flatCoefficients: flatCoefficients,
    flatCoefficientsArr: flatCoefficientsArr,
    predictiveRandom: predictiveRandom,
    // predictive random bigint
    bFlatRoots: bFlatRoots,
    bFlatRootsArr: bFlatRootsArr,
    bFlatCoefficients: bFlatCoefficients,
    bFlatCoefficientsArr: bFlatCoefficientsArr,
    // roots certified
    allRootsCertified: allRootsCertified,
    allRootsCertifiedSimplified: allRootsCertifiedSimplified,
    refineK1: refineK1,
    mid: mid,
    createRootExact: createRootExact,
    rootIntervalToExp: rootIntervalToExp,
    // roots descartes bigint
    bNumRoots: bNumRoots,
    bNumRootsIn01: bNumRootsIn01,
    bNumRootsInRange: bNumRootsInRange,
    bSignChanges: bSignChanges,
    // roots descartes double
    numRoots: numRoots,
    numRootsIn01: numRootsIn01,
    numRootsInRange: numRootsInRange,
    signChanges: signChanges,
    // roots descartes expansion
    eNumRoots: eNumRoots,
    eNumRootsIn01: eNumRootsIn01,
    eNumRootsInRange: eNumRootsInRange,
    eSignChanges: eSignChanges,
    // roots from roots
    bFromRoots: bFromRoots,
    fromRoots: fromRoots,
    eFromRoots: eFromRoots,
    // roots naive
    allRoots: allRoots,
    bisection: bisection,
    brent: brent,
    brentPoly: brentPoly,
    ddDeflate: ddDeflate,
    deflate: deflate,
    quadraticRoots: quadraticRoots,
    // roots root bounds
    positiveRootUpperBound_LMQ: positiveRootUpperBound_LMQ,
    positiveRootLowerBound_LMQ: positiveRootLowerBound_LMQ,
    negativeRootLowerBound_LMQ: negativeRootLowerBound_LMQ,
    negativeRootUpperBound_LMQ: negativeRootUpperBound_LMQ,
    rootMagnitudeUpperBound_fujiwara: rootMagnitudeUpperBound_fujiwara,
    rootMagnitudeUpperBound_rouche: rootMagnitudeUpperBound_rouche,
    // scale to int
    scaleFloatToInt: scaleFloatToInt,
    scaleFloatsToInts: scaleFloatsToInts,
    scaleFloatssToIntss: scaleFloatssToIntss,
    scaleFloatToBigint: scaleFloatToBigint,
    scaleFloatsToBigints: scaleFloatsToBigints,
    scaleFloatssToBigintss: scaleFloatssToBigintss,
    // gcd bigint
    bGcdPrs: bGcdPrs,
    bGcdInt: bGcdInt,
    bGcdInts: bGcdInts,
    // gcd double
    //gcdPrs,
    gcdInt: gcdInt,
    gcdInts: gcdInts,
    // gcd expansion
    //eGcdPrs,
    eGcdInt: eGcdInt,
    eGcdInts: eGcdInts
};


//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./src/local-properties-at-t/ds.ts


function ds(ps, t) {
    const [dX, dY] = getDxy(ps);
    function f(t) {
        const dx = Horner(dX, t);
        const dy = Horner(dY, t);
        return Math.sqrt(dx * dx + dy * dy);
    }
    // Curry
    return t === undefined ? f : f(t);
}


;// CONCATENATED MODULE: ./node_modules/flo-gauss-quadrature/node/index.js
// TODO A future improvement can be to use the Gauss–Kronrod rules
// to estimate the error and thus choose a number of constants based
// on the error.
// TODO In future, the constants can be calculated and cached so we can
// choose any value for the order.
/**
 * Numerically integrates the given function using the Gaussian Quadrature
 * method.
 *
 * See https://en.wikipedia.org/wiki/Gaussian_quadrature
 * See http://pomax.github.io/bezierinfo/#arclength
 * @param f The univariate function to be integrated
 * @param interval The integration interval
 * @param order Can be 2, 4, 8, or 16. Higher values give more accurate results
 * but is slower - defaults to 16.
 */
function gaussQuadrature(f, interval, order = 16) {
    if (interval[0] === interval[1]) {
        return 0;
    }
    let { weights, abscissas } = GAUSS_CONSTANTS[order];
    let [a, b] = interval;
    let result = 0;
    let m1 = (b - a) / 2;
    let m2 = (b + a) / 2;
    for (let i = 0; i <= order - 1; i++) {
        result += weights[i] * f(m1 * abscissas[i] + m2);
    }
    return m1 * result;
}
// The Gaussian Legendre Quadrature method constants. 
const GAUSS_CONSTANTS = {
    2: {
        weights: [1, 1],
        abscissas: [-0.5773502691896257, 0.5773502691896257]
    },
    4: {
        weights: [0.6521451548625461, 0.6521451548625461,
            0.3478548451374538, 0.3478548451374538],
        abscissas: [-0.3399810435848563, 0.3399810435848563,
            -0.8611363115940526, 0.8611363115940526]
    },
    8: {
        weights: [0.3626837833783620, 0.3626837833783620,
            0.3137066458778873, 0.3137066458778873,
            0.2223810344533745, 0.2223810344533745,
            0.1012285362903763, 0.1012285362903763],
        abscissas: [-0.1834346424956498, 0.1834346424956498,
            -0.5255324099163290, 0.5255324099163290,
            -0.7966664774136267, 0.7966664774136267,
            -0.9602898564975363, 0.9602898564975363]
    },
    // Taken from http://keisan.casio.com/exec/system/1330940731
    16: {
        abscissas: [-0.989400934991649932596,
            -0.944575023073232576078,
            -0.86563120238783174388,
            -0.7554044083550030338951,
            -0.6178762444026437484467,
            -0.4580167776572273863424,
            -0.28160355077925891323,
            -0.0950125098376374401853,
            0.0950125098376374401853,
            0.28160355077925891323,
            0.4580167776572273863424,
            0.617876244402643748447,
            0.755404408355003033895,
            0.8656312023878317438805,
            0.944575023073232576078,
            0.989400934991649932596
        ],
        weights: [
            0.0271524594117540948518,
            0.062253523938647892863,
            0.0951585116824927848099,
            0.1246289712555338720525,
            0.1495959888165767320815,
            0.169156519395002538189,
            0.182603415044923588867,
            0.189450610455068496285,
            0.1894506104550684962854,
            0.182603415044923588867,
            0.1691565193950025381893,
            0.149595988816576732081,
            0.124628971255533872053,
            0.095158511682492784809,
            0.062253523938647892863,
            0.027152459411754094852
        ]
    }
};

//# sourceMappingURL=index.js.map
;// CONCATENATED MODULE: ./src/global-properties/length/length-bez2.ts


/**
 * Returns the curve length in the specified interval. This function is curried.
 * @param ps A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]
 * @param interval The paramter interval over which the length is
 * to be calculated (often === [0,1]).
 *
 * @internal
 */
function lengthBez2(interval, ps) {
    if (interval[0] === interval[1]) {
        return 0;
    }
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    // Ensure zero length curve returns zero!
    if (x0 === x1 && x1 === x2 && y0 === y1 && y1 === y2) {
        return 0;
    }
    const evDs = ds(ps);
    return gaussQuadrature(evDs, interval);
}
/**
 * Returns the curve length in the specified interval. This function is curried.
 * Unused because it is not numerically stable in its current form.
 * See https://gist.github.com/tunght13488/6744e77c242cc7a94859
 * @param ps - A quadratic bezier, e.g. [[0,0],[1,1],[2,1]]
 * @param interval - The paramter interval over which the length is
 * to be calculated (often === [0,1]).
 */
/*
function lengthBez2(interval: number[], ps: number[][]) {
    if (interval[0] === interval[1]) { return 0; }

    const [[x0_, y0_], [x1_, y1_], [x2_, y2_]] = ps;
    // Keep line below to ensure zero length curve returns zero!
    if (x0_ === x1_ && x1_ === x2_ && y0_ === y1_ && y1_ === y2_) {
        return 0;
    }

    const [[x0, y0], [x1, y1], [x2, y2]] =
            fromTo(ps)(interval[0], interval[1]);

    const ax = x0 - 2*x1 + x2;
    const ay = y0 - 2*y1 + y2;
    const bx = 2*x1 - 2*x0;
    const by = 2*y1 - 2*y0;

    const A = 4 * (ax*ax + ay*ay);
    const B = 4 * (ax*bx + ay*by);
    const C = bx*bx + by*by;

    const Sabc = 2*Math.sqrt(A+B+C);
    const A_2 = Math.sqrt(A);
    const A_32 = 2*A*A_2;
    const C_2 = 2*Math.sqrt(C);
    const BA = B/A_2;

    return (
        A_32*Sabc + A_2*B*(Sabc - C_2) +
        (4*C*A - B*B)*Math.log((2*A_2 + BA + Sabc) / (BA + C_2))
    ) / (4*A_32);
}
*/


;// CONCATENATED MODULE: ./src/global-properties/length/length-bez3.ts


/**
 * Returns the curve length in the specified interval.
 *
 * @param ps a cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 * @param interval the paramter interval over which the length is to be
 * calculated (often === [0,1]).
 *
 * @internal
 */
function lengthBez3(interval, ps) {
    if (interval[0] === interval[1]) {
        return 0;
    }
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    // Keep line below to ensure zero length curve returns zero!
    if (x0 === x1 && x1 === x2 && x2 === x3 &&
        y0 === y1 && y1 === y2 && y2 === y3) {
        return 0;
    }
    const evDs = ds(ps);
    return gaussQuadrature(evDs, interval);
}


;// CONCATENATED MODULE: ./src/global-properties/length/length.ts



/**
 * Returns the curve length (linear, quadratic or cubic bezier) in the
 * specified interval calculated using Gaussian Quadrature.
 *
 * @param ps a bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 * @param interval the paramter interval over which the length is
 * to be calculated (typically `=== [0,1]`).
 *
 * @doc mdx
 */
function length_length(interval, ps) {
    if (ps.length === 4) {
        return lengthBez3(interval, ps);
    }
    if (ps.length === 3) {
        return lengthBez2(interval, ps);
    }
    if (ps.length === 2) {
        return lengthBez1(interval, ps);
    }
    if (ps.length === 1) {
        return 0;
    }
    throw new Error('The given bezier curve is invalid');
}


;// CONCATENATED MODULE: ./src/global-properties/length/total-length.ts



/**
 * Returns the curve (linear, quadratic or cubic bezier) length in the specified
 * interval calculated using Gaussian Quadrature.
 *
 * @param ps a cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 * @param interval the paramter interval over which the length is
 * to be calculated (usually === [0,1]).
 *
 * @doc mdx
 */
function totalLength(ps) {
    if (ps.length === 4) {
        return lengthBez3([0, 1], ps);
    }
    if (ps.length === 3) {
        return lengthBez2([0, 1], ps);
    }
    if (ps.length === 2) {
        return lengthBez1([0, 1], ps);
    }
    if (ps.length === 1) {
        return 0;
    }
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/transformation/clone.ts
/**
 * Returns a clone of the given cubic bezier (with a different reference).
 *
 * @param ps A cubic bezier given by its array of control points
 *
 * @doc
 */
function clone(ps) {
    if (ps.length === 4) {
        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];
    }
    else if (ps.length === 3) {
        const [[x0, y0], [x1, y1], [x2, y2]] = ps;
        return [[x0, y0], [x1, y1], [x2, y2]];
    }
    else if (ps.length === 2) {
        const [[x0, y0], [x1, y1]] = ps;
        return [[x0, y0], [x1, y1]];
    }
}


;// CONCATENATED MODULE: ./src/transformation/degree-or-type/linear-to-cubic.ts
/**
 * Returns a cubic bezier from the given line with evenly spaced control points.
 *
 * @param l a 2d line represented by two points
 *
 * @internal
 */
function linearToCubic(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    const xInterval = (x1 - x0) / 3;
    const yInterval = (y1 - y0) / 3;
    return [
        [x0, y0],
        [x0 + xInterval, y0 + yInterval],
        [x0 + xInterval * 2, y0 + yInterval * 2],
        [x1, y1]
    ];
}


;// CONCATENATED MODULE: ./src/transformation/degree-or-type/quadratic-to-cubic.ts
/**
 * Returns the cubic version of the given quadratic bezier curve. Quadratic
 * bezier curves can always be represented by cubics - the converse is false.
 *
 * @param ps a quadratic bezier curve.
 *
 * @internal
 */
function quadraticToCubic(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    return [
        [x0, y0],
        [(1 / 3) * x0 + (2 / 3) * x1, (1 / 3) * y0 + (2 / 3) * y1],
        [(2 / 3) * x1 + (1 / 3) * x2, (2 / 3) * y1 + (1 / 3) * y2],
        [x2, y2]
    ];
}


;// CONCATENATED MODULE: ./src/transformation/degree-or-type/to-cubic.ts


/**
 * Returns a cubic bezier curve that is equivalent to the given linear or
 * quadratic bezier curve. Cubics are just returned unaltered.
 *
 * @param ps An order 1, 2 or 3 bezier curve
 *
 * @doc mdx
 */
function toCubic(ps) {
    if (ps.length === 4) { // Cubic
        return ps;
    }
    if (ps.length === 3) { // Quadratic
        return quadraticToCubic(ps);
    }
    if (ps.length === 2) { // Linear
        return linearToCubic(ps);
    }
    if (ps.length === 1) { // Point
        const p = ps[0];
        return [p, p, p, p];
    }
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/local-properties-to-t/get-t-at-length.ts



function getTAtLength(ps, s) {
    let ps_ = toCubic(ps);
    const lenAtT = (t) => length_length([0, t], ps_);
    function f(s) {
        if (s === 0) {
            return 0;
        }
        return brent(t => (lenAtT(t) - s), 0, 1.125);
    }
    // Curry
    return s === undefined ? f : f(s);
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/equal.ts
/**
 * Returns true if the two given bezier curves are exactly equal when compared
 * by value (deep equality)
 *
 * @param ps1 an order 1, 2 or 3 bezier curve
 * @param ps2 another bezier curve
 *
 * @doc
 */
function simultaneous_properties_equal_equal(ps1, ps2) {
    if (ps1 === ps2) {
        return true;
    }
    if (ps1.length !== ps2.length) {
        return false;
    }
    for (let i = 0; i < ps1.length; i++) {
        if (ps1[i][0] !== ps2[i][0] || ps1[i][1] !== ps2[i][1]) {
            return false;
        }
    }
    return true;
}


;// CONCATENATED MODULE: ./src/transformation/cubic-to-quadratic.ts
/**
 * Returns the best least squares quadratic bezier approximation to the given
 * cubic bezier.
 * * the input and output bezier endpoints will differ in general
 *
 * @param ps - A cubic bezier curve.
 *
 * @doc
 */
function cubicToQuadratic(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    return [
        [(19 / 20) * x0 + (3 / 20) * x1 + (-3 / 20) * x2 + (1 / 20) * x3,
            (19 / 20) * y0 + (3 / 20) * y1 + (-3 / 20) * y2 + (1 / 20) * y3],
        [(-1 / 4) * x0 + (3 / 4) * x1 + (3 / 4) * x2 + (-1 / 4) * x3,
            (-1 / 4) * y0 + (3 / 4) * y1 + (3 / 4) * y2 + (-1 / 4) * y3],
        [(1 / 20) * x0 + (-3 / 20) * x1 + (3 / 20) * x2 + (19 / 20) * x3,
            (1 / 20) * y0 + (-3 / 20) * y1 + (3 / 20) * y2 + (19 / 20) * y3]
    ];
}


;// CONCATENATED MODULE: ./src/transformation/split-merge-clone/split-at.ts
// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗

const split_at_tp = two_product_twoProduct;
const sum = eSum;
const split_at_estimate = e_estimate_eEstimate;
const epr = expansion_product_expansionProduct;
const split_at_fes = fastExpansionSum;
const split_at_sce = scaleExpansion;
const splitAtFs = [splitLineAt, splitQuadAt, splitCubicAt];
/**
 * Returns 2 new beziers split at the given t parameter, i.e. for the ranges
 * [0,t] and [t,1].
 *
 * @param ps An order 1, 2 or 3 bezier curve
 * @param t The curve parameter
 *
 * @doc
 */
function splitAt(ps, t) {
    return splitAtFs[ps.length - 2](ps, t);
}
const splitAtPreciseFs = [
    splitLineAtPrecise,
    splitQuadAtPrecise,
    splitCubicAtPrecise
];
/**
 * Returns 2 new beziers split at the given t parameter, i.e. for the ranges
 * [0,t] and [t,1].
 *
 * The result is precise, i.e. each returned coordinate is rounded to the
 * nearest ulp (unit in the last place)
 *
 * @param ps An order 1, 2 or 3 bezier curve
 * @param t The curve parameter
 *
 * @doc
 */
function splitAtPrecise(ps, t) {
    return splitAtPreciseFs[ps.length - 2](ps, t);
}
const splitAtExactFs = [
    splitLineAtExact,
    splitQuadAtExact,
    splitCubicAtExact
];
// TODO - currently the bezier returned is exact, but not exactly according
// to the given ts due to division
function splitAtExact(ps, t) {
    return splitAtExactFs[ps.length - 2](ps, t);
}
/**
 * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges
 * [0,t] and [t,1]. Uses de Casteljau's algorithm.
 *
 * A loose bound on the accuracy of the resultant points is given by:
 * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points
 * and η is Number.EPSILON.
 *
 * @param ps A cubic bezier curve
 * @param t The t parameter where the curve should be split
 *
 * @doc
 */
function splitCubicAt(ps, t) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    const s = 1 - t;
    /** The split point */
    const p = [
        x3 * t ** 3 + 3 * x2 * s * t ** 2 + 3 * x1 * s ** 2 * t + x0 * s ** 3,
        y3 * t ** 3 + 3 * y2 * s * t ** 2 + 3 * y1 * s ** 2 * t + y0 * s ** 3
    ];
    const ps1 = [
        [x0, y0],
        [x1 * t + x0 * s,
            y1 * t + y0 * s],
        [x2 * t ** 2 + 2 * x1 * s * t + x0 * s ** 2,
            y2 * t ** 2 + 2 * y1 * s * t + y0 * s ** 2],
        p
    ];
    const ps2 = [
        p,
        [x3 * t ** 2 + 2 * x2 * t * s + x1 * s ** 2,
            y3 * t ** 2 + 2 * y2 * t * s + y1 * s ** 2],
        [x3 * t + x2 * s,
            y3 * t + y2 * s],
        [x3, y3]
    ];
    return [ps1, ps2];
}
function splitCubicAtExact(ps, t) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    const s = 1 - t;
    const s2 = split_at_tp(s, s);
    const s3 = split_at_sce(s2, s);
    const t2 = split_at_tp(t, t);
    const t3 = split_at_sce(t2, t);
    const st = split_at_tp(s, t);
    const st2 = split_at_sce(t2, s);
    const s2t = split_at_sce(s2, t);
    /** The split point */
    const p = [
        //x3*t**3 + 3*x2*s*t**2 + 3*x1*s**2*t + x0*s**3,
        //y3*t**3 + 3*y2*s*t**2 + 3*y1*s**2*t + y0*s**3
        sum([
            epr(t3, x3),
            epr(st2, split_at_sce(x2, 3)),
            epr(s2t, split_at_sce(x1, 3)),
            epr(s3, x0)
        ]),
        sum([
            epr(t3, y3),
            epr(st2, split_at_sce(y2, 3)),
            epr(s2t, split_at_sce(y1, 3)),
            epr(s3, y0)
        ])
    ];
    const ps1 = [
        [x0, y0],
        [
            //x1*t + x0*s,
            //y1*t + y0*s
            split_at_fes(split_at_sce(x1, t), split_at_sce(x0, s)),
            split_at_fes(split_at_sce(y1, t), split_at_sce(y0, s))
        ],
        [
            //x2*t**2 + 2*x1*s*t + x0*s**2, 
            //y2*t**2 + 2*y1*s*t + y0*s**2
            sum([
                epr(t2, x2),
                epr(st, split_at_sce(x1, 2)),
                epr(s2, x0)
            ]),
            sum([
                epr(t2, y2),
                epr(st, split_at_sce(y1, 2)),
                epr(s2, y0)
            ])
        ],
        p
    ];
    const ps2 = [
        p,
        [
            //x3*t**2 + 2*x2*t*s + x1*s**2, 
            //y3*t**2 + 2*y2*t*s + y1*s**2
            sum([
                epr(t2, x3),
                epr(st, split_at_sce(x2, 2)),
                epr(s2, x1)
            ]),
            sum([
                epr(t2, y3),
                epr(st, split_at_sce(y2, 2)),
                epr(s2, y1)
            ])
        ],
        [
            //x3*t + x2*s, 
            //y3*t + y2*s
            split_at_fes(split_at_sce(x3, t), split_at_sce(x2, s)),
            split_at_fes(split_at_sce(y3, t), split_at_sce(y2, s)),
        ],
        [x3, y3]
    ];
    return [ps1, ps2];
}
/**
 * Returns 2 new cubic beziers split at the given t parameter, i.e. for the ranges
 * [0,t] and [t,1]. Uses de Casteljau's algorithm.
 *
 * The result is precise, i.e. each returned coordinate is rounded to the
 * nearest ulp (unit in the last place)
 * @param ps A cubic bezier curve
 * @param t The t parameter where the curve should be split
 */
function splitCubicAtPrecise(ps, t) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    const s = 1 - t;
    const s2 = split_at_tp(s, s);
    const s3 = split_at_sce(s2, s);
    const t2 = split_at_tp(t, t);
    const t3 = split_at_sce(t2, t);
    const st = split_at_tp(s, t);
    const st2 = split_at_sce(t2, s);
    const s2t = split_at_sce(s2, t);
    /** The split point */
    const p = [
        //x3*t**3 + 3*x2*s*t**2 + 3*x1*s**2*t + x0*s**3,
        //y3*t**3 + 3*y2*s*t**2 + 3*y1*s**2*t + y0*s**3
        split_at_estimate(sum([
            split_at_sce(t3, x3),
            split_at_sce(st2, 3 * x2),
            split_at_sce(s2t, 3 * x1),
            split_at_sce(s3, x0)
        ])),
        split_at_estimate(sum([
            split_at_sce(t3, y3),
            split_at_sce(st2, 3 * y2),
            split_at_sce(s2t, 3 * y1),
            split_at_sce(s3, y0)
        ]))
    ];
    const ps1 = [
        [x0, y0],
        [
            //x1*t + x0*s,
            //y1*t + y0*s
            split_at_estimate(split_at_fes(split_at_tp(x1, t), split_at_tp(x0, s))),
            split_at_estimate(split_at_fes(split_at_tp(y1, t), split_at_tp(y0, s)))
        ],
        [
            //x2*t**2 + 2*x1*s*t + x0*s**2, 
            //y2*t**2 + 2*y1*s*t + y0*s**2
            split_at_estimate(sum([
                split_at_sce(t2, x2),
                split_at_sce(st, 2 * x1),
                split_at_sce(s2, x0)
            ])),
            split_at_estimate(sum([
                split_at_sce(t2, y2),
                split_at_sce(st, 2 * y1),
                split_at_sce(s2, y0)
            ]))
        ],
        p
    ];
    const ps2 = [
        p,
        [
            //x3*t**2 + 2*x2*t*s + x1*s**2, 
            //y3*t**2 + 2*y2*t*s + y1*s**2
            split_at_estimate(sum([
                split_at_sce(t2, x3),
                split_at_sce(st, 2 * x2),
                split_at_sce(s2, x1)
            ])),
            split_at_estimate(sum([
                split_at_sce(t2, y3),
                split_at_sce(st, 2 * y2),
                split_at_sce(s2, y1)
            ]))
        ],
        [
            //x3*t + x2*s, 
            //y3*t + y2*s
            split_at_estimate(split_at_fes(split_at_tp(x3, t), split_at_tp(x2, s))),
            split_at_estimate(split_at_fes(split_at_tp(y3, t), split_at_tp(y2, s))),
        ],
        [x3, y3]
    ];
    return [ps1, ps2];
}
function splitQuadAt(ps, t) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    const s = 1 - t;
    /** The split point */
    const p = [
        x0 * s ** 2 + 2 * x1 * s * t + x2 * t ** 2,
        y0 * s ** 2 + 2 * y1 * s * t + y2 * t ** 2
    ];
    const ps1 = [
        [x0, y0],
        [x0 * s + x1 * t,
            y0 * s + y1 * t],
        p
    ];
    const ps2 = [
        p,
        [x1 * s + x2 * t,
            y1 * s + y2 * t],
        [x2, y2]
    ];
    return [ps1, ps2];
}
function splitQuadAtExact(ps, t) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    const s = 1 - t;
    const t2 = split_at_tp(t, t);
    const s2 = split_at_tp(s, s);
    const st = split_at_tp(s, t);
    /** The split point */
    const p = [
        //x0*s**2 + 2*x1*s*t + x2*t**2,
        //y0*s**2 + 2*y1*s*t + y2*t**2
        sum([
            epr(s2, x0),
            epr(st, split_at_sce(x1, 2)),
            epr(t2, x2)
        ]),
        sum([
            epr(s2, y0),
            epr(st, split_at_sce(y1, 2)),
            epr(t2, y2)
        ])
    ];
    const ps1 = [
        [x0, y0],
        [
            //x0*s + x1*t, 
            //y0*s + y1*t
            split_at_fes(split_at_sce(x0, s), split_at_sce(x1, t)),
            split_at_fes(split_at_sce(y0, s), split_at_sce(y1, t)),
        ],
        p
    ];
    const ps2 = [
        p,
        [
            //x1*s + x2*t, 
            //y1*s + y2*t
            split_at_fes(split_at_sce(x1, s), split_at_sce(x2, t)),
            split_at_fes(split_at_sce(y1, s), split_at_sce(y2, t)),
        ],
        [x2, y2]
    ];
    return [ps1, ps2];
}
/**
 *
 * @param ps
 * @param t
 */
function splitQuadAtPrecise(ps, t) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    const s = 1 - t;
    const t2 = split_at_tp(t, t);
    const s2 = split_at_tp(s, s);
    const st = split_at_tp(s, t);
    /** The split point */
    const p = [
        //x0*s**2 + 2*x1*s*t + x2*t**2,
        //y0*s**2 + 2*y1*s*t + y2*t**2
        split_at_estimate(sum([
            split_at_sce(s2, x0),
            split_at_sce(st, 2 * x1),
            split_at_sce(t2, x2)
        ])),
        split_at_estimate(sum([
            split_at_sce(s2, y0),
            split_at_sce(st, 2 * y1),
            split_at_sce(t2, y2)
        ]))
    ];
    const ps1 = [
        [x0, y0],
        [
            //x0*s + x1*t, 
            //y0*s + y1*t
            split_at_estimate(split_at_fes(split_at_tp(x0, s), split_at_tp(x1, t))),
            split_at_estimate(split_at_fes(split_at_tp(y0, s), split_at_tp(y1, t))),
        ],
        p
    ];
    const ps2 = [
        p,
        [
            //x1*s + x2*t, 
            //y1*s + y2*t
            split_at_estimate(split_at_fes(split_at_tp(x1, s), split_at_tp(x2, t))),
            split_at_estimate(split_at_fes(split_at_tp(y1, s), split_at_tp(y2, t))),
        ],
        [x2, y2]
    ];
    return [ps1, ps2];
}
function splitLineAt(ps, t) {
    const [[x0, y0], [x1, y1]] = ps;
    const s = 1 - t;
    /** The split point */
    const p = [
        s * x0 + t * x1,
        s * y0 + t * y1
    ];
    const ps1 = [
        [x0, y0],
        p
    ];
    const ps2 = [
        p,
        [x1, y1]
    ];
    return [ps1, ps2];
}
function splitLineAtExact(ps, t) {
    const [[x0, y0], [x1, y1]] = ps;
    const s = 1 - t;
    /** The split point */
    const p = [
        //s*x0 + t*x1,
        //s*y0 + t*y1
        split_at_fes(split_at_sce(x0, s), split_at_sce(x1, t)),
        split_at_fes(split_at_sce(y0, s), split_at_sce(y1, t))
    ];
    const ps1 = [
        [x0, y0],
        p
    ];
    const ps2 = [
        p,
        [x1, y1]
    ];
    return [ps1, ps2];
}
/**
 *
 * @param ps
 * @param t
 */
function splitLineAtPrecise(ps, t) {
    const [[x0, y0], [x1, y1]] = ps;
    const s = 1 - t;
    /** The split point */
    const p = [
        //s*x0 + t*x1,
        //s*y0 + t*y1
        split_at_estimate(split_at_fes(split_at_tp(s, x0), split_at_tp(t, x1))),
        split_at_estimate(split_at_fes(split_at_tp(s, y0), split_at_tp(t, y1)))
    ];
    const ps1 = [
        [x0, y0],
        p
    ];
    const ps2 = [
        p,
        [x1, y1]
    ];
    return [ps1, ps2];
}


;// CONCATENATED MODULE: ./src/transformation/split-merge-clone/from-0-to-T.ts

/**
 * Returns an order 1, 2 or 3 bezier curve that starts at the given curve's t=0
 * and ends at the given t parameter.
 *
 * A loose bound on the accuracy of the resultant points is given by:
 * |δP| = 2n*max(|b_k|)η, where n = 3 (cubic), b_k are the control points
 * and η is Number.EPSILON.
 *
 * @param ps a cubic bezier curve
 * @param t the t parameter where the resultant bezier should end
 *
 * @doc
 */
function from0ToT(ps, t) {
    return splitAt(ps, t)[0];
}
/*
function from0ToT(ps: number[][], t: number): number[][] {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    
    const xs = [x0,x1,x2,x3];
    const ys = [y0,y1,y2,y3];

    const [x0_, x1_, x2_, x3_] = deCasteljau(xs, t)[0];
    const [y0_, y1_, y2_, y3_] = deCasteljau(ys, t)[0];

    return [[x0_, y0_], [x1_, y1_], [x2_, y2_], [x3_, y3_]];
}
*/


;// CONCATENATED MODULE: ./src/transformation/split-merge-clone/from-T-to-1.ts

/**
 * Returns an order 1, 2 or 3 bezier curve that starts at the given t parameter
 * and ends at t=1.
 *
 * A loose bound on the accuracy of the resultant points is given by:
 * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points
 * abd η is Number.EPSILON.
 *
 * @param ps a cubic bezier curve
 * @param t the t parameter where the resultant bezier should start
 *
 * @doc
 */
function fromTTo1(ps, t) {
    return splitAt(ps, t)[1];
}
/*
function fromTTo1(ps: number[][], t: number): number[][] {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    
    const xs = [x0,x1,x2,x3];
    const ys = [y0,y1,y2,y3];

    const [x0_, x1_, x2_, x3_] = deCasteljau(xs, t)[1];
    const [y0_, y1_, y2_, y3_] = deCasteljau(ys, t)[1];

    return [[x0_, y0_], [x1_, y1_], [x2_, y2_], [x3_, y3_]];
}
*/


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-xy/double/eval-de-casteljau.ts
/**
 * Returns the result of evaluating the given bezier curve at the parameter `t`
 * using [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)
 * in double precision floating point arithmetic.
 *
 * The resulting point `p` is returned as the pair `[x,y]`, where `x` and `y` are
 * double precision floating point numbers.
 *
 * * max bit-aligned bitlength increase: ??? bits TODO
 *
 * @param ps an order 1, 2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 * @param t the parameter value where the bezier should be evaluated
 *
 * @doc mdx
 **/
function evalDeCasteljau(ps, t) {
    if (t === 0) {
        return ps[0];
    }
    else if (t === 1) {
        return ps[ps.length - 1];
    }
    if (ps.length === 4) {
        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        const a01 = x0 + (x1 - x0) * t;
        const a11 = x1 + (x2 - x1) * t;
        const a21 = x2 + (x3 - x2) * t;
        const a02 = a01 + (a11 - a01) * t;
        const a12 = a11 + (a21 - a11) * t;
        const x = a02 + (a12 - a02) * t;
        const b01 = y0 + (y1 - y0) * t;
        const b11 = y1 + (y2 - y1) * t;
        const b21 = y2 + (y3 - y2) * t;
        const b02 = b01 + (b11 - b01) * t;
        const b12 = b11 + (b21 - b11) * t;
        const y = b02 + (b12 - b02) * t;
        return [x, y];
    }
    if (ps.length === 3) {
        const [[x0, y0], [x1, y1], [x2, y2]] = ps;
        const a01 = x0 + (x1 - x0) * t;
        const a11 = x1 + (x2 - x1) * t;
        const x = a01 + (a11 - a01) * t;
        const b01 = y0 + (y1 - y0) * t;
        const b11 = y1 + (y2 - y1) * t;
        const y = b01 + (b11 - b01) * t;
        return [x, y];
    }
    if (ps.length === 2) {
        const [[x0, y0], [x1, y1]] = ps;
        const x = x0 + (x1 - x0) * t;
        const y = y0 + (y1 - y0) * t;
        return [x, y];
    }
    if (ps.length === 1) {
        return ps[0];
    }
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/transformation/from-bezier-piece.ts



/**
 * Returns a new bezier from the given bezier by limiting its t range.
 *
 * Uses de Casteljau's algorithm.
 *
 * @param bezierPart A partial bezier
 *
 * @doc
 */
function bezierFromPart(bezierPart) {
    const { ps, ts } = bezierPart;
    // If ts = [0,1] then return original bezier.
    if (ts[0] === 0 && ts[1] === 1) {
        return ps;
    }
    // If ts[0] === ts[1] then return a single point degenerated bezier.
    if (ts[0] === ts[1]) {
        const p = evalDeCasteljau(ps, ts[0]);
        return [p, p, p, p];
    }
    if (ts[0] === 0) {
        return from0ToT(ps, ts[1]);
    }
    if (ts[1] === 1) {
        return fromTTo1(ps, ts[0]);
    }
    // At this stage we know the t range is not degenerate and ts[0] !== 0 
    // and ts[1] !== 1
    return from0ToT(fromTTo1(ps, ts[0]), (ts[1] - ts[0]) / (1 - ts[0]));
}


;// CONCATENATED MODULE: ./src/global-properties/bounds/get-control-point-box.ts
function getControlPointBox(ps) {
    let minX = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    for (const p of ps) {
        const x = p[0];
        const y = p[1];
        if (x < minX) {
            minX = x;
        }
        if (x > maxX) {
            maxX = x;
        }
        if (y < minY) {
            minY = y;
        }
        if (y > maxY) {
            maxY = y;
        }
    }
    return [[minX, minY], [maxX, maxY]];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/closest-point-on-bezier/get-coeffs/double/get-closest-on-bezier3-from-point.ts
function getClosestOnBezier3FromPoint(ps, p) {
    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    //const [xp, yp] = p;
    const p0 = ps[0];
    const p1 = ps[1];
    const p2 = ps[2];
    const p3 = ps[3];
    const x0 = p0[0];
    const y0 = p0[1];
    const x1 = p1[0];
    const y1 = p1[1];
    const x2 = p2[0];
    const y2 = p2[1];
    const x3 = p3[0];
    const y3 = p3[1];
    const xp = p[0];
    const yp = p[1];
    const xx0 = x0 - xp;
    const xx1 = x1 - xp;
    const xx2 = x2 - xp;
    const xx3 = x3 - xp;
    const yy0 = y0 - yp;
    const yy1 = y1 - yp;
    const yy2 = y2 - yp;
    const yy3 = y3 - yp;
    const x00 = xx0 * xx0;
    const x01 = 6 * xx0 * xx1;
    const x02 = 6 * xx0 * xx2;
    const x03 = 2 * xx0 * xx3;
    const x11 = 9 * xx1 * xx1;
    const x12 = 18 * xx1 * xx2;
    const x13 = 6 * xx1 * xx3;
    const x22 = 9 * xx2 * xx2;
    const x23 = 6 * xx2 * xx3;
    const x33 = xx3 * xx3;
    const y00 = yy0 * yy0;
    const y01 = 6 * yy0 * yy1;
    const y02 = 6 * yy0 * yy2;
    const y03 = 2 * yy0 * yy3;
    const y11 = 9 * yy1 * yy1;
    const y12 = 18 * yy1 * yy2;
    const y13 = 6 * yy1 * yy3;
    const y22 = 9 * yy2 * yy2;
    const y23 = 6 * yy2 * yy3;
    const y33 = yy3 * yy3;
    const q1 = x13 + x22;
    const q2 = x03 + x12;
    const q3 = x02 + x11;
    const r1 = y13 + y22;
    const r2 = y03 + y12;
    const r3 = y02 + y11;
    const t5 = 6 * (((((x33 - x23) + (x00 - x01)) + q1) + (q3 - q2)) +
        ((((y33 - y23) + (y00 - y01)) + r1) + (r3 - r2)));
    const t4 = 5 * ((((x23 + 5 * x01) + 3 * q2) - 2 * (q1 + 2 * q3 + 3 * x00)) +
        (((y23 + 5 * y01) + 3 * r2) - 2 * (r1 + 2 * r3 + 3 * y00)));
    const t3 = 4 * (((q1 - 3 * (q2 - 2 * q3)) - 5 * (2 * x01 - 3 * x00)) +
        ((r1 - 3 * (r2 - 2 * r3)) - 5 * (2 * y01 - 3 * y00)));
    const t2 = 3 * ((q2 - 2 * (2 * q3 - 5 * (x01 - 2 * x00))) +
        (r2 - 2 * (2 * r3 - 5 * (y01 - 2 * y00))));
    const t1 = 2 * ((q3 - 5 * (x01 - 3 * x00)) +
        (r3 - 5 * (y01 - 3 * y00)));
    const t0 = ((x01 - 6 * x00) +
        (y01 - 6 * y00));
    return [t5, t4, t3, t2, t1, t0];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/closest-point-on-bezier/get-coeffs/double/get-closest-on-bezier2-from-point.ts
function getClosestOnBezier2FromPoint(ps, p) {
    //const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    //const [xp, yp] = p;
    const p0 = ps[0];
    const p1 = ps[1];
    const p2 = ps[2];
    const x0 = p0[0];
    const y0 = p0[1];
    const x1 = p1[0];
    const y1 = p1[1];
    const x2 = p2[0];
    const y2 = p2[1];
    const xp = p[0];
    const yp = p[1];
    const xx0 = x0 - xp;
    const xx1 = x1 - xp;
    const xx2 = x2 - xp;
    const yy0 = y0 - yp;
    const yy1 = y1 - yp;
    const yy2 = y2 - yp;
    const x00 = xx0 * xx0;
    const x01 = xx0 * xx1;
    const x02 = xx0 * xx2;
    const x11 = xx1 * xx1;
    const x12 = xx1 * xx2;
    const x22 = xx2 * xx2;
    const y00 = yy0 * yy0;
    const y01 = yy0 * yy1;
    const y02 = yy0 * yy2;
    const y11 = yy1 * yy1;
    const y12 = yy1 * yy2;
    const y22 = yy2 * yy2;
    const q1 = y02 + 2 * y11;
    const r1 = x02 + 2 * x11;
    const t3 = ((y22 + y00) + 2 * q1 - 4 * (y12 + y01)) +
        ((x22 + x00) + 2 * r1 - 4 * (x12 + x01));
    const t2 = 3 * (((y12 - q1) + (3 * y01 - y00)) +
        ((x12 - r1) + (3 * x01 - x00)));
    const t1 = (q1 - 3 * (2 * y01 - y00)) +
        (r1 - 3 * (2 * x01 - x00));
    const t0 = (y01 - y00) +
        (x01 - x00);
    return [t3, t2, t1, t0];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/closest-point-on-bezier/get-coeffs/double/get-closest-on-bezier1-from-point.ts
function getClosestOnBezier1FromPoint(ps, p) {
    const [[x0, y0], [x1, y1]] = ps;
    const [xp, yp] = p;
    const xx0 = x0 - xp;
    const xx1 = x1 - xp;
    const yy0 = y0 - yp;
    const yy1 = y1 - yp;
    const x01 = xx0 * xx1;
    const y01 = yy0 * yy1;
    const s1 = x01 + y01;
    const s2 = yy0 * yy0 + xx0 * xx0;
    const t1 = (xx1 * xx1 + yy1 * yy1) + (s2 - 2 * s1);
    const t0 = s1 - s2;
    return [t1, t0];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier.ts






function closestPointOnBezier(ps, p) {
    let poly;
    if (ps.length === 4) {
        poly = getClosestOnBezier3FromPoint(ps, p);
    }
    else if (ps.length === 3) {
        poly = getClosestOnBezier2FromPoint(ps, p);
    }
    else if (ps.length === 2) {
        poly = getClosestOnBezier1FromPoint(ps, p);
    }
    else {
        // TODO - add case of degenerate point
        throw new Error('The given bezier curve is invalid.');
    }
    const ts = allRoots(poly, 0, 1);
    ts.push(0);
    ts.push(1);
    // Get point with minimum distance
    let minD = Number.POSITIVE_INFINITY;
    let minP = undefined;
    for (const t of ts) {
        const p_ = evalDeCasteljau(ps, t);
        const d = squared_distance_between_squaredDistanceBetween(p_, p);
        if (d < minD) {
            minD = d;
            minP = { p: p_, t };
        }
    }
    // keep TypeScript happy; `minP` cannot be `undefined` here
    return minP;
}


;// CONCATENATED MODULE: ./src/intersection/bezier3-intersection/clip/to-hybrid-quadratic.ts
/**
 * Returns a hybrid quadratic bezier curve with error bounds (with the first
 * and last control points omitted).
 *
 * * **the returned error bounds have counters of <8> and <12> respectively for
 * the 1st and 2nd control points (i.e. for the hybrid control points)**
 * * specifically modified for use in the geometric interval bezier-bezier
 * intersection algorithm, e.g. for efficiency the first and last points are
 * not returned
 * * **precondition:** coordinate-wise error bound 'Wilson counters' on the
 * cubic bezier control points of
 * `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]` are assumed (due to other
 * parts of the algorithm)
 *
 * @param G a cubic bezier curve - coordinate error bounds are assumed to have
 * counters of `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]`
 *
 * @internal
 */
function toHybridQuadratic(G) {
    // the below is too slow
    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; 
    const Gps = G.ps; // the cubic bezier curve
    const G_ps = G._ps; // and its error bound coordinates
    const p0 = Gps[0];
    const p1 = Gps[1];
    const p2 = Gps[2];
    const p3 = Gps[3];
    const x0 = p0[0]; // <6>x0
    const y0 = p0[1]; // <6>y0
    const x1 = p1[0]; // <6>x1
    const y1 = p1[1]; // <6>y1
    const x2 = p2[0]; // <10>x2
    const y2 = p2[1]; // <10>y2
    const x3 = p3[0]; // <11>x3
    const y3 = p3[1]; // <11>y3
    const _p0 = G_ps[0];
    const _p1 = G_ps[1];
    const _p2 = G_ps[2];
    const _p3 = G_ps[3];
    const _x0 = _p0[0];
    const _y0 = _p0[1];
    const _x1 = _p1[0];
    const _y1 = _p1[1];
    const _x2 = _p2[0];
    const _y2 = _p2[1];
    const _x3 = _p3[0];
    const _y3 = _p3[1];
    // <8> <= <8>(<7>(<0>3*<6>x1) + <6>x0)
    const _hq1 = [(3 * _x1 + _x0) / 2, (3 * _y1 + _y0) / 2];
    // <12> <= <12>(<11>(<0>3*<10>x2) + <11>x3)
    const _hq2 = [(3 * _x2 + _x3) / 2, (3 * _y2 + _y3) / 2];
    return {
        hq: [[(3 * x1 - x0) / 2, (3 * y1 - y0) / 2],
            [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2]],
        // error bounds (still need to be multiplied by 4*u and 6*u)
        _hq: [_hq1, _hq2]
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier3-intersection/clip/geo-clip.ts

const __debug__ = (typeof globalThis !== 'undefined' && globalThis.__debug__)
    ? globalThis.__debug__
    : undefined;
const geo_clip_toHybridQuadratic = toHybridQuadratic;
const geo_clip_min = Math.min;
const geo_clip_max = Math.max;
const geo_clip_abs = Math.abs;
const geo_clip_eps = Number.EPSILON;
const geo_clip_u = geo_clip_eps / 2;
const onemin = 1 - geo_clip_eps;
const onemax = 1 + geo_clip_eps;
const noIntersection = undefined;
const noClip = [0, 1];
/**
 * Performs geometric clipping of the given bezier curve and returns the new
 * minimum and maximum `t` parameter values.
 *
 * * helper function to the geometric interval bezier-bezier intersection
 * algorithm
 * * the returned min and max `t` values has the following guarantees:
 *   * `Number.EPSILON | t`
 *   * `0 <= t <= 1`
 *
 * @param G the bezier curve to be geo clipped - coordinate error bounds are
 * assumed to have counters of `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]`
 * @param dF function to calculate a min and max distance to the fat line's 'baseline'
 * @param dMin fat line min signed distance
 * @param dMax fat line max signed distance
 *
 * @internal
 */
function geoClip(G, dF, dMin, dMax) {
    // estimated bezier control points
    const Gps = G.ps;
    const lenG = Gps.length;
    const _hq_ = lenG === 4
        ? geo_clip_toHybridQuadratic(G)
        : { hq: [Gps[1], Gps[1]], _hq: [[0, 0], [0, 0]] }; // degenerate
    // estimated hybrid coordinates
    const hq = _hq_.hq;
    // hybrid coordinate error bounds with error counters of <8> and <12> for
    // the two points respectively (both x and y coordinates have same error
    // counters)
    const _hq = _hq_._hq;
    // coordinate error bounds are assumed to have counters 
    // of `[[<6>,<6>], [<6>,<6>], [<10>,<10>], [<11>,<11>]]`
    const G_ps = G._ps;
    /** min/max distance (from line) to hybrid quadratic (and cubic) first control point */
    const dH0 = dF(Gps[0], G_ps[0]);
    /** min/max distance (from line) to hybrid quadratic (and cubic) last control point */
    const dH2 = dF(Gps[lenG - 1], G_ps[lenG - 1]);
    /** min/max distance (from line) to hybrid quadratic's moving control point start */
    const dH10 = dF(hq[0], _hq[0]);
    /** min/max distance (from line) to hybrid quadratic's moving control point end */
    const dH11 = dF(hq[1], _hq[1]);
    const dH1min = geo_clip_min(dH10.dMin, dH11.dMin);
    const dH1max = geo_clip_max(dH10.dMax, dH11.dMax);
    if (__debug__ !== undefined && !__debug__.already) {
        const currentIter = __debug__.currentIter;
        // just for drawing purposes (not perfectle accurate)
        currentIter.hq = [G.ps[0], ...hq, G.ps[lenG - 1]];
        if (currentIter.geo) {
            // we already did the first geoclip - assume this to be the perpendicular clip
            currentIter.geoPerp = { dH0, dH10, dH11, dH2, dMin, dMax };
        }
        else {
            currentIter.geo = { dH0, dH10, dH11, dH2, dMin, dMax };
        }
    }
    const dH0Min = dH0.dMin;
    const dH0Max = dH0.dMax;
    const dH2Min = dH2.dMin;
    const dH2Max = dH2.dMax;
    //--------------------------------------------------------------------------
    // see the paper at https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?referer=&httpsredir=1&article=2206&context=etd)
    // After writing eq. (3.16) and (3.17) in power basis (by simply multiplying 
    // out and collecting terms) and taking error bounds into account:
    //--------------------------------------------------------------------------
    /** the quadratic term coefficient of the *lower* Bernstein basis polynomial */
    const a = dH0Min - 2 * dH1min + dH2Min; // t^2 
    /** the linear term coefficient of the *lower* Bernstein basis polynomial */
    const b = -2 * (dH0Min - dH1min); // t^1
    /**
     * the constant term coefficient of the *lower* Bernstein basis polynomial's
     * intersection with the lower fat line (dMin)
     */
    const c1 = dH0Min - dMin; // t^0 - dMin
    /**
     * the constant term coefficient of the *lower* Bernstein basis polynomial's
     * intersection with the upper fat line (dMax)
     */
    const c2 = dH0Min - dMax; // t^0 - dMax
    /** the quadratic term coefficient of the *upper* Bernstein basis polynomial */
    const d = dH0Max - 2 * dH1max + dH2Max;
    /** the linear term coefficient of the *upper* Bernstein basis polynomial */
    const e = -2 * (dH0Max - dH1max);
    /**
     * the constant term coefficient of the *upper* Bernstein basis polynomial's
     * intersection with the *lower* fat line (dMin)
     */
    const f1 = dH0Max - dMin;
    /**
     * the constant term coefficient of the *upper* Bernstein basis polynomial's
     * intersection with the *upper* fat line (dMax)
     */
    const f2 = dH0Max - dMax;
    //--------------------------------------------------------------------------
    let tMin = Number.POSITIVE_INFINITY;
    let tMax = Number.NEGATIVE_INFINITY;
    /** *lower* Bernstein *lower* fatline roots */
    const rootsMinBMinF = geo_clip_quadraticRoots(a, b, c1);
    /** *lower* Bernstein *upper* fatline roots */
    const rootsMinBMaxF = geo_clip_quadraticRoots(a, b, c2);
    /** *upper* Bernstein *lower* fatline roots */
    const rootsMaxBMinF = geo_clip_quadraticRoots(d, e, f1);
    /** *upper* Bernstein *upper* fatline roots */
    const rootsMaxBMaxF = geo_clip_quadraticRoots(d, e, f2);
    // if there are an infinite number of roots, i.e. if the quadratic is
    // really the zero polynomial (of negative infinite degree)
    if (rootsMinBMinF === undefined || rootsMinBMaxF === undefined ||
        rootsMaxBMinF === undefined || rootsMaxBMaxF === undefined) {
        // no clipping could happen
        return noClip;
    }
    //--------------------------------------------------------------------------
    // see the paper at https://scholarsarchive.byu.edu/cgi/viewcontent.cgi?referer=&httpsredir=1&article=2206&context=etd)
    // According to the paper we can do clipping such that 2 intervals are
    // sometimes returned. We just return the combined interval in those cases
    // which might make the algorithm slightly slower but a bit simpler.
    //--------------------------------------------------------------------------
    for (let i = 0; i < rootsMinBMinF.length; i++) {
        const r = rootsMinBMinF[i];
        if (r < tMin) {
            tMin = r;
        }
        if (r > tMax) {
            tMax = r;
        }
    }
    for (let i = 0; i < rootsMinBMaxF.length; i++) {
        const r = rootsMinBMaxF[i];
        if (r < tMin) {
            tMin = r;
        }
        if (r > tMax) {
            tMax = r;
        }
    }
    for (let i = 0; i < rootsMaxBMinF.length; i++) {
        const r = rootsMaxBMinF[i];
        if (r < tMin) {
            tMin = r;
        }
        if (r > tMax) {
            tMax = r;
        }
    }
    for (let i = 0; i < rootsMaxBMaxF.length; i++) {
        const r = rootsMaxBMaxF[i];
        if (r < tMin) {
            tMin = r;
        }
        if (r > tMax) {
            tMax = r;
        }
    }
    if (dH0Max >= dMin && dH0Min <= dMax) {
        tMin = 0;
    }
    if (dH2Max >= dMin && dH2Min <= dMax) {
        tMax = 1;
    }
    if (tMin === Number.POSITIVE_INFINITY) {
        // will have here also: `tMax === Number.NEGATIVE_INFINITY`
        return noIntersection;
    }
    return [tMin, tMax];
}
/**
 * Floating-point-stably calculates and returns the (ordered) quadratic roots of
 * the given quadratic polynomial in [0,1].
 *
 * * **precondition:** the input polynomial must be quadratic (given as an array
 * of exactly 3 values with the first value *unequal* to zero)
 *
 * @param p a quadratic polynomial with coefficients given as an array
 * of double floating point numbers from highest to lowest power, e.g. `[5,-3,0]`
 * represents the quadratic `5x^2 - 3x`
 *
 * @example
 * ```typescript
 * quadraticRoots([1, -3, 2]); //=> [1,2]
 * ```
 *
 * @doc
 */
function geo_clip_quadraticRoots(a, b, c) {
    if (a === 0) {
        if (b === 0) {
            // degenerate constant (degree 0 polynomial)
            if (c === 0) {
                // degenerate zero polynomial (degree -infinity polynomial)
                // infinite number of roots
                return undefined;
            }
            // no roots
            return [];
        }
        // degenerate linear
        //return [-c/b];
        const r = -c / b;
        const E = geo_clip_abs(r * geo_clip_u);
        const Emin = r - E;
        const Emax = r + E;
        if (Emax < 0 || Emin > 1) {
            return [];
        }
        if (Emin < 0 && Emax > 0) {
            return [0, Emax];
        }
        if (Emin < 1 && Emax > 1) {
            return [Emin, 1];
        }
        // we return the root interval pairs inline to account for error
        return [Emin, Emax];
    }
    if (c === 0) {
        const r = -b / a;
        const E = geo_clip_abs(r * geo_clip_u);
        const Emin = r - E;
        const Emax = r + E;
        if (Emax < 0 || Emin > 1) {
            return [0];
        }
        if (Emin < 0 && Emax > 0) {
            return [0, Emax];
        }
        if (Emin < 1 && Emax > 1) {
            return [0, Emin, 1];
        }
        // we return the root interval pairs inline to account for error
        return [0, Emin, Emax];
    }
    const D1 = b * b; // <1>D1 (error counters)
    const D2 = 4 * a * c; // <1>D2
    const D = D1 - D2;
    // <2>D <= D1 - D2;  // <2>(<1>D1 + <1>D2)
    const _D = D1 + geo_clip_abs(D2);
    const D_ = 2 * geo_clip_u * _D;
    if (D + D_ < 0) {
        // no real roots possible
        return [];
    }
    // at this point `D + D_ >= 0`
    if (D + D_ === 0) {
        const r = -b / (2 * a);
        const E = geo_clip_abs(r * geo_clip_u); // single division error
        const Emin = r - E;
        const Emax = r + E;
        if (Emax < 0 || Emin > 1) {
            return [];
        }
        if (Emin < 0 && Emax > 0) {
            return [0, Emax];
        }
        if (Emin < 1 && Emax > 1) {
            return [Emin, 1];
        }
        // we return the root interval pairs inline to account for error
        return [Emin, Emax];
    }
    // at this point `D + D_ > 0`
    const Dmin = D - D_ < 0 ? 0 : D - D_;
    const DDmin = Math.sqrt(Dmin) * (onemin);
    const DDmax = Math.sqrt(D + D_) * (onemax);
    // at this point DDMax > 0
    // at this point `DDmax > 0` and `DDmin >= 0`
    let numerMaxAbs;
    let numerMinAbs;
    if (b >= 0) {
        numerMaxAbs = -b - DDmax;
        numerMinAbs = -b - DDmin;
    }
    else {
        numerMinAbs = -b + DDmin;
        numerMaxAbs = -b + DDmax;
    }
    const a2 = 2 * a;
    const c2 = 2 * c;
    //const r1 = numerMin / a2;
    //const r2 = c2 / numerMin;
    // at this point `numerMin` and `numerMax` have the same sign (or numerMin is zero)
    let r1min;
    let r1max;
    let r2min;
    let r2max;
    if (numerMaxAbs * a2 >= 0) {
        // same signs - `r1min >= 0` and `r1max > 0`
        r1min = (numerMinAbs / a2) * (onemin);
        r1max = (numerMaxAbs / a2) * (onemax);
    }
    else {
        // opposite signs - `r1min <= 0` and `r1max < 0`
        r1min = (numerMaxAbs / a2) * (onemax);
        r1max = (numerMinAbs / a2) * (onemin);
    }
    if (numerMaxAbs * c2 > 0) {
        // same signs - `r2min > 0` and `r2Max >= 0`
        r2min = (c2 / numerMaxAbs) * (onemin);
        // `r2max` cannot be a `NaN` since `c2` is > 0
        r2max = (c2 / numerMinAbs) * (onemax); // could be +-inf
    }
    else if (numerMaxAbs * c2 < 0) {
        // opposite signs - `r2min < 0` and `r2Max <= 0`
        // `r2min` cannot be a `NaN` since `c2` is > 0
        r2min = (c2 / numerMinAbs) * (onemax); // could be +-inf 
        r2max = (c2 / numerMaxAbs) * (onemin);
    }
    const rs = [];
    if (r1max < 0 || r1min > 1) {
        // root is outside of range
    }
    else {
        // we return the root interval pairs inline
        // at this stage r1min might be (slightly) < 0 and r1max > 1
        rs.push(r1min < 0 ? 0 : r1min, r1max > 1 ? 1 : r1max);
    }
    // keep TypeScript happy; `r2max` cannot be `undefined` at this point
    if (r2max < 0 || r2min > 1) {
        // root is outside of range
    }
    else {
        // we return the root interval pairs inline
        // at this stage r2min might be (slightly) < 0 and r2max > 1
        // keep TypeScript happy; `r2max` cannot be `undefined` at this point
        rs.push(r2min < 0 ? 0 : r2min, r2max > 1 ? 1 : r2max);
    }
    return rs; // not ordered
}


;// CONCATENATED MODULE: ./src/intersection/bezier3-intersection/get-distance-to-line-function.ts

const get_distance_to_line_function_tp = node_twoProduct;
const qdq = node_ddDiffDd;
const get_distance_to_line_function_abs = Math.abs;
const get_distance_to_line_function_eps = Number.EPSILON;
const get_distance_to_line_function_u = get_distance_to_line_function_eps / 2;
/*
function getDistanceToLineFunction(
        pS: number[],
        pE: number[]): (p: number[]) => number {

    const xS = pS[0];
    const yS = pS[1];
    const xE = pE[0];
    const yE = pE[1];

    const s = yS - yE;
    const t = xE - xS;
    const u = qdq(tp(xS,yE), tp(xE,yS))[1];

    return function(p: number[]) {
        return s*p[0] + t*p[1] + u;
    }
}
*/
function getDistanceToLineFunction(pS, pE) {
    const xS = pS[0];
    const yS = pS[1];
    const xE = pE[0];
    const yE = pE[1];
    // note: td(yS, yE) nearly always has low double === 0 -> could potentially be taken advantage of in future
    const s = yS - yE; // <1>s
    const t = xE - xS; // <1>t
    const v = qdq(get_distance_to_line_function_tp(xS, yE), get_distance_to_line_function_tp(xE, yS))[1]; // <1>v
    const _s = get_distance_to_line_function_abs(s);
    const _t = get_distance_to_line_function_abs(t);
    const _v = get_distance_to_line_function_abs(v);
    return function (p, _p) {
        // error counter assumed <12> 
        // (the max of <6>,<6>,<10>,<11> and <12> from other functions)
        const x = p[0]; // <12>x 
        const y = p[1]; // <12>y
        //return s*x + t*y + u;
        const _x = _p[0];
        const _y = _p[1];
        // error counter of <12> on all coordinates
        const d = s * x + t * y + v;
        // <16>r <= <16>(<15>(<14>(<1>s*<12>x) + <14>(<1>t*<12>y)) + <1>v)
        const _d = _s * _x + _t * _y + _v;
        const E = 16 * get_distance_to_line_function_u * _d;
        return { dMin: d - E, dMax: d + E };
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier3-intersection/from-to/from-to-3.ts
const from_to_3_eps = Number.EPSILON;
const from_to_3_u = from_to_3_eps / 2;
const from_to_3_abs = Math.abs;
/** error free error bounds */
const psErrorFree = [[0, 0], [0, 0], [0, 0], [0, 0]];
/**
 * Returns a bezier curve that starts and ends at the given t parameters
 * including an error bound (that needs to be multiplied by `11u`, where
 * `u === Number.EPSILON/2`).
 *
 * * precondition 1: exact tS, tE, ps
 * * precondition 2: tS, tE ∈ [0,1]
 * * precondition 3: `Number.EPSILON | tS` and `Number.EPSILON | tE`
 * * precondition 4: tE > tS
 *
 * @param ps a cubic bezier curve
 * @param tS the t parameter where the resultant bezier should start
 * @param tE the t parameter where the resultant bezier should end
 */
function fromTo3(ps, tS, tE) {
    if (tS === 0) {
        if (tE === 1) {
            return { ps, _ps: psErrorFree };
        }
        return splitLeft3(ps, tE);
    }
    if (tE === 1) {
        return splitRight3(ps, tS);
    }
    return splitAtBoth3(ps, tS, tE);
}
/**
 * Returns a bezier curve that starts at the given t parameter and ends
 * at `t === 1` including an error bound (that needs to be multiplied
 * by `11u`, where `u === Number.EPSILON/2`).
 *
 * * precondition 1: exact `t`, `ps`
 * * precondition 2: t ∈ [0,1)
 * * precondition 3: `Number.EPSILON | t`
 *
 * @param ps a cubic bezier curve
 * @param t the t parameter where the resultant bezier should start
 */
function splitRight3(ps, t) {
    // --------------------------------------------------------
    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; 
    const p0 = ps[0];
    const p1 = ps[1]; // exact
    const p2 = ps[2];
    const p3 = ps[3]; // exact
    const x0 = p0[0];
    const y0 = p0[1]; // exact
    const x1 = p1[0];
    const y1 = p1[1]; // exact
    const x2 = p2[0];
    const y2 = p2[1]; // exact
    const x3 = p3[0];
    const y3 = p3[1]; // exact
    // --------------------------------------------------------
    // error bound using counters <k>:
    // counter rules:
    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   2. <k>a<l>b = <k + l + 1>ab
    //   3. fl(a) === <1>a
    const s = 1 - t; // <0>s <= exact by precondition 3
    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)
    const ttt = t * tt; // <2>ttt <= <0>t<1>tt  (again by counter rule 2)
    const ss = s * s; // <1>ss  <= <0>s<0>s
    const sss = s * ss; // <2>sss <= <0>s<1>ss
    const ts = t * s; // <1>ts  <= <0>t<0>s
    const sst = t * ss; // <2>sst <= <0>t<1>ss
    const stt = s * tt; // <2>stt <= <0>s<1>tt
    const psR = [
        [(x3 * ttt + x0 * sss) + 3 * (x2 * stt + x1 * sst),
            (y3 * ttt + y0 * sss) + 3 * (y2 * stt + y1 * sst)],
        [(x3 * tt + x1 * ss) + 2 * x2 * ts,
            (y3 * tt + y1 * ss) + 2 * y2 * ts],
        [x3 * t + x2 * s,
            y3 * t + y2 * s],
        [x3,
            y3] // yy3
    ];
    // -----------------------
    // Calculate error bounds
    // -----------------------
    const _x0 = from_to_3_abs(x0);
    const _y0 = from_to_3_abs(y0);
    const _x1 = from_to_3_abs(x1);
    const _y1 = from_to_3_abs(y1);
    const _x2 = from_to_3_abs(x2);
    const _y2 = from_to_3_abs(y2);
    const _x3 = from_to_3_abs(x3);
    const _y3 = from_to_3_abs(y3);
    // using error bound counter rule 2 in the final step:
    // <2>xx2 <= <2>(<1>(<0>x3*<0>t) + <1>(<0>x2*<0>s))
    const _xx2 = _x3 * t + _x2 * s;
    // <4>xx1 <= <4>(<3>(<2>(<0>x3*<1>tt) + <2>(<0>x1*<1>ss)) + <2>(2*<0>x2*<1>ts))
    const _xx1 = (_x3 * tt + _x1 * ss) + 2 * _x2 * ts;
    // <6>xx0 <= <6>(<4>(<3>(<0>x3*<2>ttt) + <3>(<0>x0*<2>sss)) + <5>(3*(<4>(<3>(<0>x2*<2>stt) + <3>(<0>x1*<2>sst)))))
    const _xx0 = (_x3 * ttt + _x0 * sss) + 3 * (_x2 * stt + _x1 * sst);
    const _yy2 = _y3 * t + _y2 * s;
    const _yy1 = (_y3 * tt + _y1 * ss) + 2 * _y2 * ts;
    const _yy0 = (_y3 * ttt + _y0 * sss) + 3 * (_y2 * stt + _y1 * sst);
    /** the coordinate-wise error bound */
    //const psR_ = [
    //    [6*u*_xx0, 6*u*_yy0],
    //    [4*u*_xx1, 4*u*_yy1],
    //    [2*u*_xx2, 2*u*_yy2],
    //    [0, 0]
    //];
    const psR_ = [
        [_xx0, _yy0],
        [_xx1, _yy1],
        [_xx2, _yy2],
        [0, 0]
    ];
    return {
        ps: psR,
        _ps: psR_
    };
}
/**
 * Returns a bezier curve that starts at `t === 0` and ends at the given t
 * parameter including an error bound (that needs to be multiplied by `11u`, where
 * `u === Number.EPSILON/2`).
 *
 * * precondition 1: exact `t`, `ps`
 * * precondition 2: `t ∈ (0,1]`
 * * precondition 3: `Number.EPSILON | t`  (i.e. `eps` divides `t`)
 *
 * @param ps a cubic bezier curve
 * @param t the `t` parameter where the resultant bezier should end
 */
function splitLeft3(ps, t) {
    // --------------------------------------------------------
    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; 
    const p0 = ps[0];
    const p1 = ps[1]; // exact
    const p2 = ps[2];
    const p3 = ps[3]; // exact
    const x0 = p0[0];
    const y0 = p0[1]; // exact
    const x1 = p1[0];
    const y1 = p1[1]; // exact
    const x2 = p2[0];
    const y2 = p2[1]; // exact
    const x3 = p3[0];
    const y3 = p3[1]; // exact
    // --------------------------------------------------------
    // error bound using counters <k>:
    // counter rules:
    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   2. <k>a<l>b = <k + l + 1>ab
    //   3. fl(a) === <1>a
    const s = 1 - t; // <0>s <= exact by precondition 3
    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)
    const ttt = t * tt; // <2>ttt <= <0>t<1>tt  (again by counter rule 2)
    const ss = s * s; // <1>ss  <= <0>s<0>s
    const sss = s * ss; // <2>sss <= <0>s<1>ss
    const ts = t * s; // <1>ts  <= <0>t<0>s
    const sst = t * ss; // <2>sst <= <0>t<1>ss
    const stt = s * tt; // <2>stt <= <0>s<1>tt
    const psL = [
        [x0,
            y0],
        [x1 * t + x0 * s,
            y1 * t + y0 * s],
        [(x2 * tt + x0 * ss) + 2 * x1 * ts,
            (y2 * tt + y0 * ss) + 2 * y1 * ts],
        [(x3 * ttt + x0 * sss) + 3 * (x2 * stt + x1 * sst),
            (y3 * ttt + y0 * sss) + 3 * (y2 * stt + y1 * sst)] // yy3 - split point y
    ];
    // -----------------------
    // Calculate error bounds
    // -----------------------
    const _x0 = from_to_3_abs(x0);
    const _y0 = from_to_3_abs(y0);
    const _x1 = from_to_3_abs(x1);
    const _y1 = from_to_3_abs(y1);
    const _x2 = from_to_3_abs(x2);
    const _y2 = from_to_3_abs(y2);
    const _x3 = from_to_3_abs(x3);
    const _y3 = from_to_3_abs(y3);
    const _xx1 = _x1 * t + _x0 * s;
    // <2>xx1 <= <2>(<1>(<0>x1*<0>t) + <1>(<0>x0*<0>s))
    const _xx2 = (_x2 * tt + _x0 * ss) + 2 * _x1 * ts;
    // <4>xx2 <= <4>(<3>(<2>(<0>x2*<1>tt) + <2>(<0>x0*<1>ss)) + <2>(2*<0>x1*<1>ts))
    const _xx3 = (_x3 * ttt + _x0 * sss) + 3 * (_x2 * stt + _x1 * sst);
    // <6>xx3 <= <6>(<4>(<3>(<0>x3*<2>ttt) + <3>(<0>x0*<2>sss)) + <5>(3*(<4>(<3>(<0>x2*<2>stt) + <3>(<0>x1*<2>sst)))))
    const _yy1 = _y1 * t + _y0 * s;
    const _yy2 = (_y2 * tt + _y0 * ss) + 2 * _y1 * ts;
    const _yy3 = (_y3 * ttt + _y0 * sss) + 3 * (_y2 * stt + _y1 * sst);
    /** the coordinate-wise error bound */
    //const psL_ = [
    //    [0, 0],
    //    [2*u*_xx1, 2*u*_yy1],
    //    [4*u*_xx2, 4*u*_yy2],
    //    [6*u*_xx3, 6*u*_yy3]
    //];
    const psL_ = [
        [0, 0],
        [_xx1, _yy1],
        [_xx2, _yy2],
        [_xx3, _yy3]
    ];
    return {
        ps: psL,
        _ps: psL_
    };
}
/**
 * Returns a bezier curve that starts and ends at the given `t` parameters
 * including an error bound (that needs to be multiplied by `11u`, where
 * `u === Number.EPSILON/2`).
 *
 * * precondition 1: exact `t`, `tE`, `ps`
 * * precondition 2: `tS, tE ∈ (0,1)`
 * * precondition 3: `Number.EPSILON | t (and tE)`  (i.e. `eps` divides `t` and `tE`)
 * * precondition 4: `t > 0 && tE < 1 && t < tE`
 *
 * @param ps a cubic bezier curve
 * @param t the t parameter where the resultant bezier should start
 * @param tE the t parameter where the resultant bezier should end
 */
function splitAtBoth3(ps, t, tE) {
    // --------------------------------------------------------
    // const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; 
    const p0 = ps[0];
    const p1 = ps[1]; // exact
    const p2 = ps[2];
    const p3 = ps[3]; // exact
    const x0 = p0[0];
    const y0 = p0[1]; // exact
    const x1 = p1[0];
    const y1 = p1[1]; // exact
    const x2 = p2[0];
    const y2 = p2[1]; // exact
    const x3 = p3[0];
    const y3 = p3[1]; // exact
    // --------------------------------------------------------
    // error bound using counters <k>:
    // counter rules:
    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   2. <k>a<l>b = <k + l + 1>ab
    //   3. fl(a) === <1>a
    // splitRight
    const s = 1 - t; // <0>s <= exact by precondition 3
    // make v the smallest float > (the true v) such that `eps | v`
    //const v = (tE - t)/s; 
    // see the function `getV` below to see why `v` is calculated this way
    const v = ((tE - t) / s) * (1 + Number.EPSILON) + 1 - 1;
    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)
    const ttt = t * tt; // <2>ttt <= <0>t<1>tt  (again by counter rule 2)
    const ss = s * s; // <1>ss  <= <0>s<0>s
    const sss = s * ss; // <2>sss <= <0>s<1>ss
    const ts = t * s; // <1>ts  <= <0>t<0>s
    const sst = ss * t; // <2>sst <= <0>t<1>ss
    const tts = tt * s; // <2>stt <= <0>s<1>tt
    // splitLeft
    const sL = 1 - v; // <0>s <= exact by precondition 3 and by construction that `eps | v`
    const ttL = v * v; // <1>uu <= <0>u<0>u
    const tttL = v * ttL; // <2>uuu <= <0>u<1>uu
    const ssL = sL * sL; // <1>ss  <= <0>s<0>s
    const sssL = sL * ssL; // <2>sss <= <0>s<1>ss
    const tsL = v * sL; // <1>us  <= <0>u<0>s
    const ssuL = ssL * v; // <2>ssu  <= <1>ss<0>u
    const xa = (ss * x1 + tt * x3) + 2 * ts * x2;
    const xb = ttL * (s * x2 + t * x3);
    const xx0 = 3 * (tts * x2 + sst * x1) + (sss * x0 + ttt * x3);
    const xx1 = sL * xx0 + v * xa;
    const xx2 = (ssL * xx0 + xb) + tsL * 2 * xa;
    const xx3 = 3 * (ssuL * xa + sL * xb) + (sssL * xx0 + tttL * x3);
    const ya = ss * y1 + tt * y3 + 2 * ts * y2;
    const yb = ttL * (s * y2 + t * y3);
    const yy0 = 3 * (tts * y2 + sst * y1) + (sss * y0 + ttt * y3);
    const yy1 = sL * yy0 + v * ya;
    const yy2 = (ssL * yy0 + yb) + tsL * 2 * ya;
    const yy3 = 3 * (ssuL * ya + sL * yb) + (sssL * yy0 + tttL * y3);
    // -----------------------
    // Calculate error bounds
    // -----------------------
    const _x0 = from_to_3_abs(x0);
    const _y0 = from_to_3_abs(y0);
    const _x1 = from_to_3_abs(x1);
    const _y1 = from_to_3_abs(y1);
    const _x2 = from_to_3_abs(x2);
    const _y2 = from_to_3_abs(y2);
    const _x3 = from_to_3_abs(x3);
    const _y3 = from_to_3_abs(y3);
    // <4>xa <= <4>(<3>((<2>(<1>ss*<0>x1) + <2>(<1>tt*<0>x3))) + <2>(2*<1>ts*<0>x2));
    const _xa = (ss * _x1 + tt * _x3) + 2 * ts * _x2;
    // <4>xb <= <4>(<1>ttL*<2>((<1>(<0>s*<0>x2) + <1>(<0>t*<0>x3))));
    const _xb = ttL * (s * _x2 + t * _x3);
    // <6>xx0 <= <6>(<5>(3*<4>(<3>(<2>tts*<0>x2) + <3>(<2>sst*<0>x1))) + <4>(<3>(<2>sss*<0>x0) + <3>(<2>ttt*<0>x3)));
    const _xx0 = 3 * (tts * _x2 + sst * _x1) + (sss * _x0 + ttt * _x3);
    // <6>xx1 = <6>(<1>(<0>sL*<0>xx0) + <5>(<0>u*<4>xa));
    const _xx1 = sL * _xx0 + v * _xa;
    // <10>xx2 = <10>(<9>(<8>(<1>ssL*<6>xx0) + <4>xb) + <6>(<1>tsL*2*<4>xa));
    const _xx2 = (ssL * _xx0 + _xb) + tsL * 2 * _xa;
    // <11>xx3 = <11>(<9>(3*<8>(<7>(<2>ssuL*<4>xa) + <5>(<0>sL*<4>xb))) + <10>(<9>(<2>sssL*<6>xx0) + <3>(<2>tttL*<0>x3)));
    const _xx3 = 3 * (ssuL * _xa + sL * _xb) + (sssL * _xx0 + tttL * _x3);
    const _ya = ss * _y1 + tt * _y3 + 2 * ts * _y2;
    const _yb = ttL * (s * _y2 + t * _y3);
    const _yy0 = 3 * (tts * _y2 + sst * _y1) + (sss * _y0 + ttt * _y3);
    const _yy1 = sL * _yy0 + v * _ya;
    const _yy2 = (ssL * _yy0 + _yb) + tsL * 2 * _ya;
    const _yy3 = 3 * (ssuL * _ya + sL * _yb) + (sssL * _yy0 + tttL * _y3);
    return {
        ps: [[xx0, yy0], [xx1, yy1], [xx2, yy2], [xx3, yy3]],
        //ps_: [
        //    [6* u*_xx0, 6* u*_yy0],
        //    [6* u*_xx1, 6* u*_yy1],
        //    [10*u*_xx2, 10*u*_yy2],
        //    [11*u*_xx3, 11*u*_yy3]
        //]
        _ps: [
            [_xx0, _yy0],
            [_xx1, _yy1],
            [_xx2, _yy2],
            [_xx3, _yy3]
        ]
    };
}
/**
 * Returns the smallest double (call it `v`) such that:
 * * `v > _v_ === (tE - tS)/(1 - tS)` AND
 * * such that `eps | v` (where `eps === Number.EPSILON`)
 *
 * * this function is for demonstration purposes and was inlined to save a
 * function call
 *
 * Preconditions:
 *  1. exact `tS`, `tE`
 *  2. `tS, tE ∈ (0,1)`
 *  3. `Number.EPSILON | tS` (and `Number.EPSILON | tE`)
 *  4. `tE > tS`
 *
 * @internal
 */
function getV(tS, tE) {
    //const numer = tE - tS;  // exact and > 0 due to preconditions 3 and 4
    //const denom = 1 - tS;  // exact and > 0 due to preconditions 2 and 3
    // Recall: the result of +, -, * and / is exactly rounded; that is, the 
    // result is computed exactly and then rounded to the nearest 
    // floating-point number (using round to even).
    // Therefore: it is guaranteed that `u > 0` and `u < 1`
    // The `+ 1` and then `- 1` at the end is critical in 
    // ensuring that `Number.EPSILON | u`. (this also causes `u` to be able to go to `1`)
    // e.g.:
    // `function a(a) { return (a*(1+Number.EPSILON) + 1 - 1)/Number.EPSILON; }`
    // `function b(a) { return (a*(1+Number.EPSILON)        )/Number.EPSILON; }`
    // `a(0.0000000321276211)  // 144689942`
    // `b(0.0000000321276211)  // 144689942.41426048`
    // Also the `(1 + Number.EPSILON)` part ensures that we're rounding up
    const u = ((tE - tS) / (1 - tS)) * (1 + Number.EPSILON) + 1 - 1;
}


;// CONCATENATED MODULE: ./src/intersection/bezier3-intersection/from-to/from-to-2.ts
const from_to_2_eps = Number.EPSILON;
const from_to_2_u = from_to_2_eps / 2;
const from_to_2_abs = Math.abs;
/** error free error bounds */
const from_to_2_psErrorFree = [[0, 0], [0, 0], [0, 0]];
/**
 * Returns a bezier curve that starts and ends at the given `t` parameters
 * including an error bound (that needs to be multiplied by `6u`, where
 * `u === Number.EPSILON/2`).
 *
 * * precondition 1: exact tS, tE, ps
 * * precondition 2: tS, tE ∈ [0,1]
 * * precondition 3: `Number.EPSILON | tS` and `Number.EPSILON | tE`
 * * precondition 4: tE > tS
 *
 * @param ps a quadratic bezier curve
 * @param tS the `t` parameter where the resultant bezier should start
 * @param tE the `t` parameter where the resultant bezier should end
 */
function fromTo2(ps, tS, tE) {
    if (tS === 0) {
        if (tE === 1) {
            return { ps, _ps: from_to_2_psErrorFree };
        }
        return splitLeft2(ps, tE);
    }
    if (tE === 1) {
        return splitRight2(ps, tS);
    }
    return splitAtBoth2(ps, tS, tE);
}
/**
 * Returns a bezier curve that starts at the given t parameter and ends
 * at `t === 1` including an error bound (that needs to be multiplied
 * by `4u`, where `u === Number.EPSILON/2`).
 *
 * * precondition 1: exact `t`, `ps`
 * * precondition 2: t ∈ [0,1)
 * * precondition 3: `Number.EPSILON | t`
 *
 * @param ps a quadratic bezier curve
 * @param t the `t` parameter where the resultant bezier should start
 */
function splitRight2(ps, t) {
    // --------------------------------------------------------
    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; 
    const p0 = ps[0]; // exact
    const p1 = ps[1]; // exact
    const p2 = ps[2]; // exact
    const x0 = p0[0];
    const y0 = p0[1]; // exact
    const x1 = p1[0];
    const y1 = p1[1]; // exact
    const x2 = p2[0];
    const y2 = p2[1]; // exact
    // --------------------------------------------------------
    // error bound using counters <k>:
    // counter rules:
    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   2. <k>a<l>b = <k + l + 1>ab
    //   3. fl(a) === <1>a
    const s = 1 - t; // <0>s <= exact by precondition 3
    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)
    const ss = s * s; // <1>ss  <= <0>s<0>s
    const ts = t * s; // <1>ts  <= <0>t<0>s
    const psR = [
        [x0 * ss + x2 * tt + 2 * x1 * ts,
            y0 * ss + y2 * tt + 2 * y1 * ts],
        [x1 * s + x2 * t,
            y1 * s + y2 * t],
        [x2,
            y2] // yy2
    ];
    // -----------------------
    // Calculate error bounds
    // -----------------------
    const _x0 = from_to_2_abs(x0);
    const _y0 = from_to_2_abs(y0);
    const _x1 = from_to_2_abs(x1);
    const _y1 = from_to_2_abs(y1);
    const _x2 = from_to_2_abs(x2);
    const _y2 = from_to_2_abs(y2);
    // <4>xx0 <= <4>(<3>(<2>(x0*<1>ss) + <2>(x2*<1>tt)) + <2>(2*x1*<1>ts))
    const _xx0 = _x0 * ss + _x2 * tt + 2 * _x1 * ts;
    // <2>xx1 <= <2>(<1>(x1*s) + <1>(x2*t))
    const _xx1 = _x1 * s + _x2 * t;
    const _yy0 = _y0 * ss + _y2 * tt + 2 * _y1 * ts;
    const _yy1 = _y1 * s + _y2 * t;
    /** the coordinate-wise error bound */
    //const psR_ = [
    //    [4*u*_xx0, 4*u*_yy0],
    //    [2*u*_xx1, 2*u*_yy1],
    //    [0, 0]
    //];
    const psR_ = [
        [_xx0, _yy0],
        [_xx1, _yy1],
        [0, 0]
    ];
    return {
        ps: psR,
        _ps: psR_
    };
}
/**
 * Returns a bezier curve that starts at `t === 0` and ends at the given `t`
 * parameter including an error bound (that needs to be multiplied by `4u`,
 * where `u === Number.EPSILON/2`).
 *
 * * precondition 1: exact `t`, `ps`
 * * precondition 2: `t ∈ (0,1]`
 * * precondition 3: `Number.EPSILON | t`
 *
 * @param ps a quadratic bezier curve
 * @param t the `t` parameter where the resultant bezier should end
 */
function splitLeft2(ps, t) {
    // --------------------------------------------------------
    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; 
    const p0 = ps[0]; // exact 
    const p1 = ps[1]; // exact
    const p2 = ps[2]; // exact
    const x0 = p0[0];
    const y0 = p0[1]; // exact
    const x1 = p1[0];
    const y1 = p1[1]; // exact
    const x2 = p2[0];
    const y2 = p2[1]; // exact
    // --------------------------------------------------------
    // error bound using counters <k>:
    // counter rules:
    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   2. <k>a<l>b = <k + l + 1>ab
    //   3. fl(a) === <1>a
    const s = 1 - t; // <0>s <= exact by precondition 3
    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)
    const ss = s * s; // <1>ss  <= <0>s<0>s
    const ts = t * s; // <1>ts  <= <0>t<0>s
    const psL = [
        [x0,
            y0],
        [x1 * t + x0 * s,
            y1 * t + y0 * s],
        [(x2 * tt + x0 * ss) + 2 * x1 * ts,
            (y2 * tt + y0 * ss) + 2 * y1 * ts] // yy2 - split point y
    ];
    // -----------------------
    // Calculate error bounds
    // -----------------------
    const _x0 = from_to_2_abs(x0);
    const _y0 = from_to_2_abs(y0);
    const _x1 = from_to_2_abs(x1);
    const _y1 = from_to_2_abs(y1);
    const _x2 = from_to_2_abs(x2);
    const _y2 = from_to_2_abs(y2);
    // <2>xx1 <= <2>(<1>(<0>x1*<0>t) + <1>(<0>x0*<0>s))
    const _xx1 = _x1 * t + _x0 * s;
    // <4>xx2 <= <4>(<3>(<2>(<0>x2*<1>tt) + <2>(<0>x0*<1>ss)) + <2>(2*<0>x1*<1>ts))
    const _xx2 = (_x2 * tt + _x0 * ss) + 2 * _x1 * ts;
    const _yy1 = _y1 * t + _y0 * s;
    const _yy2 = (_y2 * tt + _y0 * ss) + 2 * _y1 * ts;
    /** the coordinate-wise error bound */
    //const psL_ = [
    //    [0, 0],
    //    [2*u*_xx1, 2*u*_yy1],
    //    [4*u*_xx2, 4*u*_yy2],
    //];
    const psL_ = [
        [0, 0],
        [_xx1, _yy1],
        [_xx2, _yy2]
    ];
    return {
        ps: psL,
        _ps: psL_
    };
}
/**
 * Returns a bezier curve that starts and ends at the given `t` parameters
 * including an error bound (that needs to be multiplied by `6u`, where
 * `u === Number.EPSILON/2`).
 *
 * * precondition 1: exact `t`, `tE`, `ps`
 * * precondition 2: `tS, tE ∈ (0,1)`
 * * precondition 3: `Number.EPSILON | t` and `Number.EPSILON | tE`
 * * precondition 4: `t < tE`
 *
 * @param ps a quadratic bezier curve
 * @param t the t parameter where the resultant bezier should start
 * @param tE the t parameter where the resultant bezier should end
 */
function splitAtBoth2(ps, t, tE) {
    // --------------------------------------------------------
    // const [[x0, y0], [x1, y1], [x2, y2]] = ps; 
    const p0 = ps[0]; // exact
    const p1 = ps[1]; // exact
    const p2 = ps[2]; // exact
    const x0 = p0[0];
    const y0 = p0[1]; // exact
    const x1 = p1[0];
    const y1 = p1[1]; // exact
    const x2 = p2[0];
    const y2 = p2[1]; // exact
    // --------------------------------------------------------
    // error bound using counters <k>:
    // counter rules:
    //   1. <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   2. <k>a<l>b = <k + l + 1>ab
    //   3. fl(a) === <1>a
    // splitRight
    const s = 1 - t; // <0>s <= exact by precondition 3
    const tt = t * t; // <1>tt  <= <0>t<0>t   (by counter rule 2)
    const ss = s * s; // <1>ss  <= <0>s<0>s
    const ts = t * s; // <1>ts  <= <0>t<0>s
    // make v the smallest float > (the true v) such that `eps | v`
    //const v = (tE - t)/s; 
    // see the function `getV` below to see why `v` is calculated this way
    const tL = ((tE - t) / s) * (1 + Number.EPSILON) + 1 - 1;
    // splitLeft
    const sL = 1 - tL; // <0>s <= exact by precondition 3 and by construction that `eps | v`
    const ttL = tL * tL; // <1>uu <= <0>u<0>u
    const ssL = sL * sL; // <1>ss  <= <0>s<0>s
    const tsL = tL * sL; // <1>us  <= <0>u<0>s
    const xa = s * x1 + t * x2;
    const xx0 = (ss * x0 + tt * x2) + 2 * ts * x1;
    const xx1 = sL * xx0 + tL * xa;
    const xx2 = ssL * xx0 + (2 * tsL * xa + ttL * x2);
    const ya = s * y1 + t * y2;
    const yy0 = (ss * y0 + tt * y2) + 2 * ts * y1;
    const yy1 = sL * yy0 + tL * ya;
    const yy2 = ssL * yy0 + (2 * tsL * ya + ttL * y2);
    // -----------------------
    // Calculate error bounds
    // -----------------------
    const _x0 = from_to_2_abs(x0);
    const _y0 = from_to_2_abs(y0);
    const _x1 = from_to_2_abs(x1);
    const _y1 = from_to_2_abs(y1);
    const _x2 = from_to_2_abs(x2);
    const _y2 = from_to_2_abs(y2);
    // <2>xa = <2>(<1>(s*x1) + <1>(t*x2))
    const _xa = s * _x1 + t * _x2;
    // <4>xx0 = <4>(<3>(<2>(ss*x0) + <2>(tt*x2)) + 2*<2>(<1>ts*<0>x1));
    const _xx0 = (ss * _x0 + tt * _x2) + 2 * ts * _x1;
    // <6>xx1 = <6>(<5>(<0>sL*<4>xx0) + <3>(<0>tL*<2>xa));
    const _xx1 = sL * _xx0 + tL * _xa;
    // <7>xx2 = <7>(<6>(<1>ssL*<4>xx0) + <6>(<5>(<4>(2*<1>tsL*<2>xa) + <2>(<1>ttL*<0>x2))));
    const _xx2 = ssL * _xx0 + (2 * tsL * _xa + ttL * _x2);
    const _ya = s * _y1 + t * _y2;
    const _yy0 = (ss * _y0 + tt * _y2) + 2 * ts * _y1;
    const _yy1 = sL * _yy0 + tL * _ya;
    const _yy2 = ssL * _yy0 + (2 * tsL * _ya + ttL * _y2);
    return {
        ps: [[xx0, yy0], [xx1, yy1], [xx2, yy2]],
        //ps_: [
        //    [4*u*_xx0, 4*u*_yy0],
        //    [6*u*_xx1, 6*u*_yy1],
        //    [7*u*_xx2, 4*u*_yy2]
        //]
        _ps: [
            [_xx0, _yy0],
            [_xx1, _yy1],
            [_xx2, _yy2]
        ]
    };
}
/**
 * Returns the smallest double (call it `v`) such that:
 * * `v > _v_ === (tE - tS)/(1 - tS)` AND
 * * such that `eps | v` (where `eps === Number.EPSILON`)
 *
 * * this function is for demonstration purposes and was inlined to save a
 * function call
 *
 * Preconditions:
 *  1. exact `tS`, `tE`
 *  2. `tS, tE ∈ (0,1)`
 *  3. `Number.EPSILON | tS` (and `Number.EPSILON | tE`)
 *  4. `tE > tS`
 *
 * @internal
 */
function from_to_2_getV(tS, tE) {
    //const numer = tE - tS;  // exact and > 0 due to preconditions 3 and 4
    //const denom = 1 - tS;  // exact and > 0 due to preconditions 2 and 3
    // Recall: the result of +, -, * and / is exactly rounded; that is, the 
    // result is computed exactly and then rounded to the nearest 
    // floating-point number (using round to even).
    // Therefore: it is guaranteed that `u > 0` and `u < 1`
    // The `+ 1` and then `- 1` at the end is critical in 
    // ensuring that `Number.EPSILON | u`. (this also causes `u` to be able to go to `1`)
    // e.g.:
    // `function a(a) { return (a*(1+Number.EPSILON) + 1 - 1)/Number.EPSILON; }`
    // `function b(a) { return (a*(1+Number.EPSILON)        )/Number.EPSILON; }`
    // `a(0.0000000321276211)  // 144689942`
    // `b(0.0000000321276211)  // 144689942.41426048`
    // Also the `(1 + Number.EPSILON)` part ensures that we're rounding up
    const u = ((tE - tS) / (1 - tS)) * (1 + Number.EPSILON) + 1 - 1;
}


;// CONCATENATED MODULE: ./src/intersection/bezier3-intersection/from-to/from-to.ts


const from_to_fromTo3 = fromTo3;
const from_to_fromTo2 = fromTo2;
/**
 * Returns a bezier curve that starts and ends at the given t parameters
 * including an error bound (that needs to be multiplied by `6u` or `11u` (for
 * quadratic and cubic bezier curves respectively), where `u === Number.EPSILON/2`).
 *
 * * precondition 1: exact tS, tE, ps
 * * precondition 2: tS, tE ∈ [0,1]
 * * precondition 3: `Number.EPSILON | tS` and `Number.EPSILON | tE`
 * * precondition 4: tE > tS
 *
 * @param ps a cubic bezier curve
 * @param tS the t parameter where the resultant bezier should start
 * @param tE the t parameter where the resultant bezier should end
 *
 * @internal
 */
function from_to_fromTo(ps, tS, tE) {
    if (ps.length === 4) {
        return from_to_fromTo3(ps, tS, tE);
    }
    if (ps.length === 3) {
        return from_to_fromTo2(ps, tS, tE);
    }
    throw new Error('The given bezier curve is invalid; it must be of order 2 or 3.');
}


;// CONCATENATED MODULE: ./src/intersection/bezier3-intersection/check-intersection-in-ranges.ts






const check_intersection_in_ranges_debug_ = (typeof globalThis !== 'undefined' && globalThis.__debug__)
    ? globalThis.__debug__
    : undefined;
const check_intersection_in_ranges_getDistanceToLineFunction = getDistanceToLineFunction;
const check_intersection_in_ranges_geoClip = geoClip;
const check_intersection_in_ranges_fromTo = from_to_fromTo;
const fromToVect = fromTo;
const check_intersection_in_ranges_translate = translate;
const check_intersection_in_ranges_toLength = toLength;
const check_intersection_in_ranges_noIntersection = undefined;
const check_intersection_in_ranges_noClip = (/* unused pure expression or super */ null && ([0, 1]));
/**
 * the heuristic value indicating the maximum `t` parameter span allowed after
 * clipping before perpendicular fatline clipping or curve splitting is
 * employed.
 */
const maxClipTSpan = 0.7;
/**
 * Returns 0, 1 or 2 new narrowed ranges of possible intersections based on the
 * given current iteration's ranges.
 *
 * * helper function to the geometric interval bezier-bezier intersection
 * algorithm
 *
 * @param F the bezier curve that should be fat line bounded
 * @param G the bezier curve that should be geometric interval bounded
 *
 * @internal
 */
function checkIntersectionInRanges(iter) {
    //--------------------------------------
    // let { F, G, fRange, gRange } = iter;
    const F = iter.F;
    const G = iter.G;
    const fRange = iter.fRange;
    const gRange = iter.gRange;
    //--------------------------------------
    //-----------------------------------------------------------------------
    // an invariant at this stage is that `eps | ftMin, ftMax, gtMin, gtMax`
    //-----------------------------------------------------------------------
    /**
     * the minimum `t` value bound for the bezier that will be fatline bounded;
     * it will not change during normal geo clipping
     */
    const ftMin = fRange[0];
    /**
     * the maximum `t` value bound for the bezier that will be fatline bounded;
     * it will not change during normal geo clipping
     */
    const ftMax = fRange[1];
    /**
     * the minimum `t` value bound for the bezier that will be geo bounded;
     * it will be geo clipped for the next iteration
     */
    const gtMin = gRange[0];
    /**
     * the maximum `t` value bound for the bezier that will be geo bounded;
     * it will be geo clipped for the next iteration
     */
    const gtMax = gRange[1];
    // Get the bezier curves (and an error bound) within the narrowed ranges
    // Note: the error bound need be multiplied by `11u`, where 
    // `u === Number.EPSILON/2` (see `fromTo3` for details).
    const F_ = check_intersection_in_ranges_fromTo(F, ftMin, ftMax);
    const G_ = check_intersection_in_ranges_fromTo(G, gtMin, gtMax);
    const Fps = F_.ps;
    const F_ps = F_._ps;
    if (check_intersection_in_ranges_debug_ !== undefined && !check_intersection_in_ranges_debug_.already) {
        check_intersection_in_ranges_debug_.currentIter.F_ = F_;
        check_intersection_in_ranges_debug_.currentIter.G_ = G_;
    }
    const lenF = Fps.length;
    // Q will be fat line bounded. Get start and endpoint of curve
    let FS = Fps[0];
    let FE = Fps[lenF - 1];
    // Note: The case where `FS` and `FE` are the same point will result in
    // `geoClip` not clipping and returning 'no intersection' so we don't
    // explicitly test for it here.
    // Get the implict line equation for the line defined by the first and 
    // last control point of Q. This equation gives the distance between any 
    // point and the line (but scaled for efficiency *and* robustness).
    let dF = check_intersection_in_ranges_getDistanceToLineFunction(FS, FE);
    // Signed distances to cubic mid control points *plus* the first and last
    // control points since there is an error bound involved that need to
    // be included to ensure robustness
    let dF0 = dF(Fps[0], F_ps[0]);
    let dF1 = dF(Fps[1], F_ps[1]);
    let dF2 = dF(Fps[2], F_ps[2]);
    let dF3 = lenF === 4 ? dF(Fps[3], F_ps[3]) : { dMin: 0, dMax: 0 };
    // Calculate the fat line of F.
    // Calculate the distance from the control points of F to the line.
    //let C = len === 4 ? (dF1*dF2 > 0) ? 3/4 : 4/9 : 1/2;
    // The above calculation of C has been replaced by the one below so we can
    // ensure robustness (`dF1` and `dF2` are not simply numbers but also have
    // an error bound associated with them)
    let C = lenF === 4 ? 3 / 4 : 1 / 2;
    const dMin = C * Math.min(0, dF0.dMin, dF1.dMin, dF2.dMin, dF3.dMin);
    const dMax = C * Math.max(0, dF0.dMax, dF1.dMax, dF2.dMax, dF3.dMax);
    // Add fatline debug info
    if (check_intersection_in_ranges_debug_ !== undefined && !check_intersection_in_ranges_debug_.already) {
        check_intersection_in_ranges_debug_.currentIter.fatline = getFatlineDebugInfo(FS, FE, dMin, dMax);
    }
    const tRange = check_intersection_in_ranges_geoClip(G_, dF, dMin, dMax);
    const last = iter.last;
    if (tRange === check_intersection_in_ranges_noIntersection) {
        return [];
    }
    let tMin = tRange[0];
    let tMax = tRange[1];
    if (!last && tMax - tMin > maxClipTSpan) {
        // This optimization is for cases where the bezier curves meet nearly 
        // collinearly at interface points.
        if (!clipPerp()) {
            return [];
        }
        ;
    }
    if (!last && tMax - tMin > maxClipTSpan) {
        return split();
    }
    const gtSpan = gtMax - gtMin;
    // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMin_`
    const tMin_ = gtMin + tMin * gtSpan + 1 - 1;
    // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMax_`
    const tMax_ = gtMin + tMax * gtSpan + 1 - 1;
    // Swap Q and P and iterate.
    const newIter = {
        F: G, G: F,
        fRange: [tMin_, tMax_],
        gRange: fRange,
        last
    };
    if (check_intersection_in_ranges_debug_ !== undefined && !check_intersection_in_ranges_debug_.already) {
        newIter.parent = check_intersection_in_ranges_debug_.currentIter;
        check_intersection_in_ranges_debug_.currentIter.children = [newIter];
    }
    return [newIter];
    function clipPerp() {
        // First try a fatline perpendicular to the prior one. This is 
        // important for efficiency especially in cases where the bezier
        // curves meet (or almost meet) with nearly the same tangent and
        // curvature.
        const FSx = FS[0];
        const FSy = FS[1];
        const FEx = FE[0];
        const FEy = FE[1];
        // rotate [FS,FE] 90 degrees about FS
        const V = [FSx + FSy - FEy, FSy + FEx - FSx];
        let dQ_ = check_intersection_in_ranges_getDistanceToLineFunction(FS, V);
        // Signed distances to other 3 control points *plus* the first
        // control point since there is an error bound involved that need to
        // be included to ensure robustness
        let dF0_ = dQ_(Fps[0], F_ps[0]);
        let dF1_ = dQ_(Fps[1], F_ps[1]);
        let dF2_ = dQ_(Fps[2], F_ps[2]);
        let dF3_ = lenF === 4 ? dQ_(Fps[3], F_ps[3]) : { dMin: 0, dMax: 0 };
        const dMin_ = Math.min(0, dF0_.dMin, dF1_.dMin, dF2_.dMin, dF3_.dMin);
        const dMax_ = Math.max(0, dF0_.dMax, dF1_.dMax, dF2_.dMax, dF3_.dMax);
        // Add fatline debug info
        if (check_intersection_in_ranges_debug_ !== undefined && !check_intersection_in_ranges_debug_.already) {
            check_intersection_in_ranges_debug_.currentIter.fatlinePerp = getFatlineDebugInfo(FS, V, dMin_, dMax_);
        }
        const tRange = check_intersection_in_ranges_geoClip(G_, dQ_, dMin_, dMax_);
        if (tRange === check_intersection_in_ranges_noIntersection) {
            return false;
        }
        const tMin_ = tRange[0];
        const tMax_ = tRange[1];
        tMin = Math.max(tMin, tMin_);
        tMax = Math.min(tMax, tMax_);
        return true;
    }
    /**
     * Split the bezier curve.
     */
    function split() {
        // The paper calls for a heuristic that if less than 30% will be
        // clipped, rather split the longest curve and find intersections in the
        // two halfs seperately.
        const gtSpan = gtMax - gtMin;
        const ftSpan = ftMax - ftMin;
        // Split the curve in half
        if (gtSpan >= ftSpan) {
            // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMin_`
            const tMid = gtMin + gtSpan / 2 + 1 - 1;
            const iter1 = { F, G, fRange, gRange: [gtMin, tMid], last };
            const iter2 = { F, G, fRange, gRange: [tMid, gtMax], last };
            if (check_intersection_in_ranges_debug_ !== undefined && !check_intersection_in_ranges_debug_.already) {
                iter1.parent = check_intersection_in_ranges_debug_.currentIter;
                iter2.parent = check_intersection_in_ranges_debug_.currentIter;
                check_intersection_in_ranges_debug_.currentIter.children = [iter2, iter1];
            }
            return [iter2, iter1];
        }
        // The `+ 1 - 1` at the end is critical in ensuring that `Number.EPSILON | tMin_`
        const tMid = ftMin + ftSpan / 2 + 1 - 1;
        const iter1 = { F, G, fRange: [ftMin, tMid], gRange, last };
        const iter2 = { F, G, fRange: [tMid, ftMax], gRange, last };
        if (check_intersection_in_ranges_debug_ !== undefined && !check_intersection_in_ranges_debug_.already) {
            iter1.parent = check_intersection_in_ranges_debug_.currentIter;
            iter2.parent = check_intersection_in_ranges_debug_.currentIter;
            check_intersection_in_ranges_debug_.currentIter.children = [iter2, iter1];
        }
        return [iter2, iter1];
    }
}
function getFatlineDebugInfo(FS, FE, dMin, dMax) {
    let vF = fromToVect(FS, FE); // Move [FS, FE] to the origin
    let vFr = [-vF[1], vF[0]]; // Rotate vector by -90 degrees
    // get scale factor `d` to scale back to actual distances 
    // (not perfectly accurate due to rounding)
    const xS = FS[0];
    const yS = FS[1];
    const xE = FE[0];
    const yE = FE[1];
    let s = yS - yE;
    let t = xE - xS;
    let u = xS * yE - xE * yS;
    let d = Math.sqrt(s ** 2 + t ** 2);
    let offsetMin = check_intersection_in_ranges_toLength(vFr, dMin / d);
    let offsetMax = check_intersection_in_ranges_toLength(vFr, dMax / d);
    let psMin = [check_intersection_in_ranges_translate(FS, offsetMin), check_intersection_in_ranges_translate(FE, offsetMin)];
    let psMax = [check_intersection_in_ranges_translate(FS, offsetMax), check_intersection_in_ranges_translate(FE, offsetMax)];
    return {
        psBase: [FS, FE],
        psMin, psMax
    };
}


;// CONCATENATED MODULE: ./src/error-analysis/error-analysis.ts
const error_analysis_u = Number.EPSILON / 2;
const error_analysis_uu = error_analysis_u * error_analysis_u;
/** @internal */
function error_analysis_(n) {
    const nu = n * error_analysis_u;
    return nu / (1 - nu);
}
/** @internal */
function error_analysis_error_analysis_(n) {
    const nuu = n * error_analysis_uu;
    return nuu / (1 - nuu);
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-xy/double-double/get-xy-dd-with-running-error.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const td = node_twoDiff; // error -> 0
const get_xy_dd_with_running_error_qmd = node_ddMultDouble2; // error -> 3*u²
const get_xy_dd_with_running_error_qaq = node_ddAddDd;
const qad = node_ddAddDouble; // error -> 2*u²
const get_xy_dd_with_running_error_abs = Math.abs;
// TODO - modify docs (the doc below is from `getXY`)
/**
 * Returns the power basis representation of a line, quadratic or cubic bezier.
 *
 * * **non-exact:** if certain preconditions are met (see below) it returns the
 * exact result, else round-off may have occured during intermediate calculation.
 * * returns the power basis polynomial from highest power to lowest,
 * e.g. `at^3 + bt^2 + ct + d` is returned as `[a,b,c,d]`
 *
 * * **bitlength:** If the coordinates of the control points are bit-aligned then:
 *  * max bitlength increase = 4 (for cubics)
 * (due to 'multiplication' by 9 (3x 6x 3x)
 *  * max bitlength increase = 2 (for quadratics)
 * (due to 'multiplication' by 4 (1x 2x 1x)
 *  * max bitlength increase = 1 (for lines)
 * (due to 'multiplication' by 4 (1x 1x)
 *
 * @param ps an order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function get_xy_dd_with_running_error_getXY3DdWithRunningError(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    // ----------------------------
    // xx3 = (x3 - x0) + 3*(x1 - x2)
    // ----------------------------
    const xa = td(x3, x0); // error free
    const xb = td(x1, x2); // error free
    const $xc = 3 * (x1 - x2);
    const xc = get_xy_dd_with_running_error_qmd(3, xb);
    const _xc_ = get_xy_dd_with_running_error_abs($xc);
    const xx3 = get_xy_dd_with_running_error_qaq(xa, xc);
    const xx3_ = _xc_ + get_xy_dd_with_running_error_abs(x3 - x0 + $xc);
    // ----------------------------
    // xx2 = 3*(x2 - 2*x1 + x0)
    // ----------------------------
    const xd = td(x2, 2 * x1); // error free
    const xe = qad(xd, x0);
    const _xe_ = get_xy_dd_with_running_error_abs(x2 - 2 * x1 + x0);
    const xx2 = get_xy_dd_with_running_error_qmd(3, xe);
    //const xx2_ = 3*_xe_ + 3*_xe_;
    const xx2_ = 6 * _xe_;
    // ----------------------------
    // xx1 = 3*(x1 - x0)
    // ----------------------------
    const xg = td(x1, x0); // error free
    const xx1 = get_xy_dd_with_running_error_qmd(3, xg);
    const xx1_ = get_xy_dd_with_running_error_abs(3 * (x1 - x0));
    // ----------------------------
    // yy3 = y3 + 3*(y1 - y2) - y0
    // ----------------------------
    const ya = td(y3, y0); // error free
    const yb = td(y1, y2); // error free
    const $yc = 3 * (y1 - y2);
    const yc = get_xy_dd_with_running_error_qmd(3, yb);
    const _yc_ = get_xy_dd_with_running_error_abs($yc);
    const yy3 = get_xy_dd_with_running_error_qaq(ya, yc);
    const yy3_ = _yc_ + get_xy_dd_with_running_error_abs(y3 - y0 + $yc);
    // ----------------------------
    // yy2 = 3*(y2 - 2*y1 + y0)
    // ----------------------------
    const yd = td(y2, 2 * y1); // error free
    const ye = qad(yd, y0);
    const _ye_ = get_xy_dd_with_running_error_abs(y2 - 2 * y1 + y0);
    const yy2 = get_xy_dd_with_running_error_qmd(3, ye);
    //const yy2_ = 3*_ye_ + 3*_ye_;
    const yy2_ = 6 * _ye_;
    // ----------------------------
    // yy1 = 3*(y1 - y0)
    // ----------------------------
    const yg = td(y1, y0); // error free
    const yy1 = get_xy_dd_with_running_error_qmd(3, yg);
    const yy1_ = get_xy_dd_with_running_error_abs(3 * (y1 - y0));
    return {
        coeffs: [[xx3, xx2, xx1, x0], [yy3, yy2, yy1, y0]],
        errorBound: [[xx3_, xx2_, xx1_, 0], [yy3_, yy2_, yy1_, 0]]
    };
}
/**
 * only quadratic monomial coefficient has an error, the others are exact
 * @param ps
 */
function get_xy_dd_with_running_error_getXY2DdWithRunningError(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    // ---------------------
    // xx2 = x2 - 2*x1 + x0
    // ---------------------
    const $a = x2 - 2 * x1;
    const a = td(x2, 2 * x1); // error free
    const xx2 = qad(a, x0);
    const xx2_ = get_xy_dd_with_running_error_abs($a + x0);
    // ---------------------
    // xx1 = 2*(x1 - x0)
    // ---------------------
    const xx1 = td(2 * x1, 2 * x0); // error free
    // ---------------------
    // yy2 = y2 - 2*y1 + y0
    // ---------------------
    const $b = y2 - 2 * y1;
    const b = td(y2, 2 * y1); // error free
    const yy2 = qad(b, y0);
    const yy2_ = get_xy_dd_with_running_error_abs($b + y0);
    // ---------------------
    // yy1 = 2*(y1 - y0)
    // ---------------------
    const yy1 = td(2 * y1, 2 * y0); // error free
    return {
        coeffs: [[xx2, xx1, x0], [yy2, yy1, y0]],
        errorBound: [[xx2_, 0, 0], [yy2_, 0, 0]]
    };
}
/**
 * * exact for any bitlength
 * @param ps linear bezier curve
 */
function get_xy_dd_with_running_error_getXY1DdWithRunningError(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    return [[
            td(x1, x0),
            x0,
        ], [
            td(y1, y0),
            y0,
        ]];
}


;// CONCATENATED MODULE: ./src/implicit-form/double-double/get-implicit-form1-dd-with-running-error.ts



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_implicit_form1_dd_with_running_error_qdq = node_ddDiffDd; // error -> 3*γ²
const get_implicit_form1_dd_with_running_error_qmd = node_ddMultDouble2;
const eno = eNegativeOf;
const get_implicit_form1_dd_with_running_error_abs = Math.abs;
// TODO - modify
/**
 * Returns the error-free double-double precision implicit form of the given
 * linear bezier.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓx + vᵧy + v = 0`
 * * **precondition:** TODO - add underflow / overflow conditions + docs below
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm1DdWithRunningError(ps) {
    // The implicit form is given by:
    // vₓx + vᵧy + v = 0
    const [[a1, a0], [b1, b0]] = get_xy_dd_with_running_error_getXY1DdWithRunningError(ps);
    const vₓ = eno(b1); // exact
    const vᵧ = a1; // exact
    //const v = a1*b0 - a0*b1;
    const a1b0 = get_implicit_form1_dd_with_running_error_qmd(b0, a1);
    const _a1b0_ = get_implicit_form1_dd_with_running_error_abs(a1b0[1]);
    const a0b1 = get_implicit_form1_dd_with_running_error_qmd(a0, b1);
    const _a0b1_ = get_implicit_form1_dd_with_running_error_abs(a0b1[1]);
    const v = get_implicit_form1_dd_with_running_error_qdq(a0b1, a1b0);
    const v_ = _a1b0_ + _a0b1_ + get_implicit_form1_dd_with_running_error_abs(v[1]);
    return {
        coeffs: { vₓ, vᵧ, v },
        errorBound: { v_ } // vₓ_, vᵧ_ === 0
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez1-dd.ts




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_bez1_bez1_dd_tp = (/* unused pure expression or super */ null && (twoProduct));
const get_coeffs_bez1_bez1_dd_qaq = node_ddAddDd;
const get_coeffs_bez1_bez1_dd_qmd = node_ddMultDouble2;
const qmq = node_ddMultDd;
const get_coeffs_bez1_bez1_dd_abs = Math.abs;
const get_coeffs_bez1_bez1_dd_3 = error_analysis_error_analysis_(3);
// TODO - modify docs
/**
 * Returns a polynomial in 1 variable (including coefficientwise error bound)
 * whose roots are the parameter values of the intersection points of two
 * order 1 bezier curves (i.e. 2 lines).
 *
 * The returned polynomial degree will be 1
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** none TODO - include underflow / overflow
 * * intermediate calculations are done in double-double precision and the
 * result is exact if the precondition is met
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1 a linear bezier curve
 * @param ps2 a linear bezier curve
 *
 * @doc mdx
 */
// TODO - rename all these by chopping off the AnyBitlength part since it
// is now implied implicitly
function getCoeffsBez1Bez1Dd(ps1, ps2) {
    const { coeffs: { vₓ, vᵧ, v }, // all these are double-doubles
    errorBound: { v_ } } = getImplicitForm1DdWithRunningError(ps1);
    const [[c1, c0], [d1, d0]] = get_xy_dd_with_running_error_getXY1DdWithRunningError(ps2);
    const $c1 = c1[1];
    const $d1 = d1[1];
    const $vₓ = vₓ[1];
    const $vᵧ = vᵧ[1];
    const $v = v[1];
    //----------------------------------
    // const v1 = c1*vₓ + d1*vᵧ;
    //----------------------------------
    const $p1 = $c1 * $vₓ;
    const _p1 = get_coeffs_bez1_bez1_dd_abs($p1);
    const p1_ = 2 * _p1;
    const p1 = qmq(c1, vₓ);
    const $p2 = $d1 * $vᵧ;
    const _p2 = get_coeffs_bez1_bez1_dd_abs($p2);
    const p2_ = 2 * _p2;
    const p2 = qmq(d1, vᵧ);
    const $v1 = $p1 + $p2;
    //const _$v1 = abs($v1);
    const v1 = get_coeffs_bez1_bez1_dd_qaq(p1, p2);
    const v1_ = p1_ + p2_ + get_coeffs_bez1_bez1_dd_abs($v1);
    //----------------------------------
    // const v0 = c0*vₓ + d0*vᵧ + v_0;
    //----------------------------------
    const $p3 = c0 * $vₓ;
    const p3 = get_coeffs_bez1_bez1_dd_qmd(c0, vₓ);
    const _p3_ = get_coeffs_bez1_bez1_dd_abs($p3);
    const $p4 = d0 * $vᵧ;
    const p4 = get_coeffs_bez1_bez1_dd_qmd(d0, vᵧ);
    const _p4_ = get_coeffs_bez1_bez1_dd_abs($p4);
    const $p5 = $p3 + $p4;
    //const _p5 = abs($p5);
    const p5 = get_coeffs_bez1_bez1_dd_qaq(p3, p4);
    const p5_ = _p3_ + _p4_ + get_coeffs_bez1_bez1_dd_abs($p5);
    const v0 = get_coeffs_bez1_bez1_dd_qaq(p5, v);
    const v0_ = p5_ + v_ + get_coeffs_bez1_bez1_dd_abs($p5 + $v);
    return {
        coeffs: [v1, v0],
        errBound: [get_coeffs_bez1_bez1_dd_3 * v1_, get_coeffs_bez1_bez1_dd_3 * v0_]
    };
}


;// CONCATENATED MODULE: ./src/implicit-form/double-double/get-implicit-form2-dd-with-running-error.ts


const qno = node_ddNegativeOf; // error -> 0
const qm2 = node_ddMultBy2; // error -> 0 
//const qmd2 = qMultDouble1;  // error -> 1.5*γ²
const get_implicit_form2_dd_with_running_error_qmd = node_ddMultDouble2; // error -> 3*γ²
const get_implicit_form2_dd_with_running_error_qmq = node_ddMultDd; // error -> 7*γ² (theoretical), 5*γ² (worst found), we use 6*γ²
const get_implicit_form2_dd_with_running_error_qdq = node_ddDiffDd; // error -> 3*γ²
const get_implicit_form2_dd_with_running_error_abs = Math.abs;
/**
 * Returns a double-double precision implicit form of the given quadratic
 * bezier and a coefficientwise error bound.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`
 * * **precondition:** TODO - add underflow / overflow conditions + docs below
 * * intermediate calculations are done in double-double precision and this is
 * reflected in the output error bound (which is approximately
 * `n * (Number.EPSILON**2) * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned first needs to be scaled by `γγ3 === (3*u*u) / (1 - 3*u*u)`,
 * where `u === Number.EPSILON / 2` before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm2DdWithRunningError(ps) {
    // The implicit form is given by:
    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0
    const { coeffs: [[a2, a1, a0], [b2, b1, b0]], errorBound: [[a2_], [b2_]] } = get_xy_dd_with_running_error_getXY2DdWithRunningError(ps);
    const $a2 = a2[1];
    const $a1 = a1[1];
    const $b2 = b2[1];
    const $b1 = b1[1];
    const _a0 = get_implicit_form2_dd_with_running_error_abs(a0);
    const _a1 = get_implicit_form2_dd_with_running_error_abs($a1);
    const _a2 = get_implicit_form2_dd_with_running_error_abs($a2);
    const _b0 = get_implicit_form2_dd_with_running_error_abs(b0);
    const _b1 = get_implicit_form2_dd_with_running_error_abs($b1);
    const _b2 = get_implicit_form2_dd_with_running_error_abs($b2);
    const a2b1 = get_implicit_form2_dd_with_running_error_qmq(a2, b1);
    const a2b1_ = a2_ * _b1 + 2 * get_implicit_form2_dd_with_running_error_abs($a2 * $b1);
    const a1b2 = get_implicit_form2_dd_with_running_error_qmq(a1, b2);
    const a1b2_ = _a1 * b2_ + 2 * get_implicit_form2_dd_with_running_error_abs($a1 * $b2);
    const a2b0 = get_implicit_form2_dd_with_running_error_qmd(b0, a2);
    const a2b0_ = _b0 * a2_ + get_implicit_form2_dd_with_running_error_abs(b0 * $a2);
    const a0b2 = get_implicit_form2_dd_with_running_error_qmd(a0, b2);
    const a0b2_ = _a0 * b2_ + get_implicit_form2_dd_with_running_error_abs(a0 * $b2);
    const a1b0 = get_implicit_form2_dd_with_running_error_qmd(b0, a1);
    const a1b0_ = get_implicit_form2_dd_with_running_error_abs(b0 * $a1);
    const a0b1 = get_implicit_form2_dd_with_running_error_qmd(a0, b1);
    const a0b1_ = get_implicit_form2_dd_with_running_error_abs(a0 * $b1);
    const a2a2 = get_implicit_form2_dd_with_running_error_qmq(a2, a2);
    const a2a2_ = 2 * (a2_ * _a2 + get_implicit_form2_dd_with_running_error_abs($a2 * $a2));
    const a2b2 = get_implicit_form2_dd_with_running_error_qmq(a2, b2);
    const a2b2_ = a2_ * _b2 + _a2 * b2_ + 2 * get_implicit_form2_dd_with_running_error_abs($a2 * $b2);
    const b2b2 = get_implicit_form2_dd_with_running_error_qmq(b2, b2);
    const b2b2_ = 2 * (b2_ * _b2 + get_implicit_form2_dd_with_running_error_abs($b2 * $b2));
    const $a2b1 = $a2 * $b1;
    const $a1b2 = $a1 * $b2;
    const $a2b0 = $a2 * b0;
    const $a0b2 = a0 * $b2;
    const $a1b0 = $a1 * b0;
    const $a0b1 = a0 * $b1;
    const $q1 = $a2b1 - $a1b2;
    const $q2 = $a2b0 - $a0b2;
    const $q3 = $a1b0 - $a0b1;
    const q1 = get_implicit_form2_dd_with_running_error_qdq(a2b1, a1b2);
    const _q1 = get_implicit_form2_dd_with_running_error_abs($q1);
    const q1_ = a2b1_ + a1b2_ + get_implicit_form2_dd_with_running_error_abs($q1);
    const q2 = get_implicit_form2_dd_with_running_error_qdq(a2b0, a0b2);
    const _q2 = get_implicit_form2_dd_with_running_error_abs($q2);
    const q2_ = a2b0_ + a0b2_ + get_implicit_form2_dd_with_running_error_abs($q2);
    const q3 = get_implicit_form2_dd_with_running_error_qdq(a1b0, a0b1);
    const _q3 = get_implicit_form2_dd_with_running_error_abs($q3);
    const q3_ = a1b0_ + a0b1_ + get_implicit_form2_dd_with_running_error_abs($q3);
    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2
    // -------------
    // b2**2 *x**2
    // -b2**2 *x**2
    // -------------
    const vₓₓ = qno(b2b2);
    const vₓₓ_ = b2b2_;
    // -------------
    // -2*a2*b2 *x*y
    // 2*a2*b2 *x*y
    // -------------
    const vₓᵧ = qm2(a2b2);
    const vₓᵧ_ = a2b2_;
    // -------------
    // a2**2 *y**2 
    // -a2**2 *y**2 
    // -------------
    const vᵧᵧ = qno(a2a2);
    const vᵧᵧ_ = a2a2_;
    // -----------------------------------------------
    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2
    // (b1*q1 + -2*b2*q2) *x
    //const vₓ = b1*q1 - 2*b2*q2;
    // -----------------------------------------------
    const $w1 = $b1 * $q1;
    const w1 = get_implicit_form2_dd_with_running_error_qmq(b1, q1);
    const w1_ = _b1 * q1_ + 2 * get_implicit_form2_dd_with_running_error_abs($w1);
    const $w2 = 2 * $q2 * $b2;
    const w2 = qm2(get_implicit_form2_dd_with_running_error_qmq(b2, q2));
    const w2_ = 2 * (b2_ * _q2 + _b2 * q2_ + 2 * get_implicit_form2_dd_with_running_error_abs($w2));
    const $vₓ = $w1 - $w2;
    const vₓ = get_implicit_form2_dd_with_running_error_qdq(w1, w2);
    const vₓ_ = w1_ + w2_ + get_implicit_form2_dd_with_running_error_abs($vₓ);
    // -----------------------------------------------
    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0
    // (-a1*q1 + 2*a2*q2) *y
    // -----------------------------------------------
    const $w3 = 2 * $a2 * $q2;
    const w3 = qm2(get_implicit_form2_dd_with_running_error_qmq(a2, q2));
    const w3_ = 2 * (a2_ * _q2 + _a2 * q2_ + 2 * get_implicit_form2_dd_with_running_error_abs($w3));
    const $w4 = $a1 * $q1;
    const w4 = get_implicit_form2_dd_with_running_error_qmq(a1, q1);
    const w4_ = _a1 * q1_ + 2 * get_implicit_form2_dd_with_running_error_abs($w4);
    const $vᵧ = $w3 - $w4;
    const vᵧ = get_implicit_form2_dd_with_running_error_qdq(w3, w4);
    const vᵧ_ = w3_ + w4_ + get_implicit_form2_dd_with_running_error_abs($vᵧ);
    // --------------------------------------------------------------------------------------------------
    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2
    // q1*q3 + -q2**2
    // --------------------------------------------------------------------------------------------------
    const $w5 = $q1 * $q3;
    const w5 = get_implicit_form2_dd_with_running_error_qmq(q1, q3);
    const w5_ = q1_ * _q3 + _q1 * q3_ + 2 * get_implicit_form2_dd_with_running_error_abs($w5);
    const $w6 = $q2 * $q2;
    const w6 = get_implicit_form2_dd_with_running_error_qmq(q2, q2);
    const w6_ = 2 * (q2_ * _q2 + get_implicit_form2_dd_with_running_error_abs($w6));
    const $v = $w5 - $w6;
    const v = get_implicit_form2_dd_with_running_error_qdq(w5, w6);
    const v_ = w5_ + w6_ + get_implicit_form2_dd_with_running_error_abs($v);
    return {
        coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },
        errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez1-dd.ts




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_bez2_bez1_dd_tp = node_twoProduct;
const get_coeffs_bez2_bez1_dd_qm2 = node_ddMultBy2;
const get_coeffs_bez2_bez1_dd_qmd = node_ddMultDouble2;
const get_coeffs_bez2_bez1_dd_qmq = node_ddMultDd;
const get_coeffs_bez2_bez1_dd_qaq = node_ddAddDd;
const get_coeffs_bez2_bez1_dd_abs = Math.abs;
const get_coeffs_bez2_bez1_dd_3 = error_analysis_error_analysis_(3);
/**
 * Returns a polynomial in 1 variable (including coefficientwise error bound)
 * whose roots are the parameter values of the intersection points of an order
 * 2 and 1 bezier curve (i.e. a quadratic bezier curve and a line).
 *
 * The returned polynomial degree will be 2
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** none
 * * intermediate calculations are done in double-double precision and this is
 * reflected in the output error bound (which is approximately
 * `n * (Number.EPSILON**2) * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned need **not** be scaled before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez2Bez1Dd(ps1, ps2) {
    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = getImplicitForm2DdWithRunningError(ps1);
    const [[c1, c0], [d1, d0]] = get_xy_dd_with_running_error_getXY1DdWithRunningError(ps2);
    const $vₓₓ = vₓₓ[1];
    const $vₓᵧ = vₓᵧ[1];
    const $vᵧᵧ = vᵧᵧ[1];
    const $vₓ = vₓ[1];
    const $vᵧ = vᵧ[1];
    const $v = v[1];
    const _vₓₓ = get_coeffs_bez2_bez1_dd_abs($vₓₓ);
    const _vₓᵧ = get_coeffs_bez2_bez1_dd_abs($vₓᵧ);
    const _vᵧᵧ = get_coeffs_bez2_bez1_dd_abs($vᵧᵧ);
    const $c1 = c1[1];
    const $d1 = d1[1];
    const _c0 = get_coeffs_bez2_bez1_dd_abs(c0);
    const _c1 = get_coeffs_bez2_bez1_dd_abs($c1);
    const _d0 = get_coeffs_bez2_bez1_dd_abs(d0);
    const _d1 = get_coeffs_bez2_bez1_dd_abs($d1);
    const $c0c0 = c0 * c0;
    const $c0c1 = c0 * $c1;
    const $c0d0 = c0 * d0;
    const $c0d1 = c0 * $d1;
    const $c1c1 = $c1 * $c1;
    const $c1d0 = $c1 * d0;
    const $c1d1 = $c1 * $d1;
    const $d0d0 = d0 * d0;
    const $d0d1 = d0 * $d1;
    const $d1d1 = $d1 * $d1;
    const c0c0 = get_coeffs_bez2_bez1_dd_tp(c0, c0);
    const c0c1 = get_coeffs_bez2_bez1_dd_qmd(c0, c1);
    const _c0c1_ = get_coeffs_bez2_bez1_dd_abs($c0c1);
    const c0d0 = get_coeffs_bez2_bez1_dd_tp(c0, d0);
    const c0d1 = get_coeffs_bez2_bez1_dd_qmd(c0, d1);
    const c0d1_ = get_coeffs_bez2_bez1_dd_abs($c0d1);
    const _c1c1 = get_coeffs_bez2_bez1_dd_abs($c1c1);
    const c1c1 = get_coeffs_bez2_bez1_dd_qmq(c1, c1);
    const c1c1_ = 2 * _c1c1;
    const c1d0 = get_coeffs_bez2_bez1_dd_qmd(d0, c1);
    const c1d0_ = get_coeffs_bez2_bez1_dd_abs($c1d0);
    const _c1d1 = get_coeffs_bez2_bez1_dd_abs($c1d1);
    const c1d1 = get_coeffs_bez2_bez1_dd_qmq(c1, d1);
    const c1d1_ = 2 * _c1d1;
    const d0d0 = get_coeffs_bez2_bez1_dd_tp(d0, d0);
    const d0d1 = get_coeffs_bez2_bez1_dd_qmd(d0, d1);
    const _d0d1_ = get_coeffs_bez2_bez1_dd_abs($d0d1);
    const _d1d1 = get_coeffs_bez2_bez1_dd_abs($d1d1);
    const d1d1 = get_coeffs_bez2_bez1_dd_qmq(d1, d1);
    const d1d1_ = 2 * _d1d1;
    // a1**2*vₓₓ + a1*b1*vₓᵧ + b1**2*vᵧᵧ
    const $p1 = $c1c1 * $vₓₓ;
    const p1 = get_coeffs_bez2_bez1_dd_qmq(c1c1, vₓₓ);
    const p1_ = c1c1_ * _vₓₓ * _c1c1 * vₓₓ_ + 2 * get_coeffs_bez2_bez1_dd_abs($p1);
    const $p2 = $d1d1 * $vᵧᵧ;
    const p2 = get_coeffs_bez2_bez1_dd_qmq(d1d1, vᵧᵧ);
    const p2_ = d1d1_ * _vᵧᵧ * _d1d1 * vᵧᵧ_ + 2 * get_coeffs_bez2_bez1_dd_abs($p2);
    const $p3 = $c1d1 * $vₓᵧ;
    const p3 = get_coeffs_bez2_bez1_dd_qmq(c1d1, vₓᵧ);
    const p3_ = c1d1_ * _vₓᵧ * _c1d1 * vₓᵧ_ + 2 * get_coeffs_bez2_bez1_dd_abs($p3);
    const $p4 = $p1 + $p2;
    const p4 = get_coeffs_bez2_bez1_dd_qaq(p1, p2);
    const p4_ = p1_ + p2_ + get_coeffs_bez2_bez1_dd_abs($p4);
    const $v2 = $p4 + $p3;
    const v2 = get_coeffs_bez2_bez1_dd_qaq(p4, p3);
    const v2_ = p4_ + p3_ + get_coeffs_bez2_bez1_dd_abs($v2);
    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*vₓ + 2*b0*b1*vᵧᵧ + b1*vᵧ
    const $p5 = $c0c1 * $vₓₓ;
    const p5 = get_coeffs_bez2_bez1_dd_qmq(c0c1, vₓₓ);
    const p5_ = _c0c1_ * (_vₓₓ + vₓₓ_) + 2 * get_coeffs_bez2_bez1_dd_abs($p5);
    const $p6 = $d0d1 * $vᵧᵧ;
    const p6 = get_coeffs_bez2_bez1_dd_qmq(d0d1, vᵧᵧ);
    const p6_ = _d0d1_ * (_vᵧᵧ + vᵧᵧ_) + 2 * get_coeffs_bez2_bez1_dd_abs($p6);
    const $p7 = $c0d1 + $c1d0;
    const p7 = get_coeffs_bez2_bez1_dd_qaq(c0d1, c1d0);
    const p7_ = c0d1_ + c1d0_ + get_coeffs_bez2_bez1_dd_abs($p7);
    const $pn = $p7 * $vₓᵧ;
    const pn = get_coeffs_bez2_bez1_dd_qmq(p7, vₓᵧ);
    const pn_ = p7_ * _vₓᵧ + get_coeffs_bez2_bez1_dd_abs($p7) * vₓᵧ_ + 2 * get_coeffs_bez2_bez1_dd_abs($pn);
    const $p8 = 2 * ($p5 + $p6);
    const p8 = get_coeffs_bez2_bez1_dd_qm2(get_coeffs_bez2_bez1_dd_qaq(p5, p6));
    const p8_ = 2 * (p5_ + p6_) + get_coeffs_bez2_bez1_dd_abs($p8);
    const $p9 = $p8 + $pn;
    const p9 = get_coeffs_bez2_bez1_dd_qaq(p8, pn);
    const p9_ = p8_ + pn_ + get_coeffs_bez2_bez1_dd_abs($p9);
    const $pa = $c1 * $vₓ;
    const pa = get_coeffs_bez2_bez1_dd_qmq(c1, vₓ);
    const pa_ = _c1 * vₓ_ + 2 * get_coeffs_bez2_bez1_dd_abs($pa);
    const $pb = $d1 * $vᵧ;
    const pb = get_coeffs_bez2_bez1_dd_qmq(d1, vᵧ);
    const pb_ = _d1 * vᵧ_ + 2 * get_coeffs_bez2_bez1_dd_abs($pb);
    const $pc = $pa + $pb;
    const pc = get_coeffs_bez2_bez1_dd_qaq(pa, pb);
    const pc_ = pa_ + pb_ + get_coeffs_bez2_bez1_dd_abs($pc);
    const $v1 = $p9 + $pc;
    const v1 = get_coeffs_bez2_bez1_dd_qaq(p9, pc);
    const v1_ = p9_ + pc_ + get_coeffs_bez2_bez1_dd_abs($v1);
    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*vₓ + b0**2*vᵧᵧ + b0*vᵧ + v_0
    const $pe = $c0c0 * $vₓₓ;
    const pe = get_coeffs_bez2_bez1_dd_qmq(c0c0, vₓₓ);
    const pe_ = 2 * get_coeffs_bez2_bez1_dd_abs($pe);
    const $pf = $c0d0 * $vₓᵧ;
    const pf = get_coeffs_bez2_bez1_dd_qmq(c0d0, vₓᵧ);
    const pf_ = 2 * get_coeffs_bez2_bez1_dd_abs($pf);
    const $pg = $d0d0 * $vᵧᵧ;
    const pg = get_coeffs_bez2_bez1_dd_qmq(d0d0, vᵧᵧ);
    const pg_ = 2 * get_coeffs_bez2_bez1_dd_abs($pg);
    const $ph = $pe + $pf;
    const ph = get_coeffs_bez2_bez1_dd_qaq(pe, pf);
    const ph_ = pe_ + pf_ + get_coeffs_bez2_bez1_dd_abs($ph);
    const $pi = $ph + $pg;
    const pi = get_coeffs_bez2_bez1_dd_qaq(ph, pg);
    const pi_ = ph_ + pg_ + get_coeffs_bez2_bez1_dd_abs($pi);
    const $pj = c0 * $vₓ;
    const pj = get_coeffs_bez2_bez1_dd_qmd(c0, vₓ);
    const pj_ = _c0 * vₓ_ + get_coeffs_bez2_bez1_dd_abs($pj);
    const $pk = d0 * $vᵧ;
    const pk = get_coeffs_bez2_bez1_dd_qmd(d0, vᵧ);
    const pk_ = _d0 * vᵧ_ + get_coeffs_bez2_bez1_dd_abs($pk);
    const $pl = $pj + $pk;
    const pl = get_coeffs_bez2_bez1_dd_qaq(pj, pk);
    const pl_ = pj_ + pk_ + get_coeffs_bez2_bez1_dd_abs($pl);
    const $pm = $pi + $pl;
    const pm = get_coeffs_bez2_bez1_dd_qaq(pi, pl);
    const pm_ = pi_ + pl_ + get_coeffs_bez2_bez1_dd_abs($pm);
    const $v0 = $pm + $v;
    const v0 = get_coeffs_bez2_bez1_dd_qaq(pm, v);
    const v0_ = pm_ + v_ + get_coeffs_bez2_bez1_dd_abs($v0);
    return {
        coeffs: [v2, v1, v0],
        errBound: [get_coeffs_bez2_bez1_dd_3 * v2_, get_coeffs_bez2_bez1_dd_3 * v1_, get_coeffs_bez2_bez1_dd_3 * v0_]
    };
}


;// CONCATENATED MODULE: ./src/implicit-form/double-double/get-implicit-form3-dd-with-running-error.ts


const get_implicit_form3_dd_with_running_error_abs = Math.abs;
const get_implicit_form3_dd_with_running_error_qno = node_ddNegativeOf; // error -> 0
const get_implicit_form3_dd_with_running_error_qm2 = node_ddMultBy2; // error -> 0 
const qd2 = node_ddDivBy2; // error -> 0 
//const qmd2 = qMultDouble1;  // error -> 1.5*γ²
const get_implicit_form3_dd_with_running_error_qmd = node_ddMultDouble2; // error -> 3*γ²
const get_implicit_form3_dd_with_running_error_qmq = node_ddMultDd; // error -> 5*γ² (worst found), 7*γ² (theoretical), we use 6*γ²
const get_implicit_form3_dd_with_running_error_qdq = node_ddDiffDd; // error -> 3*γ²
const get_implicit_form3_dd_with_running_error_qaq = node_ddAddDd; // error -> 3*γ²
/**
 * Returns a double-double precision implicit form of the given cubic
 * bezier curve and a coefficientwise error bound.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`
 * * **precondition:** TODO - add underflow / overflow conditions + docs below
 * * intermediate calculations are done in double-double precision and this is
 * reflected in the output error bound (which is approximately
 * `n * (Number.EPSILON**2) * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned first needs to be multiplied by `γγ3 === (3*u*u) / (1 - 3*u*u)`,
 * where `u === Number.EPSILON / 2` before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 * * takes about 15 micro-seconds on a 3rd gen i7 and Chrome 79
 *
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm3DdWithRunningError(ps) {
    //--------------------------------------------------------------------------
    // `var` -> a variable
    // `$var` -> the double precision approximation to `var`
    // `_var` -> the absolute value of $var (a prefix underscore on a variable means absolute value)
    // `var_` -> the error in var (a postfix underscore means error bound but should still be multiplied by 3*γ²)
    // `_var_` -> means both absolute value and absolute error bound
    // recall: `a*b`, where both `a` and `b` have errors |a| and |b| we get for the
    //   * error bound of (a*b) === a_|b| + |a|b_ + |a*b|   (when either of a and b is double)
    //   * error bound of (a*b) === a_|b| + |a|b_ + 2|a*b|  (when both a and b is double-double)
    //   * error bound of (a+b) === a_ + b_ + |a+b|         (when a and/or b is double or double-double)
    // * the returned errors need to be multiplied by 3γ² to get the true error
    // * can use either `$var` or `var[var.length-1]` (the approx value) in error calculations
    //   due to multiplication by 3*γ² and not 3*u²
    //--------------------------------------------------------------------------
    // examples: (all?)
    // ----------------
    // let qmd === ddMultDouble2, etc.
    //
    // ---------------
    // 1. double-double X by double
    // ---------------
    // qmd(a,b);  // both `a` and `b` is error-free
    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)
    //                           === 0|b| + |a|0 + |a*b|
    //                           === |a*b|
    //
    // ---------------
    // 2a. double-double +/- double-double
    // ---------------
    // qdq(a,b);  // error in a === |a|, thus call the error _a_, same with b
    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)
    //                           === _a_ + _b_ + |a+b|
    //
    // ---------------
    // 2b. double-double +/- double-double
    // ---------------
    // qaq(a,b);  // error in a === 2|a|, thus the error is 2*_a, same with b
    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)
    //                           === 2*_a + 2*_b + |a+b|
    //                           === 2*(_a + _b) + |a+b| OR
    //                           === a_ + b_ + |a+b|
    //
    // ---------------
    // 3a. double-double X double-double
    // ---------------
    // qmq(a,b);  // both `a` and `b` error-free
    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)
    //                           === 0|b| + |a|0 + 2|a*b|
    //                           === 2|a*b| 
    //
    // ---------------
    // 3b. double-double X double-double
    // ---------------
    // qmq(a,b);  // both `a` and `b` not error-free
    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)
    //
    // ---------------
    // 3b. double-double X double-double
    // ---------------
    // qmq(a,b);  // both `a` not error-free and `b` error-free
    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)
    //                           === a_|b| + 2|a*b| 
    //
    // ---------------
    // 4a. double-double +/- double
    // ---------------
    // qad(a,b);  // both `a` and `b` error-free
    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)
    //                           === 0 + 0 + |a+b|
    //                           === |a+b| 
    //--------------------------------------------------------------------------
    const { coeffs: [[a3, a2, a1, a0], [b3, b2, b1, b0]], errorBound: [[a3_, a2_, a1_], [b3_, b2_, b1_]] // a0, b0 - error free
     } = get_xy_dd_with_running_error_getXY3DdWithRunningError(ps);
    // The implicit form is given by:
    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0
    const $a1 = a1[1];
    const $a2 = a2[1];
    const $a3 = a3[1];
    const $b1 = b1[1];
    const $b2 = b2[1];
    const $b3 = b3[1];
    const _a0 = get_implicit_form3_dd_with_running_error_abs(a0);
    const _a1 = get_implicit_form3_dd_with_running_error_abs($a1);
    const _a2 = get_implicit_form3_dd_with_running_error_abs($a2);
    const _a3 = get_implicit_form3_dd_with_running_error_abs($a3);
    const _b0 = get_implicit_form3_dd_with_running_error_abs(b0);
    const _b1 = get_implicit_form3_dd_with_running_error_abs($b1);
    const _b2 = get_implicit_form3_dd_with_running_error_abs($b2);
    const _b3 = get_implicit_form3_dd_with_running_error_abs($b3);
    const a3b1 = get_implicit_form3_dd_with_running_error_qmq(a3, b1);
    const $a3b1 = $a3 * $b1;
    const a3b1_ = a3_ * _b1 + _a3 * b1_ + 2 * get_implicit_form3_dd_with_running_error_abs($a3b1);
    const a1b3 = get_implicit_form3_dd_with_running_error_qmq(a1, b3);
    const $a1b3 = $a1 * $b3;
    const a1b3_ = a1_ * _b3 + _a1 * b3_ + 2 * get_implicit_form3_dd_with_running_error_abs($a1b3);
    const a3b2 = get_implicit_form3_dd_with_running_error_qmq(a3, b2);
    const $a3b2 = $a3 * $b2;
    const a3b2_ = a3_ * _b2 + _a3 * b2_ + 2 * get_implicit_form3_dd_with_running_error_abs($a3b2);
    const a2b2 = get_implicit_form3_dd_with_running_error_qmq(a2, b2);
    const $a2b2 = $a2 * $b2;
    const a2b2_ = a2_ * _b2 + _a2 * b2_ + 2 * get_implicit_form3_dd_with_running_error_abs($a2b2);
    const a2b3 = get_implicit_form3_dd_with_running_error_qmq(a2, b3);
    const $a2b3 = $a2 * $b3;
    const a2b3_ = a2_ * _b3 + _a2 * b3_ + 2 * get_implicit_form3_dd_with_running_error_abs($a2b3);
    const a3a3 = get_implicit_form3_dd_with_running_error_qmq(a3, a3);
    const $a3a3 = $a3 * $a3;
    const _a3a3 = get_implicit_form3_dd_with_running_error_abs($a3a3);
    const a3a3_ = a3_ * _a3 + _a3 * a3_ + 2 * get_implicit_form3_dd_with_running_error_abs($a3a3);
    const b2b2 = get_implicit_form3_dd_with_running_error_qmq(b2, b2);
    const $b2b2 = $b2 * $b2;
    const b2b2_ = b2_ * _b2 + _b2 * b2_ + 2 * get_implicit_form3_dd_with_running_error_abs($b2b2);
    const b3b3 = get_implicit_form3_dd_with_running_error_qmq(b3, b3);
    const $b3b3 = $b3 * $b3;
    const _b3b3 = get_implicit_form3_dd_with_running_error_abs($b3b3);
    const b3b3_ = b3_ * _b3 + _b3 * b3_ + 2 * get_implicit_form3_dd_with_running_error_abs($b3b3);
    const a1a3 = get_implicit_form3_dd_with_running_error_qmq(a1, a3);
    const $a1a3 = $a1 * $a3;
    const a1a3_ = a1_ * _a3 + _a1 * a3_ + 2 * get_implicit_form3_dd_with_running_error_abs($a1a3);
    const a2a2 = get_implicit_form3_dd_with_running_error_qmq(a2, a2);
    const $a2a2 = $a2 * $a2;
    const a2a2_ = a2_ * _a2 + _a2 * a2_ + 2 * get_implicit_form3_dd_with_running_error_abs($a2a2);
    const b1b3 = get_implicit_form3_dd_with_running_error_qmq(b1, b3);
    const $b1b3 = $b1 * $b3;
    const b1b3_ = b1_ * _b3 + _b1 * b3_ + 2 * get_implicit_form3_dd_with_running_error_abs($b1b3);
    const b2b3 = get_implicit_form3_dd_with_running_error_qmq(b2, b3);
    const _b2b3 = get_implicit_form3_dd_with_running_error_abs($b2 * $b3); // or equivalently `_b2b3 = _b2*_b3`;
    const b2b3_ = b2_ * _b3 + _b2 * b3_ + 2 * _b2b3;
    const a2a3 = get_implicit_form3_dd_with_running_error_qmq(a2, a3);
    const _a2a3 = get_implicit_form3_dd_with_running_error_abs($a2 * $a3);
    const a2a3_ = a2_ * _a3 + _a2 * a3_ + 2 * _a2a3;
    const a3b3 = get_implicit_form3_dd_with_running_error_qmq(a3, b3);
    const _a3b3 = get_implicit_form3_dd_with_running_error_abs($a3 * $b3);
    const a3b3_ = a3_ * _b3 + _a3 * b3_ + 2 * _a3b3;
    const a3b0 = get_implicit_form3_dd_with_running_error_qmd(b0, a3);
    const $a3b0 = $a3 * b0;
    const a3b0_ = a3_ * _b0 + get_implicit_form3_dd_with_running_error_abs($a3b0);
    const a0b3 = get_implicit_form3_dd_with_running_error_qmd(a0, b3);
    const $a0b3 = a0 * $b3;
    const a0b3_ = _a0 * b3_ + get_implicit_form3_dd_with_running_error_abs($a0b3);
    const a2b0 = get_implicit_form3_dd_with_running_error_qmd(b0, a2);
    const $a2b0 = $a2 * b0;
    const a2b0_ = a2_ * _b0 + get_implicit_form3_dd_with_running_error_abs($a2b0);
    const a0b2 = get_implicit_form3_dd_with_running_error_qmd(a0, b2);
    const $a0b2 = a0 * $b2;
    const a0b2_ = _a0 * b2_ + get_implicit_form3_dd_with_running_error_abs($a0b2);
    const a2b1 = get_implicit_form3_dd_with_running_error_qmq(a2, b1);
    const $a2b1 = $a2 * $b1;
    const a2b1_ = a2_ * _b1 + _a2 * b1_ + 2 * get_implicit_form3_dd_with_running_error_abs($a2b1);
    const a1b2 = get_implicit_form3_dd_with_running_error_qmq(a1, b2);
    const $a1b2 = $a1 * $b2;
    const a1b2_ = a1_ * _b2 + _a1 * b2_ + 2 * get_implicit_form3_dd_with_running_error_abs($a1b2);
    const a1b0 = get_implicit_form3_dd_with_running_error_qmd(b0, a1);
    const $a1b0 = $a1 * b0;
    const a1b0_ = a1_ * _b0 + get_implicit_form3_dd_with_running_error_abs($a1b0);
    const a0b1 = get_implicit_form3_dd_with_running_error_qmd(a0, b1);
    const $a0b1 = a0 * $b1;
    const a0b1_ = _a0 * b1_ + get_implicit_form3_dd_with_running_error_abs($a0b1);
    const q1 = get_implicit_form3_dd_with_running_error_qdq(a3b0, a0b3);
    const q1_ = a3b0_ + a0b3_ + get_implicit_form3_dd_with_running_error_abs($a3b0 - $a0b3);
    const q2 = get_implicit_form3_dd_with_running_error_qdq(a3b1, a1b3);
    const q2_ = a3b1_ + a1b3_ + get_implicit_form3_dd_with_running_error_abs($a3b1 - $a1b3);
    const q3 = get_implicit_form3_dd_with_running_error_qdq(a3b2, a2b3);
    const q3_ = a3b2_ + a2b3_ + get_implicit_form3_dd_with_running_error_abs($a3b2 - $a2b3);
    const q4 = get_implicit_form3_dd_with_running_error_qdq(a2b0, a0b2);
    const q4_ = a2b0_ + a0b2_ + get_implicit_form3_dd_with_running_error_abs($a2b0 - $a0b2);
    const q5 = get_implicit_form3_dd_with_running_error_qdq(a2b1, a1b2);
    const q5_ = a2b1_ + a1b2_ + get_implicit_form3_dd_with_running_error_abs($a2b1 - $a1b2);
    const q6 = get_implicit_form3_dd_with_running_error_qdq(a1b0, a0b1);
    const q6_ = a1b0_ + a0b1_ + get_implicit_form3_dd_with_running_error_abs($a1b0 - $a0b1);
    const _t1 = get_implicit_form3_dd_with_running_error_abs($b1b3 - $b2b2);
    const t1 = get_implicit_form3_dd_with_running_error_qdq(b1b3, b2b2);
    const t1_ = b1b3_ + b2b2_ + _t1;
    const _t2 = get_implicit_form3_dd_with_running_error_abs($a1a3 - $a2a2);
    const t2 = get_implicit_form3_dd_with_running_error_qdq(a1a3, a2a2);
    const t2_ = a1a3_ + a2a2_ + get_implicit_form3_dd_with_running_error_abs($a1a3 - $a2a2);
    const _p1 = get_implicit_form3_dd_with_running_error_abs($a2b3 + $a3b2);
    const p1 = get_implicit_form3_dd_with_running_error_qaq(a2b3, a3b2);
    const p1_ = a2b3_ + a3b2_ + get_implicit_form3_dd_with_running_error_abs($a2b3 + $a3b2);
    const $p2 = $a1b3 + $a3b1;
    const _p2 = get_implicit_form3_dd_with_running_error_abs($p2);
    const p2 = get_implicit_form3_dd_with_running_error_qaq(a1b3, a3b1);
    const p2_ = a1b3_ + a3b1_ + _p2;
    const tq2 = get_implicit_form3_dd_with_running_error_qm2(q2);
    const tq2_ = 2 * q2_;
    const $q1 = $a3b0 - $a0b3;
    const $q2 = $a3b1 - $a1b3;
    const $q3 = $a3b2 - $a2b3;
    const $q4 = $a2b0 - $a0b2;
    const $q5 = $a2b1 - $a1b2;
    const $q6 = $a1b0 - $a0b1;
    const _q1 = get_implicit_form3_dd_with_running_error_abs($q1);
    const _q2 = get_implicit_form3_dd_with_running_error_abs($q2);
    const _q3 = get_implicit_form3_dd_with_running_error_abs($q3);
    const _q4 = get_implicit_form3_dd_with_running_error_abs($q4);
    const _q5 = get_implicit_form3_dd_with_running_error_abs($q5);
    const _q6 = get_implicit_form3_dd_with_running_error_abs($q6);
    const _tq2 = 2 * _q2;
    const q1q1 = get_implicit_form3_dd_with_running_error_qmq(q1, q1);
    const q1q2 = get_implicit_form3_dd_with_running_error_qmq(q1, q2);
    const q1q3 = get_implicit_form3_dd_with_running_error_qmq(q1, q3);
    const q1q5 = get_implicit_form3_dd_with_running_error_qmq(q1, q5);
    const q2q2 = get_implicit_form3_dd_with_running_error_qmq(q2, q2);
    const tq2q4 = get_implicit_form3_dd_with_running_error_qmq(tq2, q4);
    const q3q4 = get_implicit_form3_dd_with_running_error_qmq(q3, q4);
    const q3q5 = get_implicit_form3_dd_with_running_error_qmq(q3, q5);
    const q3q6 = get_implicit_form3_dd_with_running_error_qmq(q3, q6);
    const q1q1_ = q1_ * _q1 + _q1 * q1_ + 2 * get_implicit_form3_dd_with_running_error_abs(q1q1[1]);
    const q1q2_ = q1_ * _q2 + _q1 * q2_ + 2 * get_implicit_form3_dd_with_running_error_abs(q1q2[1]);
    const q1q3_ = q1_ * _q3 + _q1 * q3_ + 2 * get_implicit_form3_dd_with_running_error_abs(q1q3[1]);
    const q1q5_ = q1_ * _q5 + _q1 * q5_ + 2 * get_implicit_form3_dd_with_running_error_abs(q1q5[1]);
    const q2q2_ = q2_ * _q2 + _q2 * q2_ + 2 * get_implicit_form3_dd_with_running_error_abs(q2q2[1]);
    const tq2q4_ = tq2_ * _q4 + _tq2 * q4_ + 2 * get_implicit_form3_dd_with_running_error_abs(tq2q4[1]);
    const q3q4_ = q3_ * _q4 + _q3 * q4_ + 2 * get_implicit_form3_dd_with_running_error_abs(q3q4[1]);
    const q3q5_ = q3_ * _q5 + _q3 * q5_ + 2 * get_implicit_form3_dd_with_running_error_abs(q3q5[1]);
    const q3q6_ = q3_ * _q6 + _q3 * q6_ + 2 * get_implicit_form3_dd_with_running_error_abs(q3q4[1]);
    const vₓₓₓ = get_implicit_form3_dd_with_running_error_qmq(get_implicit_form3_dd_with_running_error_qno(b3), b3b3);
    const vₓₓₓ_ = b3_ * _b3b3 + _b3 * b3b3_ + 2 * get_implicit_form3_dd_with_running_error_abs(vₓₓₓ[1]);
    const _z1 = 3 * _a3;
    const z1 = get_implicit_form3_dd_with_running_error_qmd(3, a3);
    const z1_ = 3 * a3_ + _z1;
    const vₓₓᵧ = get_implicit_form3_dd_with_running_error_qmq(z1, b3b3);
    const vₓₓᵧ_ = z1_ * _b3b3 + _z1 * b3b3_ + 2 * get_implicit_form3_dd_with_running_error_abs(vₓₓᵧ[1]);
    const _z2 = 3 * _b3;
    const z2 = get_implicit_form3_dd_with_running_error_qmd(-3, b3);
    const z2_ = 3 * b3_ + _z2;
    const vₓᵧᵧ = get_implicit_form3_dd_with_running_error_qmq(z2, a3a3);
    const vₓᵧᵧ_ = z2_ * _a3a3 + _z2 * a3a3_ + 2 * get_implicit_form3_dd_with_running_error_abs(vₓᵧᵧ[1]);
    const vᵧᵧᵧ = get_implicit_form3_dd_with_running_error_qmq(a3, a3a3);
    const vᵧᵧᵧ_ = a3_ * _a3a3 + _a3 * a3a3_ + 2 * get_implicit_form3_dd_with_running_error_abs(vᵧᵧᵧ[1]);
    const $z3 = -3 * $q1;
    const _z3 = 3 * _q1;
    const z3 = get_implicit_form3_dd_with_running_error_qmd(-3, q1);
    const z3_ = 3 * q1_ + _z3;
    const u1 = get_implicit_form3_dd_with_running_error_qdq(z3, q5);
    const _u1 = get_implicit_form3_dd_with_running_error_abs($z3 - $q5);
    const u1_ = z3_ + q5_ + _u1;
    //const t1_ = _b1b3 + _b2b2 + _t1;
    //const _t2 = abs(t2);
    //const t2_ = _a1a3 + _a2a2 + abs(t2);
    const w1 = get_implicit_form3_dd_with_running_error_qmq(u1, b3b3);
    const w1_ = u1_ * _b3b3 + _u1 * b3b3_ + 2 * get_implicit_form3_dd_with_running_error_abs(w1[1]);
    const w2 = get_implicit_form3_dd_with_running_error_qmq(q3, t1);
    const w2_ = q3_ * _t1 + _q3 * t1_ + 2 * get_implicit_form3_dd_with_running_error_abs(w2[1]);
    const w3 = get_implicit_form3_dd_with_running_error_qaq(w1, w2);
    const w3_ = w1_ + w2_ + get_implicit_form3_dd_with_running_error_abs(w3[1]);
    const w4 = get_implicit_form3_dd_with_running_error_qmq(tq2, b2b3);
    const w4_ = tq2_ * _b2b3 + _tq2 * b2b3_ + 2 * get_implicit_form3_dd_with_running_error_abs(w4[1]);
    //const vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;
    const vₓₓ = get_implicit_form3_dd_with_running_error_qaq(w3, w4);
    const vₓₓ_ = w3_ + w4_ + get_implicit_form3_dd_with_running_error_abs(vₓₓ[1]);
    const w5 = get_implicit_form3_dd_with_running_error_qmq(u1, a3a3);
    const w5_ = u1_ * _a3a3 + _u1 * a3a3_ + 2 * get_implicit_form3_dd_with_running_error_abs(w5[1]);
    const w6 = get_implicit_form3_dd_with_running_error_qmq(q3, t2);
    const w6_ = q3_ * _t2 + _q3 * t2_ + 2 * get_implicit_form3_dd_with_running_error_abs(w6[1]);
    const w7 = get_implicit_form3_dd_with_running_error_qaq(w5, w6);
    const w7_ = w5_ + w6_ + get_implicit_form3_dd_with_running_error_abs(w7[1]);
    const w8 = get_implicit_form3_dd_with_running_error_qmq(tq2, a2a3);
    const w8_ = tq2_ * _a2a3 + _tq2 * a2a3_ + 2 * get_implicit_form3_dd_with_running_error_abs(w8[1]);
    //const vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;
    const vᵧᵧ = get_implicit_form3_dd_with_running_error_qaq(w7, w8);
    const vᵧᵧ_ = w7_ + w8_ + get_implicit_form3_dd_with_running_error_abs(vᵧᵧ[1]);
    const _wa = get_implicit_form3_dd_with_running_error_abs($a2b2 - $p2 / 2);
    const wa = get_implicit_form3_dd_with_running_error_qdq(a2b2, qd2(p2));
    const wa_ = a2b2_ + p2_ / 2 + get_implicit_form3_dd_with_running_error_abs(wa[1]);
    const wb = get_implicit_form3_dd_with_running_error_qmq(u1, a3b3);
    const wb_ = u1_ * _a3b3 + _u1 * a3b3_ + 2 * get_implicit_form3_dd_with_running_error_abs(wb[1]);
    const wc = get_implicit_form3_dd_with_running_error_qmq(q2, p1);
    const wc_ = q2_ * _p1 + _q2 * p1_ + 2 * get_implicit_form3_dd_with_running_error_abs(wc[1]);
    const wd = get_implicit_form3_dd_with_running_error_qaq(wb, wc);
    const wd_ = wb_ + wc_ + get_implicit_form3_dd_with_running_error_abs(wd[1]);
    const wq = get_implicit_form3_dd_with_running_error_qmq(q3, wa);
    const wq_ = q3_ * _wa + _q3 * wa_ + 2 * get_implicit_form3_dd_with_running_error_abs(wq[1]);
    //-------------------------------------------------------
    // const vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));
    //-------------------------------------------------------
    const vₓᵧ = get_implicit_form3_dd_with_running_error_qm2(get_implicit_form3_dd_with_running_error_qdq(wq, wd));
    const vₓᵧ_ = 2 * (wq_ + wd_) + get_implicit_form3_dd_with_running_error_abs(vₓᵧ[1]);
    const wr = get_implicit_form3_dd_with_running_error_qmd(-3, q1q1);
    const wr_ = 3 * q1q1_ + get_implicit_form3_dd_with_running_error_abs(wr[1]);
    const we = get_implicit_form3_dd_with_running_error_qdq(wr, get_implicit_form3_dd_with_running_error_qm2(q1q5));
    const we_ = wr_ + 2 * q1q5_ + get_implicit_form3_dd_with_running_error_abs(we[1]);
    const wf = get_implicit_form3_dd_with_running_error_qaq(tq2q4, q3q6);
    const wf_ = tq2q4_ + q3q6_ + get_implicit_form3_dd_with_running_error_abs(wf[1]);
    //------------------------------------------------
    // const s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);
    //------------------------------------------------
    const s1 = get_implicit_form3_dd_with_running_error_qaq(we, wf);
    const _s1 = get_implicit_form3_dd_with_running_error_abs(s1[1]);
    const s1_ = we_ + wf_ + _s1;
    //-----------------------------
    // const s2 = 2*(q1q2 - q3q4);
    //-----------------------------
    const s2 = get_implicit_form3_dd_with_running_error_qm2(get_implicit_form3_dd_with_running_error_qdq(q1q2, q3q4));
    const _s2 = get_implicit_form3_dd_with_running_error_abs(s2[1]);
    const s2_ = 2 * (q1q2_ + q3q4_) + _s2;
    const wl = get_implicit_form3_dd_with_running_error_qdq(q1q3, q2q2);
    const wl_ = q1q3_ + q2q2_ + get_implicit_form3_dd_with_running_error_abs(wl[1]);
    //-------------------------------
    // const s3 = q1q3 - q2q2 + q3q5;
    //-------------------------------
    const s3 = get_implicit_form3_dd_with_running_error_qaq(wl, q3q5);
    const _s3 = get_implicit_form3_dd_with_running_error_abs(s3[1]);
    const s3_ = wl_ + q3q5_ + _s3;
    const wm = get_implicit_form3_dd_with_running_error_qmq(b3, s1);
    const wm_ = b3_ * _s1 + _b3 * s1_ + 2 * get_implicit_form3_dd_with_running_error_abs(wm[1]);
    const ws = get_implicit_form3_dd_with_running_error_qmq(b2, s2);
    const ws_ = b2_ * _s2 + _b2 * s2_ + 2 * get_implicit_form3_dd_with_running_error_abs(ws[1]);
    const wt = get_implicit_form3_dd_with_running_error_qmq(b1, s3);
    const wt_ = b1_ * _s3 + _b1 * s3_ + 2 * get_implicit_form3_dd_with_running_error_abs(wt[1]);
    const wn = get_implicit_form3_dd_with_running_error_qaq(ws, wt);
    const wn_ = ws_ + wt_ + get_implicit_form3_dd_with_running_error_abs(wn[1]);
    //-------------------------------
    // const vₓ = b3*s1 + (b2*s2 + b1*s3);
    //-------------------------------
    const vₓ = get_implicit_form3_dd_with_running_error_qaq(wm, wn);
    const vₓ_ = wm_ + wn_ + get_implicit_form3_dd_with_running_error_abs(vₓ[1]);
    const wo = get_implicit_form3_dd_with_running_error_qmq(a3, s1);
    const wo_ = a3_ * _s1 + _a3 * s1_ + 2 * get_implicit_form3_dd_with_running_error_abs(wo[1]);
    const wu = get_implicit_form3_dd_with_running_error_qmq(a2, s2);
    const wu_ = a2_ * _s2 + _a2 * s2_ + 2 * get_implicit_form3_dd_with_running_error_abs(wu[1]);
    const wv = get_implicit_form3_dd_with_running_error_qmq(a1, s3);
    const wv_ = a1_ * _s3 + _a1 * s3_ + 2 * get_implicit_form3_dd_with_running_error_abs(wv[1]);
    const wp = get_implicit_form3_dd_with_running_error_qaq(wu, wv);
    const wp_ = wu_ + wv_ + get_implicit_form3_dd_with_running_error_abs(wp[1]);
    //-------------------------------------
    // const vᵧ = -a3*s1 - (a2*s2 + a1*s3);
    //-------------------------------------
    const vᵧ = get_implicit_form3_dd_with_running_error_qno(get_implicit_form3_dd_with_running_error_qaq(wo, wp));
    const vᵧ_ = wo_ + wp_ + get_implicit_form3_dd_with_running_error_abs(vᵧ[1]);
    // the commented part above is re
    const v3 = get_implicit_form3_dd_with_running_error_qdq(tq2q4, q1q1);
    const v1 = get_implicit_form3_dd_with_running_error_qdq(v3, q1q5);
    const _v1 = get_implicit_form3_dd_with_running_error_abs(v1[1]);
    const v4 = get_implicit_form3_dd_with_running_error_qmq(s3, q6);
    const v5 = get_implicit_form3_dd_with_running_error_qmq(q3q4, q4);
    const v2 = get_implicit_form3_dd_with_running_error_qdq(v4, v5);
    const v2_ = s3_ * get_implicit_form3_dd_with_running_error_abs(q6[1]) + 2 * get_implicit_form3_dd_with_running_error_abs(v4[1]) + q3q4_ * get_implicit_form3_dd_with_running_error_abs(q4[1]) + 2 * get_implicit_form3_dd_with_running_error_abs(v5[1]) + get_implicit_form3_dd_with_running_error_abs(v2[1]);
    const v6 = get_implicit_form3_dd_with_running_error_qmq(q1, v1);
    const v6_ = q1_ * _v1 + _q1 * tq2q4_ + q1q1_ + get_implicit_form3_dd_with_running_error_abs(v3[1]) + q1q5_ + _v1 + 2 * get_implicit_form3_dd_with_running_error_abs(v6[1]);
    // -------------------------------------------------------------------------
    //-------------------------------------------------------
    // const v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;
    //-------------------------------------------------------
    const v = get_implicit_form3_dd_with_running_error_qaq(v6, v2);
    const v_ = v6_ + v2_ + get_implicit_form3_dd_with_running_error_abs(v[1]);
    return {
        coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v },
        errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ }
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez1-dd.ts




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_bez3_bez1_dd_tp = node_twoProduct;
const get_coeffs_bez3_bez1_dd_qm2 = node_ddMultBy2;
const get_coeffs_bez3_bez1_dd_qmd = node_ddMultDouble2;
const get_coeffs_bez3_bez1_dd_qmq = node_ddMultDd;
const get_coeffs_bez3_bez1_dd_qaq = node_ddAddDd;
const get_coeffs_bez3_bez1_dd_abs = Math.abs;
const get_coeffs_bez3_bez1_dd_3 = error_analysis_error_analysis_(3);
/**
 * Returns a polynomial in 1 variable (including coefficientwise error bound)
 * whose roots are the parameter values of the intersection points of an order
 * 3 and 1 bezier curve (i.e. a cubic bezier curve and a line).
 *
 * The returned polynomial degree will be 3
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** none
 * * intermediate calculations are done in double-double precision and this is
 * reflected in the output error bound (which is approximately
 * `n * (Number.EPSILON**2) * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned need **not** be scaled before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez3Bez1Dd(ps1, ps2) {
    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = getImplicitForm3DdWithRunningError(ps1);
    const [[c1, c0], [d1, d0]] = get_xy_dd_with_running_error_getXY1DdWithRunningError(ps2);
    const $vₓₓₓ = vₓₓₓ[1];
    const $vₓₓᵧ = vₓₓᵧ[1];
    const $vₓᵧᵧ = vₓᵧᵧ[1];
    const $vᵧᵧᵧ = vᵧᵧᵧ[1];
    const $vₓₓ = vₓₓ[1];
    const $vₓᵧ = vₓᵧ[1];
    const $vᵧᵧ = vᵧᵧ[1];
    const $vₓ = vₓ[1];
    const $vᵧ = vᵧ[1];
    const $v = v[1];
    const $c1 = c1[1];
    const $d1 = d1[1];
    const _c0 = get_coeffs_bez3_bez1_dd_abs(c0);
    const _c1 = get_coeffs_bez3_bez1_dd_abs($c1);
    const _d0 = get_coeffs_bez3_bez1_dd_abs(d0);
    const _d1 = get_coeffs_bez3_bez1_dd_abs($d1);
    const $c0c0 = c0 * c0;
    const $c0c1 = c0 * $c1;
    const $c0d0 = c0 * d0;
    const $c0d1 = c0 * $d1;
    const $c1c1 = $c1 * $c1;
    const $c1d0 = $c1 * d0;
    const $c1d1 = $c1 * $d1;
    const $d0d0 = d0 * d0;
    const $d0d1 = d0 * $d1;
    const $d1d1 = $d1 * $d1;
    const c0c0 = get_coeffs_bez3_bez1_dd_tp(c0, c0); // error free
    const c0c1 = get_coeffs_bez3_bez1_dd_qmd(c0, c1);
    const c0c1_ = get_coeffs_bez3_bez1_dd_abs($c0c1);
    const c0d0 = get_coeffs_bez3_bez1_dd_tp(c0, d0); // error free
    const c0d1 = get_coeffs_bez3_bez1_dd_qmd(c0, d1);
    const c0d1_ = get_coeffs_bez3_bez1_dd_abs($c0d1);
    const c1c1 = get_coeffs_bez3_bez1_dd_qmq(c1, c1);
    const c1c1_ = 2 * get_coeffs_bez3_bez1_dd_abs($c1c1);
    const c1d0 = get_coeffs_bez3_bez1_dd_qmd(d0, c1);
    const c1d0_ = get_coeffs_bez3_bez1_dd_abs($c1d0);
    const c1d1 = get_coeffs_bez3_bez1_dd_qmq(c1, d1);
    const c1d1_ = 2 * get_coeffs_bez3_bez1_dd_abs($c1d1);
    const d0d0 = get_coeffs_bez3_bez1_dd_tp(d0, d0); // error free
    const d0d1 = get_coeffs_bez3_bez1_dd_qmd(d0, d1);
    const d0d1_ = get_coeffs_bez3_bez1_dd_abs($d0d1);
    const d1d1 = get_coeffs_bez3_bez1_dd_qmq(d1, d1);
    const d1d1_ = 2 * get_coeffs_bez3_bez1_dd_abs($d1d1);
    const _c0c0 = get_coeffs_bez3_bez1_dd_abs($c0c0);
    const _c0c1 = get_coeffs_bez3_bez1_dd_abs($c0c1);
    const _c0d0 = get_coeffs_bez3_bez1_dd_abs($c0d0);
    const _c0d1 = get_coeffs_bez3_bez1_dd_abs($c0d1);
    const _c1c1 = get_coeffs_bez3_bez1_dd_abs($c1c1);
    const _c1d0 = get_coeffs_bez3_bez1_dd_abs($c1d0);
    const _c1d1 = get_coeffs_bez3_bez1_dd_abs($c1d1);
    const _d0d0 = get_coeffs_bez3_bez1_dd_abs($d0d0);
    const _d0d1 = get_coeffs_bez3_bez1_dd_abs($d0d1);
    const _d1d1 = get_coeffs_bez3_bez1_dd_abs($d1d1);
    const $z1 = c0 * $vₓₓₓ;
    const z1 = get_coeffs_bez3_bez1_dd_qmd(c0, vₓₓₓ);
    const z1_ = _c0 * vₓₓₓ_ + get_coeffs_bez3_bez1_dd_abs($z1);
    const $za = 3 * c0;
    const za = get_coeffs_bez3_bez1_dd_tp(3, c0);
    const _za = get_coeffs_bez3_bez1_dd_abs($za);
    const $z7 = $za * $vₓₓₓ;
    const z7 = get_coeffs_bez3_bez1_dd_qmq(za, vₓₓₓ);
    const z7_ = _za * vₓₓₓ_ + 2 * get_coeffs_bez3_bez1_dd_abs($z7);
    const $z2 = c0 * $vₓₓᵧ;
    const z2 = get_coeffs_bez3_bez1_dd_qmd(c0, vₓₓᵧ);
    const z2_ = _c0 * vₓₓᵧ_ + get_coeffs_bez3_bez1_dd_abs($z2);
    const $z3 = d0 * $vₓₓᵧ;
    const z3 = get_coeffs_bez3_bez1_dd_qmd(d0, vₓₓᵧ);
    const z3_ = _d0 * vₓₓᵧ_ + get_coeffs_bez3_bez1_dd_abs($z3);
    const $z4 = c0 * $vₓᵧᵧ;
    const z4 = get_coeffs_bez3_bez1_dd_qmd(c0, vₓᵧᵧ);
    const z4_ = _c0 * vₓᵧᵧ_ + get_coeffs_bez3_bez1_dd_abs($z4);
    const $z5 = d0 * $vₓᵧᵧ;
    const z5 = get_coeffs_bez3_bez1_dd_qmd(d0, vₓᵧᵧ);
    const z5_ = _d0 * vₓᵧᵧ_ + get_coeffs_bez3_bez1_dd_abs($z5);
    const $z6 = d0 * $vᵧᵧᵧ;
    const z6 = get_coeffs_bez3_bez1_dd_qmd(d0, vᵧᵧᵧ);
    const z6_ = _d0 * vᵧᵧᵧ_ + get_coeffs_bez3_bez1_dd_abs($z6);
    const $zb = 3 * d0;
    const zb = get_coeffs_bez3_bez1_dd_tp(3, d0);
    const _zb = get_coeffs_bez3_bez1_dd_abs($zb);
    const $z8 = $zb * $vᵧᵧᵧ;
    const z8 = get_coeffs_bez3_bez1_dd_qmq(zb, vᵧᵧᵧ);
    const z8_ = _zb * vᵧᵧᵧ_ + 2 * get_coeffs_bez3_bez1_dd_abs($z8);
    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy
    //const v3 =
    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +
    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);
    const $u1 = $c1 * $vₓₓₓ;
    const u1 = get_coeffs_bez3_bez1_dd_qmq(c1, vₓₓₓ);
    const u1_ = _c1 * vₓₓₓ_ + 2 * get_coeffs_bez3_bez1_dd_abs($u1);
    const $u2 = $c1 * $vₓᵧᵧ;
    const u2 = get_coeffs_bez3_bez1_dd_qmq(c1, vₓᵧᵧ);
    const u2_ = _c1 * vₓᵧᵧ_ + 2 * get_coeffs_bez3_bez1_dd_abs($u2);
    const $u3 = $d1 * $vₓₓᵧ;
    const u3 = get_coeffs_bez3_bez1_dd_qmq(d1, vₓₓᵧ);
    const u3_ = _d1 * vₓₓᵧ_ + 2 * get_coeffs_bez3_bez1_dd_abs($u3);
    const $u4 = $d1 * $vᵧᵧᵧ;
    const u4 = get_coeffs_bez3_bez1_dd_qmq(d1, vᵧᵧᵧ);
    const u4_ = _d1 * vᵧᵧᵧ_ + 2 * get_coeffs_bez3_bez1_dd_abs($u4);
    const $u5 = $u1 + $u3;
    const u5 = get_coeffs_bez3_bez1_dd_qaq(u1, u3);
    const _u5 = get_coeffs_bez3_bez1_dd_abs($u5);
    const u5_ = u1_ + u3_ + _u5;
    const $u6 = $u2 + $u4;
    const u6 = get_coeffs_bez3_bez1_dd_qaq(u2, u4);
    const _u6 = get_coeffs_bez3_bez1_dd_abs($u6);
    const u6_ = u2_ + u4_ + _u6;
    const $u7 = $c1c1 * $u5;
    const u7 = get_coeffs_bez3_bez1_dd_qmq(c1c1, u5);
    const u7_ = c1c1_ * _u5 + _c1c1 * u5_ + 2 * get_coeffs_bez3_bez1_dd_abs($u7);
    const $u8 = $d1d1 * $u6;
    const u8 = get_coeffs_bez3_bez1_dd_qmq(d1d1, u6);
    const u8_ = d1d1_ * _u6 + _d1d1 * u6_ + 2 * get_coeffs_bez3_bez1_dd_abs($u8);
    const $v3 = $u7 + $u8;
    const v3 = get_coeffs_bez3_bez1_dd_qaq(u7, u8);
    const v3_ = u7_ + u8_ + get_coeffs_bez3_bez1_dd_abs($v3);
    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy
    //const v2 =
    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +
    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +
    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);
    //const v2 =
    //    c1c1*(3*z1 +   z3 + vₓₓ) +
    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +
    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);
    const $u9 = $z7 + $z3;
    const u9 = get_coeffs_bez3_bez1_dd_qaq(z7, z3);
    const u9_ = z7_ + z3_ + get_coeffs_bez3_bez1_dd_abs($u9);
    const $ua = 2 * ($z2 + $z5);
    const ua = get_coeffs_bez3_bez1_dd_qm2(get_coeffs_bez3_bez1_dd_qaq(z2, z5));
    const ua_ = 2 * (z2_ + z5_) + get_coeffs_bez3_bez1_dd_abs($ua);
    const $ub = $z4 + $z8;
    const ub = get_coeffs_bez3_bez1_dd_qaq(z4, z8);
    const ub_ = z4_ + z8_ + get_coeffs_bez3_bez1_dd_abs($ub);
    const $uc = $u9 + $vₓₓ;
    const uc = get_coeffs_bez3_bez1_dd_qaq(u9, vₓₓ);
    const _uc = get_coeffs_bez3_bez1_dd_abs($uc);
    const uc_ = u9_ + vₓₓ_ + _uc;
    const $ud = $ua + $vₓᵧ;
    const ud = get_coeffs_bez3_bez1_dd_qaq(ua, vₓᵧ);
    const _ud = get_coeffs_bez3_bez1_dd_abs($ud);
    const ud_ = ua_ + vₓᵧ_ + _ud;
    const $ue = $ub + $vᵧᵧ;
    const ue = get_coeffs_bez3_bez1_dd_qaq(ub, vᵧᵧ);
    const _ue = get_coeffs_bez3_bez1_dd_abs($ue);
    const ue_ = ub_ + vᵧᵧ_ + _ue;
    const $uf = $c1c1 * $uc;
    const uf = get_coeffs_bez3_bez1_dd_qmq(c1c1, uc);
    const uf_ = c1c1_ * _uc + _c1c1 * uc_ + 2 * get_coeffs_bez3_bez1_dd_abs($uf);
    const $ug = $c1d1 * $ud;
    const ug = get_coeffs_bez3_bez1_dd_qmq(c1d1, ud);
    const ug_ = c1d1_ * _ud + _c1d1 * ud_ + 2 * get_coeffs_bez3_bez1_dd_abs($ug);
    const $uh = $d1d1 * $ue;
    const uh = get_coeffs_bez3_bez1_dd_qmq(d1d1, ue);
    const uh_ = d1d1_ * _ue + _d1d1 * ue_ + 2 * get_coeffs_bez3_bez1_dd_abs($uh);
    const $ui = $uf + $ug;
    const ui = get_coeffs_bez3_bez1_dd_qaq(uf, ug);
    const ui_ = uf_ + ug_ + get_coeffs_bez3_bez1_dd_abs($ui);
    const $v2 = $ui + $uh;
    const v2 = get_coeffs_bez3_bez1_dd_qaq(ui, uh);
    const v2_ = ui_ + uh_ + get_coeffs_bez3_bez1_dd_abs($v2);
    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y
    //const v1 =
    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +
    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +
    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +
    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +
    //    vₓ*c1 +
    //    vᵧ*d1;
    const $uj = 2 * ($z3 + $vₓₓ);
    const uj = get_coeffs_bez3_bez1_dd_qm2(get_coeffs_bez3_bez1_dd_qaq(z3, vₓₓ));
    const uj_ = 2 * (z3_ + vₓₓ_) + get_coeffs_bez3_bez1_dd_abs($uj);
    const $uk = 2 * ($z4 + $vᵧᵧ);
    const uk = get_coeffs_bez3_bez1_dd_qm2(get_coeffs_bez3_bez1_dd_qaq(z4, vᵧᵧ));
    const uk_ = 2 * (z4_ + vᵧᵧ_) + get_coeffs_bez3_bez1_dd_abs($uk);
    const $un = $z7 + $uj;
    const un = get_coeffs_bez3_bez1_dd_qaq(z7, uj);
    const _un = get_coeffs_bez3_bez1_dd_abs($un);
    const un_ = z7_ + uj_ + _un;
    const $uo = $z8 + $uk;
    const uo = get_coeffs_bez3_bez1_dd_qaq(z8, uk);
    const _uo = get_coeffs_bez3_bez1_dd_abs($uo);
    const uo_ = z8_ + uk_ + _uo;
    const $up = $z2 + $vₓᵧ;
    const up = get_coeffs_bez3_bez1_dd_qaq(z2, vₓᵧ);
    const _up = get_coeffs_bez3_bez1_dd_abs($up);
    const up_ = z2_ + vₓᵧ_ + _up;
    const $uq = $z5 + $vₓᵧ;
    const uq = get_coeffs_bez3_bez1_dd_qaq(z5, vₓᵧ);
    const _uq = get_coeffs_bez3_bez1_dd_abs($uq);
    const uq_ = z5_ + vₓᵧ_ + _uq;
    const $ur = $c0c1 * $un;
    const ur = get_coeffs_bez3_bez1_dd_qmq(c0c1, un);
    const ur_ = c0c1_ * _un + _c0c1 * un_ + 2 * get_coeffs_bez3_bez1_dd_abs($ur);
    const $us = $d0d1 * $uo;
    const us = get_coeffs_bez3_bez1_dd_qmq(d0d1, uo);
    const us_ = d0d1_ * _uo + _d0d1 * uo_ + 2 * get_coeffs_bez3_bez1_dd_abs($us);
    const $ut = $c0d1 * $up;
    const ut = get_coeffs_bez3_bez1_dd_qmq(c0d1, up);
    const ut_ = c0d1_ * _up + _c0d1 * up_ + 2 * get_coeffs_bez3_bez1_dd_abs($ut);
    const $uu = $c1d0 * $uq;
    const uu = get_coeffs_bez3_bez1_dd_qmq(c1d0, uq);
    const uu_ = c1d0_ * _uq + _c1d0 * uq_ + 2 * get_coeffs_bez3_bez1_dd_abs($uu);
    const $uv = $c1 * $vₓ;
    const uv = get_coeffs_bez3_bez1_dd_qmq(c1, vₓ);
    const uv_ = _c1 * vₓ_ + 2 * get_coeffs_bez3_bez1_dd_abs($uv);
    const $uw = $d1 * $vᵧ;
    const uw = get_coeffs_bez3_bez1_dd_qmq(d1, vᵧ);
    const uw_ = _d1 * vᵧ_ + 2 * get_coeffs_bez3_bez1_dd_abs($uw);
    const $ux = $ur + $us;
    const ux = get_coeffs_bez3_bez1_dd_qaq(ur, us);
    const ux_ = ur_ + us_ + get_coeffs_bez3_bez1_dd_abs($ux);
    const $uy = $ut + $uu;
    const uy = get_coeffs_bez3_bez1_dd_qaq(ut, uu);
    const uy_ = ut_ + uu_ + get_coeffs_bez3_bez1_dd_abs($uy);
    const $uz = $ux + $uy;
    const uz = get_coeffs_bez3_bez1_dd_qaq(ux, uy);
    const uz_ = ux_ + uy_ + get_coeffs_bez3_bez1_dd_abs($uz);
    const $u0 = $uv + $uw;
    const u0 = get_coeffs_bez3_bez1_dd_qaq(uv, uw);
    const u0_ = uv_ + uw_ + get_coeffs_bez3_bez1_dd_abs($u0);
    const $v1 = $uz + $u0;
    const v1 = get_coeffs_bez3_bez1_dd_qaq(uz, u0);
    const v1_ = uz_ + u0_ + get_coeffs_bez3_bez1_dd_abs($v1);
    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0
    //const v0 =
    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +
    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +
    //    c0d0*vₓᵧ +
    //    c0*vₓ    +
    //    d0*vᵧ    +
    //    v;
    //const v0 =
    //    c0c0*(z1 + z3 + vₓₓ) +
    //    d0d0*(z6 + z4 + vᵧᵧ) +
    //    c0d0*vₓᵧ +
    //    c0*vₓ    +
    //    d0*vᵧ    +
    //    v;
    const $f1 = $z1 + $z3;
    const f1 = get_coeffs_bez3_bez1_dd_qaq(z1, z3);
    const f1_ = z1_ + z3_ + get_coeffs_bez3_bez1_dd_abs($f1);
    const $f2 = $z6 + $z4;
    const f2 = get_coeffs_bez3_bez1_dd_qaq(z6, z4);
    const f2_ = z6_ + z4_ + get_coeffs_bez3_bez1_dd_abs($f2);
    const $f3 = $f1 + $vₓₓ;
    const f3 = get_coeffs_bez3_bez1_dd_qaq(f1, vₓₓ);
    const _f3 = get_coeffs_bez3_bez1_dd_abs($f3);
    const f3_ = f1_ + vₓₓ_ + _f3;
    const $f4 = $f2 + $vᵧᵧ;
    const f4 = get_coeffs_bez3_bez1_dd_qaq(f2, vᵧᵧ);
    const _f4 = get_coeffs_bez3_bez1_dd_abs($f4);
    const f4_ = f2_ + vᵧᵧ_ + _f4;
    const $f5 = $c0c0 * $f3;
    const f5 = get_coeffs_bez3_bez1_dd_qmq(c0c0, f3);
    const f5_ = _c0c0 * f3_ + 2 * get_coeffs_bez3_bez1_dd_abs($f5);
    const $f6 = $d0d0 * $f4;
    const f6 = get_coeffs_bez3_bez1_dd_qmq(d0d0, f4);
    const f6_ = _d0d0 * f4_ + 2 * get_coeffs_bez3_bez1_dd_abs($f6);
    const $f7 = $c0d0 * $vₓᵧ;
    const f7 = get_coeffs_bez3_bez1_dd_qmq(c0d0, vₓᵧ);
    const f7_ = _c0d0 * vₓᵧ_ + 2 * get_coeffs_bez3_bez1_dd_abs($f7);
    const $f8 = $f5 + $f6;
    const f8 = get_coeffs_bez3_bez1_dd_qaq(f5, f6);
    const f8_ = f5_ + f6_ + get_coeffs_bez3_bez1_dd_abs($f8);
    const $f9 = $f8 + $f7;
    const f9 = get_coeffs_bez3_bez1_dd_qaq(f8, f7);
    const f9_ = f8_ + f7_ + get_coeffs_bez3_bez1_dd_abs($f9);
    const $fa = c0 * $vₓ;
    const fa = get_coeffs_bez3_bez1_dd_qmd(c0, vₓ);
    const fa_ = _c0 * vₓ_ + get_coeffs_bez3_bez1_dd_abs($fa);
    const $fb = d0 * $vᵧ;
    const fb = get_coeffs_bez3_bez1_dd_qmd(d0, vᵧ);
    const fb_ = _d0 * vᵧ_ + get_coeffs_bez3_bez1_dd_abs($fb);
    const $fc = $fa + $fb;
    const fc = get_coeffs_bez3_bez1_dd_qaq(fa, fb);
    const fc_ = fa_ + fb_ + get_coeffs_bez3_bez1_dd_abs($fc);
    const $fd = $f9 + $fc;
    const fd = get_coeffs_bez3_bez1_dd_qaq(f9, fc);
    const fd_ = f9_ + fc_ + get_coeffs_bez3_bez1_dd_abs($fd);
    const $v0 = $fd + $v;
    const v0 = get_coeffs_bez3_bez1_dd_qaq(fd, v);
    const v0_ = fd_ + v_ + get_coeffs_bez3_bez1_dd_abs($v0);
    return {
        coeffs: [v3, v2, v1, v0],
        errBound: [get_coeffs_bez3_bez1_dd_3 * v3_, get_coeffs_bez3_bez1_dd_3 * v2_, get_coeffs_bez3_bez1_dd_3 * v1_, get_coeffs_bez3_bez1_dd_3 * v0_]
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez2-dd.ts




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_bez1_bez2_dd_tp = (/* unused pure expression or super */ null && (twoProduct));
const get_coeffs_bez1_bez2_dd_qaq = node_ddAddDd;
const get_coeffs_bez1_bez2_dd_qmd = node_ddMultDouble2;
const get_coeffs_bez1_bez2_dd_qmq = node_ddMultDd;
const get_coeffs_bez1_bez2_dd_abs = Math.abs;
const get_coeffs_bez1_bez2_dd_3 = error_analysis_error_analysis_(3);
// TODO - change docs
/**
 * Returns a polynomial in 1 variable (including coefficientwise error bound)
 * whose roots are the parameter values of the intersection points of an order
 * 1 and order 2 bezier curve (i.e. a line and a quadratic bezier curve).
 *
 * The returned polynomial degree will be 2
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** none
 * * intermediate calculations are done in double-double precision and the
 * result is exact if the precondition is met
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez1Bez2Dd(ps1, ps2) {
    const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = getImplicitForm1DdWithRunningError(ps1);
    const { coeffs: [[c2, c1, c0], [d2, d1, d0]], errorBound: [[c2_], [d2_]] } = get_xy_dd_with_running_error_getXY2DdWithRunningError(ps2);
    const $vₓ = vₓ[1];
    const $vᵧ = vᵧ[1];
    const $v = v[1];
    const _vₓ = get_coeffs_bez1_bez2_dd_abs($vₓ);
    const _vᵧ = get_coeffs_bez1_bez2_dd_abs($vᵧ);
    const _v = get_coeffs_bez1_bez2_dd_abs($v);
    const $c1 = c1[1];
    const $c2 = c2[1];
    const $d1 = d1[1];
    const $d2 = d2[1];
    // --------------------------
    // a2*v_x + b2*v_y
    // const v2 = c2*vₓ + d2*vᵧ;
    // --------------------------
    const $p1 = $c2 * $vₓ;
    const p1 = get_coeffs_bez1_bez2_dd_qmq(c2, vₓ);
    const p1_ = c2_ * _vₓ + 2 * get_coeffs_bez1_bez2_dd_abs($p1);
    const $p2 = $d2 * $vᵧ;
    const p2 = get_coeffs_bez1_bez2_dd_qmq(d2, vᵧ);
    const p2_ = d2_ * _vᵧ + 2 * get_coeffs_bez1_bez2_dd_abs($p2);
    const $v2 = $p1 + $p2;
    const v2 = get_coeffs_bez1_bez2_dd_qaq(p1, p2);
    const v2_ = p1_ + p2_ + get_coeffs_bez1_bez2_dd_abs($v2);
    // a1*v_x + b1*v_y
    //const v1 = c1*vₓ + d1*vᵧ;
    const $p3 = $c1 * $vₓ;
    const p3 = get_coeffs_bez1_bez2_dd_qmq(c1, vₓ);
    const p3_ = 2 * get_coeffs_bez1_bez2_dd_abs($p3);
    const $p4 = $d1 * $vᵧ;
    const p4 = get_coeffs_bez1_bez2_dd_qmq(d1, vᵧ);
    const p4_ = 2 * get_coeffs_bez1_bez2_dd_abs($p4);
    const $v1 = $p3 + $p4;
    const v1 = get_coeffs_bez1_bez2_dd_qaq(p3, p4);
    const v1_ = p3_ + p4_ + get_coeffs_bez1_bez2_dd_abs($v1);
    // a0*v_x + b0*v_y + v_0
    //const v0 = c0*vₓ + d0*vᵧ + v;
    const p5 = get_coeffs_bez1_bez2_dd_qmd(c0, vₓ);
    const $p5 = c0 * $vₓ;
    const p5_ = get_coeffs_bez1_bez2_dd_abs($p5);
    const p6 = get_coeffs_bez1_bez2_dd_qmd(d0, vᵧ);
    const $p6 = d0 * $vᵧ;
    const p6_ = get_coeffs_bez1_bez2_dd_abs($p6);
    const $p7 = $p5 + $p6;
    const p7 = get_coeffs_bez1_bez2_dd_qaq(p5, p6);
    const p7_ = p5_ + p6_ + get_coeffs_bez1_bez2_dd_abs($p7);
    const $v0 = $p7 + $v;
    const v0 = get_coeffs_bez1_bez2_dd_qaq(p7, v);
    const v0_ = p7_ + v_ + get_coeffs_bez1_bez2_dd_abs($v0);
    return {
        coeffs: [v2, v1, v0],
        errBound: [get_coeffs_bez1_bez2_dd_3 * v2_, get_coeffs_bez1_bez2_dd_3 * v1_, get_coeffs_bez1_bez2_dd_3 * v0_]
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez2-dd.ts




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_bez2_bez2_dd_tp = node_twoProduct;
const get_coeffs_bez2_bez2_dd_qm2 = node_ddMultBy2;
const get_coeffs_bez2_bez2_dd_qmd = node_ddMultDouble2;
const get_coeffs_bez2_bez2_dd_qmq = node_ddMultDd;
const get_coeffs_bez2_bez2_dd_qaq = node_ddAddDd;
const get_coeffs_bez2_bez2_dd_abs = Math.abs;
const get_coeffs_bez2_bez2_dd_3 = error_analysis_error_analysis_(3);
/**
 * Returns a polynomial in 1 variable (including coefficientwise error bound)
 * whose roots are the parameter values of the intersection points of 2 order
 * 2 bezier curves (i.e. 2 quadratic bezier curves).
 *
 * The returned polynomial degree will be 4
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** none
 * * intermediate calculations are done in double-double precision and this is
 * reflected in the output error bound (which is approximately
 * `n * (Number.EPSILON**2) * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned need **not** be scaled before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez2Bez2Dd(ps1, ps2) {
    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = getImplicitForm2DdWithRunningError(ps1);
    const { coeffs: [[c2, c1, c0], [d2, d1, d0]], errorBound: [[c2_], [d2_]] } = get_xy_dd_with_running_error_getXY2DdWithRunningError(ps2);
    const $vₓₓ = vₓₓ[1];
    const $vₓᵧ = vₓᵧ[1];
    const $vᵧᵧ = vᵧᵧ[1];
    const $vₓ = vₓ[1];
    const $vᵧ = vᵧ[1];
    const $v = v[1];
    const _vₓₓ = get_coeffs_bez2_bez2_dd_abs($vₓₓ);
    const _vₓᵧ = get_coeffs_bez2_bez2_dd_abs($vₓᵧ);
    const _vᵧᵧ = get_coeffs_bez2_bez2_dd_abs($vᵧᵧ);
    const _vₓ = get_coeffs_bez2_bez2_dd_abs($vₓ);
    const _vᵧ = get_coeffs_bez2_bez2_dd_abs($vᵧ);
    const $c1 = c1[1];
    const $c2 = c2[1];
    const $d1 = d1[1];
    const $d2 = d2[1];
    const _c0 = get_coeffs_bez2_bez2_dd_abs(c0);
    const _c1 = get_coeffs_bez2_bez2_dd_abs($c1);
    const _c2 = get_coeffs_bez2_bez2_dd_abs($c2);
    const _d0 = get_coeffs_bez2_bez2_dd_abs(d0);
    const _d1 = get_coeffs_bez2_bez2_dd_abs($d1);
    const _d2 = get_coeffs_bez2_bez2_dd_abs($d2);
    const $c0c0 = c0 * c0;
    const $c0c1 = c0 * $c1;
    const $c0c2 = c0 * $c2;
    const $c0d0 = c0 * d0;
    const $c0d1 = c0 * $d1;
    const $c0d2 = c0 * $d2;
    const $c1c1 = $c1 * $c1;
    const $c1c2 = $c1 * $c2;
    const $c1d0 = $c1 * d0;
    const $c1d1 = $c1 * $d1;
    const $c1d2 = $c1 * $d2;
    const $c2d1 = $c2 * $d1;
    const $c2c2 = $c2 * $c2;
    const $c2d0 = $c2 * d0;
    const $c2d2 = $c2 * $d2;
    const $d0d0 = d0 * d0;
    const $d0d1 = d0 * $d1;
    const $d0d2 = d0 * $d2;
    const $d1d1 = $d1 * $d1;
    const $d1d2 = $d1 * $d2;
    const $d2d2 = $d2 * $d2;
    const _c0c0 = get_coeffs_bez2_bez2_dd_abs($c0c0);
    const _c0d0 = get_coeffs_bez2_bez2_dd_abs($c0d0);
    const _d0d0 = get_coeffs_bez2_bez2_dd_abs($d0d0);
    const c0c0 = get_coeffs_bez2_bez2_dd_tp(c0, c0); // error free
    const c0c1 = get_coeffs_bez2_bez2_dd_qmd(c0, c1);
    const _c0c1_ = get_coeffs_bez2_bez2_dd_abs($c0c1);
    const c0c2 = get_coeffs_bez2_bez2_dd_qmd(c0, c2);
    const _c0c2_ = get_coeffs_bez2_bez2_dd_abs($c0c2);
    const c0d0 = get_coeffs_bez2_bez2_dd_tp(c0, d0); // error free
    const c0d1 = get_coeffs_bez2_bez2_dd_qmd(c0, d1);
    const _c0d1_ = get_coeffs_bez2_bez2_dd_abs($c0d1);
    const c0d2 = get_coeffs_bez2_bez2_dd_qmd(c0, d2);
    const _c0d2_ = get_coeffs_bez2_bez2_dd_abs($c0d2);
    const c1c1 = get_coeffs_bez2_bez2_dd_qmq(c1, c1);
    const c1c1_ = 2 * get_coeffs_bez2_bez2_dd_abs($c1c1);
    const c1c2 = get_coeffs_bez2_bez2_dd_qmq(c1, c2);
    const _c1c2 = get_coeffs_bez2_bez2_dd_abs($c1c2);
    const c1c2_ = _c1 * c2_ + 2 * _c1c2;
    const c1d0 = get_coeffs_bez2_bez2_dd_qmd(d0, c1);
    const _c1d0_ = get_coeffs_bez2_bez2_dd_abs($c1d0);
    const c1d1 = get_coeffs_bez2_bez2_dd_qmq(c1, d1);
    const c1d1_ = 2 * get_coeffs_bez2_bez2_dd_abs($c1d1);
    const c1d2 = get_coeffs_bez2_bez2_dd_qmq(c1, d2);
    const c1d2_ = _c1 * d2_ + 2 * get_coeffs_bez2_bez2_dd_abs($c1d2);
    const c2d1 = get_coeffs_bez2_bez2_dd_qmq(c2, d1);
    const c2d1_ = c2_ * _d1 + 2 * get_coeffs_bez2_bez2_dd_abs($c2d1);
    const c2c2 = get_coeffs_bez2_bez2_dd_qmq(c2, c2);
    const _c2c2 = get_coeffs_bez2_bez2_dd_abs($c2c2);
    const c2c2_ = 2 * (c2_ * _c2 + _c2c2);
    const c2d0 = get_coeffs_bez2_bez2_dd_qmd(d0, c2);
    const _c2d0_ = get_coeffs_bez2_bez2_dd_abs($c2d0);
    const c2d2 = get_coeffs_bez2_bez2_dd_qmq(c2, d2);
    const _c2d2 = get_coeffs_bez2_bez2_dd_abs($c2d2);
    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * _c2d2;
    const d0d0 = get_coeffs_bez2_bez2_dd_tp(d0, d0); // error free
    const d0d1 = get_coeffs_bez2_bez2_dd_qmd(d0, d1);
    const _d0d1_ = get_coeffs_bez2_bez2_dd_abs($d0d1);
    const d0d2 = get_coeffs_bez2_bez2_dd_qmd(d0, d2);
    const _d0d2_ = get_coeffs_bez2_bez2_dd_abs($d0d2);
    const d1d1 = get_coeffs_bez2_bez2_dd_qmq(d1, d1);
    const d1d1_ = 2 * get_coeffs_bez2_bez2_dd_abs($d1d1);
    const d1d2 = get_coeffs_bez2_bez2_dd_qmq(d1, d2);
    const _d1d2 = get_coeffs_bez2_bez2_dd_abs($d1d2);
    const d1d2_ = _d1 * d2_ + 2 * _d1d2;
    const d2d2 = get_coeffs_bez2_bez2_dd_qmq(d2, d2);
    const _d2d2 = get_coeffs_bez2_bez2_dd_abs($d2d2);
    const d2d2_ = 2 * (d2_ * _d2 + _d2d2);
    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy
    //const v4 = 
    //    (c2*c2)*vₓₓ +
    //    (c2*d2)*vₓᵧ +
    //    (d2*d2)*vᵧᵧ;
    const $p1 = $c2c2 * $vₓₓ;
    const p1 = get_coeffs_bez2_bez2_dd_qmq(c2c2, vₓₓ);
    const p1_ = c2c2_ * _vₓₓ + _c2c2 * vₓₓ_ + 2 * get_coeffs_bez2_bez2_dd_abs($p1);
    const $p2 = $c2d2 * $vₓᵧ;
    const p2 = get_coeffs_bez2_bez2_dd_qmq(c2d2, vₓᵧ);
    const p2_ = c2d2_ * _vₓᵧ + _c2d2 * vₓᵧ_ + 2 * get_coeffs_bez2_bez2_dd_abs($p2);
    const $p3 = $d2d2 * $vᵧᵧ;
    const p3 = get_coeffs_bez2_bez2_dd_qmq(d2d2, vᵧᵧ);
    const p3_ = d2d2_ * _vᵧᵧ + _d2d2 * vᵧᵧ_ + 2 * get_coeffs_bez2_bez2_dd_abs($p3);
    const $p4 = $p1 + $p2;
    const p4 = get_coeffs_bez2_bez2_dd_qaq(p1, p2);
    const p4_ = p1_ + p2_ + get_coeffs_bez2_bez2_dd_abs($p4);
    const $v4 = $p4 + $p3;
    const v4 = get_coeffs_bez2_bez2_dd_qaq(p4, p3);
    const v4_ = p4_ + p3_ + get_coeffs_bez2_bez2_dd_abs($v4);
    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy
    //const v3 =
    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +
    //    ((c1*d2) + (c2*d1))*vₓᵧ;
    const $p5 = $c1c2 * $vₓₓ;
    const p5 = get_coeffs_bez2_bez2_dd_qmq(c1c2, vₓₓ);
    const p5_ = c1c2_ * _vₓₓ + _c1c2 * vₓₓ_ + 2 * get_coeffs_bez2_bez2_dd_abs($p5);
    const $p6 = $d1d2 * $vᵧᵧ;
    const p6 = get_coeffs_bez2_bez2_dd_qmq(d1d2, vᵧᵧ);
    const p6_ = d1d2_ * _vᵧᵧ + _d1d2 * vᵧᵧ_ + 2 * get_coeffs_bez2_bez2_dd_abs($p6);
    const $p7 = $c1d2 + $c2d1;
    const p7 = get_coeffs_bez2_bez2_dd_qaq(c1d2, c2d1);
    const _p7 = get_coeffs_bez2_bez2_dd_abs($p7);
    const p7_ = c1d2_ + c2d1_ + _p7;
    const $p8 = $p7 * $vₓᵧ;
    const p8 = get_coeffs_bez2_bez2_dd_qmq(p7, vₓᵧ);
    const p8_ = p7_ * _vₓᵧ + _p7 * vₓᵧ_ + 2 * get_coeffs_bez2_bez2_dd_abs($p8);
    const $p9 = 2 * ($p5 + $p6);
    const p9 = get_coeffs_bez2_bez2_dd_qm2(get_coeffs_bez2_bez2_dd_qaq(p5, p6));
    const p9_ = 2 * (p5_ + p6_) + get_coeffs_bez2_bez2_dd_abs($p9);
    const $v3 = $p9 + $p8;
    const v3 = get_coeffs_bez2_bez2_dd_qaq(p9, p8);
    const v3_ = p9_ + p8_ + get_coeffs_bez2_bez2_dd_abs($v3);
    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + 
    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + 
    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y
    //const v2 = 
    //    (2*(c0*c2) + (c1*c1))*vₓₓ +
    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          
    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +
    //    c2*vₓ  +          
    //    d2*vᵧ;
    const $pa = 2 * $c0c2 + $c1c1;
    const _pa = get_coeffs_bez2_bez2_dd_abs($pa);
    const pa = get_coeffs_bez2_bez2_dd_qaq(get_coeffs_bez2_bez2_dd_qm2(c0c2), c1c1);
    const pa_ = 2 * _c0c2_ + c1c1_ + get_coeffs_bez2_bez2_dd_abs($pa);
    const $pb = 2 * $d0d2 + $d1d1;
    const _pb = get_coeffs_bez2_bez2_dd_abs($pb);
    const pb = get_coeffs_bez2_bez2_dd_qaq(get_coeffs_bez2_bez2_dd_qm2(d0d2), d1d1);
    const pb_ = 2 * _d0d2_ + d1d1_ + get_coeffs_bez2_bez2_dd_abs($pb);
    const $pc = $c0d2 + $c1d1;
    const _pc = get_coeffs_bez2_bez2_dd_abs($pc);
    const pc = get_coeffs_bez2_bez2_dd_qaq(c0d2, c1d1);
    const pc_ = _c0d2_ + c1d1_ + get_coeffs_bez2_bez2_dd_abs($pc);
    const $pd = $pc + $c2d0;
    const pd = get_coeffs_bez2_bez2_dd_qaq(pc, c2d0);
    const _pd = get_coeffs_bez2_bez2_dd_abs($pd);
    const pd_ = pc_ + _c2d0_ + _pd;
    const $pe = $pa * $vₓₓ;
    const pe = get_coeffs_bez2_bez2_dd_qmq(pa, vₓₓ);
    const pe_ = pa_ * _vₓₓ + _pa * vₓₓ_ + 2 * get_coeffs_bez2_bez2_dd_abs($pe);
    const $pf = $pb * $vᵧᵧ;
    const pf = get_coeffs_bez2_bez2_dd_qmq(pb, vᵧᵧ);
    const pf_ = pb_ * _vᵧᵧ + _pb * vᵧᵧ_ + 2 * get_coeffs_bez2_bez2_dd_abs($pf);
    const $pg = $pd * $vₓᵧ;
    const pg = get_coeffs_bez2_bez2_dd_qmq(pd, vₓᵧ);
    const pg_ = pd_ * _vₓᵧ + _pd * vₓᵧ_ + 2 * get_coeffs_bez2_bez2_dd_abs($pg);
    const $ph = $c2 * $vₓ;
    const ph = get_coeffs_bez2_bez2_dd_qmq(c2, vₓ);
    const ph_ = c2_ * _vₓ + _c2 * vₓ_ + get_coeffs_bez2_bez2_dd_abs($ph);
    const $pi = $d2 * $vᵧ;
    const pi = get_coeffs_bez2_bez2_dd_qmq(d2, vᵧ);
    const pi_ = d2_ * _vᵧ + _d2 * vᵧ_ + get_coeffs_bez2_bez2_dd_abs($pi);
    const $pj = $pe + $pf;
    const pj = get_coeffs_bez2_bez2_dd_qaq(pe, pf);
    const pj_ = pe_ + pf_ + get_coeffs_bez2_bez2_dd_abs($pj);
    const $pk = $pj + $pg;
    const pk = get_coeffs_bez2_bez2_dd_qaq(pj, pg);
    const pk_ = pj_ + pg_ + get_coeffs_bez2_bez2_dd_abs($pk);
    const $pl = $ph + $pi;
    const pl = get_coeffs_bez2_bez2_dd_qaq(ph, pi);
    const pl_ = ph_ + pi_ + get_coeffs_bez2_bez2_dd_abs($pl);
    const $v2 = $pk + $pl;
    const v2 = get_coeffs_bez2_bez2_dd_qaq(pk, pl);
    const v2_ = pk_ + pl_ + get_coeffs_bez2_bez2_dd_abs($v2);
    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + 
    // a1*v_x + 2*b0*b1*v_yy + b1*v_y
    //const v1 =
    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +
    //    ((c0*d1) + (c1*d0))*vₓᵧ +
    //    c1*vₓ  +
    //    d1*vᵧ;
    const $pm = $c0c1 * $vₓₓ;
    const pm = get_coeffs_bez2_bez2_dd_qmq(c0c1, vₓₓ);
    const pm_ = _c0c1_ * (_vₓₓ + vₓₓ_) + 2 * get_coeffs_bez2_bez2_dd_abs($pm);
    const $pn = $d0d1 * $vᵧᵧ;
    const pn = get_coeffs_bez2_bez2_dd_qmq(d0d1, vᵧᵧ);
    const pn_ = _d0d1_ * (_vᵧᵧ + vᵧᵧ_) + 2 * get_coeffs_bez2_bez2_dd_abs($pn);
    const $po = $c0d1 + $c1d0;
    const po = get_coeffs_bez2_bez2_dd_qaq(c0d1, c1d0);
    const _po = get_coeffs_bez2_bez2_dd_abs($po);
    const po_ = _c0d1_ + _c1d0_ + _po;
    const $pp = $po * $vₓᵧ;
    const pp = get_coeffs_bez2_bez2_dd_qmq(po, vₓᵧ);
    const pp_ = po_ * _vₓᵧ + _po * vₓᵧ_ + 2 * get_coeffs_bez2_bez2_dd_abs($pp);
    const $pq = 2 * ($pm + $pn);
    const pq = get_coeffs_bez2_bez2_dd_qm2(get_coeffs_bez2_bez2_dd_qaq(pm, pn));
    const pq_ = 2 * (pm_ + pn_) + get_coeffs_bez2_bez2_dd_abs($pq);
    const $pr = $c1 * $vₓ;
    const pr = get_coeffs_bez2_bez2_dd_qmq(c1, vₓ);
    const pr_ = _c1 * vₓ_ + 2 * get_coeffs_bez2_bez2_dd_abs($pr);
    const $ps = $d1 * $vᵧ;
    const ps = get_coeffs_bez2_bez2_dd_qmq(d1, vᵧ);
    const ps_ = _d1 * vᵧ_ + 2 * get_coeffs_bez2_bez2_dd_abs($ps);
    const $pt = $pq + $pp;
    const pt = get_coeffs_bez2_bez2_dd_qaq(pq, pp);
    const pt_ = pq_ + pp_ + get_coeffs_bez2_bez2_dd_abs($pt);
    const $pu = $pr + $ps;
    const pu = get_coeffs_bez2_bez2_dd_qaq(pr, ps);
    const pu_ = pr_ + ps_ + get_coeffs_bez2_bez2_dd_abs($pu);
    const $v1 = $pt + $pu;
    const v1 = get_coeffs_bez2_bez2_dd_qaq(pt, pu);
    const v1_ = pt_ + pu_ + get_coeffs_bez2_bez2_dd_abs($v1);
    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + 
    // b0**2*v_yy + b0*v_y + v_0
    //const v0 =
    //    (c0*c0)*vₓₓ + 
    //    (c0*d0)*vₓᵧ + 
    //    (d0*d0)*vᵧᵧ + 
    //    c0*vₓ  +         
    //    d0*vᵧ  +
    //    v;
    const $pv = $c0c0 * $vₓₓ;
    const pv = get_coeffs_bez2_bez2_dd_qmq(c0c0, vₓₓ);
    const pv_ = _c0c0 * vₓₓ_ + 2 * get_coeffs_bez2_bez2_dd_abs($pv);
    const $pw = $c0d0 * $vₓᵧ;
    const pw = get_coeffs_bez2_bez2_dd_qmq(c0d0, vₓᵧ);
    const pw_ = _c0d0 * vₓᵧ_ + 2 * get_coeffs_bez2_bez2_dd_abs($pw);
    const $px = $d0d0 * $vᵧᵧ;
    const px = get_coeffs_bez2_bez2_dd_qmq(d0d0, vᵧᵧ);
    const px_ = _d0d0 * vᵧᵧ_ + 2 * get_coeffs_bez2_bez2_dd_abs($px);
    const $py = c0 * $vₓ;
    const py = get_coeffs_bez2_bez2_dd_qmd(c0, vₓ);
    const py_ = _c0 * vₓ_ + get_coeffs_bez2_bez2_dd_abs($py);
    const $pz = d0 * $vᵧ;
    const pz = get_coeffs_bez2_bez2_dd_qmd(d0, vᵧ);
    const pz_ = _d0 * vᵧ_ + get_coeffs_bez2_bez2_dd_abs($pz);
    const $q1 = $pv + $pw;
    const q1 = get_coeffs_bez2_bez2_dd_qaq(pv, pw);
    const q1_ = pv_ + pw_ + get_coeffs_bez2_bez2_dd_abs($q1);
    const $q2 = $q1 + $px;
    const q2 = get_coeffs_bez2_bez2_dd_qaq(q1, px);
    const q2_ = q1_ + px_ + get_coeffs_bez2_bez2_dd_abs($q2);
    const $q3 = $py + $pz;
    const q3 = get_coeffs_bez2_bez2_dd_qaq(py, pz);
    const q3_ = py_ + pz_ + get_coeffs_bez2_bez2_dd_abs($q3);
    const $q4 = $q2 + $q3;
    const q4 = get_coeffs_bez2_bez2_dd_qaq(q2, q3);
    const q4_ = q2_ + q3_ + get_coeffs_bez2_bez2_dd_abs($q4);
    const $v0 = $q4 + $v;
    const v0 = get_coeffs_bez2_bez2_dd_qaq(q4, v);
    const v0_ = q4_ + v_ + get_coeffs_bez2_bez2_dd_abs($v0);
    return {
        coeffs: [v4, v3, v2, v1, v0],
        errBound: [get_coeffs_bez2_bez2_dd_3 * v4_, get_coeffs_bez2_bez2_dd_3 * v3_, get_coeffs_bez2_bez2_dd_3 * v2_, get_coeffs_bez2_bez2_dd_3 * v1_, get_coeffs_bez2_bez2_dd_3 * v0_]
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez2-dd.ts




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_bez3_bez2_dd_tp = node_twoProduct;
const get_coeffs_bez3_bez2_dd_qm2 = node_ddMultBy2;
const get_coeffs_bez3_bez2_dd_qmd = node_ddMultDouble2;
const get_coeffs_bez3_bez2_dd_qmq = node_ddMultDd;
const get_coeffs_bez3_bez2_dd_qaq = node_ddAddDd;
const get_coeffs_bez3_bez2_dd_abs = Math.abs;
const get_coeffs_bez3_bez2_dd_3 = error_analysis_error_analysis_(3);
/**
 * Returns a polynomial in 1 variable (including coefficientwise error bound)
 * whose roots are the parameter values of the intersection points of an order
 * 3 and 2 bezier curve (i.e. a cubic bezier curve and a quadratic bezier curve).
 *
 * The returned polynomial degree will be 6
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** none
 * * intermediate calculations are done in double-double precision and this is
 * reflected in the output error bound (which is approximately
 * `n * (Number.EPSILON**2) * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned need **not** be scaled before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez3Bez2Dd(ps1, ps2) {
    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = getImplicitForm3DdWithRunningError(ps1);
    const { coeffs: [[c2, c1, c0], [d2, d1, d0]], errorBound: [[c2_], [d2_]] } = get_xy_dd_with_running_error_getXY2DdWithRunningError(ps2);
    const $vₓₓₓ = vₓₓₓ[1];
    const $vₓₓᵧ = vₓₓᵧ[1];
    const $vₓᵧᵧ = vₓᵧᵧ[1];
    const $vᵧᵧᵧ = vᵧᵧᵧ[1];
    const $vₓₓ = vₓₓ[1];
    const $vₓᵧ = vₓᵧ[1];
    const $vᵧᵧ = vᵧᵧ[1];
    const $vₓ = vₓ[1];
    const $vᵧ = vᵧ[1];
    const $v = v[1];
    const _vₓₓₓ = get_coeffs_bez3_bez2_dd_abs($vₓₓₓ);
    const _vₓₓᵧ = get_coeffs_bez3_bez2_dd_abs($vₓₓᵧ);
    const _vₓᵧᵧ = get_coeffs_bez3_bez2_dd_abs($vₓᵧᵧ);
    const _vᵧᵧᵧ = get_coeffs_bez3_bez2_dd_abs($vᵧᵧᵧ);
    const _vₓₓ = get_coeffs_bez3_bez2_dd_abs($vₓₓ);
    const _vᵧᵧ = get_coeffs_bez3_bez2_dd_abs($vᵧᵧ);
    const _vₓᵧ = get_coeffs_bez3_bez2_dd_abs($vₓᵧ);
    const _vₓ = get_coeffs_bez3_bez2_dd_abs($vₓ);
    const _vᵧ = get_coeffs_bez3_bez2_dd_abs($vᵧ);
    const $c1 = c1[1];
    const $c2 = c2[1];
    const $d1 = d1[1];
    const $d2 = d2[1];
    const _c0 = get_coeffs_bez3_bez2_dd_abs(c0);
    const _c1 = get_coeffs_bez3_bez2_dd_abs($c1);
    const _c2 = get_coeffs_bez3_bez2_dd_abs($c2);
    const _d0 = get_coeffs_bez3_bez2_dd_abs(d0);
    const _d1 = get_coeffs_bez3_bez2_dd_abs($d1);
    const _d2 = get_coeffs_bez3_bez2_dd_abs($d2);
    const $c0c0 = c0 * c0;
    const $c0c1 = c0 * $c1;
    const $c0c2 = c0 * $c2;
    const $c0d0 = c0 * d0;
    const $c0d1 = c0 * $d1;
    const $c0d2 = c0 * $d2;
    const $c1c1 = $c1 * $c1;
    const $c1c2 = $c1 * $c2;
    const $c1d0 = $c1 * d0;
    const $c1d1 = $c1 * $d1;
    const $c1d2 = $c1 * $d2;
    const $c2d1 = $c2 * $d1;
    const $c2c2 = $c2 * $c2;
    const $c2d0 = $c2 * d0;
    const $c2d2 = $c2 * $d2;
    const $d0d0 = d0 * d0;
    const $d0d1 = d0 * $d1;
    const $d0d2 = d0 * $d2;
    const $d1d1 = $d1 * $d1;
    const $d1d2 = $d1 * $d2;
    const $d2d2 = $d2 * $d2;
    const c0c0 = get_coeffs_bez3_bez2_dd_tp(c0, c0); // error free
    const c0c1 = get_coeffs_bez3_bez2_dd_qmd(c0, c1);
    const c0c1_ = get_coeffs_bez3_bez2_dd_abs($c0c1);
    const c0c2 = get_coeffs_bez3_bez2_dd_qmd(c0, c2);
    const c0c2_ = _c0 * c2_ + get_coeffs_bez3_bez2_dd_abs($c0c2);
    const c0d0 = get_coeffs_bez3_bez2_dd_tp(c0, d0); // error free
    const c0d1 = get_coeffs_bez3_bez2_dd_qmd(c0, d1);
    const c0d1_ = get_coeffs_bez3_bez2_dd_abs($c0d1);
    const c0d2 = get_coeffs_bez3_bez2_dd_qmd(c0, d2);
    const c0d2_ = _c0 * d2_ + get_coeffs_bez3_bez2_dd_abs($c0d2);
    const c1c1 = get_coeffs_bez3_bez2_dd_qmq(c1, c1);
    const c1c1_ = 2 * get_coeffs_bez3_bez2_dd_abs($c1c1);
    const c1c2 = get_coeffs_bez3_bez2_dd_qmq(c1, c2);
    const c1c2_ = _c1 * c2_ + 2 * get_coeffs_bez3_bez2_dd_abs($c1c2);
    const c1d0 = get_coeffs_bez3_bez2_dd_qmd(d0, c1);
    const c1d0_ = get_coeffs_bez3_bez2_dd_abs($c1d0);
    const c1d1 = get_coeffs_bez3_bez2_dd_qmq(c1, d1);
    const c1d1_ = 2 * get_coeffs_bez3_bez2_dd_abs($c1d1);
    const c1d2 = get_coeffs_bez3_bez2_dd_qmq(c1, d2);
    const c1d2_ = _c1 * d2_ + 2 * get_coeffs_bez3_bez2_dd_abs($c1d2);
    const c2d1 = get_coeffs_bez3_bez2_dd_qmq(c2, d1);
    const c2d1_ = c2_ * _d1 + 2 * get_coeffs_bez3_bez2_dd_abs($c2d1);
    const c2c2 = get_coeffs_bez3_bez2_dd_qmq(c2, c2);
    const c2c2_ = 2 * (c2_ * _c2 + get_coeffs_bez3_bez2_dd_abs($c2c2));
    const c2d0 = get_coeffs_bez3_bez2_dd_qmd(d0, c2);
    const c2d0_ = _d0 * c2_ + get_coeffs_bez3_bez2_dd_abs($c2d0);
    const c2d2 = get_coeffs_bez3_bez2_dd_qmq(c2, d2);
    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * get_coeffs_bez3_bez2_dd_abs($c2d2);
    const d0d0 = get_coeffs_bez3_bez2_dd_tp(d0, d0); // error free
    const d0d1 = get_coeffs_bez3_bez2_dd_qmd(d0, d1);
    const d0d1_ = get_coeffs_bez3_bez2_dd_abs($d0d1);
    const d0d2 = get_coeffs_bez3_bez2_dd_qmd(d0, d2);
    const d0d2_ = _d0 * d2_ + get_coeffs_bez3_bez2_dd_abs($d0d2);
    const d1d1 = get_coeffs_bez3_bez2_dd_qmq(d1, d1);
    const d1d1_ = 2 * get_coeffs_bez3_bez2_dd_abs($d1d1);
    const d1d2 = get_coeffs_bez3_bez2_dd_qmq(d1, d2);
    const d1d2_ = _d1 * d2_ + 2 * get_coeffs_bez3_bez2_dd_abs($d1d2);
    const d2d2 = get_coeffs_bez3_bez2_dd_qmq(d2, d2);
    const d2d2_ = 2 * (d2_ * _d2 + get_coeffs_bez3_bez2_dd_abs($d2d2));
    const _c0c0 = get_coeffs_bez3_bez2_dd_abs($c0c0);
    const _c0c1 = get_coeffs_bez3_bez2_dd_abs($c0c1);
    const _c0d0 = get_coeffs_bez3_bez2_dd_abs($c0d0);
    const _c0d1 = get_coeffs_bez3_bez2_dd_abs($c0d1);
    const _c1c2 = get_coeffs_bez3_bez2_dd_abs($c1c2);
    const _c2c2 = get_coeffs_bez3_bez2_dd_abs($c2c2);
    const _c2d2 = get_coeffs_bez3_bez2_dd_abs($c2d2);
    const _c1d0 = get_coeffs_bez3_bez2_dd_abs($c1d0);
    const _d0d0 = get_coeffs_bez3_bez2_dd_abs($d0d0);
    const _d0d1 = get_coeffs_bez3_bez2_dd_abs($d0d1);
    const _d1d2 = get_coeffs_bez3_bez2_dd_abs($d1d2);
    const _d2d2 = get_coeffs_bez3_bez2_dd_abs($d2d2);
    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy
    //const v6 =
    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +
    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);
    const e1 = get_coeffs_bez3_bez2_dd_qmq(c2, vₓₓₓ);
    const $e1 = $c2 * $vₓₓₓ;
    const e1_ = c2_ * _vₓₓₓ + _c2 * vₓₓₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($e1);
    const e2 = get_coeffs_bez3_bez2_dd_qmq(c2, vₓᵧᵧ);
    const $e2 = $c2 * $vₓᵧᵧ;
    const e2_ = c2_ * _vₓᵧᵧ + _c2 * vₓᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($e2);
    const e3 = get_coeffs_bez3_bez2_dd_qmq(d2, vₓₓᵧ);
    const $e3 = $d2 * $vₓₓᵧ;
    const e3_ = d2_ * _vₓₓᵧ + _d2 * vₓₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($e3);
    const e4 = get_coeffs_bez3_bez2_dd_qmq(d2, vᵧᵧᵧ);
    const $e4 = $d2 * $vᵧᵧᵧ;
    const e4_ = d2_ * _vᵧᵧᵧ + _d2 * vᵧᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($e4);
    const $e5 = $e1 + $e3;
    const e5 = get_coeffs_bez3_bez2_dd_qaq(e1, e3);
    const _e5 = get_coeffs_bez3_bez2_dd_abs($e5);
    const e5_ = e1_ + e3_ + _e5;
    const $e6 = $e2 + $e4;
    const e6 = get_coeffs_bez3_bez2_dd_qaq(e2, e4);
    const _e6 = get_coeffs_bez3_bez2_dd_abs($e6);
    const e6_ = e2_ + e4_ + _e6;
    const $e7 = $c2c2 * $e5;
    const e7 = get_coeffs_bez3_bez2_dd_qmq(c2c2, e5);
    const e7_ = c2c2_ * _e5 + _c2c2 * e5_ + 2 * get_coeffs_bez3_bez2_dd_abs($e7);
    const $e8 = $d2d2 * $e6;
    const e8 = get_coeffs_bez3_bez2_dd_qmq(d2d2, e6);
    const e8_ = d2d2_ * _e6 + _d2d2 * e6_ + 2 * get_coeffs_bez3_bez2_dd_abs($e8);
    const $v6 = $e7 + $e8;
    const v6 = get_coeffs_bez3_bez2_dd_qaq(e7, e8);
    const v6_ = e7_ + e8_ + get_coeffs_bez3_bez2_dd_abs($v6);
    ///
    const $z1 = $c0c2 + $c1c1;
    const z1 = get_coeffs_bez3_bez2_dd_qaq(c0c2, c1c1);
    const _z1 = get_coeffs_bez3_bez2_dd_abs($z1);
    const z1_ = c0c2_ + c1c1_ + _z1;
    const $z2 = $d0d2 + $d1d1;
    const z2 = get_coeffs_bez3_bez2_dd_qaq(d0d2, d1d1);
    const _z2 = get_coeffs_bez3_bez2_dd_abs($z2);
    const z2_ = d0d2_ + d1d1_ + _z2;
    const $z3 = 2 * $c0c2 + $c1c1;
    const _z3 = get_coeffs_bez3_bez2_dd_abs($z3);
    const z3 = get_coeffs_bez3_bez2_dd_qaq(get_coeffs_bez3_bez2_dd_qm2(c0c2), c1c1);
    const z3_ = 2 * c0c2_ + c1c1_ + _z3;
    const $z4 = 2 * $d0d2 + $d1d1;
    const z4 = get_coeffs_bez3_bez2_dd_qaq(get_coeffs_bez3_bez2_dd_qm2(d0d2), d1d1);
    const _z4 = get_coeffs_bez3_bez2_dd_abs($z4);
    const z4_ = 2 * d0d2_ + d1d1_ + _z4;
    const $z5 = 2 * $c1d1 + $c2d0;
    const z5 = get_coeffs_bez3_bez2_dd_qaq(get_coeffs_bez3_bez2_dd_qm2(c1d1), c2d0);
    const _z5 = get_coeffs_bez3_bez2_dd_abs($z5);
    const z5_ = 2 * c1d1_ + c2d0_ + _z5;
    const $z6 = 2 * $c1d1 + $c0d2;
    const z6 = get_coeffs_bez3_bez2_dd_qaq(get_coeffs_bez3_bez2_dd_qm2(c1d1), c0d2);
    const _z6 = get_coeffs_bez3_bez2_dd_abs($z6);
    const z6_ = 2 * c1d1_ + c0d2_ + _z6;
    const $z7 = 2 * $c2d0 + $c1d1;
    const z7 = get_coeffs_bez3_bez2_dd_qaq(get_coeffs_bez3_bez2_dd_qm2(c2d0), c1d1);
    const z7_ = 2 * c2d0_ + c1d1_ + get_coeffs_bez3_bez2_dd_abs($z7);
    const $z8 = 6 * $c0c2 + $c1c1;
    const $q1 = 6 * $c0c2;
    const q1 = get_coeffs_bez3_bez2_dd_qmd(6, c0c2);
    const q1_ = 6 * c0c2_ + get_coeffs_bez3_bez2_dd_abs($q1);
    const z8 = get_coeffs_bez3_bez2_dd_qaq(q1, c1c1);
    const z8_ = q1_ + c1c1_ + get_coeffs_bez3_bez2_dd_abs($q1 + $c1c1);
    const $z9 = 6 * $d0d2 + $d1d1;
    const $q2 = 6 * $d0d2;
    const q2 = get_coeffs_bez3_bez2_dd_qmd(6, d0d2);
    const q2_ = 6 * d0d2_ + get_coeffs_bez3_bez2_dd_abs($q2);
    const z9 = get_coeffs_bez3_bez2_dd_qaq(q2, d1d1);
    const z9_ = q2_ + d1d1_ + get_coeffs_bez3_bez2_dd_abs($q2 + $d1d1);
    const $za = $c1d2 + $c2d1;
    const za = get_coeffs_bez3_bez2_dd_qaq(c1d2, c2d1);
    const _za = get_coeffs_bez3_bez2_dd_abs($za);
    const za_ = c1d2_ + c2d1_ + _za;
    const $zb = $c0d2 + $c2d0;
    const zb = get_coeffs_bez3_bez2_dd_qaq(c0d2, c2d0);
    const zb_ = c0d2_ + c2d0_ + get_coeffs_bez3_bez2_dd_abs($zb);
    const $zc = 2 * $c1d0 + $c0d1;
    const zc = get_coeffs_bez3_bez2_dd_qaq(get_coeffs_bez3_bez2_dd_qm2(c1d0), c0d1);
    const zc_ = 2 * c1d0_ + c0d1_ + get_coeffs_bez3_bez2_dd_abs($zc);
    const $zd = 2 * $c0d1 + $c1d0;
    const zd = get_coeffs_bez3_bez2_dd_qaq(get_coeffs_bez3_bez2_dd_qm2(c0d1), c1d0);
    const zd_ = 2 * c0d1_ + c1d0_ + get_coeffs_bez3_bez2_dd_abs($zd);
    const $zf = $c0d2 + $c1d1;
    const zf = get_coeffs_bez3_bez2_dd_qaq(c0d2, c1d1);
    const zf_ = c0d2_ + c1d1_ + get_coeffs_bez3_bez2_dd_abs($zf);
    const $ze = $zf + $c2d0;
    const ze = get_coeffs_bez3_bez2_dd_qaq(zf, c2d0);
    const _ze = get_coeffs_bez3_bez2_dd_abs($ze);
    const ze_ = zf_ + c2d0_ + _ze;
    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + 
    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy
    //const v5 =
    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +
    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);
    const $s0 = 3 * $c2c2;
    const s0 = get_coeffs_bez3_bez2_dd_qmd(3, c2c2);
    const s0_ = 3 * c2c2_ + get_coeffs_bez3_bez2_dd_abs($s0);
    const _s0 = get_coeffs_bez3_bez2_dd_abs($s0);
    const $t1 = 3 * $d2d2;
    const t1 = get_coeffs_bez3_bez2_dd_qmd(3, d2d2);
    const t1_ = 3 * d2d2_ + get_coeffs_bez3_bez2_dd_abs($t1);
    const _t1 = get_coeffs_bez3_bez2_dd_abs($t1);
    const $s1 = $s0 * $vₓₓₓ;
    const s1 = get_coeffs_bez3_bez2_dd_qmq(s0, vₓₓₓ);
    const s1_ = s0_ * _vₓₓₓ + _s0 * vₓₓₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($s1);
    const $s2 = $c2c2 * $vₓₓᵧ;
    const s2 = get_coeffs_bez3_bez2_dd_qmq(c2c2, vₓₓᵧ);
    const s2_ = c2c2_ * _vₓₓᵧ + _c2c2 * vₓₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($s2);
    const $s3 = 2 * $c2d2 * $vₓₓᵧ;
    const s3 = get_coeffs_bez3_bez2_dd_qm2(get_coeffs_bez3_bez2_dd_qmq(c2d2, vₓₓᵧ));
    const s3_ = 2 * (c2d2_ * _vₓₓᵧ + _c2d2 * vₓₓᵧ_ + get_coeffs_bez3_bez2_dd_abs($s3));
    const $s4 = 2 * $c2d2 * $vₓᵧᵧ;
    const s4 = get_coeffs_bez3_bez2_dd_qm2(get_coeffs_bez3_bez2_dd_qmq(c2d2, vₓᵧᵧ));
    const s4_ = 2 * (c2d2_ * _vₓᵧᵧ + _c2d2 * vₓᵧᵧ_ + get_coeffs_bez3_bez2_dd_abs($s4));
    const $s5 = $d2d2 * $vₓᵧᵧ;
    const s5 = get_coeffs_bez3_bez2_dd_qmq(d2d2, vₓᵧᵧ);
    const s5_ = d2d2_ * _vₓᵧᵧ + _d2d2 * vₓᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($s5);
    const $s6 = $t1 * $vᵧᵧᵧ;
    const s6 = get_coeffs_bez3_bez2_dd_qmq(t1, vᵧᵧᵧ);
    const s6_ = t1_ * _vᵧᵧᵧ + _t1 * vᵧᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($s6);
    const $s7 = $s1 + $s3;
    const s7 = get_coeffs_bez3_bez2_dd_qaq(s1, s3);
    const s7_ = s1_ + s3_ + get_coeffs_bez3_bez2_dd_abs($s7);
    const $s8 = $s2 + $s4;
    const s8 = get_coeffs_bez3_bez2_dd_qaq(s2, s4);
    const s8_ = s2_ + s4_ + get_coeffs_bez3_bez2_dd_abs($s8);
    const $s9 = $s7 + $s5;
    const s9 = get_coeffs_bez3_bez2_dd_qaq(s7, s5);
    const s9_ = s7_ + s5_ + get_coeffs_bez3_bez2_dd_abs($s9);
    const $sa = $s8 + $s6;
    const sa = get_coeffs_bez3_bez2_dd_qaq(s8, s6);
    const sa_ = s8_ + s6_ + get_coeffs_bez3_bez2_dd_abs($sa);
    const $sb = $c1 * $s9;
    const sb = get_coeffs_bez3_bez2_dd_qmq(c1, s9);
    const sb_ = _c1 * s9_ + get_coeffs_bez3_bez2_dd_abs($sb);
    const $sc = $d1 * $sa;
    const sc = get_coeffs_bez3_bez2_dd_qmq(d1, sa);
    const sc_ = _d1 * sa_ + get_coeffs_bez3_bez2_dd_abs($sc);
    const $v5 = $sb + $sc;
    const v5 = get_coeffs_bez3_bez2_dd_qaq(sb, sc);
    const v5_ = sb_ + sc_ + get_coeffs_bez3_bez2_dd_abs($v5);
    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + 
    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + 
    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + 
    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + 
    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy
    //const v4 =
    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + 
    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + 
    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +
    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +
    //    vₓₓ*c2c2 +
    //    vᵧᵧ*d2d2 +
    //    vₓᵧ*c2d2;
    //const v4 =
    //    (3*c2)*z1*vₓₓₓ + 
    //    (3*d2)*z2*vᵧᵧᵧ + 
    //    (d2*z3 + c2*z5)*vₓₓᵧ +
    //    (d2*z6 + c2*z4)*vₓᵧᵧ +
    //    vₓₓ*c2c2 +
    //    vᵧᵧ*d2d2 +
    //    vₓᵧ*c2d2;
    const $sd = $d2 * $z3;
    const sd = get_coeffs_bez3_bez2_dd_qmq(d2, z3);
    const sd_ = d2_ * _z3 + _d2 * z3_ + 2 * get_coeffs_bez3_bez2_dd_abs($sd);
    const $se = $d2 * $z6;
    const se = get_coeffs_bez3_bez2_dd_qmq(d2, z6);
    const se_ = d2_ * _z6 + _d2 * z6_ + 2 * get_coeffs_bez3_bez2_dd_abs($se);
    const $sf = $c2 * $z5;
    const sf = get_coeffs_bez3_bez2_dd_qmq(c2, z5);
    const sf_ = c2_ * _z5 + _c2 * z5_ + 2 * get_coeffs_bez3_bez2_dd_abs($sf);
    const $sg = $c2 * $z4;
    const sg = get_coeffs_bez3_bez2_dd_qmq(c2, z4);
    const sg_ = c2_ * _z4 + _c2 * z4_ + 2 * get_coeffs_bez3_bez2_dd_abs($sg);
    const $q3 = 3 * $c2;
    const q3 = get_coeffs_bez3_bez2_dd_qmd(3, c2);
    const _q3 = get_coeffs_bez3_bez2_dd_abs($q3);
    const q3_ = 3 * c2_ + _q3;
    const $sh = $q3 * $z1;
    const sh = get_coeffs_bez3_bez2_dd_qmq(q3, z1);
    const _sh = get_coeffs_bez3_bez2_dd_abs($sh);
    const sh_ = q3_ * _z1 + _q3 * z1_ + _sh;
    const $q4 = 3 * $d2;
    const q4 = get_coeffs_bez3_bez2_dd_qmd(3, d2);
    const _q4 = get_coeffs_bez3_bez2_dd_abs($q4);
    const q4_ = 3 * d2_ + _q4;
    const $si = $q4 * $z2;
    const si = get_coeffs_bez3_bez2_dd_qmq(q4, z2);
    const _si = get_coeffs_bez3_bez2_dd_abs($si);
    const si_ = q4_ * _z2 + _q4 * z2_ + _si;
    const $sj = $sd + $sf;
    const sj = get_coeffs_bez3_bez2_dd_qaq(sd, sf);
    const _sj = get_coeffs_bez3_bez2_dd_abs($sj);
    const sj_ = sd_ + sf_ + _sj;
    const $sk = $se + $sg;
    const sk = get_coeffs_bez3_bez2_dd_qaq(se, sg);
    const _sk = get_coeffs_bez3_bez2_dd_abs($sk);
    const sk_ = se_ + sg_ + _sk;
    const $sl = $sh * $vₓₓₓ;
    const sl = get_coeffs_bez3_bez2_dd_qmq(sh, vₓₓₓ);
    const sl_ = sh_ * _vₓₓₓ + _sh * vₓₓₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($sl);
    const $sm = $si * $vᵧᵧᵧ;
    const sm = get_coeffs_bez3_bez2_dd_qmq(si, vᵧᵧᵧ);
    const sm_ = si_ * _vᵧᵧᵧ + _si * vᵧᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($sm);
    const $sn = $sj * $vₓₓᵧ;
    const sn = get_coeffs_bez3_bez2_dd_qmq(sj, vₓₓᵧ);
    const sn_ = sj_ * _vₓₓᵧ + _sj * vₓₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($sn);
    const $so = $sk * $vₓᵧᵧ;
    const so = get_coeffs_bez3_bez2_dd_qmq(sk, vₓᵧᵧ);
    const so_ = sk_ * _vₓᵧᵧ + _sk * vₓᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($so);
    const $sp = $sl + $sm;
    const sp = get_coeffs_bez3_bez2_dd_qaq(sl, sm);
    const sp_ = sl_ + sm_ + get_coeffs_bez3_bez2_dd_abs($sp);
    const $sq = $sn + $so;
    const sq = get_coeffs_bez3_bez2_dd_qaq(sn, so);
    const sq_ = sn_ + so_ + get_coeffs_bez3_bez2_dd_abs($sq);
    const $sr = $c2c2 * $vₓₓ;
    const sr = get_coeffs_bez3_bez2_dd_qmq(c2c2, vₓₓ);
    const sr_ = c2c2_ * _vₓₓ + _c2c2 * vₓₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($sr);
    const $ss = $d2d2 * $vᵧᵧ;
    const ss = get_coeffs_bez3_bez2_dd_qmq(d2d2, vᵧᵧ);
    const ss_ = d2d2_ * _vᵧᵧ + _d2d2 * vᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($ss);
    const $st = $c2d2 * $vₓᵧ;
    const st = get_coeffs_bez3_bez2_dd_qmq(c2d2, vₓᵧ);
    const st_ = c2d2_ * _vₓᵧ + _c2d2 * vₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($st);
    const $su = $sr + $ss;
    const su = get_coeffs_bez3_bez2_dd_qaq(sr, ss);
    const su_ = sr_ + ss_ + get_coeffs_bez3_bez2_dd_abs($su);
    const $sv = $sp + $sq;
    const sv = get_coeffs_bez3_bez2_dd_qaq(sp, sq);
    const sv_ = sp_ + sq_ + get_coeffs_bez3_bez2_dd_abs($sv);
    const $sw = $su + $st;
    const sw = get_coeffs_bez3_bez2_dd_qaq(su, st);
    const sw_ = su_ + st_ + get_coeffs_bez3_bez2_dd_abs($sw);
    const $v4 = $sv + $sw;
    const v4 = get_coeffs_bez3_bez2_dd_qaq(sv, sw);
    const v4_ = sv_ + sw_ + get_coeffs_bez3_bez2_dd_abs($v4);
    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + 
    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + 
    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + 
    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + 
    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + 
    // 2*b1*b2*v_yy
    //const v3 =
    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +
    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        
    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +
    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +
    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +
    //    c1d2*vₓᵧ + c2d1*vₓᵧ;
    //const v3 =
    //    c1*z8*vₓₓₓ +
    //    d1*z9*vᵧᵧᵧ +        
    //    (2*c0*za + c1*z7)*vₓₓᵧ +
    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +
    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +
    //    za*vₓᵧ;
    const $sx = $c1 * $z8;
    const sx = get_coeffs_bez3_bez2_dd_qmq(c1, z8);
    const _sx = _c1 * z8_ + 2 * get_coeffs_bez3_bez2_dd_abs($sx);
    const sx_ = 2 * _sx;
    const $sy = $d1 * $z9;
    const sy = get_coeffs_bez3_bez2_dd_qmq(d1, z9);
    const _sy = _d1 * z9_ + 2 * get_coeffs_bez3_bez2_dd_abs($sy);
    const sy_ = 2 * _sy;
    const $sz = 2 * c0 * $za;
    const sz = get_coeffs_bez3_bez2_dd_qmd(2 * c0, za);
    const sz_ = 2 * _c0 * za_ + get_coeffs_bez3_bez2_dd_abs($sz);
    const $o1 = 2 * $d1 * $zb;
    const o1 = get_coeffs_bez3_bez2_dd_qmq(get_coeffs_bez3_bez2_dd_qm2(d1), zb);
    const o1_ = 2 * _d1 * zb_ + 2 * get_coeffs_bez3_bez2_dd_abs($o1);
    const $o2 = $c1 * $z7;
    const o2 = get_coeffs_bez3_bez2_dd_qmq(c1, z7);
    const o2_ = _c1 * z7_ + 2 * get_coeffs_bez3_bez2_dd_abs($o2);
    const $o3 = $c1 * $z4;
    const o3 = get_coeffs_bez3_bez2_dd_qmq(c1, z4);
    const o3_ = _c1 * z4_ + 2 * get_coeffs_bez3_bez2_dd_abs($o3);
    const $o4 = $sz + $o2;
    const o4 = get_coeffs_bez3_bez2_dd_qaq(sz, o2);
    const _o4 = sz_ + o2_ + get_coeffs_bez3_bez2_dd_abs($o4);
    const o4_ = sz_ + o2_ + _o4;
    const $o5 = $o1 + $o3;
    const o5 = get_coeffs_bez3_bez2_dd_qaq(o1, o3);
    const _o5 = o1_ + o3_ + get_coeffs_bez3_bez2_dd_abs($o5);
    const o5_ = o1_ + o3_ + _o5;
    const $o6 = $d1d2 * $vᵧᵧ;
    const o6 = get_coeffs_bez3_bez2_dd_qmq(d1d2, vᵧᵧ);
    const o6_ = d1d2_ * _vᵧᵧ + _d1d2 * vᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($o6);
    const $o7 = $c1c2 * $vₓₓ;
    const o7 = get_coeffs_bez3_bez2_dd_qmq(c1c2, vₓₓ);
    const o7_ = c1c2_ * _vₓₓ + _c1c2 * vₓₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($o7);
    const $o8 = $za * $vₓᵧ;
    const o8 = get_coeffs_bez3_bez2_dd_qmq(za, vₓᵧ);
    const o8_ = za_ * _vₓᵧ + _za * vₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($o8);
    const $o9 = $o6 + $o7;
    const o9 = get_coeffs_bez3_bez2_dd_qaq(o6, o7);
    const o9_ = o6_ + o7_ + get_coeffs_bez3_bez2_dd_abs($o9);
    const $oa = $sx * $vₓₓₓ;
    const oa = get_coeffs_bez3_bez2_dd_qmq(sx, vₓₓₓ);
    const oa_ = sx_ * _vₓₓₓ + _sx * vₓₓₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($oa);
    const $ob = $o4 * $vₓₓᵧ;
    const ob = get_coeffs_bez3_bez2_dd_qmq(o4, vₓₓᵧ);
    const ob_ = o4_ * _vₓₓᵧ + _o4 * vₓₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($ob);
    const $oc = $sy * $vᵧᵧᵧ;
    const oc = get_coeffs_bez3_bez2_dd_qmq(sy, vᵧᵧᵧ);
    const oc_ = sy_ * _vᵧᵧᵧ + _sy * vᵧᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($oc);
    const $od = $o5 * $vₓᵧᵧ;
    const od = get_coeffs_bez3_bez2_dd_qmq(o5, vₓᵧᵧ);
    const od_ = o5_ * _vₓᵧᵧ + _o5 * vₓᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($od);
    const $oe = $oa + $oc;
    const oe = get_coeffs_bez3_bez2_dd_qaq(oa, oc);
    const oe_ = oa_ + oc_ + get_coeffs_bez3_bez2_dd_abs($oe);
    const $og = $ob + $od;
    const og = get_coeffs_bez3_bez2_dd_qaq(ob, od);
    const og_ = ob_ + od_ + get_coeffs_bez3_bez2_dd_abs($og);
    const $oh = $oe + $og;
    const oh = get_coeffs_bez3_bez2_dd_qaq(oe, og);
    const oh_ = oe_ + og_ + get_coeffs_bez3_bez2_dd_abs($oh);
    const $oi = 2 * $o9 + $o8;
    const oi = get_coeffs_bez3_bez2_dd_qaq(get_coeffs_bez3_bez2_dd_qm2(o9), o8);
    const oi_ = 2 * o9_ + o8_ + get_coeffs_bez3_bez2_dd_abs($oi);
    const $v3 = $oh + $oi;
    const v3 = get_coeffs_bez3_bez2_dd_qaq(oh, oi);
    const v3_ = oh_ + oi_ + get_coeffs_bez3_bez2_dd_abs($v3);
    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + 
    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + 
    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + 
    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y
    //const v2 =
    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +
    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +
    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +
    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +
    //    (2*c0c2 + c1c1)*vₓₓ +
    //    (2*d0d2 + d1d1)*vᵧᵧ +
    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +
    //    c2*vₓ    +
    //    d2*vᵧ;
    //const v2 =
    //    (3*c0*z1)*vₓₓₓ +
    //    (3*d0*z2)*vᵧᵧᵧ +
    //    (c0*z6 + d0*z3)*vₓₓᵧ +
    //    (c0*z4 + d0*z5)*vₓᵧᵧ +
    //    z3*vₓₓ +
    //    z4*vᵧᵧ +
    //    ze*vₓᵧ +
    //    c2*vₓ    +
    //    d2*vᵧ;
    const $q5 = 3 * c0;
    const _q5 = get_coeffs_bez3_bez2_dd_abs($q5);
    const q5 = get_coeffs_bez3_bez2_dd_tp(3, c0); // error free
    const $oj = $q5 * $z1;
    const oj = get_coeffs_bez3_bez2_dd_qmq(q5, z1);
    const _oj = get_coeffs_bez3_bez2_dd_abs($oj);
    const oj_ = _q5 * z1_ + 2 * get_coeffs_bez3_bez2_dd_abs($oj);
    const $q6 = 3 * d0;
    const _q6 = get_coeffs_bez3_bez2_dd_abs($q6);
    const q6 = get_coeffs_bez3_bez2_dd_tp(3, d0); // error free
    const $ok = $q6 * $z2;
    const ok = get_coeffs_bez3_bez2_dd_qmq(q6, z2);
    const _ok = get_coeffs_bez3_bez2_dd_abs($ok);
    const ok_ = _q6 * z2_ + 2 * get_coeffs_bez3_bez2_dd_abs($ok);
    const $ol = c0 * $z6;
    const ol = get_coeffs_bez3_bez2_dd_qmd(c0, z6);
    const ol_ = _c0 * z6_ + get_coeffs_bez3_bez2_dd_abs($ol);
    const $om = c0 * $z4;
    const om = get_coeffs_bez3_bez2_dd_qmd(c0, z4);
    const om_ = _c0 * z4_ + get_coeffs_bez3_bez2_dd_abs($om);
    const $on = d0 * $z3;
    const on = get_coeffs_bez3_bez2_dd_qmd(d0, z3);
    const on_ = _d0 * z3_ + get_coeffs_bez3_bez2_dd_abs($on);
    const $oo = d0 * $z5;
    const oo = get_coeffs_bez3_bez2_dd_qmd(d0, z5);
    const oo_ = _d0 * z5_ + get_coeffs_bez3_bez2_dd_abs($oo);
    const $op = $ol + $on;
    const op = get_coeffs_bez3_bez2_dd_qaq(ol, on);
    const _op = get_coeffs_bez3_bez2_dd_abs($op);
    const op_ = ol_ + on_ + _op;
    const $oq = $om + $oo;
    const oq = get_coeffs_bez3_bez2_dd_qaq(om, oo);
    const _oq = get_coeffs_bez3_bez2_dd_abs($oq);
    const oq_ = om_ + oo_ + _oq;
    const $or = $oj * $vₓₓₓ;
    const or = get_coeffs_bez3_bez2_dd_qmq(oj, vₓₓₓ);
    const or_ = oj_ * _vₓₓₓ + _oj * vₓₓₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($or);
    const $os = $ok * $vᵧᵧᵧ;
    const os = get_coeffs_bez3_bez2_dd_qmq(ok, vᵧᵧᵧ);
    const os_ = ok_ * _vᵧᵧᵧ + _ok * vᵧᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($os);
    const $ot = $op * $vₓₓᵧ;
    const ot = get_coeffs_bez3_bez2_dd_qmq(op, vₓₓᵧ);
    const ot_ = op_ * _vₓₓᵧ + _op * vₓₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($ot);
    const $ou = $oq * $vₓᵧᵧ;
    const ou = get_coeffs_bez3_bez2_dd_qmq(oq, vₓᵧᵧ);
    const ou_ = oq_ * _vₓᵧᵧ + _oq * vₓᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($ou);
    const $ov = $z3 * $vₓₓ;
    const ov = get_coeffs_bez3_bez2_dd_qmq(z3, vₓₓ);
    const ov_ = z3_ * _vₓₓ + _z3 * vₓₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($ov);
    const $ow = $z4 * $vᵧᵧ;
    const ow = get_coeffs_bez3_bez2_dd_qmq(z4, vᵧᵧ);
    const ow_ = z4_ * _vᵧᵧ + _z4 * vᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($ow);
    const $ox = $ze * $vₓᵧ;
    const ox = get_coeffs_bez3_bez2_dd_qmq(ze, vₓᵧ);
    const ox_ = ze_ * _vₓᵧ + _ze * vₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($ox);
    const $oy = $c2 * $vₓ;
    const oy = get_coeffs_bez3_bez2_dd_qmq(c2, vₓ);
    const oy_ = c2_ * _vₓ + _c2 * vₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($oy);
    const $oz = $d2 * $vᵧ;
    const oz = get_coeffs_bez3_bez2_dd_qmq(d2, vᵧ);
    const oz_ = d2_ * _vᵧ + _d2 * vᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($oz);
    const $p1 = $or + $os;
    const p1 = get_coeffs_bez3_bez2_dd_qaq(or, os);
    const p1_ = or_ + os_ + get_coeffs_bez3_bez2_dd_abs($p1);
    const $p2 = $ot + $ou;
    const p2 = get_coeffs_bez3_bez2_dd_qaq(ot, ou);
    const p2_ = ot_ + ou_ + get_coeffs_bez3_bez2_dd_abs($p2);
    const $p3 = $ov + $ow;
    const p3 = get_coeffs_bez3_bez2_dd_qaq(ov, ow);
    const p3_ = ov_ + ow_ + get_coeffs_bez3_bez2_dd_abs($p3);
    const $p4 = $p1 + $p2;
    const p4 = get_coeffs_bez3_bez2_dd_qaq(p1, p2);
    const p4_ = p1_ + p2_ + get_coeffs_bez3_bez2_dd_abs($p4);
    const $p5 = $p3 + $ox;
    const p5 = get_coeffs_bez3_bez2_dd_qaq(p3, ox);
    const p5_ = p3_ + ox_ + get_coeffs_bez3_bez2_dd_abs($p5);
    const $p6 = $oy + $oz;
    const p6 = get_coeffs_bez3_bez2_dd_qaq(oy, oz);
    const p6_ = oy_ + oz_ + get_coeffs_bez3_bez2_dd_abs($p6);
    const $p7 = $p4 + $p5;
    const p7 = get_coeffs_bez3_bez2_dd_qaq(p4, p5);
    const p7_ = p4_ + p5_ + get_coeffs_bez3_bez2_dd_abs($p7);
    const $v2 = $p7 + $p6;
    const v2 = get_coeffs_bez3_bez2_dd_qaq(p7, p6);
    const v2_ = p7_ + p6_ + get_coeffs_bez3_bez2_dd_abs($v2);
    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + 
    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y
    //const v1 =
    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +
    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +
    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +
    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +
    //    c0d1*vₓᵧ + c1d0*vₓᵧ +
    //    c1*vₓ + d1*vᵧ;
    //const v1 =
    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +
    //    c0*zc*vₓₓᵧ +
    //    d0*zd*vₓᵧᵧ +
    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +
    //    c0d1*vₓᵧ + c1d0*vₓᵧ +
    //    c1*vₓ + d1*vᵧ;
    const $p8 = $q5 * $c0c1;
    const p8 = get_coeffs_bez3_bez2_dd_qmq(q5, c0c1);
    const _p8 = get_coeffs_bez3_bez2_dd_abs($p8);
    const p8_ = _q5 * c0c1_ + 2 * _p8;
    const $p9 = $q6 * $d0d1;
    const p9 = get_coeffs_bez3_bez2_dd_qmq(q6, d0d1);
    const _p9 = get_coeffs_bez3_bez2_dd_abs($p9);
    const p9_ = _q6 * d0d1_ + 2 * _p9;
    const $pa = c0 * $zc;
    const pa = get_coeffs_bez3_bez2_dd_qmd(c0, zc);
    const _pa = get_coeffs_bez3_bez2_dd_abs($pa);
    const pa_ = _c0 * zc_ + get_coeffs_bez3_bez2_dd_abs($pa);
    const $pb = d0 * $zd;
    const pb = get_coeffs_bez3_bez2_dd_qmd(d0, zd);
    const _pb = get_coeffs_bez3_bez2_dd_abs($pb);
    const pb_ = _d0 * zd_ + get_coeffs_bez3_bez2_dd_abs($pb);
    const $pc = $c0c1 * $vₓₓ;
    const pc = get_coeffs_bez3_bez2_dd_qmq(c0c1, vₓₓ);
    const pc_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($pc);
    const $pd = $d0d1 * $vᵧᵧ;
    const pd = get_coeffs_bez3_bez2_dd_qmq(d0d1, vᵧᵧ);
    const pd_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($pd);
    const $pe = $c0d1 * $vₓᵧ;
    const pe = get_coeffs_bez3_bez2_dd_qmq(c0d1, vₓᵧ);
    const pe_ = c0d1_ * _vₓᵧ + _c0d1 * vₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($pe);
    const $pf = $c1d0 * $vₓᵧ;
    const pf = get_coeffs_bez3_bez2_dd_qmq(c1d0, vₓᵧ);
    const pf_ = c1d0_ * _vₓᵧ + _c1d0 * vₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($pf);
    const $pg = 2 * ($pc + $pd);
    const pg = get_coeffs_bez3_bez2_dd_qm2(get_coeffs_bez3_bez2_dd_qaq(pc, pd));
    const pg_ = 2 * (pc_ + pd_) + get_coeffs_bez3_bez2_dd_abs($pg);
    const $ph = $pe + $pf;
    const ph = get_coeffs_bez3_bez2_dd_qaq(pe, pf);
    const ph_ = pe_ + pf_ + get_coeffs_bez3_bez2_dd_abs($ph);
    const $pi = $c1 * $vₓ;
    const pi = get_coeffs_bez3_bez2_dd_qmq(c1, vₓ);
    const pi_ = _c1 * vₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($pi);
    const $pj = $d1 * $vᵧ;
    const pj = get_coeffs_bez3_bez2_dd_qmq(d1, vᵧ);
    const pj_ = _d1 * vᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($pj);
    const $pk = $p8 * $vₓₓₓ;
    const pk = get_coeffs_bez3_bez2_dd_qmq(p8, vₓₓₓ);
    const pk_ = p8_ * _vₓₓₓ + _p8 * vₓₓₓ_ + 2 * get_coeffs_bez3_bez2_dd_abs($pk);
    const $pl = $p9 * $vᵧᵧᵧ;
    const pl = get_coeffs_bez3_bez2_dd_qmq(p9, vᵧᵧᵧ);
    const pl_ = p9_ * _vᵧᵧᵧ + _p9 * vᵧᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($pl);
    const $pm = $pa * $vₓₓᵧ;
    const pm = get_coeffs_bez3_bez2_dd_qmq(pa, vₓₓᵧ);
    const pm_ = pa_ * _vₓₓᵧ + _pa * vₓₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($pm);
    const $pn = $pb * $vₓᵧᵧ;
    const pn = get_coeffs_bez3_bez2_dd_qmq(pb, vₓᵧᵧ);
    const pn_ = pb_ * _vₓᵧᵧ + _pb * vₓᵧᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($pn);
    const $po = $pk + $pl;
    const po = get_coeffs_bez3_bez2_dd_qaq(pk, pl);
    const po_ = pk_ + pl_ + get_coeffs_bez3_bez2_dd_abs($po);
    const $pp = $pm + $pn;
    const pp = get_coeffs_bez3_bez2_dd_qaq(pm, pn);
    const pp_ = pm_ + pn_ + get_coeffs_bez3_bez2_dd_abs($pp);
    const $pq = $po + $pp;
    const pq = get_coeffs_bez3_bez2_dd_qaq(po, pp);
    const pq_ = po_ + pp_ + get_coeffs_bez3_bez2_dd_abs($pq);
    const $pr = $pg + $ph;
    const pr = get_coeffs_bez3_bez2_dd_qaq(pg, ph);
    const pr_ = pg_ + ph_ + get_coeffs_bez3_bez2_dd_abs($pr);
    const $ps = $pi + $pj;
    const ps = get_coeffs_bez3_bez2_dd_qaq(pi, pj);
    const ps_ = pi_ + pj_ + get_coeffs_bez3_bez2_dd_abs($ps);
    const $pt = $pq + $pr;
    const pt = get_coeffs_bez3_bez2_dd_qaq(pq, pr);
    const pt_ = pq_ + pr_ + get_coeffs_bez3_bez2_dd_abs($pt);
    const $v1 = $pt + $ps;
    const v1 = get_coeffs_bez3_bez2_dd_qaq(pt, ps);
    const v1_ = pt_ + ps_ + get_coeffs_bez3_bez2_dd_abs($v1);
    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + 
    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0
    //const v0 =
    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +
    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +
    //    c0d0*vₓᵧ +
    //    c0*vₓ +
    //    d0*vᵧ +
    //    v;
    const $pu = c0 * $vₓₓₓ;
    const pu = get_coeffs_bez3_bez2_dd_qmd(c0, vₓₓₓ);
    const pu_ = _c0 * vₓₓₓ_ + get_coeffs_bez3_bez2_dd_abs($pu);
    const $pv = c0 * $vₓᵧᵧ;
    const pv = get_coeffs_bez3_bez2_dd_qmd(c0, vₓᵧᵧ);
    const pv_ = _c0 * vₓᵧᵧ_ + get_coeffs_bez3_bez2_dd_abs($pv);
    const $pw = d0 * $vₓₓᵧ;
    const pw = get_coeffs_bez3_bez2_dd_qmd(d0, vₓₓᵧ);
    const pw_ = _d0 * vₓₓᵧ_ + get_coeffs_bez3_bez2_dd_abs($pw);
    const $px = d0 * $vᵧᵧᵧ;
    const px = get_coeffs_bez3_bez2_dd_qmd(d0, vᵧᵧᵧ);
    const px_ = _d0 * vᵧᵧᵧ_ + get_coeffs_bez3_bez2_dd_abs($px);
    const $py = $pu + $pw;
    const py = get_coeffs_bez3_bez2_dd_qaq(pu, pw);
    const py_ = pu_ + pw_ + get_coeffs_bez3_bez2_dd_abs($py);
    const $pz = $pv + $px;
    const pz = get_coeffs_bez3_bez2_dd_qaq(pv, px);
    const pz_ = pv_ + px_ + get_coeffs_bez3_bez2_dd_abs($pz);
    const $u1 = $py + $vₓₓ;
    const u1 = get_coeffs_bez3_bez2_dd_qaq(py, vₓₓ);
    const _u1 = get_coeffs_bez3_bez2_dd_abs($u1);
    const u1_ = py_ + vₓₓ_ + _u1;
    const $u2 = $pz + $vᵧᵧ;
    const u2 = get_coeffs_bez3_bez2_dd_qaq(pz, vᵧᵧ);
    const _u2 = get_coeffs_bez3_bez2_dd_abs($u2);
    const u2_ = pz_ + vᵧᵧ_ + _u2;
    const $u3 = $c0c0 * $u1;
    const u3 = get_coeffs_bez3_bez2_dd_qmq(c0c0, u1);
    const u3_ = _c0c0 * u1_ + 2 * get_coeffs_bez3_bez2_dd_abs($u3);
    const $u4 = $d0d0 * $u2;
    const u4 = get_coeffs_bez3_bez2_dd_qmq(d0d0, u2);
    const u4_ = _d0d0 * u2_ + 2 * get_coeffs_bez3_bez2_dd_abs($u4);
    const $u5 = $c0d0 * $vₓᵧ;
    const u5 = get_coeffs_bez3_bez2_dd_qmq(c0d0, vₓᵧ);
    const u5_ = _c0d0 * vₓᵧ_ + 2 * get_coeffs_bez3_bez2_dd_abs($u5);
    const $u6 = c0 * $vₓ;
    const u6 = get_coeffs_bez3_bez2_dd_qmd(c0, vₓ);
    const u6_ = _c0 * vₓ_ + get_coeffs_bez3_bez2_dd_abs($u6);
    const $u7 = d0 * $vᵧ;
    const u7 = get_coeffs_bez3_bez2_dd_qmd(d0, vᵧ);
    const u7_ = _d0 * vᵧ_ + get_coeffs_bez3_bez2_dd_abs($u7);
    const $u8 = $u3 + $u4;
    const u8 = get_coeffs_bez3_bez2_dd_qaq(u3, u4);
    const u8_ = u3_ + u4_ + get_coeffs_bez3_bez2_dd_abs($u8);
    const $u9 = $u8 + $u5;
    const u9 = get_coeffs_bez3_bez2_dd_qaq(u8, u5);
    const u9_ = u8_ + u5_ + get_coeffs_bez3_bez2_dd_abs($u9);
    const $ua = $u6 + $u7;
    const ua = get_coeffs_bez3_bez2_dd_qaq(u6, u7);
    const ua_ = u6_ + u7_ + get_coeffs_bez3_bez2_dd_abs($ua);
    const $ub = $u9 + $ua;
    const ub = get_coeffs_bez3_bez2_dd_qaq(u9, ua);
    const ub_ = u9_ + ua_ + get_coeffs_bez3_bez2_dd_abs($ub);
    const $v0 = $ub + $v;
    const v0 = get_coeffs_bez3_bez2_dd_qaq(ub, v);
    const v0_ = ub_ + v_ + get_coeffs_bez3_bez2_dd_abs($v0);
    return {
        coeffs: [v6, v5, v4, v3, v2, v1, v0],
        errBound: [get_coeffs_bez3_bez2_dd_3 * v6_, get_coeffs_bez3_bez2_dd_3 * v5_, get_coeffs_bez3_bez2_dd_3 * v4_, get_coeffs_bez3_bez2_dd_3 * v3_, get_coeffs_bez3_bez2_dd_3 * v2_, get_coeffs_bez3_bez2_dd_3 * v1_, get_coeffs_bez3_bez2_dd_3 * v0_]
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez1-bez3-dd.ts




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_bez1_bez3_dd_tp = (/* unused pure expression or super */ null && (twoProduct));
const get_coeffs_bez1_bez3_dd_qaq = node_ddAddDd;
const get_coeffs_bez1_bez3_dd_qmd = node_ddMultDouble2;
const get_coeffs_bez1_bez3_dd_qmq = node_ddMultDd;
const get_coeffs_bez1_bez3_dd_abs = Math.abs;
const get_coeffs_bez1_bez3_dd_3 = error_analysis_error_analysis_(3);
/**
 * Returns a polynomial in 1 variable (including coefficientwise error bound)
 * whose roots are the parameter values of the intersection points of an order
 * 1 and order 3 bezier curve (i.e. a line and a cubic bezier curve).
 *
 * The returned polynomial degree will be 3
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** none
 * * intermediate calculations are done in double-double precision and the
 * result is exact if the precondition is met
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez1Bez3Dd(ps1, ps2) {
    const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = getImplicitForm1DdWithRunningError(ps1);
    const { coeffs: [[c3, c2, c1, c0], [d3, d2, d1, d0]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free
     } = get_xy_dd_with_running_error_getXY3DdWithRunningError(ps2);
    const _vₓ = get_coeffs_bez1_bez3_dd_abs(vₓ[1]);
    const _vᵧ = get_coeffs_bez1_bez3_dd_abs(vᵧ[1]);
    // a3*v_x + b3*v_y
    //const v3 = c3*vₓ + d3*vᵧ;
    const p1 = get_coeffs_bez1_bez3_dd_qmq(c3, vₓ); // vₓ is error free
    const p1_ = c3_ * _vₓ + 2 * get_coeffs_bez1_bez3_dd_abs(p1[1]);
    const p2 = get_coeffs_bez1_bez3_dd_qmq(d3, vᵧ); // vᵧ is error free
    const p2_ = d3_ * _vᵧ + 2 * get_coeffs_bez1_bez3_dd_abs(p2[1]);
    const v3 = get_coeffs_bez1_bez3_dd_qaq(p1, p2);
    const v3_ = p1_ + p2_ + get_coeffs_bez1_bez3_dd_abs(v3[1]);
    // a2*v_x + b2*v_y
    //const v2 = c2*vₓ + d2*vᵧ;
    const p3 = get_coeffs_bez1_bez3_dd_qmq(c2, vₓ); // vₓ is error free
    const p3_ = c2_ * _vₓ + 2 * get_coeffs_bez1_bez3_dd_abs(p3[1]);
    const p4 = get_coeffs_bez1_bez3_dd_qmq(d2, vᵧ); // vᵧ is error free
    const p4_ = d2_ * _vᵧ + 2 * get_coeffs_bez1_bez3_dd_abs(p4[1]);
    const v2 = get_coeffs_bez1_bez3_dd_qaq(p3, p4);
    const v2_ = p3_ + p4_ + get_coeffs_bez1_bez3_dd_abs(v2[1]);
    // a1*v_x + b1*v_y
    //const v1 = c1*vₓ + d1*vᵧ;
    const p5 = get_coeffs_bez1_bez3_dd_qmq(c1, vₓ); // vₓ is error free
    const p5_ = c1_ * _vₓ + 2 * get_coeffs_bez1_bez3_dd_abs(p5[1]);
    const p6 = get_coeffs_bez1_bez3_dd_qmq(d1, vᵧ); // vᵧ is error free
    const p6_ = d1_ * _vᵧ + 2 * get_coeffs_bez1_bez3_dd_abs(p6[1]);
    const v1 = get_coeffs_bez1_bez3_dd_qaq(p5, p6);
    const v1_ = p5_ + p6_ + get_coeffs_bez1_bez3_dd_abs(v1[1]);
    // a0*v_x + b0*v_y + v_0
    //const v0 = c0*vₓ + d0*vᵧ + v;
    const p7 = get_coeffs_bez1_bez3_dd_qmd(c0, vₓ); // vₓ is error free
    const p7_ = get_coeffs_bez1_bez3_dd_abs(p7[1]);
    const p8 = get_coeffs_bez1_bez3_dd_qmd(d0, vᵧ); // vᵧ is error free
    const p8_ = get_coeffs_bez1_bez3_dd_abs(p8[1]);
    const p9 = get_coeffs_bez1_bez3_dd_qaq(p7, p8);
    const p9_ = p7_ + p8_ + get_coeffs_bez1_bez3_dd_abs(p9[1]);
    const v0 = get_coeffs_bez1_bez3_dd_qaq(p9, v);
    const v0_ = p9_ + v_ + get_coeffs_bez1_bez3_dd_abs(v0[1]);
    return {
        coeffs: [v3, v2, v1, v0],
        errBound: [get_coeffs_bez1_bez3_dd_3 * v3_, get_coeffs_bez1_bez3_dd_3 * v2_, get_coeffs_bez1_bez3_dd_3 * v1_, get_coeffs_bez1_bez3_dd_3 * v0_]
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez2-bez3-dd.ts




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_bez2_bez3_dd_tp = node_twoProduct;
const get_coeffs_bez2_bez3_dd_qm2 = node_ddMultBy2;
const get_coeffs_bez2_bez3_dd_qmd = node_ddMultDouble2;
const get_coeffs_bez2_bez3_dd_qmq = node_ddMultDd;
const get_coeffs_bez2_bez3_dd_qaq = node_ddAddDd;
const get_coeffs_bez2_bez3_dd_abs = Math.abs;
const get_coeffs_bez2_bez3_dd_3 = error_analysis_error_analysis_(3);
/**
 * Returns a polynomial in 1 variable (including coefficientwise error bound)
 * whose roots are the parameter values of the intersection points of an order
 * 2 and 3 bezier curve (i.e. a quadratic bezier curve and a cubic bezier curve).
 *
 * The returned polynomial degree will be 6
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** none
 * * intermediate calculations are done in double-double precision and this is
 * reflected in the output error bound (which is approximately
 * `n * (Number.EPSILON**2) * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned need **not** be scaled before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez2Bez3Dd(ps1, ps2) {
    const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = getImplicitForm2DdWithRunningError(ps1);
    const { coeffs: [[c3, c2, c1, c0], [d3, d2, d1, d0]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free
     } = get_xy_dd_with_running_error_getXY3DdWithRunningError(ps2);
    const $vₓₓ = vₓₓ[1];
    const $vₓᵧ = vₓᵧ[1];
    const $vᵧᵧ = vᵧᵧ[1];
    const $vₓ = vₓ[1];
    const $vᵧ = vᵧ[1];
    const $v = v[1];
    const _vₓₓ = get_coeffs_bez2_bez3_dd_abs($vₓₓ);
    const _vₓᵧ = get_coeffs_bez2_bez3_dd_abs($vₓᵧ);
    const _vᵧᵧ = get_coeffs_bez2_bez3_dd_abs($vᵧᵧ);
    const _vₓ = get_coeffs_bez2_bez3_dd_abs($vₓ);
    const _vᵧ = get_coeffs_bez2_bez3_dd_abs($vᵧ);
    const $c1 = c1[1];
    const $c2 = c2[1];
    const $c3 = c3[1];
    const $d1 = d1[1];
    const $d2 = d2[1];
    const $d3 = d3[1];
    const _c0 = get_coeffs_bez2_bez3_dd_abs(c0);
    const _c1 = get_coeffs_bez2_bez3_dd_abs($c1);
    const _c2 = get_coeffs_bez2_bez3_dd_abs($c2);
    const _c3 = get_coeffs_bez2_bez3_dd_abs($c3);
    const _d0 = get_coeffs_bez2_bez3_dd_abs(d0);
    const _d1 = get_coeffs_bez2_bez3_dd_abs($d1);
    const _d2 = get_coeffs_bez2_bez3_dd_abs($d2);
    const _d3 = get_coeffs_bez2_bez3_dd_abs($d3);
    const $c0c0 = c0 * c0;
    const $c0c1 = c0 * $c1;
    const $c0c2 = c0 * $c2;
    const $c0c3 = c0 * $c3;
    const $c0d0 = c0 * d0;
    const $c0d1 = c0 * $d1;
    const $c0d2 = c0 * $d2;
    const $c0d3 = c0 * $d3;
    const $c1c1 = $c1 * $c1;
    const $c1c2 = $c1 * $c2;
    const $c1c3 = $c1 * $c3;
    const $c1d0 = $c1 * d0;
    const $c1d1 = $c1 * $d1;
    const $c1d2 = $c1 * $d2;
    const $c1d3 = $c1 * $d3;
    const $c2d1 = $c2 * $d1;
    const $c2c2 = $c2 * $c2;
    const $c2c3 = $c2 * $c3;
    const $c2d0 = $c2 * d0;
    const $c2d2 = $c2 * $d2;
    const $c2d3 = $c2 * $d3;
    const $c3c3 = $c3 * $c3;
    const $c3d0 = $c3 * d0;
    const $c3d1 = $c3 * $d1;
    const $c3d2 = $c3 * $d2;
    const $c3d3 = $c3 * $d3;
    const $d0d0 = d0 * d0;
    const $d0d1 = d0 * $d1;
    const $d0d2 = d0 * $d2;
    const $d0d3 = d0 * $d3;
    const $d1d1 = $d1 * $d1;
    const $d1d2 = $d1 * $d2;
    const $d3d3 = $d3 * $d3;
    const $d2d2 = $d2 * $d2;
    const $d2d3 = $d2 * $d3;
    const $d1d3 = $d1 * $d3;
    const c0c0 = get_coeffs_bez2_bez3_dd_tp(c0, c0); // error free
    const _c0c0 = get_coeffs_bez2_bez3_dd_abs($c0c0);
    const c0c1 = get_coeffs_bez2_bez3_dd_qmd(c0, c1);
    const _c0c1 = get_coeffs_bez2_bez3_dd_abs($c0c1);
    const c0c1_ = _c0 * c1_ + _c0c1;
    const c0c2 = get_coeffs_bez2_bez3_dd_qmd(c0, c2);
    const c0c2_ = _c0 * c2_ + get_coeffs_bez2_bez3_dd_abs($c0c2);
    const c0c3 = get_coeffs_bez2_bez3_dd_qmd(c0, c3);
    const c0c3_ = _c0 * c3_ + get_coeffs_bez2_bez3_dd_abs($c0c3);
    const c0d0 = get_coeffs_bez2_bez3_dd_tp(c0, d0); // error free
    const _c0d0 = get_coeffs_bez2_bez3_dd_abs($c0d0);
    const c0d1 = get_coeffs_bez2_bez3_dd_qmd(c0, d1);
    const c0d1_ = _c0 * d1_ + get_coeffs_bez2_bez3_dd_abs($c0d1);
    const c0d2 = get_coeffs_bez2_bez3_dd_qmd(c0, d2);
    const c0d2_ = _c0 * d2_ + get_coeffs_bez2_bez3_dd_abs($c0d2);
    const c0d3 = get_coeffs_bez2_bez3_dd_qmd(c0, d3);
    const c0d3_ = _c0 * d3_ + get_coeffs_bez2_bez3_dd_abs($c0d3);
    const c1c1 = get_coeffs_bez2_bez3_dd_qmq(c1, c1);
    const c1c1_ = c1_ * _c1 + _c1 * c1_ + 2 * get_coeffs_bez2_bez3_dd_abs($c1c1);
    const c1c2 = get_coeffs_bez2_bez3_dd_qmq(c1, c2);
    const c1c2_ = c1_ * _c2 + _c1 * c2_ + 2 * get_coeffs_bez2_bez3_dd_abs($c1c2);
    const c1c3 = get_coeffs_bez2_bez3_dd_qmq(c1, c3);
    const c1c3_ = c1_ * _c3 + _c1 * c3_ + 2 * get_coeffs_bez2_bez3_dd_abs($c1c3);
    const c1d0 = get_coeffs_bez2_bez3_dd_qmd(d0, c1);
    const c1d0_ = _d0 * c1_ + get_coeffs_bez2_bez3_dd_abs($c1d0);
    const c1d1 = get_coeffs_bez2_bez3_dd_qmq(c1, d1);
    const c1d1_ = c1_ * _d1 + _c1 * d1_ + 2 * get_coeffs_bez2_bez3_dd_abs($c1d1);
    const c1d2 = get_coeffs_bez2_bez3_dd_qmq(c1, d2);
    const c1d2_ = c1_ * _d2 + _c1 * d2_ + 2 * get_coeffs_bez2_bez3_dd_abs($c1d2);
    const c1d3 = get_coeffs_bez2_bez3_dd_qmq(c1, d3);
    const c1d3_ = c1_ * _d3 + _c1 * d3_ + 2 * get_coeffs_bez2_bez3_dd_abs($c1d3);
    const c2d1 = get_coeffs_bez2_bez3_dd_qmq(c2, d1);
    const c2d1_ = c2_ * _d1 + _c2 * d1_ + 2 * get_coeffs_bez2_bez3_dd_abs($c2d1);
    const c2c2 = get_coeffs_bez2_bez3_dd_qmq(c2, c2);
    const c2c2_ = c2_ * _c2 + _c2 * c2_ + 2 * get_coeffs_bez2_bez3_dd_abs($c2c2);
    const c2c3 = get_coeffs_bez2_bez3_dd_qmq(c2, c3);
    const _c2c3 = get_coeffs_bez2_bez3_dd_abs($c2c3);
    const c2c3_ = c2_ * _c3 + _c2 * c3_ + 2 * _c2c3;
    const c2d0 = get_coeffs_bez2_bez3_dd_qmd(d0, c2);
    const c2d0_ = _d0 * c2_ + get_coeffs_bez2_bez3_dd_abs($c2d0);
    const c2d2 = get_coeffs_bez2_bez3_dd_qmq(c2, d2);
    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * get_coeffs_bez2_bez3_dd_abs($c2d2);
    const c2d3 = get_coeffs_bez2_bez3_dd_qmq(c2, d3);
    const c2d3_ = c2_ * _d3 + _c2 * d3_ + 2 * get_coeffs_bez2_bez3_dd_abs($c2d3);
    const c3c3 = get_coeffs_bez2_bez3_dd_qmq(c3, c3);
    const _c3c3 = get_coeffs_bez2_bez3_dd_abs($c3c3);
    const c3c3_ = c3_ * _c3 + _c3 * c3_ + 2 * _c3c3;
    const c3d0 = get_coeffs_bez2_bez3_dd_qmd(d0, c3);
    const c3d0_ = _d0 * c3_ + get_coeffs_bez2_bez3_dd_abs($c3d0);
    const c3d1 = get_coeffs_bez2_bez3_dd_qmq(c3, d1);
    const c3d1_ = c3_ * _d1 + _c3 * d1_ + 2 * get_coeffs_bez2_bez3_dd_abs($c3d1);
    const c3d2 = get_coeffs_bez2_bez3_dd_qmq(c3, d2);
    const c3d2_ = c3_ * _d2 + _c3 * d2_ + 2 * get_coeffs_bez2_bez3_dd_abs($c3d2);
    const c3d3 = get_coeffs_bez2_bez3_dd_qmq(c3, d3);
    const _c3d3 = get_coeffs_bez2_bez3_dd_abs($c3d3);
    const c3d3_ = c3_ * _d3 + _c3 * d3_ + 2 * _c3d3;
    const d0d0 = get_coeffs_bez2_bez3_dd_tp(d0, d0); // error free
    const _d0d0 = get_coeffs_bez2_bez3_dd_abs($d0d0);
    const d0d1 = get_coeffs_bez2_bez3_dd_qmd(d0, d1);
    const _d0d1 = get_coeffs_bez2_bez3_dd_abs($d0d1);
    const d0d1_ = _d0 * d1_ + _d0d1;
    const d0d2 = get_coeffs_bez2_bez3_dd_qmd(d0, d2);
    const d0d2_ = _d0 * d2_ + get_coeffs_bez2_bez3_dd_abs($d0d2);
    const d0d3 = get_coeffs_bez2_bez3_dd_qmd(d0, d3);
    const d0d3_ = _d0 * d3_ + get_coeffs_bez2_bez3_dd_abs($d0d3);
    const d1d1 = get_coeffs_bez2_bez3_dd_qmq(d1, d1);
    const d1d1_ = d1_ * _d1 + _d1 * d1_ + 2 * get_coeffs_bez2_bez3_dd_abs($d1d1);
    const d1d2 = get_coeffs_bez2_bez3_dd_qmq(d1, d2);
    const d1d2_ = d1_ * _d2 + _d1 * d2_ + 2 * get_coeffs_bez2_bez3_dd_abs($d1d2);
    const d3d3 = get_coeffs_bez2_bez3_dd_qmq(d3, d3);
    const _d3d3 = get_coeffs_bez2_bez3_dd_abs($d3d3);
    const d3d3_ = d3_ * _d3 + _d3 * d3_ + 2 * _d3d3;
    const d2d2 = get_coeffs_bez2_bez3_dd_qmq(d2, d2);
    const d2d2_ = d2_ * _d2 + _d2 * d2_ + 2 * get_coeffs_bez2_bez3_dd_abs($d2d2);
    const d2d3 = get_coeffs_bez2_bez3_dd_qmq(d2, d3);
    const _d2d3 = get_coeffs_bez2_bez3_dd_abs($d2d3);
    const d2d3_ = d2_ * _d3 + _d2 * d3_ + 2 * _d2d3;
    const d1d3 = get_coeffs_bez2_bez3_dd_qmq(d1, d3);
    const d1d3_ = d1_ * _d3 + _d1 * d3_ + 2 * get_coeffs_bez2_bez3_dd_abs($d1d3);
    // a3**2*vₓₓ + a3*b3*vₓᵧ + b3**2*vᵧᵧ
    //const v6 =
    //    c3c3*vₓₓ +
    //    c3d3*vₓᵧ +
    //    d3d3*vᵧᵧ;
    const $p1 = $c3c3 * $vₓₓ;
    const p1 = get_coeffs_bez2_bez3_dd_qmq(c3c3, vₓₓ);
    const p1_ = c3c3_ * _vₓₓ + _c3c3 * vₓₓ_ + 2 * get_coeffs_bez2_bez3_dd_abs($p1);
    const $p2 = $c3d3 * $vₓᵧ;
    const p2 = get_coeffs_bez2_bez3_dd_qmq(c3d3, vₓᵧ);
    const p2_ = c3d3_ * _vₓᵧ + _c3d3 * vₓᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($p2);
    const $p3 = $d3d3 * $vᵧᵧ;
    const p3 = get_coeffs_bez2_bez3_dd_qmq(d3d3, vᵧᵧ);
    const p3_ = d3d3_ * _vᵧᵧ + _d3d3 * vᵧᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($p3);
    const $p4 = $p1 + $p2;
    const p4 = get_coeffs_bez2_bez3_dd_qaq(p1, p2);
    const p4_ = p1_ + p2_ + get_coeffs_bez2_bez3_dd_abs($p4);
    const $v6 = $p4 + $p3;
    const v6 = get_coeffs_bez2_bez3_dd_qaq(p4, p3);
    const v6_ = p4_ + p3_ + get_coeffs_bez2_bez3_dd_abs($v6);
    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ
    //const v5 =
    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +
    //    vₓᵧ*(c2d3 + c3d2);
    const $p5 = $c2c3 * $vₓₓ;
    const p5 = get_coeffs_bez2_bez3_dd_qmq(c2c3, vₓₓ);
    const p5_ = c2c3_ * _vₓₓ + _c2c3 * vₓₓ_ + 2 * get_coeffs_bez2_bez3_dd_abs($p5);
    const $p6 = $d2d3 * $vᵧᵧ;
    const p6 = get_coeffs_bez2_bez3_dd_qmq(d2d3, vᵧᵧ);
    const p6_ = d2d3_ * _vᵧᵧ + _d2d3 * vᵧᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($p6);
    const $p7 = $p5 + $p6;
    const p7 = get_coeffs_bez2_bez3_dd_qaq(p5, p6);
    const p7_ = p5_ + p6_ + get_coeffs_bez2_bez3_dd_abs($p7);
    const $p8 = $c2d3 + $c3d2;
    const p8 = get_coeffs_bez2_bez3_dd_qaq(c2d3, c3d2);
    const _p8 = get_coeffs_bez2_bez3_dd_abs($p8);
    const p8_ = c2d3_ + c3d2_ + _p8;
    const $p9 = $p8 * $vₓᵧ;
    const p9 = get_coeffs_bez2_bez3_dd_qmq(p8, vₓᵧ);
    const p9_ = p8_ * _vₓᵧ + _p8 * vₓᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($p9);
    const $v5 = 2 * $p7 + $p9;
    const v5 = get_coeffs_bez2_bez3_dd_qaq(get_coeffs_bez2_bez3_dd_qm2(p7), p9);
    const v5_ = 2 * p7_ + p9_ + get_coeffs_bez2_bez3_dd_abs($v5);
    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ
    //const v4 =
    //    (2*c1c3 + c2c2)*vₓₓ +
    //    (2*d1d3 + d2d2)*vᵧᵧ +
    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;
    const $pa = 2 * $c1c3 + $c2c2;
    const pa = get_coeffs_bez2_bez3_dd_qaq(get_coeffs_bez2_bez3_dd_qm2(c1c3), c2c2);
    const _pa = get_coeffs_bez2_bez3_dd_abs($pa);
    const pa_ = 2 * c1c3_ + c2c2_ + get_coeffs_bez2_bez3_dd_abs($pa);
    const $pb = 2 * $d1d3 + $d2d2;
    const pb = get_coeffs_bez2_bez3_dd_qaq(get_coeffs_bez2_bez3_dd_qm2(d1d3), d2d2);
    const _pb = get_coeffs_bez2_bez3_dd_abs($pb);
    const pb_ = 2 * d1d3_ + d2d2_ + get_coeffs_bez2_bez3_dd_abs($pb);
    const $pc = $c1d3 + $c2d2;
    const pc = get_coeffs_bez2_bez3_dd_qaq(c1d3, c2d2);
    const pc_ = c1d3_ + c2d2_ + get_coeffs_bez2_bez3_dd_abs($pc);
    const $pd = $pc + $c3d1;
    const pd = get_coeffs_bez2_bez3_dd_qaq(pc, c3d1);
    const _pd = get_coeffs_bez2_bez3_dd_abs($pd);
    const pd_ = pc_ + c3d1_ + _pd;
    const $pe = $pa * $vₓₓ;
    const pe = get_coeffs_bez2_bez3_dd_qmq(pa, vₓₓ);
    const pe_ = pa_ * _vₓₓ + _pa * vₓₓ_ + 2 * get_coeffs_bez2_bez3_dd_abs($pe);
    const $pf = $pb * $vᵧᵧ;
    const pf = get_coeffs_bez2_bez3_dd_qmq(pb, vᵧᵧ);
    const pf_ = pb_ * _vᵧᵧ + _pb * vᵧᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($pf);
    const $pg = $pe + $pf;
    const pg = get_coeffs_bez2_bez3_dd_qaq(pe, pf);
    const pg_ = pe_ + pf_ + get_coeffs_bez2_bez3_dd_abs($pg);
    const $rp = $pd * $vₓᵧ;
    const rp = get_coeffs_bez2_bez3_dd_qmq(pd, vₓᵧ);
    const rp_ = pd_ * _vₓᵧ + _pd * vₓᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($rp);
    const $v4 = $pg + $rp;
    const v4 = get_coeffs_bez2_bez3_dd_qaq(pg, rp);
    const v4_ = pg_ + rp_ + get_coeffs_bez2_bez3_dd_abs($v4);
    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + 
    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + 
    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y
    //const v3 =
    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +
    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +
    //    c3*vₓ +
    //    d3*vᵧ;
    const $ph = $c0c3 + $c1c2;
    const ph = get_coeffs_bez2_bez3_dd_qaq(c0c3, c1c2);
    const _ph = get_coeffs_bez2_bez3_dd_abs($ph);
    const ph_ = c0c3_ + c1c2_ + _ph;
    const $pi = $d0d3 + $d1d2;
    const pi = get_coeffs_bez2_bez3_dd_qaq(d0d3, d1d2);
    const _pi = get_coeffs_bez2_bez3_dd_abs($pi);
    const pi_ = d0d3_ + d1d2_ + _pi;
    const $pj = $c0d3 + $c1d2;
    const pj = get_coeffs_bez2_bez3_dd_qaq(c0d3, c1d2);
    const pj_ = c0d3_ + c1d2_ + get_coeffs_bez2_bez3_dd_abs($pj);
    const $pk = $c2d1 + $c3d0;
    const pk = get_coeffs_bez2_bez3_dd_qaq(c2d1, c3d0);
    const pk_ = c2d1_ + c3d0_ + get_coeffs_bez2_bez3_dd_abs($pk);
    const $pl = $pj + $pk;
    const pl = get_coeffs_bez2_bez3_dd_qaq(pj, pk);
    const _pl = get_coeffs_bez2_bez3_dd_abs($pl);
    const pl_ = pj_ + pk_ + _pl;
    const $pm = $ph * $vₓₓ;
    const pm = get_coeffs_bez2_bez3_dd_qmq(ph, vₓₓ);
    const pm_ = ph_ * _vₓₓ + _ph * vₓₓ_ + 2 * get_coeffs_bez2_bez3_dd_abs($pm);
    const $pn = $pi * $vᵧᵧ;
    const pn = get_coeffs_bez2_bez3_dd_qmq(pi, vᵧᵧ);
    const pn_ = pi_ * _vᵧᵧ + _pi * vᵧᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($pn);
    const $po = 2 * ($pm + $pn);
    const po = get_coeffs_bez2_bez3_dd_qm2(get_coeffs_bez2_bez3_dd_qaq(pm, pn));
    const po_ = 2 * (pm_ + pn_) + get_coeffs_bez2_bez3_dd_abs($po);
    const $pp = $pl * $vₓᵧ;
    const pp = get_coeffs_bez2_bez3_dd_qmq(pl, vₓᵧ);
    const pp_ = pl_ * _vₓᵧ + _pl * vₓᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($pp);
    const $rn = $c3 * $vₓ;
    const rn = get_coeffs_bez2_bez3_dd_qmq(c3, vₓ);
    const rn_ = c3_ * _vₓ + _c3 * vₓ_ + 2 * get_coeffs_bez2_bez3_dd_abs($rn);
    const $ro = $d3 * $vᵧ;
    const ro = get_coeffs_bez2_bez3_dd_qmq(d3, vᵧ);
    const ro_ = d3_ * _vᵧ + _d3 * vᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($ro);
    const $pq = $rn + $ro;
    const pq = get_coeffs_bez2_bez3_dd_qaq(rn, ro);
    const pq_ = rn_ + ro_ + get_coeffs_bez2_bez3_dd_abs($pq);
    const $pr = $po + $pp;
    const pr = get_coeffs_bez2_bez3_dd_qaq(po, pp);
    const pr_ = po_ + pp_ + get_coeffs_bez2_bez3_dd_abs($pr);
    const $v3 = $pr + $pq;
    const v3 = get_coeffs_bez2_bez3_dd_qaq(pr, pq);
    const v3_ = pr_ + pq_ + get_coeffs_bez2_bez3_dd_abs($v3);
    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + 
    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + 
    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y
    //const v2 =
    //    (2*c0c2 + c1c1)*vₓₓ +
    //    (2*d0d2 + d1d1)*vᵧᵧ +
    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +
    //    c2*vₓ +
    //    d2*vᵧ;
    const $ps = 2 * $c0c2 + $c1c1;
    const ps = get_coeffs_bez2_bez3_dd_qaq(get_coeffs_bez2_bez3_dd_qm2(c0c2), c1c1);
    const _ps = get_coeffs_bez2_bez3_dd_abs($ps);
    const ps_ = 2 * c0c2_ + c1c1_ + _ps;
    const $pt = 2 * $d0d2 + $d1d1;
    const pt = get_coeffs_bez2_bez3_dd_qaq(get_coeffs_bez2_bez3_dd_qm2(d0d2), d1d1);
    const _pt = get_coeffs_bez2_bez3_dd_abs($pt);
    const pt_ = 2 * d0d2_ + d1d1_ + _pt;
    const $pu = $c0d2 + $c1d1;
    const pu = get_coeffs_bez2_bez3_dd_qaq(c0d2, c1d1);
    const pu_ = c0d2_ + c1d1_ + get_coeffs_bez2_bez3_dd_abs($pu);
    const $pv = $pu + $c2d0;
    const pv = get_coeffs_bez2_bez3_dd_qaq(pu, c2d0);
    const _pv = get_coeffs_bez2_bez3_dd_abs($pv);
    const pv_ = pu_ + c2d0_ + _pv;
    const $pw = $ps * $vₓₓ;
    const pw = get_coeffs_bez2_bez3_dd_qmq(ps, vₓₓ);
    const pw_ = ps_ * _vₓₓ + _ps * vₓₓ_ + 2 * get_coeffs_bez2_bez3_dd_abs($pw);
    const $px = $pt * $vᵧᵧ;
    const px = get_coeffs_bez2_bez3_dd_qmq(pt, vᵧᵧ);
    const px_ = pt_ * _vᵧᵧ + _pt * vᵧᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($px);
    const $py = $pv * $vₓᵧ;
    const py = get_coeffs_bez2_bez3_dd_qmq(pv, vₓᵧ);
    const py_ = pv_ * _vₓᵧ + _pv * vₓᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($py);
    const $pz = $pw + $px;
    const pz = get_coeffs_bez2_bez3_dd_qaq(pw, px);
    const pz_ = pw_ + px_ + get_coeffs_bez2_bez3_dd_abs($pz);
    const $r1 = $pz + $py;
    const r1 = get_coeffs_bez2_bez3_dd_qaq(pz, py);
    const r1_ = pz_ + py_ + get_coeffs_bez2_bez3_dd_abs($r1);
    const $r2 = $c2 * $vₓ;
    const r2 = get_coeffs_bez2_bez3_dd_qmq(c2, vₓ);
    const r2_ = c2_ * _vₓ + _c2 * vₓ_ + 2 * get_coeffs_bez2_bez3_dd_abs($r2);
    const $r3 = $d2 * $vᵧ;
    const r3 = get_coeffs_bez2_bez3_dd_qmq(d2, vᵧ);
    const r3_ = d2_ * _vᵧ + _d2 * vᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($r3);
    const $r4 = $r2 + $r3;
    const r4 = get_coeffs_bez2_bez3_dd_qaq(r2, r3);
    const r4_ = r2_ + r3_ + get_coeffs_bez2_bez3_dd_abs($r4);
    const $v2 = $r1 + $r4;
    const v2 = get_coeffs_bez2_bez3_dd_qaq(r1, r4);
    const v2_ = r1_ + r4_ + get_coeffs_bez2_bez3_dd_abs($v2);
    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y
    //const v1 =
    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +
    //    (c0d1 + c1d0)*vₓᵧ +
    //    c1*vₓ +
    //    d1*vᵧ;
    const $r5 = $c0c1 * $vₓₓ;
    const r5 = get_coeffs_bez2_bez3_dd_qmq(c0c1, vₓₓ);
    const r5_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * get_coeffs_bez2_bez3_dd_abs($r5);
    const $r6 = $d0d1 * $vᵧᵧ;
    const r6 = get_coeffs_bez2_bez3_dd_qmq(d0d1, vᵧᵧ);
    const r6_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($r6);
    const $r7 = $c0d1 + $c1d0;
    const r7 = get_coeffs_bez2_bez3_dd_qaq(c0d1, c1d0);
    const _r7 = get_coeffs_bez2_bez3_dd_abs($r7);
    const r7_ = c0d1_ + c1d0_ + _r7;
    const $r8 = $r7 * $vₓᵧ;
    const r8 = get_coeffs_bez2_bez3_dd_qmq(r7, vₓᵧ);
    const r8_ = r7_ * _vₓᵧ + _r7 * vₓᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($r8);
    const $r9 = 2 * ($r5 + $r6);
    const r9 = get_coeffs_bez2_bez3_dd_qm2(get_coeffs_bez2_bez3_dd_qaq(r5, r6));
    const r9_ = 2 * (r5_ + r6_) + get_coeffs_bez2_bez3_dd_abs($r9);
    const $ra = $r9 + $r8;
    const ra = get_coeffs_bez2_bez3_dd_qaq(r9, r8);
    const ra_ = r9_ + r8_ + get_coeffs_bez2_bez3_dd_abs($ra);
    const $rb = $c1 * $vₓ;
    const rb = get_coeffs_bez2_bez3_dd_qmq(c1, vₓ);
    const rb_ = c1_ * _vₓ + _c1 * vₓ_ + 2 * get_coeffs_bez2_bez3_dd_abs($rb);
    const $rc = $d1 * $vᵧ;
    const rc = get_coeffs_bez2_bez3_dd_qmq(d1, vᵧ);
    const rc_ = d1_ * _vᵧ + _d1 * vᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($rc);
    const $rd = $rb + $rc;
    const rd = get_coeffs_bez2_bez3_dd_qaq(rb, rc);
    const rd_ = rb_ + rc_ + get_coeffs_bez2_bez3_dd_abs($rd);
    const $v1 = $ra + $rd;
    const v1 = get_coeffs_bez2_bez3_dd_qaq(ra, rd);
    const v1_ = ra_ + rd_ + get_coeffs_bez2_bez3_dd_abs($v1);
    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0
    //const v0 =
    //    c0c0*vₓₓ +
    //    c0d0*vₓᵧ +
    //    d0d0*vᵧᵧ +
    //    c0*vₓ +
    //    d0*vᵧ +
    //    v;
    const $re = $c0c0 * $vₓₓ;
    const re = get_coeffs_bez2_bez3_dd_qmq(c0c0, vₓₓ);
    const re_ = _c0c0 * vₓₓ_ + 2 * get_coeffs_bez2_bez3_dd_abs($re);
    const $rf = $c0d0 * $vₓᵧ;
    const rf = get_coeffs_bez2_bez3_dd_qmq(c0d0, vₓᵧ);
    const rf_ = _c0d0 * vₓᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($rf);
    const $rg = $d0d0 * $vᵧᵧ;
    const rg = get_coeffs_bez2_bez3_dd_qmq(d0d0, vᵧᵧ);
    const rg_ = _d0d0 * vᵧᵧ_ + 2 * get_coeffs_bez2_bez3_dd_abs($rg);
    const $rh = c0 * $vₓ;
    const rh = get_coeffs_bez2_bez3_dd_qmd(c0, vₓ);
    const rh_ = _c0 * vₓ_ + get_coeffs_bez2_bez3_dd_abs($rh);
    const $ri = d0 * $vᵧ;
    const ri = get_coeffs_bez2_bez3_dd_qmd(d0, vᵧ);
    const ri_ = _d0 * vᵧ_ + get_coeffs_bez2_bez3_dd_abs($ri);
    const $rj = $re + $rf;
    const rj = get_coeffs_bez2_bez3_dd_qaq(re, rf);
    const rj_ = re_ + rf_ + get_coeffs_bez2_bez3_dd_abs($rj);
    const $rk = $rj + $rg;
    const rk = get_coeffs_bez2_bez3_dd_qaq(rj, rg);
    const rk_ = rj_ + rg_ + get_coeffs_bez2_bez3_dd_abs($rk);
    const $rl = $rh + $ri;
    const rl = get_coeffs_bez2_bez3_dd_qaq(rh, ri);
    const rl_ = rh_ + ri_ + get_coeffs_bez2_bez3_dd_abs($rl);
    const $rm = $rk + $rl;
    const rm = get_coeffs_bez2_bez3_dd_qaq(rk, rl);
    const rm_ = rk_ + rl_ + get_coeffs_bez2_bez3_dd_abs($rm);
    const $v0 = $rm + $v;
    const v0 = get_coeffs_bez2_bez3_dd_qaq(rm, v);
    const v0_ = rm_ + v_ + get_coeffs_bez2_bez3_dd_abs($v0);
    return {
        coeffs: [v6, v5, v4, v3, v2, v1, v0],
        errBound: [get_coeffs_bez2_bez3_dd_3 * v6_, get_coeffs_bez2_bez3_dd_3 * v5_, get_coeffs_bez2_bez3_dd_3 * v4_, get_coeffs_bez2_bez3_dd_3 * v3_, get_coeffs_bez2_bez3_dd_3 * v2_, get_coeffs_bez2_bez3_dd_3 * v1_, get_coeffs_bez2_bez3_dd_3 * v0_]
    };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/double-double/get-coeffs-bez3-bez3-dd.ts




// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_bez3_bez3_dd_tp = node_twoProduct;
const get_coeffs_bez3_bez3_dd_qm2 = node_ddMultBy2;
const get_coeffs_bez3_bez3_dd_qmd = node_ddMultDouble2;
const get_coeffs_bez3_bez3_dd_qmq = node_ddMultDd;
const get_coeffs_bez3_bez3_dd_qaq = node_ddAddDd;
const get_coeffs_bez3_bez3_dd_abs = Math.abs;
const get_coeffs_bez3_bez3_dd_3 = error_analysis_error_analysis_(3);
/**
 * Returns a polynomial in 1 variable (including coefficientwise error bound)
 * whose roots are the parameter values of the intersection points of 2 order
 * 3 bezier curves (i.e. 2 cubic bezier curves).
 *
 * The returned polynomial degree will be 9
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** TODO
 * * intermediate calculations are done in double-double precision and this is
 * reflected in the output error bound (which is approximately
 * `n * (Number.EPSILON**2) * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned need **not** be scaled before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc
 */
function getCoeffsBez3Bez3Dd(ps1, ps2) {
    //--------------------------------------------------------------------------
    // `var` -> a variable
    // `$var` -> the double precision approximation to `var`
    // `_var` -> the absolute value of $var (a prefix underscore on a variable means absolute value)
    // `var_` -> the error in var (a postfix underscore means error bound but should still be multiplied by 3*γ²)
    // `_var_` -> means both absolute value and absolute error bound
    // recall: `a*b`, where both `a` and `b` have errors |a| and |b| we get for the
    //   * error bound of (a*b) === a_|b| + |a|b_ + |a*b|   (when either of a and b is double)
    //   * error bound of (a*b) === a_|b| + |a|b_ + 2|a*b|  (when both a and b is double-double)
    //   * error bound of (a+b) === a_ + b_ + |a+b|         (when a and/or b is double or double-double)
    // * the returned errors need to be multiplied by 3γ² to get the true error
    // * can use either `$var` or `var[var.length-1]` (the approx value) in error calculations
    //   due to multiplication by 3*γ² and not 3*u²
    //--------------------------------------------------------------------------
    // examples: (all?)
    // ----------------
    // let qmd === ddMultDouble2, etc.
    //
    // ---------------
    // 1. double-double X by double
    // ---------------
    // qmd(a,b);  // both `a` and `b` is error-free
    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)
    //                           === 0|b| + |a|0 + |a*b|
    //                           === |a*b|
    //
    // ---------------
    // 2a. double-double +/- double-double
    // ---------------
    // qdq(a,b);  // error in a === |a|, thus call the error _a_, same with b
    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)
    //                           === _a_ + _b_ + |a+b|
    //
    // ---------------
    // 2b. double-double +/- double-double
    // ---------------
    // qaq(a,b);  // error in a === 2|a|, thus the error is 2*_a, same with b
    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)
    //                           === 2*_a + 2*_b + |a+b|
    //                           === 2*(_a + _b) + |a+b| OR
    //                           === a_ + b_ + |a+b|
    //
    // ---------------
    // 3a. double-double X double-double
    // ---------------
    // qmq(a,b);  // both `a` and `b` error-free
    // use: error bound of (a*b) === a_|b| + |a|b_ + |a*b| (by definition)
    //                           === 0|b| + |a|0 + 2|a*b|
    //                           === 2|a*b| 
    //
    // ---------------
    // 3b. double-double X double-double
    // ---------------
    // qmq(a,b);  // both `a` and `b` not error-free
    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)
    //
    // ---------------
    // 3b. double-double X double-double
    // ---------------
    // qmq(a,b);  // both `a` not error-free and `b` error-free
    // use: error bound of (a*b) === a_|b| + |a|b_ + 2|a*b| (by definition)
    //                           === a_|b| + 2|a*b| 
    //
    // ---------------
    // 4a. double-double +/- double
    // ---------------
    // qad(a,b);  // both `a` and `b` error-free
    // use: error bound of (a+b) === a_ + b_ + |a+b| (by definition)
    //                           === 0 + 0 + |a+b|
    //                           === |a+b| 
    //--------------------------------------------------------------------------
    const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = getImplicitForm3DdWithRunningError(ps1);
    const { coeffs: [[c3, c2, c1, c0], [d3, d2, d1, d0]], errorBound: [[c3_, c2_, c1_], [d3_, d2_, d1_]] // c0 and d0 is error free
     } = get_xy_dd_with_running_error_getXY3DdWithRunningError(ps2);
    const $vₓₓₓ = vₓₓₓ[1];
    const $vₓₓᵧ = vₓₓᵧ[1];
    const $vₓᵧᵧ = vₓᵧᵧ[1];
    const $vᵧᵧᵧ = vᵧᵧᵧ[1];
    const $vₓₓ = vₓₓ[1];
    const $vₓᵧ = vₓᵧ[1];
    const $vᵧᵧ = vᵧᵧ[1];
    const $vₓ = vₓ[1];
    const $vᵧ = vᵧ[1];
    const $v = v[1];
    const _vₓₓₓ = get_coeffs_bez3_bez3_dd_abs($vₓₓₓ);
    const _vₓₓᵧ = get_coeffs_bez3_bez3_dd_abs($vₓₓᵧ);
    const _vₓᵧᵧ = get_coeffs_bez3_bez3_dd_abs($vₓᵧᵧ);
    const _vᵧᵧᵧ = get_coeffs_bez3_bez3_dd_abs($vᵧᵧᵧ);
    const _vₓₓ = get_coeffs_bez3_bez3_dd_abs($vₓₓ);
    const _vₓᵧ = get_coeffs_bez3_bez3_dd_abs($vₓᵧ);
    const _vᵧᵧ = get_coeffs_bez3_bez3_dd_abs($vᵧᵧ);
    const _vₓ = get_coeffs_bez3_bez3_dd_abs($vₓ);
    const _vᵧ = get_coeffs_bez3_bez3_dd_abs($vᵧ);
    const _v = get_coeffs_bez3_bez3_dd_abs($v);
    const $c1 = c1[1];
    const $c2 = c2[1];
    const $c3 = c3[1];
    const $d1 = d1[1];
    const $d2 = d2[1];
    const $d3 = d3[1];
    const _c0 = get_coeffs_bez3_bez3_dd_abs(c0);
    const _c1 = get_coeffs_bez3_bez3_dd_abs($c1);
    const _c2 = get_coeffs_bez3_bez3_dd_abs($c2);
    const _c3 = get_coeffs_bez3_bez3_dd_abs($c3);
    const _d0 = get_coeffs_bez3_bez3_dd_abs(d0);
    const _d1 = get_coeffs_bez3_bez3_dd_abs($d1);
    const _d2 = get_coeffs_bez3_bez3_dd_abs($d2);
    const _d3 = get_coeffs_bez3_bez3_dd_abs($d3);
    const $c0c0 = c0 * c0;
    const $c0c1 = c0 * $c1;
    const $c0c2 = c0 * $c2;
    const $c0c3 = c0 * $c3;
    const $c0d0 = c0 * d0;
    const $c0d1 = c0 * $d1;
    const $c0d2 = c0 * $d2;
    const $c0d3 = c0 * $d3;
    const $c1c1 = $c1 * $c1;
    const $c1c2 = $c1 * $c2;
    const $c1c3 = $c1 * $c3;
    const $c1d0 = $c1 * d0;
    const $c1d1 = $c1 * $d1;
    const $c1d2 = $c1 * $d2;
    const $c1d3 = $c1 * $d3;
    const $c2d1 = $c2 * $d1;
    const $c2c2 = $c2 * $c2;
    const $c2c3 = $c2 * $c3;
    const $c2d0 = $c2 * d0;
    const $c2d2 = $c2 * $d2;
    const $c2d3 = $c2 * $d3;
    const $c3c3 = $c3 * $c3;
    const $c3d0 = $c3 * d0;
    const $c3d1 = $c3 * $d1;
    const $c3d2 = $c3 * $d2;
    const $c3d3 = $c3 * $d3;
    const $d0d0 = d0 * d0;
    const $d0d1 = d0 * $d1;
    const $d0d2 = d0 * $d2;
    const $d0d3 = d0 * $d3;
    const $d1d1 = $d1 * $d1;
    const $d1d2 = $d1 * $d2;
    const $d3d3 = $d3 * $d3;
    const $d2d2 = $d2 * $d2;
    const $d2d3 = $d2 * $d3;
    const $d1d3 = $d1 * $d3;
    const c0c0 = get_coeffs_bez3_bez3_dd_tp(c0, c0); // error free
    const c0c1 = get_coeffs_bez3_bez3_dd_qmd(c0, c1);
    const c0c1_ = _c0 * c1_ + get_coeffs_bez3_bez3_dd_abs($c0c1);
    const c0c2 = get_coeffs_bez3_bez3_dd_qmd(c0, c2);
    const c0c2_ = _c0 * c2_ + get_coeffs_bez3_bez3_dd_abs($c0c2);
    const c0c3 = get_coeffs_bez3_bez3_dd_qmd(c0, c3);
    const c0c3_ = _c0 * c3_ + get_coeffs_bez3_bez3_dd_abs($c0c3);
    const c0d0 = get_coeffs_bez3_bez3_dd_tp(c0, d0); // error free
    const c0d1 = get_coeffs_bez3_bez3_dd_qmd(c0, d1);
    const c0d1_ = _c0 * d1_ + get_coeffs_bez3_bez3_dd_abs($c0d1);
    const c0d2 = get_coeffs_bez3_bez3_dd_qmd(c0, d2);
    const c0d2_ = _c0 * d2_ + get_coeffs_bez3_bez3_dd_abs($c0d2);
    const c0d3 = get_coeffs_bez3_bez3_dd_qmd(c0, d3);
    const c0d3_ = _c0 * d3_ + get_coeffs_bez3_bez3_dd_abs($c0d3);
    const c1c1 = get_coeffs_bez3_bez3_dd_qmq(c1, c1);
    const _c1c1 = get_coeffs_bez3_bez3_dd_abs($c1c1);
    const c1c1_ = 2 * (c1_ * _c1 + _c1c1);
    const c1c2 = get_coeffs_bez3_bez3_dd_qmq(c1, c2);
    const c1c2_ = c1_ * _c2 + _c1 * c2_ + 2 * get_coeffs_bez3_bez3_dd_abs($c1c2);
    const c1c3 = get_coeffs_bez3_bez3_dd_qmq(c1, c3);
    const c1c3_ = c1_ * _c3 + _c1 * c3_ + 2 * get_coeffs_bez3_bez3_dd_abs($c1c3);
    const c1d0 = get_coeffs_bez3_bez3_dd_qmd(d0, c1);
    const c1d0_ = _d0 * c1_ + get_coeffs_bez3_bez3_dd_abs($c1d0);
    const c1d1 = get_coeffs_bez3_bez3_dd_qmq(c1, d1);
    const c1d1_ = c1_ * _d1 + _c1 * d1_ + 2 * get_coeffs_bez3_bez3_dd_abs($c1d1);
    const c1d2 = get_coeffs_bez3_bez3_dd_qmq(c1, d2);
    const c1d2_ = c1_ * _d2 + _c1 * d2_ + 2 * get_coeffs_bez3_bez3_dd_abs($c1d2);
    const c1d3 = get_coeffs_bez3_bez3_dd_qmq(c1, d3);
    const c1d3_ = c1_ * _d3 + _c1 * d3_ + 2 * get_coeffs_bez3_bez3_dd_abs($c1d3);
    const c2d1 = get_coeffs_bez3_bez3_dd_qmq(c2, d1);
    const c2d1_ = c2_ * _d1 + _c2 * d1_ + 2 * get_coeffs_bez3_bez3_dd_abs($c2d1);
    const c2c2 = get_coeffs_bez3_bez3_dd_qmq(c2, c2);
    const _c2c2 = get_coeffs_bez3_bez3_dd_abs($c2c2);
    const c2c2_ = 2 * (c2_ * _c2 + _c2c2);
    const c2c3 = get_coeffs_bez3_bez3_dd_qmq(c2, c3);
    const c2c3_ = c2_ * _c3 + _c2 * c3_ + 2 * get_coeffs_bez3_bez3_dd_abs($c2c3);
    const c2d0 = get_coeffs_bez3_bez3_dd_qmd(d0, c2);
    const c2d0_ = _d0 * c2_ + get_coeffs_bez3_bez3_dd_abs($c2d0);
    const c2d2 = get_coeffs_bez3_bez3_dd_qmq(c2, d2);
    const c2d2_ = c2_ * _d2 + _c2 * d2_ + 2 * get_coeffs_bez3_bez3_dd_abs($c2d2);
    const c2d3 = get_coeffs_bez3_bez3_dd_qmq(c2, d3);
    const c2d3_ = c2_ * _d3 + _c2 * d3_ + 2 * get_coeffs_bez3_bez3_dd_abs($c2d3);
    const c3c3 = get_coeffs_bez3_bez3_dd_qmq(c3, c3);
    const c3c3_ = 2 * (c3_ * _c3 + get_coeffs_bez3_bez3_dd_abs($c3c3));
    const c3d0 = get_coeffs_bez3_bez3_dd_qmd(d0, c3);
    const c3d0_ = _d0 * c3_ + get_coeffs_bez3_bez3_dd_abs($c3d0);
    const c3d1 = get_coeffs_bez3_bez3_dd_qmq(c3, d1);
    const c3d1_ = c3_ * _d1 + _c3 * d1_ + 2 * get_coeffs_bez3_bez3_dd_abs($c3d1);
    const c3d2 = get_coeffs_bez3_bez3_dd_qmq(c3, d2);
    const _c3d2 = get_coeffs_bez3_bez3_dd_abs($c3d2);
    const c3d2_ = c3_ * _d2 + _c3 * d2_ + 2 * _c3d2;
    const c3d3 = get_coeffs_bez3_bez3_dd_qmq(c3, d3);
    const c3d3_ = c3_ * _d3 + _c3 * d3_ + 2 * get_coeffs_bez3_bez3_dd_abs($c3d3);
    const d0d0 = get_coeffs_bez3_bez3_dd_tp(d0, d0); // error free
    const d0d1 = get_coeffs_bez3_bez3_dd_qmd(d0, d1);
    const d0d1_ = _d0 * d1_ + get_coeffs_bez3_bez3_dd_abs($d0d1);
    const d0d2 = get_coeffs_bez3_bez3_dd_qmd(d0, d2);
    const d0d2_ = _d0 * d2_ + get_coeffs_bez3_bez3_dd_abs($d0d2);
    const d0d3 = get_coeffs_bez3_bez3_dd_qmd(d0, d3);
    const d0d3_ = _d0 * d3_ + get_coeffs_bez3_bez3_dd_abs($d0d3);
    const d1d1 = get_coeffs_bez3_bez3_dd_qmq(d1, d1);
    const _d1d1 = get_coeffs_bez3_bez3_dd_abs($d1d1);
    const d1d1_ = 2 * (d1_ * _d1 + _d1d1);
    const d1d2 = get_coeffs_bez3_bez3_dd_qmq(d1, d2);
    const d1d2_ = d1_ * _d2 + _d1 * d2_ + 2 * get_coeffs_bez3_bez3_dd_abs($d1d2);
    const d3d3 = get_coeffs_bez3_bez3_dd_qmq(d3, d3);
    const d3d3_ = 2 * (d3_ * _d3 + get_coeffs_bez3_bez3_dd_abs($d3d3));
    const d2d2 = get_coeffs_bez3_bez3_dd_qmq(d2, d2);
    const _d2d2 = get_coeffs_bez3_bez3_dd_abs($d2d2);
    const d2d2_ = 2 * (d2_ * _d2 + _d2d2);
    const d2d3 = get_coeffs_bez3_bez3_dd_qmq(d2, d3);
    const d2d3_ = d2_ * _d3 + _d2 * d3_ + 2 * get_coeffs_bez3_bez3_dd_abs($d2d3);
    const d1d3 = get_coeffs_bez3_bez3_dd_qmq(d1, d3);
    const _d1d3 = get_coeffs_bez3_bez3_dd_abs($d1d3);
    const d1d3_ = d1_ * _d3 + _d1 * d3_ + 2 * _d1d3;
    const _c0c0 = get_coeffs_bez3_bez3_dd_abs($c0c0);
    const _c0c1 = get_coeffs_bez3_bez3_dd_abs($c0c1);
    const _c2c3 = get_coeffs_bez3_bez3_dd_abs($c2c3);
    const _c3c3 = get_coeffs_bez3_bez3_dd_abs($c3c3);
    const _c3d3 = get_coeffs_bez3_bez3_dd_abs($c3d3);
    const _c0d0 = get_coeffs_bez3_bez3_dd_abs($c0d0);
    const _d0d0 = get_coeffs_bez3_bez3_dd_abs($d0d0);
    const _d0d1 = get_coeffs_bez3_bez3_dd_abs($d0d1);
    const _d2d3 = get_coeffs_bez3_bez3_dd_abs($d2d3);
    const _d3d3 = get_coeffs_bez3_bez3_dd_abs($d3d3);
    //-----------------------
    //const v9 =  
    //    (c3*c3c3)*vₓₓₓ + 
    //    (c3*d3d3)*vₓᵧᵧ + 
    //    (d3*c3c3)*vₓₓᵧ + 
    //    (d3*d3d3)*vᵧᵧᵧ;
    //-----------------------
    const $g1 = $c3 * $c3c3;
    const g1 = get_coeffs_bez3_bez3_dd_qmq(c3, c3c3);
    const _g1 = _c3 * _c3c3;
    const g1_ = c3_ * _c3c3 + _c3 * c3c3_ + 2 * _g1;
    const $g2 = $c3 * $d3d3;
    const g2 = get_coeffs_bez3_bez3_dd_qmq(c3, d3d3);
    const _g2 = _c3 * _d3d3;
    const g2_ = c3_ * _d3d3 + _c3 * d3d3_ + 2 * _g2;
    const $g3 = $d3 * $c3c3;
    const g3 = get_coeffs_bez3_bez3_dd_qmq(d3, c3c3);
    const _g3 = _d3 * _c3c3;
    const g3_ = d3_ * _c3c3 + _d3 * c3c3_ + 2 * _g3;
    const $g4 = $d3 * $d3d3;
    const g4 = get_coeffs_bez3_bez3_dd_qmq(d3, d3d3);
    const _g4 = _d3 * _d3d3;
    const g4_ = d3_ * _d3d3 + _d3 * d3d3_ + 2 * _g4;
    const $g5 = $g1 * $vₓₓₓ;
    const g5 = get_coeffs_bez3_bez3_dd_qmq(g1, vₓₓₓ);
    const g5_ = g1_ * _vₓₓₓ + _g1 * vₓₓₓ_ + 2 * get_coeffs_bez3_bez3_dd_abs($g5);
    const $g6 = $g2 * $vₓᵧᵧ;
    const g6 = get_coeffs_bez3_bez3_dd_qmq(g2, vₓᵧᵧ);
    const g6_ = g2_ * _vₓᵧᵧ + _g2 * vₓᵧᵧ_ + 2 * get_coeffs_bez3_bez3_dd_abs($g6);
    const $g7 = $g3 * $vₓₓᵧ;
    const g7 = get_coeffs_bez3_bez3_dd_qmq(g3, vₓₓᵧ);
    const g7_ = g3_ * _vₓₓᵧ + _g3 * vₓₓᵧ_ + 2 * get_coeffs_bez3_bez3_dd_abs($g7);
    const $g8 = $g4 * $vᵧᵧᵧ;
    const g8 = get_coeffs_bez3_bez3_dd_qmq(g4, vᵧᵧᵧ);
    const g8_ = g4_ * _vᵧᵧᵧ + _g4 * vᵧᵧᵧ_ + 2 * get_coeffs_bez3_bez3_dd_abs($g8);
    const $g9 = $g5 + $g6;
    const g9 = get_coeffs_bez3_bez3_dd_qaq(g5, g6);
    const g9_ = g5_ + g6_ + get_coeffs_bez3_bez3_dd_abs($g9);
    const $ga = $g7 + $g8;
    const ga = get_coeffs_bez3_bez3_dd_qaq(g7, g8);
    const ga_ = g7_ + g8_ + get_coeffs_bez3_bez3_dd_abs($ga);
    const $v9 = $g9 + $ga;
    const v9 = get_coeffs_bez3_bez3_dd_qaq(g9, ga);
    const v9_ = g9_ + ga_ + get_coeffs_bez3_bez3_dd_abs($v9);
    //-----------------------
    //const v8 =  
    //    2*c2*c3d3*vₓₓᵧ + 
    //    2*c3*d2d3*vₓᵧᵧ + 
    //      c2*d3d3*vₓᵧᵧ + 
    //      d2*c3c3*vₓₓᵧ + 
    //    3*c2*c3c3*vₓₓₓ + 
    //    3*d2*d3d3*vᵧᵧᵧ;  
    //-----------------------
    const $w1 = 2 * $c2d3 + $c3d2;
    const _w1 = get_coeffs_bez3_bez3_dd_abs($w1);
    const w1 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(c2d3), c3d2);
    const w1_ = 2 * c2d3_ + c3d2_ + _w1;
    const $w2 = 2 * $c3d2 + $c2d3;
    const _w2 = get_coeffs_bez3_bez3_dd_abs($w2);
    const w2 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(c3d2), c2d3);
    const w2_ = 2 * c3d2_ + c2d3_ + get_coeffs_bez3_bez3_dd_abs($w2);
    const $w3 = $c3 * $w1;
    const _w3 = get_coeffs_bez3_bez3_dd_abs($w3);
    const w3 = get_coeffs_bez3_bez3_dd_qmq(c3, w1);
    const w3_ = c3_ * _w1 + _c3 * w1_ + 2 * _w3;
    const $w4 = $d3 * $w2;
    const _w4 = get_coeffs_bez3_bez3_dd_abs($w4);
    const w4 = get_coeffs_bez3_bez3_dd_qmq(d3, w2);
    const w4_ = d3_ * _w2 + _d3 * w2_ + 2 * _w4;
    const $w5 = $c2 * $c3c3;
    const _w5 = get_coeffs_bez3_bez3_dd_abs($w5);
    const w5 = get_coeffs_bez3_bez3_dd_qmq(c2, c3c3);
    const w5_ = c2_ * _c3c3 + _c2 * c3c3_ + 2 * _w5;
    const $w6 = $d2 * $d3d3;
    const _w6 = get_coeffs_bez3_bez3_dd_abs($w6);
    const w6 = get_coeffs_bez3_bez3_dd_qmq(d2, d3d3);
    const w6_ = d2_ * _d3d3 + _d2 * d3d3_ + 2 * _w6;
    const $w7 = $vₓₓₓ * $w5;
    const w7 = get_coeffs_bez3_bez3_dd_qmq(vₓₓₓ, w5);
    const w7_ = w5_ * _vₓₓₓ + _vₓₓₓ * w5_ + 2 * get_coeffs_bez3_bez3_dd_abs($w7);
    const $u1 = $vᵧᵧᵧ * $w6;
    const u1 = get_coeffs_bez3_bez3_dd_qmq(vᵧᵧᵧ, w6);
    const u1_ = w6_ * _vᵧᵧᵧ + _vᵧᵧᵧ * w6_ + 2 * get_coeffs_bez3_bez3_dd_abs($u1);
    const $u2 = $vₓₓᵧ * $w3;
    const u2 = get_coeffs_bez3_bez3_dd_qmq(vₓₓᵧ, w3);
    const u2_ = w3_ * _vₓₓᵧ + _vₓₓᵧ * w3_ + 2 * get_coeffs_bez3_bez3_dd_abs($u2);
    const $u3 = $vₓᵧᵧ * $w4;
    const u3 = get_coeffs_bez3_bez3_dd_qmq(vₓᵧᵧ, w4);
    const u3_ = w4_ * _vₓᵧᵧ + _vₓᵧᵧ * w4_ + 2 * get_coeffs_bez3_bez3_dd_abs($u3);
    const $u4 = $u2 + $u3;
    const u4 = get_coeffs_bez3_bez3_dd_qaq(u2, u3);
    const u4_ = u2_ + u3_ + get_coeffs_bez3_bez3_dd_abs($u4);
    const $u5 = 3 * ($w7 + $u1);
    const u5 = get_coeffs_bez3_bez3_dd_qmd(3, get_coeffs_bez3_bez3_dd_qaq(w7, u1));
    const u5_ = 3 * (w7_ + u1_) + 2 * get_coeffs_bez3_bez3_dd_abs($u5);
    const $v8 = $u4 + $u5;
    const v8 = get_coeffs_bez3_bez3_dd_qaq(u4, u5);
    const v8_ = u4_ + u5_ + get_coeffs_bez3_bez3_dd_abs($v8);
    //-----------------------
    //const v7 =  
    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +
    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +
    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +
    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);
    //-----------------------
    const $o1 = $c1 * $c3d3;
    const o1 = get_coeffs_bez3_bez3_dd_qmq(c1, c3d3);
    const o1_ = c1_ * _c3d3 + _c1 * c3d3_ + 2 * get_coeffs_bez3_bez3_dd_abs($o1);
    const $o2 = $d1 * $c3c3;
    const o2 = get_coeffs_bez3_bez3_dd_qmq(d1, c3c3);
    const o2_ = d1_ * _c3c3 + _d1 * c3c3_ + 2 * get_coeffs_bez3_bez3_dd_abs($o2);
    const $o3 = $c2 * $d2d3;
    const o3 = get_coeffs_bez3_bez3_dd_qmq(c2, d2d3);
    const o3_ = c2_ * _d2d3 + _c2 * d2d3_ + 2 * get_coeffs_bez3_bez3_dd_abs($o3);
    const $o4 = $c1 * $d3d3;
    const o4 = get_coeffs_bez3_bez3_dd_qmq(c1, d3d3);
    const o4_ = c1_ * _d3d3 + _c1 * d3d3_ + 2 * get_coeffs_bez3_bez3_dd_abs($o4);
    const $o5 = $c2 * $c3d2;
    const o5 = get_coeffs_bez3_bez3_dd_qmq(c2, c3d2);
    const o5_ = c2_ * _c3d2 + _c2 * c3d2_ + 2 * get_coeffs_bez3_bez3_dd_abs($o5);
    const $o6 = $d3 * $c2c2;
    const o6 = get_coeffs_bez3_bez3_dd_qmq(d3, c2c2);
    const o6_ = d3_ * _c2c2 + _d3 * c2c2_ + 2 * get_coeffs_bez3_bez3_dd_abs($o6);
    const $o7 = $c3 * $d1d3;
    const o7 = get_coeffs_bez3_bez3_dd_qmq(c3, d1d3);
    const o7_ = c3_ * _d1d3 + _c3 * d1d3_ + 2 * get_coeffs_bez3_bez3_dd_abs($o7);
    const $o8 = $d2 * $c3d2;
    const o8 = get_coeffs_bez3_bez3_dd_qmq(d2, c3d2);
    const o8_ = d2_ * _c3d2 + _d2 * c3d2_ + 2 * get_coeffs_bez3_bez3_dd_abs($o8);
    const $w8 = $o1 + $o5;
    const w8 = get_coeffs_bez3_bez3_dd_qaq(o1, o5);
    const w8_ = o1_ + o5_ + get_coeffs_bez3_bez3_dd_abs($w8);
    const $w9 = $o2 + $o6;
    const w9 = get_coeffs_bez3_bez3_dd_qaq(o2, o6);
    const w9_ = o2_ + o6_ + get_coeffs_bez3_bez3_dd_abs($w9);
    const $wa = $o3 + $o7;
    const wa = get_coeffs_bez3_bez3_dd_qaq(o3, o7);
    const wa_ = o3_ + o7_ + get_coeffs_bez3_bez3_dd_abs($wa);
    const $wb = $o4 + $o8;
    const wb = get_coeffs_bez3_bez3_dd_qaq(o4, o8);
    const wb_ = o4_ + o8_ + get_coeffs_bez3_bez3_dd_abs($wb);
    const $wc = $c1c3 + $c2c2;
    const wc = get_coeffs_bez3_bez3_dd_qaq(c1c3, c2c2);
    const _wc = get_coeffs_bez3_bez3_dd_abs($wc);
    const wc_ = c1c3_ + c2c2_ + _wc;
    const $wd = $d1d3 + $d2d2;
    const _wd = get_coeffs_bez3_bez3_dd_abs($wd);
    const wd = get_coeffs_bez3_bez3_dd_qaq(d1d3, d2d2);
    const wd_ = d1d3_ + d2d2_ + _wd;
    const $we = 2 * $w8 + $w9;
    const we = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(w8), w9);
    const _we = get_coeffs_bez3_bez3_dd_abs($we);
    const we_ = 2 * w8_ + w9_ + _we;
    const $wf = 2 * $wa + $wb;
    const wf = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(wa), wb);
    const _wf = get_coeffs_bez3_bez3_dd_abs($wf);
    const wf_ = 2 * wa_ + wb_ + _wf;
    const $wg = $vₓₓᵧ * $we;
    const wg = get_coeffs_bez3_bez3_dd_qmq(vₓₓᵧ, we);
    const wg_ = vₓₓᵧ_ * _we + _vₓₓᵧ * we_ + 2 * get_coeffs_bez3_bez3_dd_abs($wg);
    const $wh = $vₓᵧᵧ * $wf;
    const wh = get_coeffs_bez3_bez3_dd_qmq(vₓᵧᵧ, wf);
    const wh_ = vₓᵧᵧ_ * _wf + _vₓᵧᵧ * wf_ + 2 * get_coeffs_bez3_bez3_dd_abs($wh);
    const $wi = $c3 * $wc;
    const wi = get_coeffs_bez3_bez3_dd_qmq(c3, wc);
    const _wi = get_coeffs_bez3_bez3_dd_abs($wi);
    const wi_ = c3_ * _wc + _c3 * wc_ + 2 * _wi;
    const $wj = $d3 * $wd;
    const wj = get_coeffs_bez3_bez3_dd_qmq(d3, wd);
    const _wj = get_coeffs_bez3_bez3_dd_abs($wj);
    const wj_ = d3_ * _wd + _d3 * wd_ + 2 * _wj;
    const $wk = $vₓₓₓ * $wi;
    const wk = get_coeffs_bez3_bez3_dd_qmq(vₓₓₓ, wi);
    const wk_ = vₓₓₓ_ * _wi + _vₓₓₓ * wi_ + 2 * get_coeffs_bez3_bez3_dd_abs($wk);
    const $wl = $vᵧᵧᵧ * $wj;
    const wl = get_coeffs_bez3_bez3_dd_qmq(vᵧᵧᵧ, wj);
    const wl_ = vᵧᵧᵧ_ * _wj + _vᵧᵧᵧ * wj_ + 2 * get_coeffs_bez3_bez3_dd_abs($wl);
    const $wm = $wg + $wh;
    const wm = get_coeffs_bez3_bez3_dd_qaq(wg, wh);
    const wm_ = wg_ + wh_ + get_coeffs_bez3_bez3_dd_abs($wm);
    const $wn = 3 * ($wk + $wl);
    const wn = get_coeffs_bez3_bez3_dd_qmd(3, get_coeffs_bez3_bez3_dd_qaq(wk, wl));
    const wn_ = 3 * (wk_ + wl_) + 2 * get_coeffs_bez3_bez3_dd_abs($wn);
    const $v7 = $wm + $wn;
    const v7 = get_coeffs_bez3_bez3_dd_qaq(wm, wn);
    const v7_ = wm_ + wn_ + get_coeffs_bez3_bez3_dd_abs($v7);
    //const v6 =
    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +
    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +
    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +
    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +
    //    vₓₓ *c3c3 +
    //    vᵧᵧ *d3d3 +
    //    vₓᵧ *c3d3;
    const $wo = $c2d3 + $c3d2;
    const wo = get_coeffs_bez3_bez3_dd_qaq(c2d3, c3d2);
    const _wo = get_coeffs_bez3_bez3_dd_abs($wo);
    const wo_ = c2d3_ + c3d2_ + _wo;
    const $zc = $d2 * $c2c2;
    const zc = get_coeffs_bez3_bez3_dd_qmq(d2, c2c2);
    const zc_ = d2_ * _c2c2 + _d2 * c2c2_ + 2 * get_coeffs_bez3_bez3_dd_abs($zc);
    const $zd = 2 * $c1 * $wo;
    const zd = get_coeffs_bez3_bez3_dd_qm2(get_coeffs_bez3_bez3_dd_qmq(c1, wo));
    const zd_ = 2 * (c1_ * _wo + _c1 * wo_ + 2 * get_coeffs_bez3_bez3_dd_abs($zd));
    const $wp = $zc + $zd;
    const wp = get_coeffs_bez3_bez3_dd_qaq(zc, zd);
    const wp_ = zc_ + zd_ + get_coeffs_bez3_bez3_dd_abs($wp);
    const $wq = 2 * ($c0d3 + $c2d1);
    const wq = get_coeffs_bez3_bez3_dd_qm2(get_coeffs_bez3_bez3_dd_qaq(c0d3, c2d1));
    const wq_ = 2 * (c0d3_ + c2d1_) + get_coeffs_bez3_bez3_dd_abs($wq);
    const $wr = $wq + $c3d0;
    const _wr = get_coeffs_bez3_bez3_dd_abs($wr);
    const wr = get_coeffs_bez3_bez3_dd_qaq(wq, c3d0);
    const wr_ = wq_ + c3d0_ + _wr;
    const $ze = $c3 * $wr;
    const ze = get_coeffs_bez3_bez3_dd_qmq(c3, wr);
    const ze_ = c3_ * _wr + _c3 * wr_ + 2 * get_coeffs_bez3_bez3_dd_abs($ze);
    const $ws = $wp + $ze;
    const ws = get_coeffs_bez3_bez3_dd_qaq(wp, ze);
    const _ws = get_coeffs_bez3_bez3_dd_abs($ws);
    const ws_ = wp_ + ze_ + _ws;
    const $zf = $c2 * $d2d2;
    const zf = get_coeffs_bez3_bez3_dd_qmq(c2, d2d2);
    const zf_ = c2_ * _d2d2 + _c2 * d2d2_ + 2 * get_coeffs_bez3_bez3_dd_abs($zf);
    const $zg = 2 * $d1 * $wo;
    const zg = get_coeffs_bez3_bez3_dd_qm2(get_coeffs_bez3_bez3_dd_qmq(d1, wo));
    const zg_ = 2 * (d1_ * _wo + _d1 * wo_ + get_coeffs_bez3_bez3_dd_abs($zg));
    const $wt = $zf + $zg;
    const wt = get_coeffs_bez3_bez3_dd_qaq(zf, zg);
    const wt_ = zf_ + zg_ + get_coeffs_bez3_bez3_dd_abs($wt);
    const $wu = 2 * ($c1d2 + $c3d0);
    const wu = get_coeffs_bez3_bez3_dd_qm2(get_coeffs_bez3_bez3_dd_qaq(c1d2, c3d0));
    const wu_ = 2 * (c1d2_ + c3d0_) + get_coeffs_bez3_bez3_dd_abs($wu);
    const $wv = $wu + $c0d3;
    const wv = get_coeffs_bez3_bez3_dd_qaq(wu, c0d3);
    const _wv = get_coeffs_bez3_bez3_dd_abs($wv);
    const wv_ = wu_ + c0d3_ + _wv;
    const $zh = $d3 * $wv;
    const zh = get_coeffs_bez3_bez3_dd_qmq(d3, wv);
    const zh_ = d3_ * _wv + _d3 * wv_ + 2 * get_coeffs_bez3_bez3_dd_abs($zh);
    const $ww = $wt + $zh;
    const ww = get_coeffs_bez3_bez3_dd_qaq(wt, zh);
    const _ww = get_coeffs_bez3_bez3_dd_abs($ww);
    const ww_ = wt_ + zh_ + _ww;
    const $wx = $c2 * $c2c2;
    const wx = get_coeffs_bez3_bez3_dd_qmq(c2, c2c2);
    const wx_ = c2_ * _c2c2 + _c2 * c2c2_ + 2 * get_coeffs_bez3_bez3_dd_abs($wx);
    const $wy = 2 * $c1c2 + $c0c3;
    const wy = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(c1c2), c0c3);
    const _wy = get_coeffs_bez3_bez3_dd_abs($wy);
    const wy_ = 2 * c1c2_ + c0c3_ + _wy;
    const $q1 = 3 * $c3;
    const q1 = get_coeffs_bez3_bez3_dd_qmd(3, c3);
    const _q1 = get_coeffs_bez3_bez3_dd_abs($q1);
    const q1_ = 3 * c3_ + _q1;
    const $wz = $q1 * $wy;
    const wz = get_coeffs_bez3_bez3_dd_qmq(q1, wy);
    const wz_ = q1_ * _wy + _q1 * wy_ + 2 * get_coeffs_bez3_bez3_dd_abs($wz);
    const $z1 = $wx + $wz;
    const z1 = get_coeffs_bez3_bez3_dd_qaq(wx, wz);
    const _z1 = get_coeffs_bez3_bez3_dd_abs($z1);
    const z1_ = wx_ + wz_ + _z1;
    const $z2 = $d2 * $d2d2;
    const z2 = get_coeffs_bez3_bez3_dd_qmq(d2, d2d2);
    const z2_ = d2_ * _d2d2 + _d2 * d2d2_ + 2 * get_coeffs_bez3_bez3_dd_abs($z2);
    const $z3 = 2 * $d1d2 + $d0d3;
    const z3 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(d1d2), d0d3);
    const _z3 = get_coeffs_bez3_bez3_dd_abs($z3);
    const z3_ = 2 * d1d2_ + d0d3_ + _z3;
    const $q2 = 3 * $d3;
    const q2 = get_coeffs_bez3_bez3_dd_qmd(3, d3);
    const _q2 = get_coeffs_bez3_bez3_dd_abs($q2);
    const q2_ = 3 * d3_ + _q2;
    const $z4 = $q2 * $z3;
    const z4 = get_coeffs_bez3_bez3_dd_qmq(q2, z3);
    const z4_ = q2_ * _z3 + _q2 * z3_ + 2 * get_coeffs_bez3_bez3_dd_abs($z4);
    const $z5 = $z2 + $z4;
    const z5 = get_coeffs_bez3_bez3_dd_qaq(z2, z4);
    const _z5 = get_coeffs_bez3_bez3_dd_abs($z5);
    const z5_ = z2_ + z4_ + _z5;
    const $zi = $vₓₓᵧ * $ws;
    const zi = get_coeffs_bez3_bez3_dd_qmq(vₓₓᵧ, ws);
    const zi_ = vₓₓᵧ_ * _ws + _vₓₓᵧ * ws_ + 2 * get_coeffs_bez3_bez3_dd_abs($zi);
    const $zj = $vₓᵧᵧ * $ww;
    const zj = get_coeffs_bez3_bez3_dd_qmq(vₓᵧᵧ, ww);
    const zj_ = vₓᵧᵧ_ * _ww + _vₓᵧᵧ * ww_ + 2 * get_coeffs_bez3_bez3_dd_abs($zj);
    const $z6 = $zi + $zj;
    const z6 = get_coeffs_bez3_bez3_dd_qaq(zi, zj);
    const z6_ = zi_ + zj_ + get_coeffs_bez3_bez3_dd_abs($z6);
    const $zk = $vₓₓₓ * $z1;
    const zk = get_coeffs_bez3_bez3_dd_qmq(vₓₓₓ, z1);
    const zk_ = vₓₓₓ_ * _z1 + _vₓₓₓ * z1_ + 2 * get_coeffs_bez3_bez3_dd_abs($zk);
    const $zl = $vᵧᵧᵧ * $z5;
    const zl = get_coeffs_bez3_bez3_dd_qmq(vᵧᵧᵧ, z5);
    const zl_ = vᵧᵧᵧ_ * _z5 + _vᵧᵧᵧ * z5_ + 2 * get_coeffs_bez3_bez3_dd_abs($zl);
    const $z7 = $zk + $zl;
    const z7 = get_coeffs_bez3_bez3_dd_qaq(zk, zl);
    const z7_ = zk_ + zl_ + get_coeffs_bez3_bez3_dd_abs($z7);
    const $zm = $vₓₓ * $c3c3;
    const zm = get_coeffs_bez3_bez3_dd_qmq(c3c3, vₓₓ);
    const zm_ = c3c3_ * _vₓₓ + _c3c3 * vₓₓ_ + 2 * get_coeffs_bez3_bez3_dd_abs($zm);
    const $zn = $vᵧᵧ * $d3d3;
    const zn = get_coeffs_bez3_bez3_dd_qmq(d3d3, vᵧᵧ);
    const zn_ = d3d3_ * _vᵧᵧ + _d3d3 * vᵧᵧ_ + 2 * get_coeffs_bez3_bez3_dd_abs($zn);
    const $z8 = $zm + $zn;
    const z8 = get_coeffs_bez3_bez3_dd_qaq(zm, zn);
    const z8_ = zm_ + zn_ + get_coeffs_bez3_bez3_dd_abs($z8);
    const $z9 = $vₓᵧ * $c3d3;
    const z9 = get_coeffs_bez3_bez3_dd_qmq(c3d3, vₓᵧ);
    const z9_ = c3d3_ * _vₓᵧ + _c3d3 * vₓᵧ_ + 2 * get_coeffs_bez3_bez3_dd_abs($z9);
    const $za = $z6 + $z7;
    const za = get_coeffs_bez3_bez3_dd_qaq(z6, z7);
    const za_ = z6_ + z7_ + get_coeffs_bez3_bez3_dd_abs($za);
    const $zb = $z8 + $z9;
    const zb = get_coeffs_bez3_bez3_dd_qaq(z8, z9);
    const zb_ = z8_ + z9_ + get_coeffs_bez3_bez3_dd_abs($zb);
    const $v6 = $za + $zb;
    const v6 = get_coeffs_bez3_bez3_dd_qaq(za, zb);
    const v6_ = za_ + zb_ + get_coeffs_bez3_bez3_dd_abs($v6);
    //const r4 = c2d2 + c3d1;
    //const r5 = c1d3 + c2d2;
    //const v5 =
    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +
    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +
    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + 
    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +
    //    vₓᵧ*wo +
    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);
    const $r4 = $c2d2 + $c3d1;
    const r4 = get_coeffs_bez3_bez3_dd_qaq(c2d2, c3d1);
    const _r4 = get_coeffs_bez3_bez3_dd_abs($r4);
    const r4_ = c2d2_ + c3d1_ + _r4;
    const $r5 = $c1d3 + $c2d2;
    const r5 = get_coeffs_bez3_bez3_dd_qaq(c1d3, c2d2);
    const _r5 = get_coeffs_bez3_bez3_dd_abs($r5);
    const r5_ = c1d3_ + c2d2_ + _r5;
    const $k1 = c0 * $wo;
    const k1 = get_coeffs_bez3_bez3_dd_qmd(c0, wo);
    const k1_ = _c0 * wo_ + get_coeffs_bez3_bez3_dd_abs($k1);
    const $k2 = d0 * $wo;
    const k2 = get_coeffs_bez3_bez3_dd_qmd(d0, wo);
    const k2_ = _d0 * wo_ + get_coeffs_bez3_bez3_dd_abs($k2);
    const $k3 = $c1 * $r4;
    const k3 = get_coeffs_bez3_bez3_dd_qmq(c1, r4);
    const k3_ = c1_ * _r4 + _c1 * r4_ + 2 * get_coeffs_bez3_bez3_dd_abs($k3);
    const $k4 = $d1 * $r5;
    const k4 = get_coeffs_bez3_bez3_dd_qmq(d1, r5);
    const k4_ = d1_ * _r5 + _d1 * r5_ + 2 * get_coeffs_bez3_bez3_dd_abs($k4);
    const $k5 = 2 * $c3d0 + $c2d1;
    const k5 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(c3d0), c2d1);
    const _k5 = get_coeffs_bez3_bez3_dd_abs($k5);
    const k5_ = 2 * c3d0_ + c2d1_ + _k5;
    const $k6 = 2 * $c0d3 + $c1d2;
    const k6 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(c0d3), c1d2);
    const _k6 = get_coeffs_bez3_bez3_dd_abs($k6);
    const k6_ = 2 * c0d3_ + c1d2_ + _k6;
    const $k7 = $d3 * $c1c1;
    const k7 = get_coeffs_bez3_bez3_dd_qmq(d3, c1c1);
    const k7_ = d3_ * _c1c1 + _d3 * c1c1_ + 2 * get_coeffs_bez3_bez3_dd_abs($k7);
    const $k8 = $c3 * $d1d1;
    const k8 = get_coeffs_bez3_bez3_dd_qmq(c3, d1d1);
    const k8_ = c3_ * _d1d1 + _c3 * d1d1_ + 2 * get_coeffs_bez3_bez3_dd_abs($k8);
    const $k9 = $c2 * $k5;
    const k9 = get_coeffs_bez3_bez3_dd_qmq(c2, k5);
    const k9_ = c2_ * _k5 + _c2 * k5_ + 2 * get_coeffs_bez3_bez3_dd_abs($k9);
    const $ka = $d2 * $k6;
    const ka = get_coeffs_bez3_bez3_dd_qmq(d2, k6);
    const ka_ = d2_ * _k6 + _d2 * k6_ + 2 * get_coeffs_bez3_bez3_dd_abs($ka);
    const $kb = 2 * ($k1 + $k3);
    const kb = get_coeffs_bez3_bez3_dd_qm2(get_coeffs_bez3_bez3_dd_qaq(k1, k3));
    const kb_ = 2 * (k1_ + k3_) + get_coeffs_bez3_bez3_dd_abs($kb);
    const $kc = 2 * ($k2 + $k4);
    const kc = get_coeffs_bez3_bez3_dd_qm2(get_coeffs_bez3_bez3_dd_qaq(k2, k4));
    const kc_ = 2 * (k2_ + k4_) + get_coeffs_bez3_bez3_dd_abs($kc);
    const $kd = 2 * c0 * $c2c3;
    const kd = get_coeffs_bez3_bez3_dd_qm2(get_coeffs_bez3_bez3_dd_qmd(c0, c2c3));
    const kd_ = 2 * _c0 * c2c3_ + get_coeffs_bez3_bez3_dd_abs($kd);
    const $ke = 2 * d0 * $d2d3;
    const ke = get_coeffs_bez3_bez3_dd_qm2(get_coeffs_bez3_bez3_dd_qmd(d0, d2d3));
    const ke_ = 2 * _d0 * d2d3_ + get_coeffs_bez3_bez3_dd_abs($ke);
    const $kf = $c1 * $wc;
    const kf = get_coeffs_bez3_bez3_dd_qmq(c1, wc);
    const kf_ = c1_ * _wc + _c1 * wc_ + 2 * get_coeffs_bez3_bez3_dd_abs($kf);
    const $kg = $d1 * $wd;
    const kg = get_coeffs_bez3_bez3_dd_qmq(d1, wd);
    const kg_ = d1_ * _wd + _d1 * wd_ + 2 * get_coeffs_bez3_bez3_dd_abs($kg);
    const $kh = $vₓₓ * $c2c3;
    const kh = get_coeffs_bez3_bez3_dd_qmq(c2c3, vₓₓ);
    const kh_ = c2c3_ * _vₓₓ + _c2c3 * vₓₓ_ + 2 * get_coeffs_bez3_bez3_dd_abs($kh);
    const $ki = $vᵧᵧ * $d2d3;
    const ki = get_coeffs_bez3_bez3_dd_qmq(d2d3, vᵧᵧ);
    const ki_ = d2d3_ * _vᵧᵧ + _d2d3 * vᵧᵧ_ + 2 * get_coeffs_bez3_bez3_dd_abs($ki);
    const $kj = $kb + $k7;
    const kj = get_coeffs_bez3_bez3_dd_qaq(kb, k7);
    const _kj = get_coeffs_bez3_bez3_dd_abs($kj);
    const kj_ = kb_ + k7_ + _kj;
    const $kk = $kc + $k8;
    const kk = get_coeffs_bez3_bez3_dd_qaq(kc, k8);
    const _kk = get_coeffs_bez3_bez3_dd_abs($kk);
    const kk_ = kc_ + k8_ + _kk;
    const $kl = $kj + $k9;
    const kl = get_coeffs_bez3_bez3_dd_qaq(kj, k9);
    const _kl = get_coeffs_bez3_bez3_dd_abs($kl);
    const kl_ = kj_ + k9_ + _kl;
    const $km = $kk + $ka;
    const km = get_coeffs_bez3_bez3_dd_qaq(kk, ka);
    const _km = get_coeffs_bez3_bez3_dd_abs($km);
    const km_ = kk_ + ka_ + _km;
    const $kn = $kd + $kf;
    const kn = get_coeffs_bez3_bez3_dd_qaq(kd, kf);
    const _kn = get_coeffs_bez3_bez3_dd_abs($kn);
    const kn_ = kd_ + kf_ + _kn;
    const $ko = $ke + $kg;
    const ko = get_coeffs_bez3_bez3_dd_qaq(ke, kg);
    const _ko = get_coeffs_bez3_bez3_dd_abs($ko);
    const ko_ = ke_ + kg_ + _ko;
    const $kp = 2 * ($kh + $ki);
    const kp = get_coeffs_bez3_bez3_dd_qm2(get_coeffs_bez3_bez3_dd_qaq(kh, ki));
    const kp_ = 2 * (kh_ + ki_) + get_coeffs_bez3_bez3_dd_abs($kp);
    const $kq = $vₓₓᵧ * $kl;
    const kq = get_coeffs_bez3_bez3_dd_qmq(vₓₓᵧ, kl);
    const kq_ = vₓₓᵧ_ * _kl + _vₓₓᵧ * kl_ + 2 * get_coeffs_bez3_bez3_dd_abs($kq);
    const $kr = $vₓᵧᵧ * $km;
    const kr = get_coeffs_bez3_bez3_dd_qmq(vₓᵧᵧ, km);
    const kr_ = vₓᵧᵧ_ * _km + _vₓᵧᵧ * km_ + 2 * get_coeffs_bez3_bez3_dd_abs($kr);
    const $ks = $vₓₓₓ * $kn;
    const ks = get_coeffs_bez3_bez3_dd_qmq(vₓₓₓ, kn);
    const ks_ = vₓₓₓ_ * _kn + _vₓₓₓ * kn_ + 2 * get_coeffs_bez3_bez3_dd_abs($ks);
    const $kt = $vᵧᵧᵧ * $ko;
    const kt = get_coeffs_bez3_bez3_dd_qmq(vᵧᵧᵧ, ko);
    const kt_ = vᵧᵧᵧ_ * _ko + _vᵧᵧᵧ * ko_ + 2 * get_coeffs_bez3_bez3_dd_abs($kt);
    const $ku = $kq + $kr;
    const ku = get_coeffs_bez3_bez3_dd_qaq(kq, kr);
    const ku_ = kq_ + kr_ + get_coeffs_bez3_bez3_dd_abs($ku);
    const $kv = 3 * ($ks + $kt);
    const kv = get_coeffs_bez3_bez3_dd_qmd(3, get_coeffs_bez3_bez3_dd_qaq(ks, kt));
    const kv_ = 3 * (ks_ + kt_) + 2 * get_coeffs_bez3_bez3_dd_abs($kv);
    const $kw = $vₓᵧ * $wo;
    const kw = get_coeffs_bez3_bez3_dd_qmq(vₓᵧ, wo);
    const kw_ = vₓᵧ_ * _wo + _vₓᵧ * wo_ + 2 * get_coeffs_bez3_bez3_dd_abs($kw);
    const $kx = $ku + $kv;
    const kx = get_coeffs_bez3_bez3_dd_qaq(ku, kv);
    const kx_ = ku_ + kv_ + get_coeffs_bez3_bez3_dd_abs($kx);
    const $ky = $kw + $kp;
    const ky = get_coeffs_bez3_bez3_dd_qaq(kw, kp);
    const ky_ = kw_ + kp_ + get_coeffs_bez3_bez3_dd_abs($ky);
    const $v5 = $kx + $ky;
    const v5 = get_coeffs_bez3_bez3_dd_qaq(kx, ky);
    const v5_ = kx_ + ky_ + get_coeffs_bez3_bez3_dd_abs($v5);
    //const r1 = c1d3 + r4;
    //const r2 = 2*c1c3 + c2c2;
    //const r3 = 2*d1d3 + d2d2;
    //const v4 =
    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +
    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +
    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +
    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +
    //    vₓᵧ*r1 +
    //    vₓₓ*r2 +
    //    vᵧᵧ*r3;
    const $r1 = $c1d3 + $r4;
    const r1 = get_coeffs_bez3_bez3_dd_qaq(c1d3, r4);
    const _r1 = get_coeffs_bez3_bez3_dd_abs($r1);
    const r1_ = c1d3_ + r4_ + _r1;
    const $r2 = 2 * $c1c3 + $c2c2;
    const r2 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(c1c3), c2c2);
    const _r2 = get_coeffs_bez3_bez3_dd_abs($r2);
    const r2_ = 2 * c1c3_ + c2c2_ + _r2;
    const $r3 = 2 * $d1d3 + $d2d2;
    const r3 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(d1d3), d2d2);
    const _r3 = get_coeffs_bez3_bez3_dd_abs($r3);
    const r3_ = 2 * d1d3_ + d2d2_ + _r3;
    const $s1 = 2 * c0 * $r1;
    const s1 = get_coeffs_bez3_bez3_dd_qmd(2 * c0, r1);
    const s1_ = 2 * _c0 * r1_ + get_coeffs_bez3_bez3_dd_abs($s1);
    const $s2 = 2 * d0 * $r1;
    const s2 = get_coeffs_bez3_bez3_dd_qmd(2 * d0, r1);
    const s2_ = 2 * _d0 * r1_ + get_coeffs_bez3_bez3_dd_abs($s2);
    const $s5 = $c1d2 + 2 * $c2d1;
    const s5 = get_coeffs_bez3_bez3_dd_qaq(c1d2, get_coeffs_bez3_bez3_dd_qm2(c2d1));
    const _s5 = get_coeffs_bez3_bez3_dd_abs($s5);
    const s5_ = c1d2_ + 2 * c2d1_ + _s5;
    const $s6 = $c2d1 + 2 * $c1d2;
    const s6 = get_coeffs_bez3_bez3_dd_qaq(c2d1, get_coeffs_bez3_bez3_dd_qm2(c1d2));
    const _s6 = get_coeffs_bez3_bez3_dd_abs($s6);
    const s6_ = c2d1_ + 2 * c1d2_ + _s6;
    const $s3 = d0 * $r2;
    const s3 = get_coeffs_bez3_bez3_dd_qmd(d0, r2);
    const s3_ = _d0 * r2_ + get_coeffs_bez3_bez3_dd_abs($s3);
    const $s4 = c0 * $r3;
    const s4 = get_coeffs_bez3_bez3_dd_qmd(c0, r3);
    const s4_ = _c0 * r3_ + get_coeffs_bez3_bez3_dd_abs($s4);
    const $s7 = $c1 * $s5;
    const s7 = get_coeffs_bez3_bez3_dd_qmq(c1, s5);
    const s7_ = c1_ * _s5 + _c1 * s5_ + 2 * get_coeffs_bez3_bez3_dd_abs($s7);
    const $s8 = $d1 * $s6;
    const s8 = get_coeffs_bez3_bez3_dd_qmq(d1, s6);
    const s8_ = d1_ * _s6 + _d1 * s6_ + 2 * get_coeffs_bez3_bez3_dd_abs($s8);
    const $s9 = c0 * $r2;
    const s9 = get_coeffs_bez3_bez3_dd_qmd(c0, r2);
    const s9_ = _c0 * r2_ + get_coeffs_bez3_bez3_dd_abs($s9);
    const $sa = d0 * $r3;
    const sa = get_coeffs_bez3_bez3_dd_qmd(d0, r3);
    const sa_ = _d0 * r3_ + get_coeffs_bez3_bez3_dd_abs($sa);
    const $sb = $c2 * $c1c1;
    const sb = get_coeffs_bez3_bez3_dd_qmq(c2, c1c1);
    const sb_ = c2_ * _c1c1 + _c2 * c1c1_ + 2 * get_coeffs_bez3_bez3_dd_abs($sb);
    const $sc = $d2 * $d1d1;
    const sc = get_coeffs_bez3_bez3_dd_qmq(d2, d1d1);
    const sc_ = d2_ * _d1d1 + _d2 * d1d1_ + 2 * get_coeffs_bez3_bez3_dd_abs($sc);
    const $sd = $s1 + $s3;
    const sd = get_coeffs_bez3_bez3_dd_qaq(s1, s3);
    const sd_ = s1_ + s3_ + get_coeffs_bez3_bez3_dd_abs($sd);
    const $se = $s2 + $s4;
    const se = get_coeffs_bez3_bez3_dd_qaq(s2, s4);
    const se_ = s2_ + s4_ + get_coeffs_bez3_bez3_dd_abs($se);
    const $sf = $sd + $s7;
    const sf = get_coeffs_bez3_bez3_dd_qaq(sd, s7);
    const _sf = get_coeffs_bez3_bez3_dd_abs($sf);
    const sf_ = sd_ + s7_ + _sf;
    const $sg = $se + $s8;
    const sg = get_coeffs_bez3_bez3_dd_qaq(se, s8);
    const _sg = get_coeffs_bez3_bez3_dd_abs($sg);
    const sg_ = se_ + s8_ + _sg;
    const $sh = $s9 + $sb;
    const sh = get_coeffs_bez3_bez3_dd_qaq(s9, sb);
    const _sh = get_coeffs_bez3_bez3_dd_abs($sh);
    const sh_ = s9_ + sb_ + _sh;
    const $si = $sa + $sc;
    const si = get_coeffs_bez3_bez3_dd_qaq(sa, sc);
    const _si = get_coeffs_bez3_bez3_dd_abs($si);
    const si_ = sa_ + sc_ + _si;
    const $sj = $vₓₓᵧ * $sf;
    const sj = get_coeffs_bez3_bez3_dd_qmq(vₓₓᵧ, sf);
    const sj_ = vₓₓᵧ_ * _sf + _vₓₓᵧ * sf_ + 2 * get_coeffs_bez3_bez3_dd_abs($sj);
    const $sk = $vₓᵧᵧ * $sg;
    const sk = get_coeffs_bez3_bez3_dd_qmq(vₓᵧᵧ, sg);
    const sk_ = vₓᵧᵧ_ * _sg + _vₓᵧᵧ * sg_ + 2 * get_coeffs_bez3_bez3_dd_abs($sk);
    const $sl = $vₓₓₓ * $sh;
    const sl = get_coeffs_bez3_bez3_dd_qmq(vₓₓₓ, sh);
    const sl_ = vₓₓₓ_ * _sh + _vₓₓₓ * sh_ + 2 * get_coeffs_bez3_bez3_dd_abs($sl);
    const $sm = $vᵧᵧᵧ * $si;
    const sm = get_coeffs_bez3_bez3_dd_qmq(vᵧᵧᵧ, si);
    const sm_ = vᵧᵧᵧ_ * _si + _vᵧᵧᵧ * si_ + 2 * get_coeffs_bez3_bez3_dd_abs($sm);
    const $sn = $sl + $sm;
    const _sn = get_coeffs_bez3_bez3_dd_abs($sn);
    const sn = get_coeffs_bez3_bez3_dd_qaq(sl, sm);
    const sn_ = sl_ + sm_ + _sn;
    const $so = $sj + $sk;
    const so = get_coeffs_bez3_bez3_dd_qaq(sj, sk);
    const so_ = sj_ + sk_ + get_coeffs_bez3_bez3_dd_abs($so);
    const $sp = $so + 3 * $sn;
    const sp = get_coeffs_bez3_bez3_dd_qaq(so, get_coeffs_bez3_bez3_dd_qmd(3, sn));
    const sp_ = so_ + 3 * (sn_ + _sn) + get_coeffs_bez3_bez3_dd_abs($sp);
    const $ss = $vₓᵧ * $r1;
    const ss = get_coeffs_bez3_bez3_dd_qmq(vₓᵧ, r1);
    const ss_ = vₓᵧ_ * _r1 + _vₓᵧ * r1_ + 2 * get_coeffs_bez3_bez3_dd_abs($ss);
    const $st = $vₓₓ * $r2;
    const st = get_coeffs_bez3_bez3_dd_qmq(vₓₓ, r2);
    const st_ = vₓₓ_ * _r2 + _vₓₓ * r2_ + 2 * get_coeffs_bez3_bez3_dd_abs($st);
    const $sq = $ss + $st;
    const sq = get_coeffs_bez3_bez3_dd_qaq(ss, st);
    const sq_ = ss_ + st_ + get_coeffs_bez3_bez3_dd_abs($sq);
    const $su = $vᵧᵧ * $r3;
    const su = get_coeffs_bez3_bez3_dd_qmq(vᵧᵧ, r3);
    const su_ = vᵧᵧ_ * _r3 + _vᵧᵧ * r3_ + 2 * get_coeffs_bez3_bez3_dd_abs($su);
    const $sr = $sq + $su;
    const sr = get_coeffs_bez3_bez3_dd_qaq(sq, su);
    const sr_ = sq_ + su_ + get_coeffs_bez3_bez3_dd_abs($sr);
    const $v4 = $sp + $sr;
    const v4 = get_coeffs_bez3_bez3_dd_qaq(sp, sr);
    const v4_ = sp_ + sr_ + get_coeffs_bez3_bez3_dd_abs($v4);
    //const r6 = c1d2 + c2d1;
    //const r7 = c3d0 + c0d3;
    //const r8 = c1c2 + c0c3;
    //const r9 = d1d2 + d0d3;
    //const v3 =
    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +
    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +
    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + 
    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +
    //    vₓᵧ*(r7 + r6) +
    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +
    //    vₓ*c3 + vᵧ*d3;
    const $r6 = $c1d2 + $c2d1;
    const r6 = get_coeffs_bez3_bez3_dd_qaq(c1d2, c2d1);
    const r6_ = c1d2_ + c2d1_ + get_coeffs_bez3_bez3_dd_abs($r6);
    const $r7 = $c3d0 + $c0d3;
    const r7 = get_coeffs_bez3_bez3_dd_qaq(c3d0, c0d3);
    const r7_ = c3d0_ + c0d3_ + get_coeffs_bez3_bez3_dd_abs($r7);
    const $r8 = $c1c2 + $c0c3;
    const r8 = get_coeffs_bez3_bez3_dd_qaq(c1c2, c0c3);
    const r8_ = c1c2_ + c0c3_ + get_coeffs_bez3_bez3_dd_abs($r8);
    const _r8 = get_coeffs_bez3_bez3_dd_abs($r8);
    const $r9 = $d1d2 + $d0d3;
    const r9 = get_coeffs_bez3_bez3_dd_qaq(d1d2, d0d3);
    const r9_ = d1d2_ + d0d3_ + get_coeffs_bez3_bez3_dd_abs($r9);
    const _r9 = get_coeffs_bez3_bez3_dd_abs($r9);
    const $m1 = 2 * $r6 + $c3d0;
    const m1 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(r6), c3d0);
    const m1_ = 2 * r6_ + c3d0_ + get_coeffs_bez3_bez3_dd_abs($m1);
    const $m2 = 2 * $r6 + $c0d3;
    const m2 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(r6), c0d3);
    const m2_ = 2 * r6_ + c0d3_ + get_coeffs_bez3_bez3_dd_abs($m2);
    const $m3 = 2 * $c2d0 + $c1d1;
    const m3 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(c2d0), c1d1);
    const _m3 = get_coeffs_bez3_bez3_dd_abs($m3);
    const m3_ = 2 * c2d0_ + c1d1_ + _m3;
    const $m4 = 2 * $c0d2 + $c1d1;
    const m4 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(c0d2), c1d1);
    const _m4 = get_coeffs_bez3_bez3_dd_abs($m4);
    const m4_ = 2 * c0d2_ + c1d1_ + _m4;
    const $m5 = $r8 + $c1c2;
    const m5 = get_coeffs_bez3_bez3_dd_qaq(r8, c1c2);
    const m5_ = r8_ + c1c2_ + get_coeffs_bez3_bez3_dd_abs($m5);
    const $m6 = $r9 + $d1d2;
    const m6 = get_coeffs_bez3_bez3_dd_qaq(r9, d1d2);
    const m6_ = r9_ + d1d2_ + get_coeffs_bez3_bez3_dd_abs($m6);
    const $q3 = 3 * c0;
    const q3 = get_coeffs_bez3_bez3_dd_tp(3, c0); // error free
    const $m7 = $q3 * $m5;
    const m7 = get_coeffs_bez3_bez3_dd_qmq(q3, m5);
    const m7_ = get_coeffs_bez3_bez3_dd_abs($q3) * m5_ + 2 * get_coeffs_bez3_bez3_dd_abs($m7);
    const $q4 = 3 * d0;
    const q4 = get_coeffs_bez3_bez3_dd_tp(3, d0); // error free
    const $m8 = $q4 * $m6;
    const m8 = get_coeffs_bez3_bez3_dd_qmq(q4, m6);
    const m8_ = get_coeffs_bez3_bez3_dd_abs($q4) * m6_ + 2 * get_coeffs_bez3_bez3_dd_abs($m8);
    const $m9 = $c1 * $c1c1;
    const m9 = get_coeffs_bez3_bez3_dd_qmq(c1, c1c1);
    const m9_ = c1_ * _c1c1 + _c1 * c1c1_ + 2 * get_coeffs_bez3_bez3_dd_abs($m9);
    const $ma = $d1 * $d1d1;
    const ma = get_coeffs_bez3_bez3_dd_qmq(d1, d1d1);
    const ma_ = d1_ * _d1d1 + _d1 * d1d1_ + 2 * get_coeffs_bez3_bez3_dd_abs($ma);
    const $mb = $vₓₓ * $r8;
    const mb = get_coeffs_bez3_bez3_dd_qmq(vₓₓ, r8);
    const mb_ = vₓₓ_ * _r8 + _vₓₓ * r8_ + get_coeffs_bez3_bez3_dd_abs($mb);
    const $mc = $vᵧᵧ * $r9;
    const mc = get_coeffs_bez3_bez3_dd_qmq(vᵧᵧ, r9);
    const mc_ = vᵧᵧ_ * _r9 + _vᵧᵧ * r9_ + get_coeffs_bez3_bez3_dd_abs($mc);
    const $md = $m1 + $r7;
    const md = get_coeffs_bez3_bez3_dd_qaq(m1, r7);
    const md_ = m1_ + r7_ + get_coeffs_bez3_bez3_dd_abs($md);
    const $me = $m2 + $r7;
    const me = get_coeffs_bez3_bez3_dd_qaq(m2, r7);
    const me_ = m2_ + r7_ + get_coeffs_bez3_bez3_dd_abs($me);
    const $mf = c0 * $md;
    const mf = get_coeffs_bez3_bez3_dd_qmd(c0, md);
    const mf_ = _c0 * md_ + get_coeffs_bez3_bez3_dd_abs($mf);
    const $mg = d0 * $me;
    const mg = get_coeffs_bez3_bez3_dd_qmd(d0, me);
    const mg_ = _d0 * me_ + get_coeffs_bez3_bez3_dd_abs($mg);
    const $mh = $c1 * $m3;
    const mh = get_coeffs_bez3_bez3_dd_qmq(c1, m3);
    const mh_ = c1_ * _m3 + _c1 * m3_ + 2 * get_coeffs_bez3_bez3_dd_abs($mh);
    const $mi = $d1 * $m4;
    const mi = get_coeffs_bez3_bez3_dd_qmq(d1, m4);
    const mi_ = d1_ * _m4 + _d1 * m4_ + 2 * get_coeffs_bez3_bez3_dd_abs($mi);
    const $mj = $c3 * $vₓ;
    const mj = get_coeffs_bez3_bez3_dd_qmq(c3, vₓ);
    const mj_ = c3_ * _vₓ + _c3 * vₓ_ + 2 * get_coeffs_bez3_bez3_dd_abs($mj);
    const $mk = $d3 * $vᵧ;
    const mk = get_coeffs_bez3_bez3_dd_qmq(d3, vᵧ);
    const mk_ = d3_ * _vᵧ + _d3 * vᵧ_ + 2 * get_coeffs_bez3_bez3_dd_abs($mk);
    const $ml = $mf + $mh;
    const ml = get_coeffs_bez3_bez3_dd_qaq(mf, mh);
    const _ml = get_coeffs_bez3_bez3_dd_abs($ml);
    const ml_ = mf_ + mh_ + _ml;
    const $mm = $mg + $mi;
    const mm = get_coeffs_bez3_bez3_dd_qaq(mg, mi);
    const _mm = get_coeffs_bez3_bez3_dd_abs($mm);
    const mm_ = mg_ + mi_ + _mm;
    const $mn = $m7 + $m9;
    const mn = get_coeffs_bez3_bez3_dd_qaq(m7, m9);
    const _mn = get_coeffs_bez3_bez3_dd_abs($mn);
    const mn_ = m7_ + m9_ + _mn;
    const $mo = $m8 + $ma;
    const mo = get_coeffs_bez3_bez3_dd_qaq(m8, ma);
    const _mo = get_coeffs_bez3_bez3_dd_abs($mo);
    const mo_ = m8_ + ma_ + _mo;
    const $mp = $r7 + $r6;
    const mp = get_coeffs_bez3_bez3_dd_qaq(r7, r6);
    const _mp = get_coeffs_bez3_bez3_dd_abs($mp);
    const mp_ = r7_ + r6_ + _mp;
    const $mq = 2 * ($mb + $mc);
    const mq = get_coeffs_bez3_bez3_dd_qm2(get_coeffs_bez3_bez3_dd_qaq(mb, mc));
    const mq_ = 2 * (mb_ + mc_) + get_coeffs_bez3_bez3_dd_abs($mq);
    const $mr = $vₓₓᵧ * $ml;
    const mr = get_coeffs_bez3_bez3_dd_qmq(vₓₓᵧ, ml);
    const mr_ = vₓₓᵧ_ * _ml + _vₓₓᵧ * ml_ + 2 * get_coeffs_bez3_bez3_dd_abs($mr);
    const $ms = $vₓᵧᵧ * $mm;
    const ms = get_coeffs_bez3_bez3_dd_qmq(vₓᵧᵧ, mm);
    const ms_ = vₓᵧᵧ_ * _mm + _vₓᵧᵧ * mm_ + 2 * get_coeffs_bez3_bez3_dd_abs($ms);
    const $mt = $vₓₓₓ * $mn;
    const mt = get_coeffs_bez3_bez3_dd_qmq(vₓₓₓ, mn);
    const mt_ = vₓₓₓ_ * _mn + _vₓₓₓ * mn_ + 2 * get_coeffs_bez3_bez3_dd_abs($mt);
    const $mu = $vᵧᵧᵧ * $mo;
    const mu = get_coeffs_bez3_bez3_dd_qmq(vᵧᵧᵧ, mo);
    const mu_ = vᵧᵧᵧ_ * _mo + _vᵧᵧᵧ * mo_ + 2 * get_coeffs_bez3_bez3_dd_abs($mu);
    const $mv = $vₓᵧ * $mp;
    const mv = get_coeffs_bez3_bez3_dd_qmq(vₓᵧ, mp);
    const mv_ = vₓᵧ_ * _mp + _vₓᵧ * mp_ + 2 * get_coeffs_bez3_bez3_dd_abs($mv);
    const $mw = $mr + $ms;
    const mw = get_coeffs_bez3_bez3_dd_qaq(mr, ms);
    const mw_ = mr_ + ms_ + get_coeffs_bez3_bez3_dd_abs($mw);
    const $mx = $mt + $mu;
    const mx = get_coeffs_bez3_bez3_dd_qaq(mt, mu);
    const mx_ = mt_ + mu_ + get_coeffs_bez3_bez3_dd_abs($mx);
    const $my = $mv + $mq;
    const my = get_coeffs_bez3_bez3_dd_qaq(mv, mq);
    const my_ = mv_ + mq_ + get_coeffs_bez3_bez3_dd_abs($my);
    const $mz = $mj + $mk;
    const mz = get_coeffs_bez3_bez3_dd_qaq(mj, mk);
    const mz_ = mj_ + mk_ + get_coeffs_bez3_bez3_dd_abs($mz);
    const $n1 = $mw + $mx;
    const n1 = get_coeffs_bez3_bez3_dd_qaq(mw, mx);
    const n1_ = mw_ + mx_ + get_coeffs_bez3_bez3_dd_abs($n1);
    const $n2 = $my + $mz;
    const n2 = get_coeffs_bez3_bez3_dd_qaq(my, mz);
    const n2_ = my_ + mz_ + get_coeffs_bez3_bez3_dd_abs($n2);
    const $v3 = $n1 + $n2;
    const v3 = get_coeffs_bez3_bez3_dd_qaq(n1, n2);
    const v3_ = n1_ + n2_ + get_coeffs_bez3_bez3_dd_abs($v3);
    //const ra = c1d1 + c2d0;
    //const rb = c1d1 + c0d2;
    //const v2 =
    //    vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +
    //    vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +
    //    3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + 
    //    3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +
    //    vₓᵧ*(ra + c0d2) +
    //    vₓₓ*(2*c0c2 + c1c1) + 
    //    vᵧᵧ*(2*d0d2 + d1d1) +
    //    c2*vₓ + d2*vᵧ;
    const $ra = $c1d1 + $c2d0;
    const ra = get_coeffs_bez3_bez3_dd_qaq(c1d1, c2d0);
    const ra_ = c1d1_ + c2d0_ + get_coeffs_bez3_bez3_dd_abs($ra);
    const $rb = $c1d1 + $c0d2;
    const rb = get_coeffs_bez3_bez3_dd_qaq(c1d1, c0d2);
    const rb_ = c1d1_ + c0d2_ + get_coeffs_bez3_bez3_dd_abs($rb);
    const $l1 = 2 * $ra + $c0d2;
    const l1 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(ra), c0d2);
    const l1_ = 2 * ra_ + c0d2_ + get_coeffs_bez3_bez3_dd_abs($l1);
    const $l2 = 2 * $rb + $c2d0;
    const l2 = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(rb), c2d0);
    const l2_ = 2 * rb_ + c2d0_ + get_coeffs_bez3_bez3_dd_abs($l2);
    const $l3 = c0 * $l1;
    const l3 = get_coeffs_bez3_bez3_dd_qmd(c0, l1);
    const l3_ = _c0 * l1_ + get_coeffs_bez3_bez3_dd_abs($l3);
    const $l4 = d0 * $c1c1;
    const l4 = get_coeffs_bez3_bez3_dd_qmd(d0, c1c1);
    const l4_ = _d0 * c1c1_ + get_coeffs_bez3_bez3_dd_abs($l4);
    const $l5 = d0 * $l2;
    const l5 = get_coeffs_bez3_bez3_dd_qmd(d0, l2);
    const l5_ = _d0 * l2_ + get_coeffs_bez3_bez3_dd_abs($l5);
    const $l6 = c0 * $d1d1;
    const l6 = get_coeffs_bez3_bez3_dd_qmd(c0, d1d1);
    const l6_ = _c0 * d1d1_ + get_coeffs_bez3_bez3_dd_abs($l6);
    const $l7 = c0 * $c1c1;
    const l7 = get_coeffs_bez3_bez3_dd_qmd(c0, c1c1);
    const l7_ = _c0 * c1c1_ + get_coeffs_bez3_bez3_dd_abs($l7);
    const $l8 = $c2 * $c0c0;
    const l8 = get_coeffs_bez3_bez3_dd_qmq(c2, c0c0);
    const l8_ = c2_ * _c0c0 + 2 * get_coeffs_bez3_bez3_dd_abs($l8);
    const $l9 = d0 * $d1d1;
    const l9 = get_coeffs_bez3_bez3_dd_qmd(d0, d1d1);
    const l9_ = _d0 * d1d1_ + get_coeffs_bez3_bez3_dd_abs($l9);
    const $la = $d2 * $d0d0;
    const la = get_coeffs_bez3_bez3_dd_qmq(d2, d0d0);
    const la_ = d2_ * _d0d0 + 2 * get_coeffs_bez3_bez3_dd_abs($la);
    const $lb = $l3 + $l4;
    const lb = get_coeffs_bez3_bez3_dd_qaq(l3, l4);
    const _lb = l3_ + l4_ + get_coeffs_bez3_bez3_dd_abs($lb);
    const lb_ = l3_ + l4_ + _lb;
    const $lc = $l5 + $l6;
    const lc = get_coeffs_bez3_bez3_dd_qaq(l5, l6);
    const _lc = l5_ + l6_ + get_coeffs_bez3_bez3_dd_abs($lc);
    const lc_ = l5_ + l6_ + _lc;
    const $ld = $l7 + $l8;
    const ld = get_coeffs_bez3_bez3_dd_qaq(l7, l8);
    const _ld = get_coeffs_bez3_bez3_dd_abs($ld);
    const ld_ = l7_ + l8_ + _ld;
    const $le = $l9 + $la;
    const le = get_coeffs_bez3_bez3_dd_qaq(l9, la);
    const _le = get_coeffs_bez3_bez3_dd_abs($le);
    const le_ = l9_ + la_ + _le;
    const $lf = $vₓₓₓ * $ld;
    const lf = get_coeffs_bez3_bez3_dd_qmq(vₓₓₓ, ld);
    const lf_ = vₓₓₓ_ * _ld + _vₓₓₓ * ld_ + 2 * get_coeffs_bez3_bez3_dd_abs($lf);
    const $lg = $vᵧᵧᵧ * $le;
    const lg = get_coeffs_bez3_bez3_dd_qmq(vᵧᵧᵧ, le);
    const lg_ = vᵧᵧᵧ_ * _le + _vᵧᵧᵧ * le_ + 2 * get_coeffs_bez3_bez3_dd_abs($lg);
    const $lh = 3 * ($lf + $lg);
    const lh = get_coeffs_bez3_bez3_dd_qmd(3, get_coeffs_bez3_bez3_dd_qaq(lf, lg));
    const lh_ = 3 * (lf_ + lg_) + 2 * get_coeffs_bez3_bez3_dd_abs($lh);
    const $li = $ra + $c0d2;
    const li = get_coeffs_bez3_bez3_dd_qaq(ra, c0d2);
    const _li = get_coeffs_bez3_bez3_dd_abs($li);
    const li_ = ra_ + c0d2_ + _li;
    const $lj = 2 * $c0c2 + $c1c1;
    const lj = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(c0c2), c1c1);
    const _lj = get_coeffs_bez3_bez3_dd_abs($lj);
    const lj_ = 2 * c0c2_ + c1c1_ + _lj;
    const $lk = 2 * $d0d2 + $d1d1;
    const lk = get_coeffs_bez3_bez3_dd_qaq(get_coeffs_bez3_bez3_dd_qm2(d0d2), d1d1);
    const _lk = get_coeffs_bez3_bez3_dd_abs($lk);
    const lk_ = 2 * d0d2_ + d1d1_ + _lk;
    const $ll = $vₓₓᵧ * $lb;
    const ll = get_coeffs_bez3_bez3_dd_qmq(vₓₓᵧ, lb);
    const ll_ = vₓₓᵧ_ * _lb + _vₓₓᵧ * lb_ + 2 * get_coeffs_bez3_bez3_dd_abs($ll);
    const $lm = $vₓᵧᵧ * $lc;
    const lm = get_coeffs_bez3_bez3_dd_qmq(vₓᵧᵧ, lc);
    const lm_ = vₓᵧᵧ_ * _lc + _vₓᵧᵧ * lc_ + 2 * get_coeffs_bez3_bez3_dd_abs($lm);
    const $ln = $vₓᵧ * $li;
    const ln = get_coeffs_bez3_bez3_dd_qmq(vₓᵧ, li);
    const ln_ = vₓᵧ_ * _li + _vₓᵧ * li_ + 2 * get_coeffs_bez3_bez3_dd_abs($ln);
    const $lo = $vₓₓ * $lj;
    const lo = get_coeffs_bez3_bez3_dd_qmq(vₓₓ, lj);
    const lo_ = vₓₓ_ * _lj + _vₓₓ * lj_ + 2 * get_coeffs_bez3_bez3_dd_abs($lo);
    const $lp = $vᵧᵧ * $lk;
    const lp = get_coeffs_bez3_bez3_dd_qmq(vᵧᵧ, lk);
    const lp_ = vᵧᵧ_ * _lk + _vᵧᵧ * lk_ + 2 * get_coeffs_bez3_bez3_dd_abs($lp);
    const $lq = $c2 * $vₓ;
    const lq = get_coeffs_bez3_bez3_dd_qmq(c2, vₓ);
    const lq_ = c2_ * _vₓ + _c2 * vₓ_ + get_coeffs_bez3_bez3_dd_abs($lq);
    const $lr = $d2 * $vᵧ;
    const lr = get_coeffs_bez3_bez3_dd_qmq(d2, vᵧ);
    const lr_ = d2_ * _vᵧ + _d2 * vᵧ_ + get_coeffs_bez3_bez3_dd_abs($lr);
    const $ls = $lq + $lr;
    const ls = get_coeffs_bez3_bez3_dd_qaq(lq, lr);
    const ls_ = lq_ + lr_ + get_coeffs_bez3_bez3_dd_abs($ls);
    const $lt = $ll + $lm;
    const lt = get_coeffs_bez3_bez3_dd_qaq(ll, lm);
    const lt_ = ll_ + lm_ + get_coeffs_bez3_bez3_dd_abs($lt);
    const $lu = $lh + $ln;
    const lu = get_coeffs_bez3_bez3_dd_qaq(lh, ln);
    const lu_ = lh_ + ln_ + get_coeffs_bez3_bez3_dd_abs($lu);
    const $lv = $lo + $lp;
    const lv = get_coeffs_bez3_bez3_dd_qaq(lo, lp);
    const lv_ = lo_ + lp_ + get_coeffs_bez3_bez3_dd_abs($lv);
    const $lw = $lt + $lu;
    const lw = get_coeffs_bez3_bez3_dd_qaq(lt, lu);
    const lw_ = lt_ + lu_ + get_coeffs_bez3_bez3_dd_abs($lw);
    const $lx = $lv + $ls;
    const lx = get_coeffs_bez3_bez3_dd_qaq(lv, ls);
    const lx_ = lv_ + ls_ + get_coeffs_bez3_bez3_dd_abs($lx);
    const $v2 = $lw + $lx;
    const v2 = get_coeffs_bez3_bez3_dd_qaq(lw, lx);
    const v2_ = lw_ + lx_ + get_coeffs_bez3_bez3_dd_abs($v2);
    //const rc = c1d0 + c0d1;
    //const v1 =
    //    vₓₓᵧ*c0*(rc + c1d0) +
    //    vₓᵧᵧ*d0*(rc + c0d1) +
    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +
    //    vₓᵧ*rc +
    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +
    //    c1*vₓ + d1*vᵧ ;
    const $rc = $c1d0 + $c0d1;
    const rc = get_coeffs_bez3_bez3_dd_qaq(c1d0, c0d1);
    const _rc = get_coeffs_bez3_bez3_dd_abs($rc);
    const rc_ = c1d0_ + c0d1_ + _rc;
    const $rd = c0 * $vₓₓᵧ;
    const rd = get_coeffs_bez3_bez3_dd_qmd(c0, vₓₓᵧ);
    const _rd = get_coeffs_bez3_bez3_dd_abs($rd);
    const rd_ = _c0 * vₓₓᵧ_ + _rd;
    const $re = d0 * $vₓᵧᵧ;
    const re = get_coeffs_bez3_bez3_dd_qmd(d0, vₓᵧᵧ);
    const _re = get_coeffs_bez3_bez3_dd_abs($re);
    const re_ = _d0 * vₓᵧᵧ_ + _re;
    const $rf = $rc + $c1d0;
    const rf = get_coeffs_bez3_bez3_dd_qaq(rc, c1d0);
    const _rf = get_coeffs_bez3_bez3_dd_abs($rf);
    const rf_ = rc_ + c1d0_ + _rf;
    const $rg = $rc + $c0d1;
    const rg = get_coeffs_bez3_bez3_dd_qaq(rc, c0d1);
    const _rg = get_coeffs_bez3_bez3_dd_abs($rg);
    const rg_ = rc_ + c0d1_ + _rg;
    const $rx = $c1 * $c0c0;
    const rx = get_coeffs_bez3_bez3_dd_qmq(c1, c0c0);
    const _rx = get_coeffs_bez3_bez3_dd_abs($rx);
    const rx_ = c1_ * _c0c0 + 2 * _rx;
    const $rh = $rx * $vₓₓₓ;
    const rh = get_coeffs_bez3_bez3_dd_qmq(rx, vₓₓₓ);
    const rh_ = rx_ * _vₓₓₓ + _rx * vₓₓₓ_ + 2 * get_coeffs_bez3_bez3_dd_abs($rh);
    const $ry = $d1 * $d0d0;
    const ry = get_coeffs_bez3_bez3_dd_qmq(d1, d0d0);
    const _ry = get_coeffs_bez3_bez3_dd_abs($ry);
    const ry_ = d1_ * _d0d0 + 2 * _ry;
    const $ri = $ry * $vᵧᵧᵧ;
    const ri = get_coeffs_bez3_bez3_dd_qmq(ry, vᵧᵧᵧ);
    const ri_ = ry_ * _vᵧᵧᵧ + _ry * vᵧᵧᵧ_ + 2 * get_coeffs_bez3_bez3_dd_abs($ri);
    const $rj = $vₓᵧ * $rc;
    const rj = get_coeffs_bez3_bez3_dd_qmq(vₓᵧ, rc);
    const rj_ = vₓᵧ_ * _rc + _vₓᵧ * rc_ + 2 * get_coeffs_bez3_bez3_dd_abs($rj);
    const $rk = $c0c1 * $vₓₓ;
    const rk = get_coeffs_bez3_bez3_dd_qmq(c0c1, vₓₓ);
    const rk_ = c0c1_ * _vₓₓ + _c0c1 * vₓₓ_ + 2 * get_coeffs_bez3_bez3_dd_abs($rk);
    const $rl = $d0d1 * $vᵧᵧ;
    const rl = get_coeffs_bez3_bez3_dd_qmq(d0d1, vᵧᵧ);
    const rl_ = d0d1_ * _vᵧᵧ + _d0d1 * vᵧᵧ_ + 2 * get_coeffs_bez3_bez3_dd_abs($rl);
    const $rm = $rk + $rl;
    const rm = get_coeffs_bez3_bez3_dd_qaq(rk, rl);
    const rm_ = rk_ + rl_ + get_coeffs_bez3_bez3_dd_abs($rm);
    const $rn = $c1 * $vₓ;
    const rn = get_coeffs_bez3_bez3_dd_qmq(c1, vₓ);
    const rn_ = c1_ * _vₓ + _c1 * vₓ_ + get_coeffs_bez3_bez3_dd_abs($rn);
    const $ro = $d1 * $vᵧ;
    const ro = get_coeffs_bez3_bez3_dd_qmq(d1, vᵧ);
    const ro_ = d1_ * _vᵧ + _d1 * vᵧ_ + get_coeffs_bez3_bez3_dd_abs($ro);
    const $rp = $rn + $ro;
    const rp = get_coeffs_bez3_bez3_dd_qaq(rn, ro);
    const rp_ = rn_ + ro_ + get_coeffs_bez3_bez3_dd_abs($rp);
    const $rq = $rd * $rf;
    const rq = get_coeffs_bez3_bez3_dd_qmq(rd, rf);
    const rq_ = rd_ * _rf + _rd * rf_ + 2 * get_coeffs_bez3_bez3_dd_abs($rq);
    const $rr = $re * $rg;
    const rr = get_coeffs_bez3_bez3_dd_qmq(re, rg);
    const rr_ = re_ * _rg + _re * rg_ + 2 * get_coeffs_bez3_bez3_dd_abs($rr);
    const $rs = $rq + $rr;
    const rs = get_coeffs_bez3_bez3_dd_qaq(rq, rr);
    const rs_ = rq_ + rr_ + get_coeffs_bez3_bez3_dd_abs($rs);
    const $rt = 3 * ($rh + $ri);
    const rt = get_coeffs_bez3_bez3_dd_qmd(3, get_coeffs_bez3_bez3_dd_qaq(rh, ri));
    const rt_ = 3 * (rh_ + ri_) + 2 * get_coeffs_bez3_bez3_dd_abs($rt);
    const $ru = $rj + 2 * $rm;
    const ru = get_coeffs_bez3_bez3_dd_qaq(rj, get_coeffs_bez3_bez3_dd_qm2(rm));
    const ru_ = rj_ + 2 * rm_ + get_coeffs_bez3_bez3_dd_abs($ru);
    const $rv = $rs + $rt;
    const rv = get_coeffs_bez3_bez3_dd_qaq(rs, rt);
    const rv_ = rs_ + rt_ + get_coeffs_bez3_bez3_dd_abs($rv);
    const $rw = $ru + $rp;
    const rw = get_coeffs_bez3_bez3_dd_qaq(ru, rp);
    const rw_ = ru_ + rp_ + get_coeffs_bez3_bez3_dd_abs($rw);
    const $v1 = $rv + $rw;
    const v1 = get_coeffs_bez3_bez3_dd_qaq(rv, rw);
    const v1_ = rv_ + rw_ + get_coeffs_bez3_bez3_dd_abs($v1);
    //-----
    // v0
    //-----
    const $t1 = c0 * $vₓₓₓ;
    const t1 = get_coeffs_bez3_bez3_dd_qmd(c0, vₓₓₓ);
    const t1_ = _c0 * vₓₓₓ_ + get_coeffs_bez3_bez3_dd_abs($t1);
    const $t2 = d0 * $vₓₓᵧ;
    const t2 = get_coeffs_bez3_bez3_dd_qmd(d0, vₓₓᵧ);
    const t2_ = _d0 * vₓₓᵧ_ + get_coeffs_bez3_bez3_dd_abs($t2);
    const $p4 = $t1 + $t2;
    const p4 = get_coeffs_bez3_bez3_dd_qaq(t1, t2);
    const p4_ = t1_ + t2_ + get_coeffs_bez3_bez3_dd_abs($p4);
    const $t3 = c0 * $vₓᵧᵧ;
    const t3 = get_coeffs_bez3_bez3_dd_qmd(c0, vₓᵧᵧ);
    const t3_ = _c0 * vₓᵧᵧ_ + get_coeffs_bez3_bez3_dd_abs($t3);
    const $t4 = d0 * $vᵧᵧᵧ;
    const t4 = get_coeffs_bez3_bez3_dd_qmd(d0, vᵧᵧᵧ);
    const t4_ = _d0 * vᵧᵧᵧ_ + get_coeffs_bez3_bez3_dd_abs($t4);
    const $p5 = $t3 + $t4;
    const p5 = get_coeffs_bez3_bez3_dd_qaq(t3, t4);
    const p5_ = t3_ + t4_ + get_coeffs_bez3_bez3_dd_abs($p5);
    const $p7 = $p4 + $vₓₓ;
    const p7 = get_coeffs_bez3_bez3_dd_qaq(p4, vₓₓ);
    const _p7 = get_coeffs_bez3_bez3_dd_abs($p7);
    const p7_ = p4_ + vₓₓ_ + _p7;
    const $p8 = $p5 + $vᵧᵧ;
    const p8 = get_coeffs_bez3_bez3_dd_qaq(p5, vᵧᵧ);
    const _p8 = get_coeffs_bez3_bez3_dd_abs($p8);
    const p8_ = p5_ + vᵧᵧ_ + _p8;
    const $pc = $c0c0 * $p7;
    const pc = get_coeffs_bez3_bez3_dd_qmq(c0c0, p7);
    const pc_ = _c0c0 * p7_ + 2 * get_coeffs_bez3_bez3_dd_abs($pc);
    const $pd = $d0d0 * $p8;
    const pd = get_coeffs_bez3_bez3_dd_qmq(d0d0, p8);
    const pd_ = _d0d0 * p8_ + 2 * get_coeffs_bez3_bez3_dd_abs($pd);
    const $p6 = $pc + $pd;
    const p6 = get_coeffs_bez3_bez3_dd_qaq(pc, pd);
    const p6_ = pc_ + pd_ + get_coeffs_bez3_bez3_dd_abs($p6);
    const $pe = $c0d0 * $vₓᵧ;
    const pe = get_coeffs_bez3_bez3_dd_qmq(c0d0, vₓᵧ);
    const pe_ = _c0d0 * vₓᵧ_ + get_coeffs_bez3_bez3_dd_abs($pe);
    const $p9 = $p6 + $pe;
    const p9 = get_coeffs_bez3_bez3_dd_qaq(p6, pe);
    const p9_ = p6_ + pe_ + get_coeffs_bez3_bez3_dd_abs($p9);
    const $pf = c0 * $vₓ;
    const pf = get_coeffs_bez3_bez3_dd_qmd(c0, vₓ);
    const pf_ = _c0 * vₓ_ + get_coeffs_bez3_bez3_dd_abs($pf);
    const $pg = d0 * $vᵧ;
    const pg = get_coeffs_bez3_bez3_dd_qmd(d0, vᵧ);
    const pg_ = _d0 * vᵧ_ + get_coeffs_bez3_bez3_dd_abs($pg);
    const $pa = $pf + $pg;
    const pa = get_coeffs_bez3_bez3_dd_qaq(pf, pg);
    const pa_ = pf_ + pg_ + get_coeffs_bez3_bez3_dd_abs($pa);
    const $pb = $p9 + $pa;
    const pb = get_coeffs_bez3_bez3_dd_qaq(p9, pa);
    const pb_ = p9_ + pa_ + get_coeffs_bez3_bez3_dd_abs($pb);
    const $v0 = $pb + $v;
    const v0 = get_coeffs_bez3_bez3_dd_qaq(pb, v);
    const v0_ = pb_ + v_ + get_coeffs_bez3_bez3_dd_abs($v0);
    return {
        coeffs: [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0],
        errBound: [get_coeffs_bez3_bez3_dd_3 * v9_, get_coeffs_bez3_bez3_dd_3 * v8_, get_coeffs_bez3_bez3_dd_3 * v7_, get_coeffs_bez3_bez3_dd_3 * v6_, get_coeffs_bez3_bez3_dd_3 * v5_, get_coeffs_bez3_bez3_dd_3 * v4_, get_coeffs_bez3_bez3_dd_3 * v3_, get_coeffs_bez3_bez3_dd_3 * v2_, get_coeffs_bez3_bez3_dd_3 * v1_, get_coeffs_bez3_bez3_dd_3 * v0_]
    };
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-xy/exact/get-xy-exact.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_xy_exact_td = two_diff_twoDiff;
const get_xy_exact_ts = two_sum_twoSum;
const get_xy_exact_sce = scale_expansion_scaleExpansion2;
const ge = growExpansion;
const get_xy_exact_eAdd = eAdd;
/**
 * Returns the exact power basis representation of a line, quadratic or
 * cubic bezier.
 *
 * * returns the power basis polynomial from highest power to lowest,
 * e.g. `at^3 + bt^2 + ct + d` is returned as `[a,b,c,d]`
 * * the precision of the returned coefficients can be high, e.g. for a cubic
 * the precision can require 6 doubles for the t^3 term.
 *
 * @param ps An order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getXYExact(ps) {
    if (ps.length === 4) {
        return getXY3Exact(ps);
    }
    if (ps.length === 3) {
        return getXY2Exact(ps);
    }
    return getXY1Exact(ps);
}
/**
 * Returns the exact power basis representation of a line, quadratic or
 * cubic bezier.
 *
 * * returns the power basis polynomial from highest power to lowest,
 * e.g. `at^3 + bt^2 + ct + d` is returned as `[a,b,c,d]`
 *
 * @param ps A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getXY3Exact(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    return [[
            // (x3 - x0) + 3*(x1 - x2)
            get_xy_exact_eAdd(get_xy_exact_td(x3, x0), get_xy_exact_sce(3, get_xy_exact_td(x1, x2)))
            // OR
            // (x3 - x0) - (2*x2 + x2) + (2*x1 + x1)
            //eAdd(eAdd(td(x3,x0), ts(-2*x2, -x2)), ts(2*x1, x1))
            ,
            // 3*((x2 + x0) - 2*x1)
            get_xy_exact_sce(3, ge(get_xy_exact_ts(x2, x0), -2 * x1)),
            // 3*(x1 - x0)
            get_xy_exact_sce(3, get_xy_exact_td(x1, x0)),
            // x0
            x0
        ], [
            //ge(ge(sce(3, td(y1, y2)), y3), -y0),
            get_xy_exact_eAdd(get_xy_exact_td(y3, y0), get_xy_exact_sce(3, get_xy_exact_td(y1, y2))),
            //sce(3, ge(td(y2, 2*y1), y0)),
            get_xy_exact_sce(3, ge(get_xy_exact_ts(y2, y0), -2 * y1)),
            get_xy_exact_sce(3, get_xy_exact_td(y1, y0)),
            y0
        ]];
}
/**
 * Returns the exact power basis representation of a line, quadratic or
 * cubic bezier.
 *
 * * returns the power basis polynomial from highest power to lowest,
 * e.g. `at^3 + bt^2 + ct + d` is returned as `[a,b,c,d]`
 *
 * @param ps A quadratic bezier curve, e.g. [[0,0],[1,1],[2,0]]
 *
 * @doc
 */
function getXY2Exact(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    return [[
            // x2 - 2*x1 + x0
            ge(get_xy_exact_ts(x2, x0), -2 * x1),
            // 2*(x1 - x0)
            get_xy_exact_td(2 * x1, 2 * x0),
            //x0
            x0
        ], [
            ge(get_xy_exact_ts(y2, y0), -2 * y1),
            get_xy_exact_td(2 * y1, 2 * y0),
            y0
        ]];
}
/**
 * Returns the exact power basis representation of a line, quadratic or
 * cubic bezier.
 *
 * * returns the power basis polynomial from highest power to lowest,
 * e.g. `at^3 + bt^2 + ct + d` is returned as `[a,b,c,d]`
 *
 * @param ps An order 1 bezier curve (a line), e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getXY1Exact(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    return [[
            //x1 - x0,
            get_xy_exact_td(x1, x0),
            //x0
            x0
        ], [
            get_xy_exact_td(y1, y0),
            y0
        ]];
}


;// CONCATENATED MODULE: ./src/implicit-form/exact/get-implicit-form1-exact.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗

// TODO - investigate order 1 bezier curves (points!)

const get_implicit_form1_exact_sce = scale_expansion_scaleExpansion2;
const edif = e_diff_eDiff;
const get_implicit_form1_exact_eno = eNegativeOf;
const get_implicit_form1_exact_eSign = e_sign_eSign;
// TODO - consider adding getImplicitForm0
/**
 * Returns the exact implicit form of the given linear bezier curve (a line)
 * or `undefined` if the line is really a point.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓx + vᵧy + v = 0`
 * * **precondition:** underflow/overflow
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm1Exact(ps) {
    return getImplicitForm1ExactPb(getXY1Exact(ps));
}
/**
 * The power basis version of [[getImplicitForm1ExactAnyBitlength]].
 *
 * @param pspb the power basis representation of a linear bezier curve that
 * can be found via [[getXYExactAnyBitlength1]]
 *
 * @internal
 */
function getImplicitForm1ExactPb(pspb) {
    const [[a1, a0], [b1, b0]] = pspb;
    if (get_implicit_form1_exact_eSign(a1) === 0 && get_implicit_form1_exact_eSign(b1) === 0) {
        // the input bezier curve is in fact not linear but has order < 1
        // it is a point and no implicit form is possible
        return undefined;
    }
    const vₓ = get_implicit_form1_exact_eno(b1);
    const vᵧ = a1;
    //const v = a1*b0 - a0*b1;
    const v = edif(get_implicit_form1_exact_sce(a0, b1), get_implicit_form1_exact_sce(b0, a1));
    return { vₓ, vᵧ, v };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez1-exact.ts


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗

const get_coeffs_bez1_bez1_exact_sce = scale_expansion_scaleExpansion2;
const get_coeffs_bez1_bez1_exact_epr = expansion_product_expansionProduct;
const get_coeffs_bez1_bez1_exact_fes = fastExpansionSum;
const get_coeffs_bez1_bez1_exact_eSign = e_sign_eSign;
/**
 * Returns an error-free polynomial in 1 variable whose roots are the parameter
 * values of the intersection points of two order 1 bezier curves (i.e. 2 lines).
 *
 * The returned polynomial degree will be 1
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** TODO - add underflow / overflow conditions
 * * the returned polynomial coefficients are exact (i.e. error-free)
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
// TODO - rename all these by chopping off the AnyBitlength part since it
// is now implied implicitly
function getCoeffsBez1Bez1Exact(ps1, ps2) {
    /** ps1 in power bases */
    const ps1pb = getXY1Exact(ps1);
    //const [[e1,e0],[f1,f0]] = ps1pb;
    // if both polynomials' linear terms are exactly zero then it really is a point
    if (get_coeffs_bez1_bez1_exact_eSign(ps1pb[0][0]) === 0 && get_coeffs_bez1_bez1_exact_eSign(ps1pb[1][0]) === 0) {
        // the input bezier curve is in fact not a line but has order < 1,
        // i.e. it is a point
        // TODO
        //return getCoeffsBez0Bez3ExactAnyBitlength([ps1[0]], ps2]);
    }
    const [[c1, c0], [d1, d0]] = getXY1Exact(ps2);
    if (get_coeffs_bez1_bez1_exact_eSign(c1) === 0 && get_coeffs_bez1_bez1_exact_eSign(d1) === 0) {
        // the input bezier curve is in fact not a line but has order < 1,
        // i.e. it is a point
        // TODO
        //return getCoeffsBez2Bez0ExactAnyBitlength(ps1, [ps2[0]]);
    }
    const { vₓ, vᵧ, v } = 
    // this type coercion is justified since we already checked that the
    // curve really has order 1
    getImplicitForm1ExactPb(ps1pb);
    //const v1 = c1*vₓ + d1*vᵧ;
    const p1 = get_coeffs_bez1_bez1_exact_epr(c1, vₓ);
    const p2 = get_coeffs_bez1_bez1_exact_epr(d1, vᵧ);
    const v1 = get_coeffs_bez1_bez1_exact_fes(p1, p2);
    //const v0 = c0*vₓ + d0*vᵧ + v_0;
    const p3 = get_coeffs_bez1_bez1_exact_sce(c0, vₓ);
    const p4 = get_coeffs_bez1_bez1_exact_sce(d0, vᵧ);
    const p5 = get_coeffs_bez1_bez1_exact_fes(p3, p4);
    const v0 = get_coeffs_bez1_bez1_exact_fes(p5, v);
    const r = [v1, v0];
    // remove leading zero coefficients
    //while (r.length > 1 && eSign(r[0]) === 0) {
    //    r.shift();
    //}
    return r;
}


;// CONCATENATED MODULE: ./src/implicit-form/exact/get-implicit-form2-exact.ts


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗

const get_implicit_form2_exact_sce = scale_expansion_scaleExpansion2;
const em2 = eMultBy2;
const get_implicit_form2_exact_edif = e_diff_eDiff;
const get_implicit_form2_exact_epr = expansion_product_expansionProduct;
const get_implicit_form2_exact_eno = eNegativeOf;
/**
 * Returns the exact implicit form of the given quadratic bezier curve
 * or `undefined` if the curve is really a point.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`
 * * **precondition:** TODO - add underflow / overflow conditions
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm2Exact(ps) {
    return getImplicitForm2ExactPb(getXY2Exact(ps));
}
/**
 * The power basis version of [[getImplicitForm2ExactAnyBitlength]].
 *
 * @param pspb the power basis representation of a quadratic bezier curve that
 * can be found via [[getXYExactAnyBitlength2]]
 *
 * @internal
 */
function getImplicitForm2ExactPb(pspb) {
    const [[a2, a1, a0], [b2, b1, b0]] = pspb;
    if (e_sign_eSign(a2) === 0 && e_sign_eSign(b2) === 0) {
        // the input bezier curve is in fact not cubic but has order < 2
        const implicitForm = getImplicitForm1ExactPb([[a1, a0], [b1, b0]]);
        if (implicitForm === undefined) {
            return undefined;
        }
        return {
            vₓₓ: [0], vₓᵧ: [0], vᵧᵧ: [0],
            ...implicitForm
        };
    }
    const a2b1 = get_implicit_form2_exact_epr(a2, b1);
    const a1b2 = get_implicit_form2_exact_epr(a1, b2);
    const a2b0 = get_implicit_form2_exact_sce(b0, a2);
    const a0b2 = get_implicit_form2_exact_sce(a0, b2);
    const a1b0 = get_implicit_form2_exact_sce(b0, a1);
    const a0b1 = get_implicit_form2_exact_sce(a0, b1);
    const a2a2 = get_implicit_form2_exact_epr(a2, a2);
    const a2b2 = get_implicit_form2_exact_epr(a2, b2);
    const b2b2 = get_implicit_form2_exact_epr(b2, b2);
    const q1 = get_implicit_form2_exact_edif(a2b1, a1b2);
    const q2 = get_implicit_form2_exact_edif(a2b0, a0b2);
    const q3 = get_implicit_form2_exact_edif(a1b0, a0b1);
    // -a1*q1*y - a2**2*y**2 + 2*a2*b2*x*y + 2*a2*q2*y + b1*q1*x - b2**2*x**2 - 2*b2*q2*x + q1*q3 - q2**2
    // b2**2*x**2
    // -b2**2 *x**2
    const vₓₓ = get_implicit_form2_exact_eno(b2b2);
    // -2*a2*b2*x*y
    // 2*a2*b2 *x*y
    const vₓᵧ = em2(a2b2);
    // a2**2*y**2
    // -a2**2 *y**2 
    const vᵧᵧ = get_implicit_form2_exact_eno(a2a2);
    // -2*a0*b2**2 + a1*b1*b2 + 2*a2*b0*b2 - a2*b1**2
    // (b1*q1 + -2*b2*q2) *x
    //const vₓ = b1*q1 - 2*b2*q2;
    const w1 = get_implicit_form2_exact_epr(b1, q1);
    const w2 = em2(get_implicit_form2_exact_epr(b2, q2));
    const vₓ = get_implicit_form2_exact_edif(w1, w2);
    // 2*a0*a2*b2 - a1**2*b2 + a1*a2*b1 - 2*a2**2*b0
    // (-a1*q1 + 2*a2*q2) *y
    const w3 = em2(get_implicit_form2_exact_epr(a2, q2));
    const w4 = get_implicit_form2_exact_epr(a1, q1);
    const vᵧ = get_implicit_form2_exact_edif(w3, w4);
    // a0**2*b2**2 - a0*a1*b1*b2 - 2*a0*a2*b0*b2 + a0*a2*b1**2 + a1**2*b0*b2 - a1*a2*b0*b1 + a2**2*b0**2
    // q1*q3 + -q2**2
    const w5 = get_implicit_form2_exact_epr(q1, q3);
    const w6 = get_implicit_form2_exact_epr(q2, q2);
    const v = get_implicit_form2_exact_edif(w5, w6);
    //console.log({ vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v })
    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez1-exact.ts


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗


const get_coeffs_bez2_bez1_exact_tp = two_product_twoProduct; // error -> 0
const get_coeffs_bez2_bez1_exact_sce = scale_expansion_scaleExpansion2;
const get_coeffs_bez2_bez1_exact_epr = expansion_product_expansionProduct;
const get_coeffs_bez2_bez1_exact_fes = fastExpansionSum;
const get_coeffs_bez2_bez1_exact_em2 = eMultBy2;
const get_coeffs_bez2_bez1_exact_eSign = e_sign_eSign;
/**
 * Returns an error-free polynomial in 1 variable
 * whose roots are the parameter values of the intersection points of an order
 * 2 and 1 bezier curve (i.e. a quadratic bezier curve and a line).
 *
 * The returned polynomial degree will be 2
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:**  TODO - add underflow / overflow conditions
 * * the returned polynomial coefficients are exact (i.e. error-free)
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez2Bez1Exact(ps1, ps2) {
    /** ps1 in power bases */
    const ps1pb = getXY2Exact(ps1);
    //const [[e2,e1,e0],[f2,f1,f0]] = ps1pb;
    // if both polynomials' quadratic terms are exactly zero then its really a line
    if (get_coeffs_bez2_bez1_exact_eSign(ps1pb[0][0]) === 0 && get_coeffs_bez2_bez1_exact_eSign(ps1pb[1][0]) === 0) {
        // the input bezier curve is in fact not quadratic but has order < 2
        return getCoeffsBez1Bez1Exact([ps1[0], ps1[2]], ps2);
    }
    const [[c1, c0], [d1, d0]] = getXY1Exact(ps2);
    if (get_coeffs_bez2_bez1_exact_eSign(c1) === 0 && get_coeffs_bez2_bez1_exact_eSign(d1) === 0) {
        // the input bezier curve is in fact not a line but has order < 1,
        // i.e. it is a point
        // TODO
        //return getCoeffsBez2Bez0ExactAnyBitlength(ps1, [ps2[0]]);
    }
    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = 
    // this type coercion is justified since we already checked that the
    // curve really has order 2
    getImplicitForm2ExactPb(ps1pb);
    const c0c0 = get_coeffs_bez2_bez1_exact_tp(c0, c0);
    const c0c1 = get_coeffs_bez2_bez1_exact_sce(c0, c1);
    const c0d0 = get_coeffs_bez2_bez1_exact_tp(c0, d0);
    const c0d1 = get_coeffs_bez2_bez1_exact_sce(c0, d1);
    const c1c1 = get_coeffs_bez2_bez1_exact_epr(c1, c1);
    const c1d0 = get_coeffs_bez2_bez1_exact_sce(d0, c1);
    const c1d1 = get_coeffs_bez2_bez1_exact_epr(c1, d1);
    const d0d0 = get_coeffs_bez2_bez1_exact_tp(d0, d0);
    const d0d1 = get_coeffs_bez2_bez1_exact_sce(d0, d1);
    const d1d1 = get_coeffs_bez2_bez1_exact_epr(d1, d1);
    // a1**2*vₓₓ + a1*b1*vₓᵧ + b1**2*vᵧᵧ
    const p1 = get_coeffs_bez2_bez1_exact_epr(c1c1, vₓₓ);
    const p2 = get_coeffs_bez2_bez1_exact_epr(d1d1, vᵧᵧ);
    const p3 = get_coeffs_bez2_bez1_exact_epr(c1d1, vₓᵧ);
    const p4 = get_coeffs_bez2_bez1_exact_fes(p1, p2);
    const v2 = get_coeffs_bez2_bez1_exact_fes(p4, p3);
    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*vₓ + 2*b0*b1*vᵧᵧ + b1*vᵧ
    const p5 = get_coeffs_bez2_bez1_exact_epr(c0c1, vₓₓ);
    const p6 = get_coeffs_bez2_bez1_exact_epr(d0d1, vᵧᵧ);
    const p7 = get_coeffs_bez2_bez1_exact_fes(c0d1, c1d0);
    const pn = get_coeffs_bez2_bez1_exact_epr(p7, vₓᵧ);
    const p8 = get_coeffs_bez2_bez1_exact_em2(get_coeffs_bez2_bez1_exact_fes(p5, p6));
    const p9 = get_coeffs_bez2_bez1_exact_fes(p8, pn);
    const pa = get_coeffs_bez2_bez1_exact_epr(c1, vₓ);
    const pb = get_coeffs_bez2_bez1_exact_epr(d1, vᵧ);
    const pc = get_coeffs_bez2_bez1_exact_fes(pa, pb);
    const v1 = get_coeffs_bez2_bez1_exact_fes(p9, pc);
    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*vₓ + b0**2*vᵧᵧ + b0*vᵧ + v_0
    const pe = get_coeffs_bez2_bez1_exact_epr(c0c0, vₓₓ);
    const pf = get_coeffs_bez2_bez1_exact_epr(c0d0, vₓᵧ);
    const pg = get_coeffs_bez2_bez1_exact_epr(d0d0, vᵧᵧ);
    const ph = get_coeffs_bez2_bez1_exact_fes(pe, pf);
    const pi = get_coeffs_bez2_bez1_exact_fes(ph, pg);
    const pj = get_coeffs_bez2_bez1_exact_sce(c0, vₓ);
    const pk = get_coeffs_bez2_bez1_exact_sce(d0, vᵧ);
    const pl = get_coeffs_bez2_bez1_exact_fes(pj, pk);
    const pm = get_coeffs_bez2_bez1_exact_fes(pi, pl);
    const v0 = get_coeffs_bez2_bez1_exact_fes(pm, v);
    const r = [v2, v1, v0];
    // remove leading zero coefficients
    //while (r.length > 1 && eSign(r[0]) === 0) {
    //    r.shift();
    //}
    return r;
}


;// CONCATENATED MODULE: ./src/transformation/degree-or-type/to-quad-from-cubic.ts
// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗

const to_quad_from_cubic_sce = scaleExpansion;
const to_quad_from_cubic_edif = e_diff_eDiff;
const to_quad_from_cubic_estimate = e_estimate_eEstimate;
const to_quad_from_cubic_ts = two_sum_twoSum;
/**
 * Returns a quadratic closest to the given cubic bezier by taking the midpoint
 * of the moving line of the hybrid quadratic version of the cubic as the
 * new quadratics middle control point.
 * * the resulting quadratic will be exactly the cubic if the cubic is really
 * a quadratic in disguise and the bit-aligned bitlength of the coordinates of
 * the control points <= 52.
 *
 * @param ps a cubic bezier curve.
 *
 * @doc
 */
function toQuadraticFromCubic(ps) {
    // note: if cubic is really a quad then
    // x3 + 3*(x1 - x2) === x0 && 
    // y3 + 3*(y1 - y2) === y0
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    return [
        [x0, y0],
        [
            //[
            //  (3*(x1 + x2) - (x0 + x3)) / 4, 
            //  (3*(y1 + y2) - (y0 + y3)) / 4
            //]
            to_quad_from_cubic_estimate(to_quad_from_cubic_edif(to_quad_from_cubic_sce(to_quad_from_cubic_ts(x1 / 4, x2 / 4), 3), to_quad_from_cubic_ts(x0 / 4, x3 / 4))),
            to_quad_from_cubic_estimate(to_quad_from_cubic_edif(to_quad_from_cubic_sce(to_quad_from_cubic_ts(y1 / 4, y2 / 4), 3), to_quad_from_cubic_ts(y0 / 4, y3 / 4)))
        ],
        [x3, y3]
    ];
}


;// CONCATENATED MODULE: ./src/implicit-form/exact/get-implicit-form3-exact.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗



const get_implicit_form3_exact_sce = scale_expansion_scaleExpansion2;
const get_implicit_form3_exact_epr = expansion_product_expansionProduct;
const get_implicit_form3_exact_fes = fastExpansionSum;
const get_implicit_form3_exact_edif = e_diff_eDiff;
const get_implicit_form3_exact_eno = eNegativeOf;
const get_implicit_form3_exact_em2 = eMultBy2;
const ed2 = eDivBy2;
const get_implicit_form3_exact_eSign = e_sign_eSign;
/**
 * Returns the exact implicit form of the given cubic bezier curve
 * or `undefined` if the curve is really a point.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`
 * * **precondition:** none
 *
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 * * takes about 155 micro-seconds on a 3rd gen i7 and Chrome 79
 *
 * @param ps
 *
 * @doc mdx - TODO - remove mdx from these functions - they will become too many?
 */
function getImplicitForm3Exact(ps) {
    return getImplicitForm3ExactPb(getXY3Exact(ps));
}
/**
 * The power basis version of [[getImplicitForm3ExactAnyBitlength]].
 *
 * @param pspb the power basis representation of a cubic bezier curve that can
 * be found via [[getXYExactAnyBitlength3]]
 *
 * @internal
 */
function getImplicitForm3ExactPb(pspb) {
    const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = pspb;
    if (get_implicit_form3_exact_eSign(a3) === 0 && get_implicit_form3_exact_eSign(b3) === 0) {
        // the input bezier curve is in fact not cubic but has order < 3
        const implicitForm = getImplicitForm2ExactPb([[a2, a1, a0], [b2, b1, b0]]);
        if (implicitForm === undefined) {
            return undefined;
        }
        return {
            vₓₓₓ: [0], vₓₓᵧ: [0], vₓᵧᵧ: [0], vᵧᵧᵧ: [0],
            ...implicitForm
        };
    }
    const a3b1 = get_implicit_form3_exact_epr(a3, b1);
    const a1b3 = get_implicit_form3_exact_epr(a1, b3);
    const a3b2 = get_implicit_form3_exact_epr(a3, b2);
    const a2b2 = get_implicit_form3_exact_epr(a2, b2);
    const a2b3 = get_implicit_form3_exact_epr(a2, b3);
    const a3a3 = get_implicit_form3_exact_epr(a3, a3);
    const b2b2 = get_implicit_form3_exact_epr(b2, b2);
    const b3b3 = get_implicit_form3_exact_epr(b3, b3);
    const a1a3 = get_implicit_form3_exact_epr(a1, a3);
    const a2a2 = get_implicit_form3_exact_epr(a2, a2);
    const b1b3 = get_implicit_form3_exact_epr(b1, b3);
    const b2b3 = get_implicit_form3_exact_epr(b2, b3);
    const a2a3 = get_implicit_form3_exact_epr(a2, a3);
    const a3b3 = get_implicit_form3_exact_epr(a3, b3);
    const a3b0 = get_implicit_form3_exact_sce(b0, a3);
    const a0b3 = get_implicit_form3_exact_sce(a0, b3);
    const a2b0 = get_implicit_form3_exact_sce(b0, a2);
    const a0b2 = get_implicit_form3_exact_sce(a0, b2);
    const a2b1 = get_implicit_form3_exact_epr(a2, b1);
    const a1b2 = get_implicit_form3_exact_epr(a1, b2);
    const a1b0 = get_implicit_form3_exact_sce(b0, a1);
    const a0b1 = get_implicit_form3_exact_sce(a0, b1);
    const q1 = get_implicit_form3_exact_edif(a3b0, a0b3);
    const q2 = get_implicit_form3_exact_edif(a3b1, a1b3);
    const q3 = get_implicit_form3_exact_edif(a3b2, a2b3);
    const q4 = get_implicit_form3_exact_edif(a2b0, a0b2);
    const q5 = get_implicit_form3_exact_edif(a2b1, a1b2);
    const q6 = get_implicit_form3_exact_edif(a1b0, a0b1);
    const t1 = get_implicit_form3_exact_edif(b1b3, b2b2);
    const t2 = get_implicit_form3_exact_edif(a1a3, a2a2);
    const p1 = get_implicit_form3_exact_fes(a2b3, a3b2);
    const p2 = get_implicit_form3_exact_fes(a1b3, a3b1);
    const tq2 = get_implicit_form3_exact_em2(q2); // error free
    const q1q1 = get_implicit_form3_exact_epr(q1, q1);
    const q1q2 = get_implicit_form3_exact_epr(q1, q2);
    const q1q3 = get_implicit_form3_exact_epr(q1, q3);
    const q1q5 = get_implicit_form3_exact_epr(q1, q5);
    const q2q2 = get_implicit_form3_exact_epr(q2, q2);
    const tq2q4 = get_implicit_form3_exact_epr(tq2, q4);
    const q3q4 = get_implicit_form3_exact_epr(q3, q4);
    const q3q5 = get_implicit_form3_exact_epr(q3, q5);
    const q3q6 = get_implicit_form3_exact_epr(q3, q6);
    const vₓₓₓ = get_implicit_form3_exact_epr(get_implicit_form3_exact_eno(b3), b3b3);
    const vₓₓᵧ = get_implicit_form3_exact_epr(get_implicit_form3_exact_sce(3, a3), b3b3);
    const vₓᵧᵧ = get_implicit_form3_exact_epr(get_implicit_form3_exact_sce(-3, b3), a3a3);
    const vᵧᵧᵧ = get_implicit_form3_exact_epr(a3, a3a3);
    const u1 = get_implicit_form3_exact_edif(get_implicit_form3_exact_sce(-3, q1), q5);
    //const vₓₓ = (u1*b3b3 + q3*(b1b3 - b2b2)) + tq2*b2b3;
    const w1 = get_implicit_form3_exact_epr(u1, b3b3);
    const w2 = get_implicit_form3_exact_epr(q3, t1);
    const w3 = get_implicit_form3_exact_fes(w1, w2);
    const w4 = get_implicit_form3_exact_epr(tq2, b2b3);
    const vₓₓ = get_implicit_form3_exact_fes(w3, w4);
    //const vᵧᵧ = (u1*a3a3 + q3*t2) + tq2*a2a3;
    const w5 = get_implicit_form3_exact_epr(u1, a3a3);
    const w6 = get_implicit_form3_exact_epr(q3, t2);
    const w7 = get_implicit_form3_exact_fes(w5, w6);
    const w8 = get_implicit_form3_exact_epr(tq2, a2a3);
    const vᵧᵧ = get_implicit_form3_exact_fes(w7, w8);
    //const vₓᵧ = 2*(q3*(a2b2 - p2/2) - (u1*a3b3 + q2*p1));
    const wa = get_implicit_form3_exact_edif(a2b2, ed2(p2));
    const wb = get_implicit_form3_exact_epr(u1, a3b3);
    const wc = get_implicit_form3_exact_epr(q2, p1);
    const wd = get_implicit_form3_exact_fes(wb, wc);
    const wq = get_implicit_form3_exact_epr(q3, wa);
    const vₓᵧ = get_implicit_form3_exact_em2(get_implicit_form3_exact_edif(wq, wd));
    //const s1 = (-3*q1q1 - 2*q1q5) + (tq2q4 + q3q6);
    const wr = get_implicit_form3_exact_sce(-3, q1q1);
    const we = get_implicit_form3_exact_edif(wr, get_implicit_form3_exact_em2(q1q5));
    const wf = get_implicit_form3_exact_fes(tq2q4, q3q6);
    const s1 = get_implicit_form3_exact_fes(we, wf);
    //const s2 = 2*(q1q2 - q3q4);
    const s2 = get_implicit_form3_exact_em2(get_implicit_form3_exact_edif(q1q2, q3q4));
    //const s3 = q1q3 - q2q2 + q3q5;
    const wl = get_implicit_form3_exact_edif(q1q3, q2q2);
    const s3 = get_implicit_form3_exact_fes(wl, q3q5);
    //const vₓ = b3*s1 + (b2*s2 + b1*s3);
    const wm = get_implicit_form3_exact_epr(b3, s1);
    const ws = get_implicit_form3_exact_epr(b2, s2);
    const wt = get_implicit_form3_exact_epr(b1, s3);
    const wn = get_implicit_form3_exact_fes(ws, wt);
    const vₓ = get_implicit_form3_exact_fes(wm, wn);
    //const vᵧ = -a3*s1 - (a2*s2 + a1*s3);
    const wo = get_implicit_form3_exact_epr(a3, s1);
    const wu = get_implicit_form3_exact_epr(a2, s2);
    const wv = get_implicit_form3_exact_epr(a1, s3);
    const wp = get_implicit_form3_exact_fes(wu, wv);
    const vᵧ = get_implicit_form3_exact_eno(get_implicit_form3_exact_fes(wo, wp));
    const v3 = get_implicit_form3_exact_edif(tq2q4, q1q1);
    const v1 = get_implicit_form3_exact_edif(v3, q1q5);
    const v4 = get_implicit_form3_exact_epr(s3, q6);
    const v5 = get_implicit_form3_exact_epr(q3q4, q4);
    const v2 = get_implicit_form3_exact_edif(v4, v5);
    const v6 = get_implicit_form3_exact_epr(q1, v1);
    //const v = q1*(tq2q4 - q1q1 - q1q5) + s3*q6 - q3q4*q4;
    const v = get_implicit_form3_exact_fes(v6, v2);
    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-1.ts


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗



const is_point_on_bezier_extension_1_qaq = node_ddAddDd;
const is_point_on_bezier_extension_1_epr = expansion_product_expansionProduct;
const is_point_on_bezier_extension_1_fes = fastExpansionSum;
const is_point_on_bezier_extension_1_sign = e_sign_eSign;
const is_point_on_bezier_extension_1_estimate = e_estimate_eEstimate;
const is_point_on_bezier_extension_1_qmd = (/* unused pure expression or super */ null && (ddMultDouble2));
const is_point_on_bezier_extension_1_sce = (/* unused pure expression or super */ null && (scaleExpansion2));
const is_point_on_bezier_extension_1_qmq = node_ddMultDd;
const etodd = eToDd;
const is_point_on_bezier_extension_1_abs = Math.abs;
const is_point_on_bezier_extension_1_3 = error_analysis_error_analysis_(3);
/**
 * Returns true if the given point is on the given line where
 * the parameter `t` is allowed to extend to +-infinity, i.e. t is an element of
 * [-inf, +inf], false otherwise.
 *
 * * **Precondition:** TODO - underflow/overflow
 * * there are alternative implementations to this function, e.g. ccw, etc;
 * it is kept for symmetry.
 *
 * @param ps a linear bezier curve (a line)
 * @param p A point with coordinates given as Shewchuk expansions. If only
 * double precision coordinates need to be provided then wrap it in an array,
 * e.g. for a point with x and y coordinates given as 1 and 2 set
 * `p === [[1],[2]]`. TODO - link to Schewchuk
 *
 * @internal
 */
function isPointOnBezierExtension1(ps, p) {
    const [xe, ye] = p;
    const lenX = xe.length;
    const lenY = ye.length;
    const x = xe[lenX - 1]; // get higest order double
    const y = ye[lenY - 1]; // ...
    const isDouble = (lenX === 1 && lenY === 1);
    {
        //---- pre-filter - note all coefficients below vₓ, vᵧ, v are exact
        const { coeffs: { vₓ, vᵧ, v }, errorBound: { v_ } } = getImplicitForm1DdWithRunningError(ps);
        // In the below a prefix underscore on a variable means absolute value, 
        // a postfix underscore means error bound (before multiplication by gamma).
        // h (say height) is the the result of evaluating the implicit equation; if
        // it is 0 we are on the curve, else we're not.
        // const h = vₓ*x + vᵧ*y + v;
        const xd = etodd(xe);
        const yd = etodd(ye);
        const _x = is_point_on_bezier_extension_1_abs(x);
        const _y = is_point_on_bezier_extension_1_abs(y);
        const _vₓ = is_point_on_bezier_extension_1_abs(vₓ[1]);
        const _vᵧ = is_point_on_bezier_extension_1_abs(vᵧ[1]);
        // we're multiplying by `γγ3` at the end but the error `x_` is only `γγ1`
        // and hence we need to divide the error by 3.
        const x_ = _x / 3;
        const y_ = _y / 3;
        const $vₓx = vₓ[1] * x;
        const vₓx = is_point_on_bezier_extension_1_qmq(xd, vₓ);
        const _vₓx = is_point_on_bezier_extension_1_abs($vₓx);
        const vₓx_ = _vₓ * x_ + 2 * _vₓx;
        const $vᵧy = vᵧ[1] * y;
        const vᵧy = is_point_on_bezier_extension_1_qmq(yd, vᵧ);
        const _vᵧy = is_point_on_bezier_extension_1_abs($vᵧy);
        const vᵧy_ = _vᵧ * y_ + 2 * _vᵧy;
        // group the terms to reduce error, e.g. `v` usually has the highest bitlength
        //const h = (vₓx + vᵧy) + v;
        const q7 = is_point_on_bezier_extension_1_qaq(vₓx, vᵧy);
        const q7_ = vₓx_ + vᵧy_ + is_point_on_bezier_extension_1_abs(q7[1]);
        const h = is_point_on_bezier_extension_1_qaq(q7, v);
        const h_ = q7_ + v_ + is_point_on_bezier_extension_1_abs(h[1]);
        // if the error is not too high too discern h away from zero
        if (is_point_on_bezier_extension_1_3 * h_ < is_point_on_bezier_extension_1_abs(is_point_on_bezier_extension_1_estimate(h))) {
            return false; // <-- prefilter applied
        }
    }
    {
        const implictForm = getImplicitForm1Exact(ps);
        if (implictForm === undefined) {
            // both ps are the same point
            return isDouble && x === ps[0][0] && y === ps[0][1];
        }
        const { vₓ, vᵧ, v } = implictForm;
        const vₓx = is_point_on_bezier_extension_1_epr(xe, vₓ);
        const vᵧy = is_point_on_bezier_extension_1_epr(ye, vᵧ);
        const hh = is_point_on_bezier_extension_1_fes(is_point_on_bezier_extension_1_epr(vₓx, vᵧy), v);
        return is_point_on_bezier_extension_1_sign(hh) === 0; // <= calculation was exact
    }
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-xy/double/get-xy.ts
/**
 * Returns the power basis representation of a linear, quadratic or cubic bezier curve.
 *
 * * **non-exact:** if certain preconditions are met (see below) it returns the
 * exact result, else round-off may have occured during intermediate calculation.
 * * returns the power basis polynomial from highest power to lowest,
 * e.g. `at^3 + bt^2 + ct + d` is returned as `[a,b,c,d]`
 *
 * * **bitlength:** If the coordinates of the control points are bit-aligned then:
 *  * max bitlength increase = 4 (for cubics)
 * (due to 'multiplication' by 9 (3x 6x 3x)
 *  * max bitlength increase = 2 (for quadratics)
 * (due to 'multiplication' by 4 (1x 2x 1x)
 *  * max bitlength increase = 1 (for lines)
 * (due to 'multiplication' by 4 (1x 1x)
 *
 * @param ps an order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getXY(ps) {
    if (ps.length === 4) {
        return getXY3(ps);
    }
    if (ps.length === 3) {
        return getXY2(ps);
    }
    if (ps.length === 2) {
        return getXY1(ps);
    }
    if (ps.length === 1) {
        return getXY0(ps);
    }
    throw new Error('The given bezier curve is invalid.');
}
function getXY3(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    return [[
            (x3 - x0) + 3 * (x1 - x2),
            3 * ((x2 + x0) - 2 * x1),
            3 * (x1 - x0),
            x0, // t^0 - max bitlength increase 0
        ], [
            (y3 - y0) + 3 * (y1 - y2),
            3 * ((y2 + y0) - 2 * y1),
            3 * (y1 - y0),
            y0, // t^0 - max bitlength increase 0
        ]];
}
function getXY2(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    return [[
            (x2 + x0) - 2 * x1,
            2 * (x1 - x0),
            x0, // t^0 - max bitlength increase 0
        ], [
            (y2 + y0) - 2 * y1,
            2 * (y1 - y0),
            y0, // t^0 - max bitlength increase 0            
        ]];
}
function getXY1(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    return [[
            x1 - x0,
            x0, // t^0 - max bitlength increase 0
        ], [
            y1 - y0,
            y0, // t^0 - max bitlength increase 0
        ]];
}
function getXY0(ps) {
    const [[x0, y0]] = ps;
    return [[x0], [y0]];
}


;// CONCATENATED MODULE: ./src/implicit-form/double/get-implicit-form2.ts

/**
 * Returns the implicit form of the given quadratic bezier.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`
 * * intermediate calculations are done in **double** precision
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm2(ps) {
    // The implicit form is given by:
    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0
    const [[a2, a1, a0], [b2, b1, b0]] = getXY2(ps);
    const q1 = a2 * b1 - a1 * b2;
    const q2 = a2 * b0 - a0 * b2;
    const vₓₓ = -b2 * b2;
    const vₓᵧ = 2 * a2 * b2;
    const vᵧᵧ = -a2 * a2;
    const vₓ = b1 * q1 - 2 * b2 * q2;
    const vᵧ = 2 * a2 * q2 - a1 * q1;
    const v = q1 * (a1 * b0 - a0 * b1) - q2 * q2;
    return { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-xy/get-xy-error-counters.ts
// Note: 
// Rrror counters of double-double will actually be slightly less but
// we can use this for both double and double-double precision.
// For double precision the error bound === γ * <counter> * `error_`
// For double-double precision the error bound === γγ3 * <counter> * `error_`
const get_xy_error_counters_abs = Math.abs;
// TODO - fix docs - uses Wilkinson error counters
/**
 * Returns the power basis representation of a line, quadratic or cubic bezier.
 *
 * * **non-exact:** if certain preconditions are met (see below) it returns the
 * exact result, else round-off may have occured during intermediate calculation.
 * * returns the power basis polynomial from highest power to lowest,
 * e.g. `at^3 + bt^2 + ct + d` is returned as `[a,b,c,d]`
 *
 * TODO
 * ```
 * errorBound: [[
 *		x1,  // <1>
 *		0
 * ], [
 *		y1,  // <1>
 *		0
 * ]]
 * ```
 * @param ps an order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getXY1ErrorCounters(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    const _x0 = get_xy_error_counters_abs(x0);
    const _x1 = get_xy_error_counters_abs(x1);
    const _y0 = get_xy_error_counters_abs(y0);
    const _y1 = get_xy_error_counters_abs(y1);
    return [
        [
            // <1> <= <1>(<0>x1 - <0>x0)
            _x1 + _x0,
            0,
        ], [
            _y1 + _y0,
            0,
        ]
    ];
}
// TODO - fix docs
/**
 *
 * TODO
 * ```
 * errorBound: [[
 *		x2,  // <2>
 *		x1,  // <1>
 *		0,
 * ],[
 *		y2,  // <2>
 *		y1,  // <1>
 *		0,
 * ]]
 * ```
 *
 * @param ps
 */
function getXY2ErrorCounters(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    const _x0 = get_xy_error_counters_abs(x0);
    const _x1 = get_xy_error_counters_abs(x1);
    const _x2 = get_xy_error_counters_abs(x2);
    const _y0 = get_xy_error_counters_abs(y0);
    const _y1 = get_xy_error_counters_abs(y1);
    const _y2 = get_xy_error_counters_abs(y2);
    return [
        [
            _x2 + _x0 + 2 * _x1,
            2 * (_x1 + _x0),
            0,
        ], [
            _y2 + _y0 + 2 * _y1,
            2 * (_y1 + _y0),
            0,
        ]
    ];
}
// TODO - fix docs
/**
 *
 * TODO
 * ```
 * errorBound: [[
 *		x3,  // <3>
 *		x2,  // <3>
 *		x1,  // <2>
 *		0,
 * ],[
 *		y3,  // <3>
 *		y2,  // <3>
 *		y1,  // <2>
 *		0,
 * ]]
 * ```
 *
 * @param ps
 */
function getXY3ErrorCounters(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    const _x0 = get_xy_error_counters_abs(x0);
    const _x1 = get_xy_error_counters_abs(x1);
    const _x2 = get_xy_error_counters_abs(x2);
    const _x3 = get_xy_error_counters_abs(x3);
    const _y0 = get_xy_error_counters_abs(y0);
    const _y1 = get_xy_error_counters_abs(y1);
    const _y2 = get_xy_error_counters_abs(y2);
    const _y3 = get_xy_error_counters_abs(y3);
    return [
        [
            _x3 + _x0 + 3 * (_x1 + _x2),
            3 * (_x2 + _x0 + 2 * _x1),
            3 * (_x1 + _x0),
            0,
        ], [
            _y3 + _y0 + 3 * (_y1 + _y2),
            3 * (_y2 + _y0 + 2 * _y1),
            3 * (_y1 + _y0),
            0,
        ]
    ];
}


;// CONCATENATED MODULE: ./src/implicit-form/get-error-counters/get-implicit-form2-error-counters.ts

const get_implicit_form2_error_counters_abs = Math.abs;
// TODO - docs
/**
 * Returns the implicit form of the given quadratic bezier and a coefficientwise
 * error bound.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`
 * * **precondition:** TODO - add underflow / overflow conditions + docs below
 * * intermediate calculations are done in **double** precision and this is
 * reflected in the output error bound (which is approximately
 * `n * Number.EPSILON * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned first needs to be scaled by `γ === u/(1 - u)`,
 * where `u === Number.EPSILON / 2` before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 * TODO
 * ```
 * return {
 *      vₓₓ_,  // <5>
 *      vₓᵧ_,  // <5>
 *      vᵧᵧ_,  // <5>
 *      vₓ_,   // <8>
 *      vᵧ_,   // <8>
 *      v_     // <10>
 * }
 * ```
 *
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm2ErrorCounters(ps) {
    // The implicit form is given by:
    // vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0
    //const [[,,a0],[,,b0]] = getXY(ps);
    const [a0, b0] = ps[0];
    const [[a2_, a1_], // <2>a2_, <1>a1_, <0>a0_  (a0_ is just abs(a0))
    [b2_, b1_] // <2>b2_, <1>b1_, <0>b0_  (b0_ is just abs(b0))
    ] = getXY2ErrorCounters(ps);
    //-------------------
    // Error calculation
    //-------------------
    const a0_ = get_implicit_form2_error_counters_abs(a0);
    const b0_ = get_implicit_form2_error_counters_abs(b0);
    // <5>q1 <-- <5>(<4>(<2>a2*<1>b1) - <4>(a1*b2))
    const q1_ = a2_ * b1_ + a1_ * b2_;
    // <4>q2 <-- <4>(<3>(a2*b0) - <3>(a0*b2))
    const q2_ = a2_ * b0_ + a0_ * b2_;
    // <5>vₓₓ <-- <5>(-<2>b2*<2>b2)
    const vₓₓ_ = b2_ * b2_;
    // <5>vₓᵧ <-- 2*a2*b2
    const vₓᵧ_ = 2 * a2_ * b2_;
    // <5>vᵧᵧ <-- -a2*a2
    const vᵧᵧ_ = a2_ * a2_;
    // <8>vₓ <-- <8>(<7>(<1>b1*<5>q1) - <7>(2*<2>b2*<4>q2))
    const vₓ_ = b1_ * q1_ + 2 * b2_ * q2_;
    // <8>vᵧ <-- <8>(<7>(2*<2>a2<4>q2) - <7>(<1>a1<5>q1))
    const vᵧ_ = 2 * a2_ * q2_ + a1_ * q1_;
    // <10>v <-- <10>(<9>(<5>q1*<3>(<2>(a1*b0) - <2>(a0*b1))) - <9>(<4>q2*<4>q2))
    const v_ = q1_ * (a1_ * b0_ + a0_ * b1_) + q2_ * q2_;
    return {
        vₓₓ_,
        vₓᵧ_,
        vᵧᵧ_,
        vₓ_,
        vᵧ_,
        v_ // <10>
    };
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-2.ts





// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗


const is_point_on_bezier_extension_2_tp = node_twoProduct;
const is_point_on_bezier_extension_2_qmq = node_ddMultDd;
const is_point_on_bezier_extension_2_qaq = node_ddAddDd;
const is_point_on_bezier_extension_2_sce = scale_expansion_scaleExpansion2;
const is_point_on_bezier_extension_2_epr = expansion_product_expansionProduct;
const is_point_on_bezier_extension_2_fes = fastExpansionSum;
const is_point_on_bezier_extension_2_sign = e_sign_eSign;
const is_point_on_bezier_extension_2_estimate = e_estimate_eEstimate;
const is_point_on_bezier_extension_2_etodd = eToDd;
const is_point_on_bezier_extension_2_abs = Math.abs;
const is_point_on_bezier_extension_2_1 = error_analysis_(1);
const is_point_on_bezier_extension_2_3 = error_analysis_error_analysis_(3);
/**
 * Returns true if the given point is on the given quadratic bezier curve where
 * the parameter t is allowed to extend to +-infinity, i.e. t is an element of
 * [-inf, +inf], false otherwise.
 *
 * * **Precondition:** TODO - underflow/overflow
 *
 * @param ps a quadratic bezier curve
 * @param p A point with coordinates given as Shewchuk expansions. If only
 * double precision coordinates need to be provided then wrap it in an array,
 * e.g. for a point with x and y coordinates given as 1 and 2 set
 * `p === [[1],[2]]`. TODO - link to Schewchuk
 *
 * @internal
 */
function isPointOnBezierExtension2(ps, p) {
    const [xe, ye] = p;
    const lenX = xe.length;
    const lenY = ye.length;
    const x = xe[lenX - 1]; // get higest order double
    const y = ye[lenY - 1]; // ...
    const isDouble = (lenX === 1 && lenY === 1);
    //const x_ = abs(x);
    //const y_ = abs(y);
    //---- first pre-filter
    {
        const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = getImplicitForm2(ps);
        const { vₓₓ_, // <5>
        vₓᵧ_, // <5>
        vᵧᵧ_, // <5>
        vₓ_, // <8>
        vᵧ_, // <8>
        v_ // <10>
         } = getImplicitForm2ErrorCounters(ps);
        // In the below a a postfix underscore means 
        // an error bound (>= absolute value)
        // `h` (say height) is the the result of evaluating the implicit equation; if
        // it is 0 we are on the curve, else we're not.
        // In the below, if x is given as a double then the error counter on
        // x would be 0, i.e. <0>x, else it would be <1>x. We represent the
        // error counter with a <D> so that for a point with double precion 
        // coordinates we have <D> = <0> else <D> = <1>. Same is true for y.
        // `0` if we have only double precision coordinates, `1` otherwise
        const D = isDouble ? 0 : 1;
        const x_ = is_point_on_bezier_extension_2_abs(x); // <D>x
        const y_ = is_point_on_bezier_extension_2_abs(y); // <D>y
        const xx_ = x_ * x_; // <2D+1>xx
        const xy_ = x_ * y_; // <2D+1>xy
        const yy_ = y_ * y_; // <2D+1>yy
        // group the terms to reduce error, e.g. v usually has the highest bitlength
        const h = (((vₓₓ * x * x + vₓᵧ * x * y) +
            vᵧᵧ * y * y) +
            (vₓ * x + vᵧ * y)) +
            v;
        // <D+12>h <-- <D+12>(<D+11>(<2D+9>(<2D+8> + <2D+7>) + <D+10>) + <10>);
        const h_ = ((
        // <2D+8>(<2D+7>(<5>vₓₓ*<2D+1>(xx)) + <2D+7>(<5>vₓᵧ*<2D+1>(xy)))
        (vₓₓ_ * xx_ + vₓᵧ_ * xy_) +
            // <2D+7>(<5>vᵧᵧ*<2D+1>(xy))
            vᵧᵧ_ * yy_) + (
        // <D+10>(<D+9>(<8>vₓ*<D>x) + <D+9>(<8>vᵧ*<D>y))
        vₓ_ * x_ + vᵧ_ * y_)) +
            // <10>v
            v_;
        // if the error is not too high too discern h away from zero
        if ((D + 12) * is_point_on_bezier_extension_2_1 * h_ < is_point_on_bezier_extension_2_abs(h)) {
            return false; // <-- prefilter applied
        }
    }
    // error too high - const's try double-double precision
    {
        const { coeffs: { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = getImplicitForm2DdWithRunningError(ps);
        // In the below a prefix underscore on a variable means absolute value, 
        // a postfix underscore means error bound (before multiplication by gamma).
        // h (say height) is the the result of evaluating the implicit equation; if
        // it is 0 we are on the curve, else we're not.
        // const h =
        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;
        const xd = is_point_on_bezier_extension_2_etodd(xe);
        const yd = is_point_on_bezier_extension_2_etodd(ye);
        const _x = is_point_on_bezier_extension_2_abs(x);
        const _y = is_point_on_bezier_extension_2_abs(y);
        // we're multiplying by `γγ3` at the end but the error `x_` is only `γγ1`
        // and hence we need to divide the error by 3.
        const x_ = _x / 3;
        const y_ = _y / 3;
        const xx = is_point_on_bezier_extension_2_qmq(xd, xd);
        const _xx = xx[1];
        const xx_ = 2 * (_x * x_ + _xx);
        const yy = is_point_on_bezier_extension_2_qmq(yd, yd);
        const _yy = yy[1];
        const yy_ = 2 * (_y * y_ + _yy);
        const xy = is_point_on_bezier_extension_2_qmq(xd, yd);
        const _xy = is_point_on_bezier_extension_2_abs(xy[1]);
        const xy_ = _x * y_ + x_ * _y + 2 * _xy;
        const vₓₓxx = is_point_on_bezier_extension_2_qmq(vₓₓ, xx);
        const vₓₓxx_ = is_point_on_bezier_extension_2_abs(vₓₓ[1]) * xx_ + vₓₓ_ * _xx + 2 * is_point_on_bezier_extension_2_abs(vₓₓxx[1]);
        const vₓᵧxy = is_point_on_bezier_extension_2_qmq(vₓᵧ, xy);
        const vₓᵧxy_ = is_point_on_bezier_extension_2_abs(vₓᵧ[1]) * xy_ + vₓᵧ_ * _xy + 2 * is_point_on_bezier_extension_2_abs(vₓᵧxy[1]);
        const vᵧᵧyy = is_point_on_bezier_extension_2_qmq(vᵧᵧ, yy);
        const vᵧᵧyy_ = is_point_on_bezier_extension_2_abs(vᵧᵧ[1]) * yy_ + vᵧᵧ_ * _yy + 2 * is_point_on_bezier_extension_2_abs(vᵧᵧyy[1]);
        const vₓx = is_point_on_bezier_extension_2_qmq(xd, vₓ);
        const vₓx_ = is_point_on_bezier_extension_2_abs(vₓ[1]) * x_ + vₓ_ * _x + 2 * is_point_on_bezier_extension_2_abs(vₓx[1]);
        const vᵧy = is_point_on_bezier_extension_2_qmq(yd, vᵧ);
        const vᵧy_ = is_point_on_bezier_extension_2_abs(vᵧ[1]) * y_ + vᵧ_ * _y + 2 * is_point_on_bezier_extension_2_abs(vᵧy[1]);
        // group the terms to reduce error, e.g. v usually has the highest bitlength
        //const h = 
        //    (
        //      ((vₓₓxx + vₓᵧxy) + vᵧᵧyy) + 
        //      (vₓx + vᵧy)
        //    ) + 
        //    v;
        const q4 = is_point_on_bezier_extension_2_qaq(vₓₓxx, vₓᵧxy);
        const q4_ = vₓₓxx_ + vₓᵧxy_ + is_point_on_bezier_extension_2_abs(q4[1]);
        const q5 = is_point_on_bezier_extension_2_qaq(q4, vᵧᵧyy);
        const q5_ = q4_ + vᵧᵧyy_ + is_point_on_bezier_extension_2_abs(q5[1]);
        const q7 = is_point_on_bezier_extension_2_qaq(vₓx, vᵧy);
        const q7_ = vₓx_ + vᵧy_ + is_point_on_bezier_extension_2_abs(q7[1]);
        const q8 = is_point_on_bezier_extension_2_qaq(q5, q7);
        const q8_ = q5_ + q7_ + is_point_on_bezier_extension_2_abs(q8[1]);
        const h = is_point_on_bezier_extension_2_qaq(q8, v);
        const h_ = q8_ + v_ + is_point_on_bezier_extension_2_abs(h[1]);
        // if the error is not too high too discern h away from zero
        if (is_point_on_bezier_extension_2_3 * h_ < is_point_on_bezier_extension_2_abs(is_point_on_bezier_extension_2_estimate(h))) {
            return false; // <-- prefilter applied
        }
    }
    // error still too high - const's go exact
    {
        const implictForm = getImplicitForm2Exact(ps);
        if (implictForm === undefined) {
            // all ps are the same point
            return isDouble && x === ps[0][0] && y === ps[0][1];
        }
        const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = implictForm;
        // h (say height) is the the result of evaluating the implicit equation; 
        // if it is 0 we are on the curve, else we're not.
        // const h =
        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;
        const h = is_point_on_bezier_extension_2_fes(is_point_on_bezier_extension_2_fes(is_point_on_bezier_extension_2_fes(is_point_on_bezier_extension_2_epr(vₓₓ, is_point_on_bezier_extension_2_tp(x, x)), is_point_on_bezier_extension_2_epr(vₓᵧ, is_point_on_bezier_extension_2_tp(x, y))), is_point_on_bezier_extension_2_epr(vᵧᵧ, is_point_on_bezier_extension_2_tp(y, y))), is_point_on_bezier_extension_2_fes(is_point_on_bezier_extension_2_fes(is_point_on_bezier_extension_2_sce(x, vₓ), is_point_on_bezier_extension_2_sce(y, vᵧ)), v));
        return is_point_on_bezier_extension_2_sign(h) === 0; // <= calculation was exact
    }
}


;// CONCATENATED MODULE: ./src/implicit-form/double/get-implicit-form3.ts

/**
 * Returns the implicit form of the given cubic bezier.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 * * takes about 1.2 micro-seconds on a 3rd gen i7 and Chrome 79
 *
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm3(ps) {
    // The implicit form is given by:
    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0
    const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = getXY3(ps);
    const a3b1 = a3 * b1;
    const a1b3 = a1 * b3;
    const a3b2 = a3 * b2;
    const a2b3 = a2 * b3;
    const a3a3 = a3 * a3;
    const b3b3 = b3 * b3;
    const q1 = a3 * b0 - a0 * b3;
    const q2 = a3b1 - a1b3;
    const q3 = a3b2 - a2b3;
    const q4 = a2 * b0 - a0 * b2;
    const q5 = a2 * b1 - a1 * b2;
    const q6 = a1 * b0 - a0 * b1;
    const tq2 = 2 * q2;
    const q1q1 = q1 * q1;
    const q1q5 = q1 * q5;
    const tq2q4 = tq2 * q4;
    const q3q4 = q3 * q4;
    const u1 = -3 * q1 - q5;
    const vₓₓₓ = -b3 * b3b3;
    const vₓₓᵧ = 3 * a3 * b3b3;
    const vₓᵧᵧ = -3 * b3 * a3a3;
    const vᵧᵧᵧ = a3 * a3a3;
    const vₓₓ = (u1 * b3b3 + q3 * (b1 * b3 - b2 * b2)) + tq2 * b2 * b3;
    const vᵧᵧ = (u1 * a3a3 + q3 * (a1 * a3 - a2 * a2)) + tq2 * a2 * a3;
    const vₓᵧ = 2 * (q3 * (a2 * b2 - (a1b3 + a3b1) / 2) - (u1 * a3 * b3 + q2 * (a2b3 + a3b2)));
    const s1 = (-3 * q1q1 - 2 * q1q5) + (tq2q4 + q3 * q6);
    const s2 = 2 * (q1 * q2 - q3q4);
    const s3 = q1 * q3 - q2 * q2 + q3 * q5;
    const vₓ = b3 * s1 + (b2 * s2 + b1 * s3);
    const vᵧ = -a3 * s1 - (a2 * s2 + a1 * s3);
    const v = (q1 * ((tq2q4 - q1q1) - q1q5)) + (s3 * q6 - q3q4 * q4);
    return { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v };
}


;// CONCATENATED MODULE: ./src/implicit-form/get-error-counters/get-implicit-form3-error-counters.ts

const get_implicit_form3_error_counters_abs = Math.abs;
// TODO - docs
/**
 * Returns the implicit form of the given cubic bezier and a coefficientwise
 * error bound.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0`
 * * **precondition:** TODO - add underflow / overflow conditions + docs below
 * * intermediate calculations are done in **double** precision and this is
 * reflected in the output error bound (which is approximately
 * `n * Number.EPSILON * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned first needs to be scaled by `γ === u/(1 - u)`,
 * where `u === Number.EPSILON / 2` before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 * * takes about 1.2 micro-seconds on a 3rd gen i7 and Chrome 79
 *
 *  * TODO
 * ```
 * errorBound: {
 *      vₓₓₓ_,  // <11>
 *      vₓₓᵧ_,  // <12>
 *      vₓᵧᵧ_,  // <12>
 *      vᵧᵧᵧ_,  // <11>
 *      vₓₓ_,   // <19>
 *      vₓᵧ_,   // <18>
 *      vᵧᵧ_,   // <19>
 *      vₓ_,    // <22>
 *      vᵧ_,    // <22>
 *      v_      // <24>
 * }
 * ```
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm3ErrorCounters(ps) {
    // The implicit form is given by:
    // vₓₓₓx³ + vₓₓᵧx²y + vₓᵧᵧxy² + vᵧᵧᵧy³ + vₓₓx² +vₓᵧxy + vᵧᵧy² + vₓx + vᵧy + v = 0
    //const [[,,,a0],[,,,b0]] = getXY(ps);
    const [a0, b0] = ps[0];
    const [[a3_, a2_, a1_], // <3>a3_, <3>a2_, <2>a1_, <0>a0_  (a0_ is just abs(a0))
    [b3_, b2_, b1_] // <3>b3_, <3>b2_, <2>b1_, <0>b0_  (b0_ is just abs(b0))
    ] = getXY3ErrorCounters(ps);
    //-------------------
    // Error calculation
    //-------------------
    const a0_ = get_implicit_form3_error_counters_abs(a0);
    const b0_ = get_implicit_form3_error_counters_abs(b0);
    // <6>a3b1 <-- <6>(<3>a3*<2>b1);
    const a3b1_ = a3_ * b1_;
    // <6>a1b3 <-- a1*b3;
    const a1b3_ = a1_ * b3_;
    // <7>a3b2 <-- <7>(<3>a3*<3>b2);
    const a3b2_ = a3_ * b2_;
    // <7>a2b3 <-- a2*b3;
    const a2b3_ = a2_ * b3_;
    // <7>a3a3 <-- a3*a3;
    const a3a3_ = a3_ * a3_;
    // <7>b3b3 <-- b3*b3;
    const b3b3_ = b3_ * b3_;
    // <5>q1 <-- <5>(<4>(a3*b0) - <4>(a0*b3));
    const q1_ = a3_ * b0_ + a0_ * b3_;
    // <7>q2 <-- <7>(<6>a3b1 - <6>a1b3);
    const q2_ = a3b1_ + a1b3_;
    // <8>q3 <-- <8>(<7>a3b2 - <7>a2b3);
    const q3_ = a3b2_ + a2b3_;
    // <5>q4 <-- a2*b0 - a0*b2;
    const q4_ = a2_ * b0_ + a0_ * b2_;
    // <7>q5 <-- a2*b1 - a1*b2;
    const q5_ = a2_ * b1_ + a1_ * b2_;
    // <4>q6 <-- <4>(<3>(<2>a1*<0>b0) - <3>(<0>a0*<2>b1));
    const q6_ = a1_ * b0_ + a0_ * b1_;
    // <7>tq2 <-- 2*q2;
    const tq2_ = 2 * q2_;
    // <11>q1q1 <-- <11>(<5>q1*<5>q1)
    const q1q1_ = q1_ * q1_;
    // <13>q1q5 <-- <13>(<5>q1*<7>q5)
    const q1q5_ = q1_ * q5_;
    // <13>tq2q4 <-- <13>(<7>tq2*<5>q4)
    const tq2q4_ = tq2_ * q4_;
    // <14>q3q4 <-- <14>(<8>q3*<5>q4)
    const q3q4_ = q3_ * q4_;
    // <8>u1 <-- <8>(<6>(-3*<5>q1) - <7>q5)
    const u1_ = 3 * q1_ + q5_;
    // <11>vₓₓₓ <-- <11>(-<3>b3*<7>b3b3)
    const vₓₓₓ_ = b3_ * b3b3_;
    // <12>vₓₓᵧ <--  <12>(3*<11>(<3>a3*<7>b3b3))
    const vₓₓᵧ_ = 3 * a3_ * b3b3_;
    // <12>vₓᵧᵧ <-- -3*b3*a3a3
    const vₓᵧᵧ_ = 3 * b3_ * a3a3_;
    // <11>vᵧᵧᵧ <--  a3*a3a3
    const vᵧᵧᵧ_ = a3_ * a3a3_;
    // <19>vₓₓ <-- <19>(<18>(<16>(<8>u1*<7>b3b3) + <17>(<8>q3*(<8>(<6>(b1*b3) - <7>(b2*b2))))) + <15>(<7>tq2*<7>(b2*b3)))
    const vₓₓ_ = (u1_ * b3b3_ + q3_ * (b1_ * b3_ + b2_ * b2_)) + tq2_ * b2_ * b3_;
    // <19>vᵧᵧ <-- <19>((<18>(<16>(<8>u1*<7>a3a3) + <17>(<8>q3*<8>(<6>(a1*a3) - <7>(a2*a2))))) + <15>(<7>tq2*<7>(a2*a3)))
    const vᵧᵧ_ = (u1_ * a3a3_ + q3_ * (a1_ * a3_ + a2_ * a2_)) + tq2_ * a2_ * a3_;
    // <18>vₓᵧ <-- <18>(2*(<17>(<8>q3*<8>(<7>(a2*b2) - <7>(<6>a1b3 + <6>a3b1)/2)) - <17>(<16>(<8>u1*<7>(a3*b3)) + <16>(<7>q2*(<8>(a2b3 + a3b2))))))
    const vₓᵧ_ = 2 * (q3_ * (a2_ * b2_ + (a1b3_ + a3b1_) / 2) + (u1_ * a3_ * b3_ + q2_ * (a2b3_ + a3b2_)));
    // <15>s1 <-- <15>(<14>(<12>(-3*q1q1) - <13>2*q1q5) + <14>(<13>tq2q4 + <13>(<8>q3*<4>q6)))
    const s1_ = (3 * q1q1_ + 2 * q1q5_) + (tq2q4_ + q3_ * q6_);
    // <15>s2 <-- <15>(2*(<13>(<5>q1*<7>q2) - <14>q3q4))
    const s2_ = 2 * (q1_ * q2_ + q3q4_);
    // <17>s3 <-- <17>(<16>(<14>(<5>q1*<8>q3) - <15>(<7>q2*<7>q2)) + <16>(<8>q3*<7>q5))
    const s3_ = q1_ * q3_ + q2_ * q2_ + q3_ * q5_;
    // <22>vₓ <-- <22>(<19>(<3>b3*<15>s1) + <21>(<19>(<3>b2*<15>s2) + <20>(<2>b1*<17>s3)))
    const vₓ_ = b3_ * s1_ + (b2_ * s2_ + b1_ * s3_);
    // <22>vᵧ <-- <22>(<19>(<3>-a3*<15>s1) - <21>(<19>(<3>a2*<15>s2) + <20>(<2>a1*<17>s3)))
    const vᵧ_ = a3_ * s1_ + (a2_ * s2_ + a1_ * s3_);
    // <24>v <-- <24>(<21>(<5>q1*<15>(<14>(<13>tq2q4 - <11>q1q1) - <13>q1q5)) + <23>(<22>(<17>s3*<4>q6) - <20>(<14>q3q4*<5>q4)))
    const v_ = (q1_ * ((tq2q4_ + q1q1_) + q1q5_)) + (s3_ * q6_ + q3q4_ * q4_);
    return {
        vₓₓₓ_,
        vₓₓᵧ_,
        vₓᵧᵧ_,
        vᵧᵧᵧ_,
        vₓₓ_,
        vₓᵧ_,
        vᵧᵧ_,
        vₓ_,
        vᵧ_,
        v_ // <24>
    };
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension-3.ts





// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗


const is_point_on_bezier_extension_3_qmq = node_ddMultDd;
const is_point_on_bezier_extension_3_qaq = node_ddAddDd;
const is_point_on_bezier_extension_3_epr = expansion_product_expansionProduct;
const is_point_on_bezier_extension_3_fes = fastExpansionSum;
const is_point_on_bezier_extension_3_sign = e_sign_eSign;
const is_point_on_bezier_extension_3_estimate = e_estimate_eEstimate;
const is_point_on_bezier_extension_3_etodd = eToDd;
const is_point_on_bezier_extension_3_abs = Math.abs;
const is_point_on_bezier_extension_3_1 = error_analysis_(1);
const is_point_on_bezier_extension_3_3 = error_analysis_error_analysis_(3);
/**
 * Returns `true` if the given point is on the given cubic bezier curve where
 * the parameter, `t`, is allowed to extend to `±∞`, i.e. if `t ∈ (-∞, +∞)`,
 * `false` otherwise.
 *
 * * **precondition:** TODO - underflow/overflow
 *
 * @param ps a cubic bezier curve
 * @param p A point with coordinates given as Shewchuk expansions. If only
 * double precision coordinates need to be provided then wrap it in an array,
 * e.g. for a point with x and y coordinates given as 1 and 2 set
 * `p === [[1],[2]]`. TODO - link to Schewchuk
 *
 * @internal
 */
function isPointOnBezierExtension3(ps, p) {
    const [xe, ye] = p;
    const lenX = xe.length;
    const lenY = ye.length;
    const x = xe[lenX - 1]; // get higest order double
    const y = ye[lenY - 1]; // ...
    const isDouble = (lenX === 1 && lenY === 1);
    //---- first pre-filter
    {
        // The below takes about 1.2 micro-seconds on a 1st gen i7 and Chrome 79
        const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = getImplicitForm3(ps);
        const { vₓₓₓ_, // <11>
        vₓₓᵧ_, // <12>
        vₓᵧᵧ_, // <12>
        vᵧᵧᵧ_, // <11>
        vₓₓ_, // <19>
        vₓᵧ_, // <18>
        vᵧᵧ_, // <19>
        vₓ_, // <22>
        vᵧ_, // <22>
        v_ // <24>
         } = getImplicitForm3ErrorCounters(ps);
        // In the below a a postfix underscore means 
        // an error bound (>= absolute value)
        // h (say height) is the the result of evaluating the implicit equation; if
        // it is 0 we are on the curve, else we're not.
        // const h =
        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + 
        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;
        // group the terms to reduce error, e.g. v usually has the highest bitlength
        // const h = 
        //    (
        //        ((vₓₓₓxxx + vₓₓᵧxxy) + (vₓᵧᵧxyy + vᵧᵧᵧyyy)) + 
        //        (vₓₓxx + vₓᵧxy + vᵧᵧyy)
        //    ) + 
        //    (
        //        (vₓx + vᵧy) + 
        //        v
        //    );
        const xx = x * x;
        const yy = y * y;
        const h = (((vₓₓₓ * (xx * x) + vₓₓᵧ * (xx * y)) +
            (vₓᵧᵧ * (x * yy) + vᵧᵧᵧ * (yy * y))) +
            ((vₓₓ * xx + vₓᵧ * (x * y)) + vᵧᵧ * yy)) +
            ((vₓ * x + vᵧ * y) +
                v);
        //-------------------
        // Error calculation
        //-------------------
        // In the below, if x is given as a double then the error counter on
        // x would be 0, i.e. <0>x, else it would be <1>x. We represent the
        // error counter with a <D> so that for a point with double precion 
        // coordinates we have <D> = <0> else <D> = <1>. Same is true for y.
        // `0` if we have only double precision coordinates, `1` otherwise
        const D = isDouble ? 0 : 1;
        const x_ = is_point_on_bezier_extension_3_abs(x); // <D>x
        const y_ = is_point_on_bezier_extension_3_abs(y); // <D>y
        const xx_ = x_ * x_; // <2D+1>xx
        const xy_ = x_ * y_; // <2D+1>xy
        const yy_ = y_ * y_; // <2D+1>yy
        // <D+26>h <-- <D+26>(<2D+24>(<3D+17>(<3D+16> + <3D+16>) + <2D+23>) + <D+25>(<D+24> + <24>))
        const h_ = (
        // <3D+16> <-- <3D+16>((<3D+14>(<11>vₓₓₓ*<3D+2>(xx*x)) + <3D+15>(<12>vₓₓᵧ*<3D+2>(xx*y)))) +
        (vₓₓₓ_ * (xx_ * x_) + vₓₓᵧ_ * (xx_ * y_)) +
            // <3D+16> <-- <3D+16>((<3D+15>(<12>vₓᵧᵧ*<3D+2>(x*yy)) + <3D+14>(<11>vᵧᵧᵧ*<3D+2>(yy*y)))) +
            (vₓᵧᵧ_ * (x_ * yy_) + vᵧᵧᵧ_ * (yy_ * y_)) +
            // <2D+23> <-- <2D+23>(<2D+22>(<2D+21>(<19>vₓₓ*<2D+1>xx) + <2D+20>(<18>vₓᵧ*<2D+1>(x*y))) + <2D+20>(<18>vᵧᵧ*<2D+1>yy))
            ((vₓₓ_ * xx_ + vₓᵧ_ * (xy_)) + vᵧᵧ_ * yy_)) +
            (
            // <24> <-- <D+24>(<D+23>(<22>vₓ*<D>x) + <D+23>(<22>vᵧ*<D>y))
            (vₓ_ * x_ + vᵧ_ * y_) +
                // <24>
                v_);
        // if the error is not too high too discern `h` away from zero
        if ((D + 26) * is_point_on_bezier_extension_3_1 * h_ < is_point_on_bezier_extension_3_abs(h)) {
            return false; // <-- prefilter applied
        }
    }
    // error too high - let's try double-double precision
    {
        // The below takes about 15 micro-seconds on a 1st gen i7 and Chrome 79
        const { coeffs: { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v }, errorBound: { vₓₓₓ_, vₓₓᵧ_, vₓᵧᵧ_, vᵧᵧᵧ_, vₓₓ_, vₓᵧ_, vᵧᵧ_, vₓ_, vᵧ_, v_ } } = getImplicitForm3DdWithRunningError(ps);
        const _vₓₓₓ = is_point_on_bezier_extension_3_abs(vₓₓₓ[1]);
        const _vₓₓᵧ = is_point_on_bezier_extension_3_abs(vₓₓᵧ[1]);
        const _vₓᵧᵧ = is_point_on_bezier_extension_3_abs(vₓᵧᵧ[1]);
        const _vᵧᵧᵧ = is_point_on_bezier_extension_3_abs(vᵧᵧᵧ[1]);
        // In the below a prefix underscore on a variable means absolute value, 
        // a postfix underscore means error bound (before multiplication by gamma).
        // h (say height) is the the result of evaluating the implicit equation; if
        // it is 0 we are on the curve, else we're not.
        // const h =
        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + 
        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;
        const xd = is_point_on_bezier_extension_3_etodd(xe);
        const yd = is_point_on_bezier_extension_3_etodd(ye);
        const _x = is_point_on_bezier_extension_3_abs(x);
        const _y = is_point_on_bezier_extension_3_abs(y);
        // we're multiplying by `γγ3` at the end but the error `x_` is only `γγ1`
        // and hence we need to divide the error by 3.
        const x_ = _x / 3;
        const y_ = _y / 3;
        const xx = is_point_on_bezier_extension_3_qmq(xd, xd);
        const _xx = xx[1];
        const xx_ = 2 * (_x * x_ + _xx);
        const xxx = is_point_on_bezier_extension_3_qmq(xd, xx);
        const _xxx = is_point_on_bezier_extension_3_abs(xxx[1]);
        const xxx_ = _x * xx_ + x_ * _xx + 2 * _xxx;
        const yy = is_point_on_bezier_extension_3_qmq(yd, yd);
        const _yy = yy[1];
        const yy_ = 2 * (_y * y_ + _yy);
        const yyy = is_point_on_bezier_extension_3_qmq(yd, yy);
        const _yyy = is_point_on_bezier_extension_3_abs(yyy[1]);
        const yyy_ = _y * yy_ + y_ * _yy + 2 * _yyy;
        const xxy = is_point_on_bezier_extension_3_qmq(yd, xx);
        const _xxy = is_point_on_bezier_extension_3_abs(xxy[1]);
        const xxy_ = _y * xx_ + y_ * _xx + 2 * _xxy;
        const xyy = is_point_on_bezier_extension_3_qmq(xd, yy);
        const _xyy = is_point_on_bezier_extension_3_abs(xyy[1]);
        const xyy_ = _x * yy_ + x_ * _yy + 2 * _xyy;
        const xy = is_point_on_bezier_extension_3_qmq(xd, yd);
        const _xy = is_point_on_bezier_extension_3_abs(xy[1]);
        const xy_ = _x * y_ + x_ * _y + 2 * _xy;
        const vₓₓₓxxx = is_point_on_bezier_extension_3_qmq(vₓₓₓ, xxx);
        const vₓₓₓxxx_ = _vₓₓₓ * xxx_ + vₓₓₓ_ * _xxx + 2 * is_point_on_bezier_extension_3_abs(vₓₓₓxxx[1]);
        const vₓₓᵧxxy = is_point_on_bezier_extension_3_qmq(vₓₓᵧ, xxy);
        const vₓₓᵧxxy_ = _vₓₓᵧ * xxy_ + vₓₓᵧ_ * _xxy + 2 * is_point_on_bezier_extension_3_abs(vₓₓᵧxxy[1]);
        const vₓᵧᵧxyy = is_point_on_bezier_extension_3_qmq(vₓᵧᵧ, xyy);
        const vₓᵧᵧxyy_ = _vₓᵧᵧ * xyy_ + vₓᵧᵧ_ * _xyy + 2 * is_point_on_bezier_extension_3_abs(vₓᵧᵧxyy[1]);
        const vᵧᵧᵧyyy = is_point_on_bezier_extension_3_qmq(vᵧᵧᵧ, yyy);
        const vᵧᵧᵧyyy_ = _vᵧᵧᵧ * yyy_ + vᵧᵧᵧ_ * _yyy + 2 * is_point_on_bezier_extension_3_abs(vᵧᵧᵧyyy[1]);
        const vₓₓxx = is_point_on_bezier_extension_3_qmq(vₓₓ, xx);
        const vₓₓxx_ = is_point_on_bezier_extension_3_abs(vₓₓ[1]) * xx_ + vₓₓ_ * _xx + 2 * is_point_on_bezier_extension_3_abs(vₓₓxx[1]);
        const vₓᵧxy = is_point_on_bezier_extension_3_qmq(vₓᵧ, xy);
        const vₓᵧxy_ = is_point_on_bezier_extension_3_abs(vₓᵧ[1]) * xy_ + vₓᵧ_ * _xy + 2 * is_point_on_bezier_extension_3_abs(vₓᵧxy[1]);
        const vᵧᵧyy = is_point_on_bezier_extension_3_qmq(vᵧᵧ, yy);
        const vᵧᵧyy_ = is_point_on_bezier_extension_3_abs(vᵧᵧ[1]) * yy_ + vᵧᵧ_ * _yy + 2 * is_point_on_bezier_extension_3_abs(vᵧᵧyy[1]);
        const vₓx = is_point_on_bezier_extension_3_qmq(xd, vₓ);
        const vₓx_ = is_point_on_bezier_extension_3_abs(vₓ[1]) * x_ + vₓ_ * _x + 2 * is_point_on_bezier_extension_3_abs(vₓx[1]);
        const vᵧy = is_point_on_bezier_extension_3_qmq(yd, vᵧ);
        const vᵧy_ = is_point_on_bezier_extension_3_abs(vᵧ[1]) * y_ + vᵧ_ * _y + 2 * is_point_on_bezier_extension_3_abs(vᵧy[1]);
        // group the terms to reduce error, e.g. v usually has the highest bitlength
        //const h = 
        //    (
        //        ((vₓₓₓxxx + vₓₓᵧxxy) + (vₓᵧᵧxyy + vᵧᵧᵧyyy)) + 
        //        (vₓₓxx + vₓᵧxy + vᵧᵧyy)
        //    ) + 
        //    (
        //        (vₓx + vᵧy) + 
        //        v
        //    );
        const q1 = is_point_on_bezier_extension_3_qaq(vₓₓₓxxx, vₓₓᵧxxy);
        const q1_ = vₓₓₓxxx_ + vₓₓᵧxxy_ + is_point_on_bezier_extension_3_abs(q1[1]);
        const q2 = is_point_on_bezier_extension_3_qaq(vₓᵧᵧxyy, vᵧᵧᵧyyy);
        const q2_ = vₓᵧᵧxyy_ + vᵧᵧᵧyyy_ + is_point_on_bezier_extension_3_abs(q2[1]);
        const q3 = is_point_on_bezier_extension_3_qaq(q1, q2);
        const q3_ = q1_ + q2_ + is_point_on_bezier_extension_3_abs(q3[1]);
        const q4 = is_point_on_bezier_extension_3_qaq(vₓₓxx, vₓᵧxy);
        const q4_ = vₓₓxx_ + vₓᵧxy_ + is_point_on_bezier_extension_3_abs(q4[1]);
        const q5 = is_point_on_bezier_extension_3_qaq(q4, vᵧᵧyy);
        const q5_ = q4_ + vᵧᵧyy_ + is_point_on_bezier_extension_3_abs(q5[1]);
        const q6 = is_point_on_bezier_extension_3_qaq(q3, q5);
        const q6_ = q3_ + q5_ + is_point_on_bezier_extension_3_abs(q6[1]);
        const q7 = is_point_on_bezier_extension_3_qaq(vₓx, vᵧy);
        const q7_ = vₓx_ + vᵧy_ + is_point_on_bezier_extension_3_abs(q7[1]);
        const q8 = is_point_on_bezier_extension_3_qaq(q7, v);
        const q8_ = q7_ + v_ + is_point_on_bezier_extension_3_abs(q8[1]);
        const h = is_point_on_bezier_extension_3_qaq(q6, q8);
        const h_ = q6_ + q8_ + is_point_on_bezier_extension_3_abs(h[1]);
        // if the error is not too high too discern h away from zero
        if (is_point_on_bezier_extension_3_3 * h_ < is_point_on_bezier_extension_3_abs(is_point_on_bezier_extension_3_estimate(h))) {
            return false; // <-- prefilter applied
        }
    }
    // error still too high - const's go exact
    {
        // The below takes about 155 micro-seconds on a 1st gen i7 and Chrome 79
        const implictForm = getImplicitForm3Exact(ps);
        if (implictForm === undefined) {
            // all ps are the same point
            return isDouble && x === ps[0][0] && y === ps[0][1];
        }
        let { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = implictForm;
        // `h` (say height) is the the result of evaluating the implicit 
        // equation; if it is 0 we are on the curve, else we're not.
        // const h =
        //   vₓₓₓ*x*x*x + vₓₓᵧ*x*x*y + vₓᵧᵧ*x*y*y + vᵧᵧᵧ*y*y*y + 
        //   vₓₓ*x*x + vₓᵧ*x*y + vᵧᵧ*y*y + vₓ*x + vᵧ*y + v;
        const xx = is_point_on_bezier_extension_3_epr(xe, xe); // <= error free
        const xxx = is_point_on_bezier_extension_3_epr(xe, xx);
        const yy = is_point_on_bezier_extension_3_epr(ye, ye); // <= error free
        const yyy = is_point_on_bezier_extension_3_epr(ye, yy);
        const xxy = is_point_on_bezier_extension_3_epr(ye, xx);
        const xyy = is_point_on_bezier_extension_3_epr(xe, yy);
        const xy = is_point_on_bezier_extension_3_epr(xe, ye); // <= error free
        const vₓₓₓxxx = is_point_on_bezier_extension_3_epr(vₓₓₓ, xxx);
        const vₓₓᵧxxy = is_point_on_bezier_extension_3_epr(vₓₓᵧ, xxy);
        const vₓᵧᵧxyy = is_point_on_bezier_extension_3_epr(vₓᵧᵧ, xyy);
        const vᵧᵧᵧyyy = is_point_on_bezier_extension_3_epr(vᵧᵧᵧ, yyy);
        const vₓₓxx = is_point_on_bezier_extension_3_epr(vₓₓ, xx);
        const vₓᵧxy = is_point_on_bezier_extension_3_epr(vₓᵧ, xy);
        const vᵧᵧyy = is_point_on_bezier_extension_3_epr(vᵧᵧ, yy);
        const vₓx = is_point_on_bezier_extension_3_epr(xe, vₓ);
        const vᵧy = is_point_on_bezier_extension_3_epr(ye, vᵧ);
        const q1 = is_point_on_bezier_extension_3_fes(vₓₓₓxxx, vₓₓᵧxxy);
        const q2 = is_point_on_bezier_extension_3_fes(vₓᵧᵧxyy, vᵧᵧᵧyyy);
        const q3 = is_point_on_bezier_extension_3_fes(q1, q2);
        const q4 = is_point_on_bezier_extension_3_fes(vₓₓxx, vₓᵧxy);
        const q5 = is_point_on_bezier_extension_3_fes(q4, vᵧᵧyy);
        const q6 = is_point_on_bezier_extension_3_fes(q3, q5);
        const q7 = is_point_on_bezier_extension_3_fes(vₓx, vᵧy);
        const q8 = is_point_on_bezier_extension_3_fes(q7, v);
        const h = is_point_on_bezier_extension_3_fes(q6, q8);
        return is_point_on_bezier_extension_3_sign(h) === 0; // <= calculation was exact
    }
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/is-point-on-bezier-extension/is-point-on-bezier-extension.ts




/**
 * Returns `true` if the given point is on the given bezier curve where the
 * parameter `t` is allowed to extend to ±∞, i.e. `t` is an element of
 * `(-∞, +∞)`, `false` otherwise.
 *
 * * **precondition**: TODO - underflow/overflow
 *
 * @param ps a bezier curve
 * @param p A point with coordinates given as Shewchuk expansions. If only
 * double precision coordinates need to be provided then wrap it in an array,
 * e.g. for a point with x and y coordinates given as `1` and `2` set
 * `p === [[1],[2]]`. TODO - link to Schewchuk
 */
function isPointOnBezierExtension(ps, p) {
    if (ps.length === 4) {
        return isPointOnBezierExtension3(ps, p);
    }
    if (ps.length === 3) {
        return isPointOnBezierExtension2(ps, p);
    }
    if (ps.length === 2) {
        return isPointOnBezierExtension1(ps, p);
    }
    if (ps.length === 1) {
        const x = e_compress_eCompress(p[0]);
        const y = e_compress_eCompress(p[1]);
        return (x.length === 1 && y.length === 1 &&
            x[0] === ps[0][0] && y[0] === ps[0][1]);
    }
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez1-exact.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗





const get_coeffs_bez3_bez1_exact_tp = two_product_twoProduct; // error -> 0
const get_coeffs_bez3_bez1_exact_sce = scale_expansion_scaleExpansion2;
const get_coeffs_bez3_bez1_exact_epr = expansion_product_expansionProduct;
const get_coeffs_bez3_bez1_exact_fes = fastExpansionSum;
const get_coeffs_bez3_bez1_exact_em2 = eMultBy2;
const get_coeffs_bez3_bez1_exact_eSign = e_sign_eSign;
/**
 * Returns an error-free polynomial in 1 variable
 * whose roots are the parameter values of the intersection points of an order
 * 3 and 1 bezier curve (i.e. a cubic bezier curve and a line).
 *
 * The returned polynomial degree will be 3
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:**  TODO - add underflow / overflow conditions
 * * the returned polynomial coefficients are exact (i.e. error-free)
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez3Bez1Exact(ps1, ps2) {
    /** ps1 in power bases */
    const ps1pb = getXY3Exact(ps1);
    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;
    // if both polynomials' cubic terms are exactly zero then its really a quadratic
    if (get_coeffs_bez3_bez1_exact_eSign(ps1pb[0][0]) === 0 && get_coeffs_bez3_bez1_exact_eSign(ps1pb[1][0]) === 0) {
        // the input bezier curve is in fact not cubic but has order < 3
        return getCoeffsBez2Bez1Exact(toQuadraticFromCubic(ps1), ps2);
    }
    const [[c1, c0], [d1, d0]] = getXY1Exact(ps2);
    if (get_coeffs_bez3_bez1_exact_eSign(c1) === 0 && get_coeffs_bez3_bez1_exact_eSign(d1) === 0) {
        // the input bezier curve is in fact not a line but has order < 1,
        // i.e. it is a point
        // TODO
        const p = ps2[0];
        return isPointOnBezierExtension(ps1, [[p[0]], [p[1]]])
            ? [[0]] // infinite intersections
            : [[1]]; // no intersections
    }
    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = 
    // this type coercion is justified since we already checked that the
    // curve really has order 3
    getImplicitForm3ExactPb(ps1pb);
    const c0c0 = get_coeffs_bez3_bez1_exact_tp(c0, c0);
    const c0c1 = get_coeffs_bez3_bez1_exact_sce(c0, c1);
    const c0d0 = get_coeffs_bez3_bez1_exact_tp(c0, d0);
    const c0d1 = get_coeffs_bez3_bez1_exact_sce(c0, d1);
    const c1c1 = get_coeffs_bez3_bez1_exact_epr(c1, c1);
    const c1d0 = get_coeffs_bez3_bez1_exact_sce(d0, c1);
    const c1d1 = get_coeffs_bez3_bez1_exact_epr(c1, d1);
    const d0d0 = get_coeffs_bez3_bez1_exact_tp(d0, d0);
    const d0d1 = get_coeffs_bez3_bez1_exact_sce(d0, d1);
    const d1d1 = get_coeffs_bez3_bez1_exact_epr(d1, d1);
    const z1 = get_coeffs_bez3_bez1_exact_sce(c0, vₓₓₓ);
    const z7 = get_coeffs_bez3_bez1_exact_epr(get_coeffs_bez3_bez1_exact_tp(3, c0), vₓₓₓ);
    const z2 = get_coeffs_bez3_bez1_exact_sce(c0, vₓₓᵧ);
    const z3 = get_coeffs_bez3_bez1_exact_sce(d0, vₓₓᵧ);
    const z4 = get_coeffs_bez3_bez1_exact_sce(c0, vₓᵧᵧ);
    const z5 = get_coeffs_bez3_bez1_exact_sce(d0, vₓᵧᵧ);
    const z6 = get_coeffs_bez3_bez1_exact_sce(d0, vᵧᵧᵧ);
    const z8 = get_coeffs_bez3_bez1_exact_epr(get_coeffs_bez3_bez1_exact_tp(3, d0), vᵧᵧᵧ);
    // a1**3*v_xxx + a1**2*b1*v_xxy + a1*b1**2*v_xyy + b1**3*v_yyy
    //const v3 =
    //    c1c1*(c1*vₓₓₓ + d1*vₓₓᵧ) +
    //    d1d1*(c1*vₓᵧᵧ + d1*vᵧᵧᵧ);
    const u1 = get_coeffs_bez3_bez1_exact_epr(c1, vₓₓₓ);
    const u2 = get_coeffs_bez3_bez1_exact_epr(c1, vₓᵧᵧ);
    const u3 = get_coeffs_bez3_bez1_exact_epr(d1, vₓₓᵧ);
    const u4 = get_coeffs_bez3_bez1_exact_epr(d1, vᵧᵧᵧ);
    const u5 = get_coeffs_bez3_bez1_exact_fes(u1, u3);
    const u6 = get_coeffs_bez3_bez1_exact_fes(u2, u4);
    const u7 = get_coeffs_bez3_bez1_exact_epr(c1c1, u5);
    const u8 = get_coeffs_bez3_bez1_exact_epr(d1d1, u6);
    const v3 = get_coeffs_bez3_bez1_exact_fes(u7, u8);
    // 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + a0*b1**2*v_xyy + a1**2*b0*v_xxy + a1**2*v_xx + 2*a1*b0*b1*v_xyy + a1*b1*v_xy + 3*b0*b1**2*v_yyy + b1**2*v_yy
    //const v2 =
    //    c1c1*(3*c0*vₓₓₓ +   d0*vₓₓᵧ + vₓₓ) +
    //    c1d1*(2*c0*vₓₓᵧ + 2*d0*vₓᵧᵧ + vₓᵧ) +
    //    d1d1*(  c0*vₓᵧᵧ + 3*d0*vᵧᵧᵧ + vᵧᵧ);
    //const v2 =
    //    c1c1*(3*z1 +   z3 + vₓₓ) +
    //    c1d1*(2*z2 + 2*z5 + vₓᵧ) +
    //    d1d1*(  z4 + 3*z6 + vᵧᵧ);
    const u9 = get_coeffs_bez3_bez1_exact_fes(z7, z3);
    const ua = get_coeffs_bez3_bez1_exact_em2(get_coeffs_bez3_bez1_exact_fes(z2, z5));
    const ub = get_coeffs_bez3_bez1_exact_fes(z4, z8);
    const uc = get_coeffs_bez3_bez1_exact_fes(u9, vₓₓ);
    const ud = get_coeffs_bez3_bez1_exact_fes(ua, vₓᵧ);
    const ue = get_coeffs_bez3_bez1_exact_fes(ub, vᵧᵧ);
    const uf = get_coeffs_bez3_bez1_exact_epr(c1c1, uc);
    const ug = get_coeffs_bez3_bez1_exact_epr(c1d1, ud);
    const uh = get_coeffs_bez3_bez1_exact_epr(d1d1, ue);
    const ui = get_coeffs_bez3_bez1_exact_fes(uf, ug);
    const v2 = get_coeffs_bez3_bez1_exact_fes(ui, uh);
    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y
    //const v1 =
    //    c0c1*(3*c0*vₓₓₓ + 2*(d0*vₓₓᵧ + vₓₓ)) +
    //    d0d1*(3*d0*vᵧᵧᵧ + 2*(c0*vₓᵧᵧ + vᵧᵧ)) +
    //    c0d1*(c0*vₓₓᵧ + vₓᵧ) +
    //    c1d0*(d0*vₓᵧᵧ + vₓᵧ) +
    //    vₓ*c1 +
    //    vᵧ*d1;
    const uj = get_coeffs_bez3_bez1_exact_em2(get_coeffs_bez3_bez1_exact_fes(z3, vₓₓ));
    const uk = get_coeffs_bez3_bez1_exact_em2(get_coeffs_bez3_bez1_exact_fes(z4, vᵧᵧ));
    const un = get_coeffs_bez3_bez1_exact_fes(z7, uj);
    const uo = get_coeffs_bez3_bez1_exact_fes(z8, uk);
    const up = get_coeffs_bez3_bez1_exact_fes(z2, vₓᵧ);
    const uq = get_coeffs_bez3_bez1_exact_fes(z5, vₓᵧ);
    const ur = get_coeffs_bez3_bez1_exact_epr(c0c1, un);
    const us = get_coeffs_bez3_bez1_exact_epr(d0d1, uo);
    const ut = get_coeffs_bez3_bez1_exact_epr(c0d1, up);
    const uu = get_coeffs_bez3_bez1_exact_epr(c1d0, uq);
    const uv = get_coeffs_bez3_bez1_exact_epr(c1, vₓ);
    const uw = get_coeffs_bez3_bez1_exact_epr(d1, vᵧ);
    const ux = get_coeffs_bez3_bez1_exact_fes(ur, us);
    const uy = get_coeffs_bez3_bez1_exact_fes(ut, uu);
    const uz = get_coeffs_bez3_bez1_exact_fes(ux, uy);
    const u0 = get_coeffs_bez3_bez1_exact_fes(uv, uw);
    const v1 = get_coeffs_bez3_bez1_exact_fes(uz, u0);
    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0
    //const v0 =
    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +
    //    d0d0*(d0*vᵧᵧᵧ + c0*vₓᵧᵧ + vᵧᵧ) +
    //    c0d0*vₓᵧ +
    //    c0*vₓ    +
    //    d0*vᵧ    +
    //    v;
    //const v0 =
    //    c0c0*(z1 + z3 + vₓₓ) +
    //    d0d0*(z6 + z4 + vᵧᵧ) +
    //    c0d0*vₓᵧ +
    //    c0*vₓ    +
    //    d0*vᵧ    +
    //    v;
    const f1 = get_coeffs_bez3_bez1_exact_fes(z1, z3);
    const f2 = get_coeffs_bez3_bez1_exact_fes(z6, z4);
    const f3 = get_coeffs_bez3_bez1_exact_fes(f1, vₓₓ);
    const f4 = get_coeffs_bez3_bez1_exact_fes(f2, vᵧᵧ);
    const f5 = get_coeffs_bez3_bez1_exact_epr(c0c0, f3);
    const f6 = get_coeffs_bez3_bez1_exact_epr(d0d0, f4);
    const f7 = get_coeffs_bez3_bez1_exact_epr(c0d0, vₓᵧ);
    const f8 = get_coeffs_bez3_bez1_exact_fes(f5, f6);
    const f9 = get_coeffs_bez3_bez1_exact_fes(f8, f7);
    const fa = get_coeffs_bez3_bez1_exact_sce(c0, vₓ);
    const fb = get_coeffs_bez3_bez1_exact_sce(d0, vᵧ);
    const fc = get_coeffs_bez3_bez1_exact_fes(fa, fb);
    const fd = get_coeffs_bez3_bez1_exact_fes(f9, fc);
    const v0 = get_coeffs_bez3_bez1_exact_fes(fd, v);
    const r = [v3, v2, v1, v0];
    // remove leading zero coefficients
    //while (r.length > 1 && eSign(r[0]) === 0) {
    //    r.shift();
    //}
    return r;
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez2-exact.ts


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗


const get_coeffs_bez1_bez2_exact_sce = scale_expansion_scaleExpansion2;
const get_coeffs_bez1_bez2_exact_epr = expansion_product_expansionProduct;
const get_coeffs_bez1_bez2_exact_fes = fastExpansionSum;
const get_coeffs_bez1_bez2_exact_eSign = e_sign_eSign;
/**
 * Returns an error-free polynomial in 1 variable
 * whose roots are the parameter values of the intersection points of an order
 * 1 and order 2 bezier curve (i.e. a line and a quadratic bezier curve).
 *
 * The returned polynomial degree will be 2
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:**  TODO - add underflow / overflow conditions
 * * the returned polynomial coefficients are exact (i.e. error-free)
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez1Bez2Exact(ps1, ps2) {
    /** ps1 in power bases */
    const ps1pb = getXY1Exact(ps1);
    //const [[e1,e0],[f1,f0]] = ps1pb;
    // if both polynomials' linear terms are exactly zero then it really is a point
    if (get_coeffs_bez1_bez2_exact_eSign(ps1pb[0][0]) === 0 && get_coeffs_bez1_bez2_exact_eSign(ps1pb[1][0]) === 0) {
        // the input bezier curve is in fact not a line but has order < 1,
        // i.e. it is a point
        // TODO
        //return getCoeffsBez0Bez3ExactAnyBitlength([ps1[0]], ps2]);
    }
    const [[c2, c1, c0], [d2, d1, d0]] = getXY2Exact(ps2);
    if (get_coeffs_bez1_bez2_exact_eSign(c2) === 0 && get_coeffs_bez1_bez2_exact_eSign(d2) === 0) {
        // the input bezier curve is in fact not quadratic but has order < 2
        return getCoeffsBez1Bez1Exact(ps1, [ps2[0], ps2[2]]);
    }
    const { vₓ, vᵧ, v } = 
    // this type coercion is justified since we already checked that the
    // curve really has order 1
    getImplicitForm1ExactPb(ps1pb);
    // a2*v_x + b2*v_y
    //const v2 = c2*vₓ + d2*vᵧ;
    const p1 = get_coeffs_bez1_bez2_exact_epr(c2, vₓ);
    const p2 = get_coeffs_bez1_bez2_exact_epr(d2, vᵧ);
    const v2 = get_coeffs_bez1_bez2_exact_fes(p1, p2);
    // a1*v_x + b1*v_y
    //const v1 = c1*vₓ + d1*vᵧ;
    const p3 = get_coeffs_bez1_bez2_exact_epr(c1, vₓ);
    const p4 = get_coeffs_bez1_bez2_exact_epr(d1, vᵧ);
    const v1 = get_coeffs_bez1_bez2_exact_fes(p3, p4);
    // a0*v_x + b0*v_y + v_0
    //const v0 = c0*vₓ + d0*vᵧ + v;
    const p5 = get_coeffs_bez1_bez2_exact_sce(c0, vₓ);
    const p6 = get_coeffs_bez1_bez2_exact_sce(d0, vᵧ);
    const p7 = get_coeffs_bez1_bez2_exact_fes(p5, p6);
    const v0 = get_coeffs_bez1_bez2_exact_fes(p7, v);
    const r = [v2, v1, v0];
    // remove leading zero coefficients
    //while (r.length > 1 && eSign(r[0]) === 0) {
    //    r.shift();
    //}
    return r;
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez2-exact.ts


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗



const get_coeffs_bez2_bez2_exact_tp = two_product_twoProduct; // error -> 0
const get_coeffs_bez2_bez2_exact_sce = scale_expansion_scaleExpansion2;
const get_coeffs_bez2_bez2_exact_epr = expansion_product_expansionProduct;
const get_coeffs_bez2_bez2_exact_fes = fastExpansionSum;
const get_coeffs_bez2_bez2_exact_em2 = eMultBy2;
const get_coeffs_bez2_bez2_exact_eSign = e_sign_eSign;
/**
 * Returns an error-free polynomial in 1 variable
 * whose roots are the parameter values of the intersection points of 2 order
 * 2 bezier curves (i.e. 2 quadratic bezier curves).
 *
 * The returned polynomial degree will be 4
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:**  TODO - add underflow / overflow conditions
 * * the returned polynomial coefficients are exact (i.e. error-free)
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez2Bez2Exact(ps1, ps2) {
    /** ps1 in power bases */
    const ps1pb = getXY2Exact(ps1);
    //const [[e2,e1,e0],[f2,f1,f0]] = ps1pb;
    // if both polynomials' quadratic terms are exactly zero then its really a line
    if (get_coeffs_bez2_bez2_exact_eSign(ps1pb[0][0]) === 0 && get_coeffs_bez2_bez2_exact_eSign(ps1pb[1][0]) === 0) {
        // the input bezier curve is in fact not quadratic but has order < 2
        return getCoeffsBez1Bez2Exact([ps1[0], ps1[2]], ps2);
    }
    const [[c2, c1, c0], [d2, d1, d0]] = getXY2Exact(ps2);
    if (get_coeffs_bez2_bez2_exact_eSign(c2) === 0 && get_coeffs_bez2_bez2_exact_eSign(d2) === 0) {
        // the input bezier curve is in fact not quadratic but has order < 2
        return getCoeffsBez2Bez1Exact(ps1, [ps2[0], ps2[2]]);
    }
    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = 
    // this type coercion is justified since we already checked that the
    // curve really has order 2
    getImplicitForm2ExactPb(ps1pb);
    const c0c0 = get_coeffs_bez2_bez2_exact_tp(c0, c0);
    const c0c1 = get_coeffs_bez2_bez2_exact_sce(c0, c1);
    const c0c2 = get_coeffs_bez2_bez2_exact_sce(c0, c2);
    const c0d0 = get_coeffs_bez2_bez2_exact_tp(c0, d0);
    const c0d1 = get_coeffs_bez2_bez2_exact_sce(c0, d1);
    const c0d2 = get_coeffs_bez2_bez2_exact_sce(c0, d2);
    const c1c1 = get_coeffs_bez2_bez2_exact_epr(c1, c1);
    const c1c2 = get_coeffs_bez2_bez2_exact_epr(c1, c2);
    const c1d0 = get_coeffs_bez2_bez2_exact_sce(d0, c1);
    const c1d1 = get_coeffs_bez2_bez2_exact_epr(c1, d1);
    const c1d2 = get_coeffs_bez2_bez2_exact_epr(c1, d2);
    const c2d1 = get_coeffs_bez2_bez2_exact_epr(c2, d1);
    const c2c2 = get_coeffs_bez2_bez2_exact_epr(c2, c2);
    const c2d0 = get_coeffs_bez2_bez2_exact_sce(d0, c2);
    const c2d2 = get_coeffs_bez2_bez2_exact_epr(c2, d2);
    const d0d0 = get_coeffs_bez2_bez2_exact_tp(d0, d0);
    const d0d1 = get_coeffs_bez2_bez2_exact_sce(d0, d1);
    const d0d2 = get_coeffs_bez2_bez2_exact_sce(d0, d2);
    const d1d1 = get_coeffs_bez2_bez2_exact_epr(d1, d1);
    const d1d2 = get_coeffs_bez2_bez2_exact_epr(d1, d2);
    const d2d2 = get_coeffs_bez2_bez2_exact_epr(d2, d2);
    // a2**2*v_xx + a2*b2*v_xy + b2**2*v_yy
    //const v4 = 
    //    (c2*c2)*vₓₓ +
    //    (c2*d2)*vₓᵧ +
    //    (d2*d2)*vᵧᵧ;
    const p1 = get_coeffs_bez2_bez2_exact_epr(c2c2, vₓₓ);
    const p2 = get_coeffs_bez2_bez2_exact_epr(c2d2, vₓᵧ);
    const p3 = get_coeffs_bez2_bez2_exact_epr(d2d2, vᵧᵧ);
    const p4 = get_coeffs_bez2_bez2_exact_fes(p1, p2);
    const v4 = get_coeffs_bez2_bez2_exact_fes(p4, p3);
    // 2*a1*a2*v_xx + a1*b2*v_xy + a2*b1*v_xy + 2*b1*b2*v_yy
    //const v3 =
    //    2*((c1*c2)*vₓₓ + (d1*d2)*vᵧᵧ) +
    //    ((c1*d2) + (c2*d1))*vₓᵧ;
    const p5 = get_coeffs_bez2_bez2_exact_epr(c1c2, vₓₓ);
    const p6 = get_coeffs_bez2_bez2_exact_epr(d1d2, vᵧᵧ);
    const p7 = get_coeffs_bez2_bez2_exact_fes(c1d2, c2d1);
    const p8 = get_coeffs_bez2_bez2_exact_epr(p7, vₓᵧ);
    const p9 = get_coeffs_bez2_bez2_exact_em2(get_coeffs_bez2_bez2_exact_fes(p5, p6));
    const v3 = get_coeffs_bez2_bez2_exact_fes(p9, p8);
    // 2*a0*a2*v_xx + a0*b2*v_xy + a1**2*v_xx + 
    // a1*b1*v_xy + a2*b0*v_xy + a2*v_x + 
    // 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y
    //const v2 = 
    //    (2*(c0*c2) + (c1*c1))*vₓₓ +
    //    (2*(d0*d2) + (d1*d1))*vᵧᵧ +          
    //    ((c0*d2) + (c1*d1) + (c2*d0))*vₓᵧ +
    //    c2*vₓ  +          
    //    d2*vᵧ;
    const pa = get_coeffs_bez2_bez2_exact_fes(get_coeffs_bez2_bez2_exact_em2(c0c2), c1c1);
    const pb = get_coeffs_bez2_bez2_exact_fes(get_coeffs_bez2_bez2_exact_em2(d0d2), d1d1);
    const pc = get_coeffs_bez2_bez2_exact_fes(c0d2, c1d1);
    const pd = get_coeffs_bez2_bez2_exact_fes(pc, c2d0);
    const pe = get_coeffs_bez2_bez2_exact_epr(pa, vₓₓ);
    const pf = get_coeffs_bez2_bez2_exact_epr(pb, vᵧᵧ);
    const pg = get_coeffs_bez2_bez2_exact_epr(pd, vₓᵧ);
    const ph = get_coeffs_bez2_bez2_exact_epr(c2, vₓ);
    const pi = get_coeffs_bez2_bez2_exact_epr(d2, vᵧ);
    const pj = get_coeffs_bez2_bez2_exact_fes(pe, pf);
    const pk = get_coeffs_bez2_bez2_exact_fes(pj, pg);
    const pl = get_coeffs_bez2_bez2_exact_fes(ph, pi);
    const v2 = get_coeffs_bez2_bez2_exact_fes(pk, pl);
    // 2*a0*a1*v_xx + a0*b1*v_xy + a1*b0*v_xy + 
    // a1*v_x + 2*b0*b1*v_yy + b1*v_y
    //const v1 =
    //    2*((c0*c1)*vₓₓ + (d0*d1)*vᵧᵧ) +
    //    ((c0*d1) + (c1*d0))*vₓᵧ +
    //    c1*vₓ  +
    //    d1*vᵧ;
    const pm = get_coeffs_bez2_bez2_exact_epr(c0c1, vₓₓ);
    const pn = get_coeffs_bez2_bez2_exact_epr(d0d1, vᵧᵧ);
    const po = get_coeffs_bez2_bez2_exact_fes(c0d1, c1d0);
    const pp = get_coeffs_bez2_bez2_exact_epr(po, vₓᵧ);
    const pq = get_coeffs_bez2_bez2_exact_em2(get_coeffs_bez2_bez2_exact_fes(pm, pn));
    const pr = get_coeffs_bez2_bez2_exact_epr(c1, vₓ);
    const ps = get_coeffs_bez2_bez2_exact_epr(d1, vᵧ);
    const pt = get_coeffs_bez2_bez2_exact_fes(pq, pp);
    const pu = get_coeffs_bez2_bez2_exact_fes(pr, ps);
    const v1 = get_coeffs_bez2_bez2_exact_fes(pt, pu);
    // a0**2*v_xx + a0*b0*v_xy + a0*v_x + 
    // b0**2*v_yy + b0*v_y + v_0
    //const v0 =
    //    (c0*c0)*vₓₓ + 
    //    (c0*d0)*vₓᵧ + 
    //    (d0*d0)*vᵧᵧ + 
    //    c0*vₓ  +         
    //    d0*vᵧ  +
    //    v;
    const pv = get_coeffs_bez2_bez2_exact_epr(c0c0, vₓₓ);
    const pw = get_coeffs_bez2_bez2_exact_epr(c0d0, vₓᵧ);
    const px = get_coeffs_bez2_bez2_exact_epr(d0d0, vᵧᵧ);
    const py = get_coeffs_bez2_bez2_exact_sce(c0, vₓ);
    const pz = get_coeffs_bez2_bez2_exact_sce(d0, vᵧ);
    const q1 = get_coeffs_bez2_bez2_exact_fes(pv, pw);
    const q2 = get_coeffs_bez2_bez2_exact_fes(q1, px);
    const q3 = get_coeffs_bez2_bez2_exact_fes(py, pz);
    const q4 = get_coeffs_bez2_bez2_exact_fes(q2, q3);
    const v0 = get_coeffs_bez2_bez2_exact_fes(q4, v);
    const r = [v4, v3, v2, v1, v0];
    // remove leading zero coefficients
    //while (r.length > 1 && eSign(r[0]) === 0) {
    //    r.shift();
    //}
    return r;
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez2-exact.ts





// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗

const get_coeffs_bez3_bez2_exact_tp = two_product_twoProduct; // error -> 0
const get_coeffs_bez3_bez2_exact_sce = scale_expansion_scaleExpansion2;
const get_coeffs_bez3_bez2_exact_epr = expansion_product_expansionProduct;
const get_coeffs_bez3_bez2_exact_fes = fastExpansionSum;
const get_coeffs_bez3_bez2_exact_em2 = eMultBy2;
const get_coeffs_bez3_bez2_exact_eSign = e_sign_eSign;
/**
 * Returns an error-free polynomial in 1 variable
 * whose roots are the parameter values of the intersection points of an order
 * 3 and 2 bezier curve (i.e. a cubic bezier curve and a quadratic bezier curve).
 *
 * The returned polynomial degree will be 6
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:**  TODO - add underflow / overflow conditions
 * * the returned polynomial coefficients are exact (i.e. error-free)
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez3Bez2Exact(ps1, ps2) {
    /** ps1 in power bases */
    const ps1pb = getXY3Exact(ps1);
    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;
    // if both polynomials' cubic terms are exactly zero then its really a quadratic
    if (get_coeffs_bez3_bez2_exact_eSign(ps1pb[0][0]) === 0 && get_coeffs_bez3_bez2_exact_eSign(ps1pb[1][0]) === 0) {
        // the input bezier curve is in fact not cubic but has order < 3
        return getCoeffsBez2Bez2Exact(toQuadraticFromCubic(ps1), ps2);
    }
    const [[c2, c1, c0], [d2, d1, d0]] = getXY2Exact(ps2);
    if (get_coeffs_bez3_bez2_exact_eSign(c2) === 0 && get_coeffs_bez3_bez2_exact_eSign(d2) === 0) {
        // the input bezier curve is in fact not quadratic but has order < 2
        return getCoeffsBez3Bez1Exact(ps1, [ps2[0], ps2[2]]);
    }
    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = 
    // this type coercion is justified since we already checked that the
    // curve really has order 3
    getImplicitForm3ExactPb(ps1pb);
    const c0c0 = get_coeffs_bez3_bez2_exact_tp(c0, c0);
    const c0c1 = get_coeffs_bez3_bez2_exact_sce(c0, c1);
    const c0c2 = get_coeffs_bez3_bez2_exact_sce(c0, c2);
    const c0d0 = get_coeffs_bez3_bez2_exact_tp(c0, d0);
    const c0d1 = get_coeffs_bez3_bez2_exact_sce(c0, d1);
    const c0d2 = get_coeffs_bez3_bez2_exact_sce(c0, d2);
    const c1c1 = get_coeffs_bez3_bez2_exact_epr(c1, c1);
    const c1c2 = get_coeffs_bez3_bez2_exact_epr(c1, c2);
    const c1d0 = get_coeffs_bez3_bez2_exact_sce(d0, c1);
    const c1d1 = get_coeffs_bez3_bez2_exact_epr(c1, d1);
    const c1d2 = get_coeffs_bez3_bez2_exact_epr(c1, d2);
    const c2d1 = get_coeffs_bez3_bez2_exact_epr(c2, d1);
    const c2c2 = get_coeffs_bez3_bez2_exact_epr(c2, c2);
    const c2d0 = get_coeffs_bez3_bez2_exact_sce(d0, c2);
    const c2d2 = get_coeffs_bez3_bez2_exact_epr(c2, d2);
    const d0d0 = get_coeffs_bez3_bez2_exact_tp(d0, d0);
    const d0d1 = get_coeffs_bez3_bez2_exact_sce(d0, d1);
    const d0d2 = get_coeffs_bez3_bez2_exact_sce(d0, d2);
    const d1d1 = get_coeffs_bez3_bez2_exact_epr(d1, d1);
    const d1d2 = get_coeffs_bez3_bez2_exact_epr(d1, d2);
    const d2d2 = get_coeffs_bez3_bez2_exact_epr(d2, d2);
    // a2**3*v_xxx + a2**2*b2*v_xxy + a2*b2**2*v_xyy + b2**3*v_yyy
    //const v6 =
    //    c2c2*(c2*vₓₓₓ + d2*vₓₓᵧ) +
    //    d2d2*(c2*vₓᵧᵧ + d2*vᵧᵧᵧ);
    const e1 = get_coeffs_bez3_bez2_exact_epr(c2, vₓₓₓ);
    const e2 = get_coeffs_bez3_bez2_exact_epr(c2, vₓᵧᵧ);
    const e3 = get_coeffs_bez3_bez2_exact_epr(d2, vₓₓᵧ);
    const e4 = get_coeffs_bez3_bez2_exact_epr(d2, vᵧᵧᵧ);
    const e5 = get_coeffs_bez3_bez2_exact_fes(e1, e3);
    const e6 = get_coeffs_bez3_bez2_exact_fes(e2, e4);
    const e7 = get_coeffs_bez3_bez2_exact_epr(c2c2, e5);
    const e8 = get_coeffs_bez3_bez2_exact_epr(d2d2, e6);
    const v6 = get_coeffs_bez3_bez2_exact_fes(e7, e8);
    const z1 = get_coeffs_bez3_bez2_exact_fes(c0c2, c1c1);
    const z2 = get_coeffs_bez3_bez2_exact_fes(d0d2, d1d1);
    const z3 = get_coeffs_bez3_bez2_exact_fes(get_coeffs_bez3_bez2_exact_em2(c0c2), c1c1);
    const z4 = get_coeffs_bez3_bez2_exact_fes(get_coeffs_bez3_bez2_exact_em2(d0d2), d1d1);
    const z5 = get_coeffs_bez3_bez2_exact_fes(get_coeffs_bez3_bez2_exact_em2(c1d1), c2d0);
    const z6 = get_coeffs_bez3_bez2_exact_fes(get_coeffs_bez3_bez2_exact_em2(c1d1), c0d2);
    const z7 = get_coeffs_bez3_bez2_exact_fes(get_coeffs_bez3_bez2_exact_em2(c2d0), c1d1);
    const z8 = get_coeffs_bez3_bez2_exact_fes(get_coeffs_bez3_bez2_exact_sce(6, c0c2), c1c1);
    const z9 = get_coeffs_bez3_bez2_exact_fes(get_coeffs_bez3_bez2_exact_sce(6, d0d2), d1d1);
    const za = get_coeffs_bez3_bez2_exact_fes(c1d2, c2d1);
    const zb = get_coeffs_bez3_bez2_exact_fes(c0d2, c2d0);
    const zc = get_coeffs_bez3_bez2_exact_fes(get_coeffs_bez3_bez2_exact_em2(c1d0), c0d1);
    const zd = get_coeffs_bez3_bez2_exact_fes(get_coeffs_bez3_bez2_exact_em2(c0d1), c1d0);
    const zf = get_coeffs_bez3_bez2_exact_fes(c0d2, c1d1);
    const ze = get_coeffs_bez3_bez2_exact_fes(zf, c2d0);
    // 3*a1*a2**2*v_xxx + 2*a1*a2*b2*v_xxy + a1*b2**2*v_xyy + 
    // a2**2*b1*v_xxy + 2*a2*b1*b2*v_xyy + 3*b1*b2**2*v_yyy
    //const v5 =
    //    c1*(3*c2c2*vₓₓₓ + 2*c2d2*vₓₓᵧ +   d2d2*vₓᵧᵧ) +
    //    d1*(  c2c2*vₓₓᵧ + 2*c2d2*vₓᵧᵧ + 3*d2d2*vᵧᵧᵧ);
    const s0 = get_coeffs_bez3_bez2_exact_sce(3, c2c2);
    const t1 = get_coeffs_bez3_bez2_exact_sce(3, d2d2);
    const s1 = get_coeffs_bez3_bez2_exact_epr(s0, vₓₓₓ);
    const s2 = get_coeffs_bez3_bez2_exact_epr(c2c2, vₓₓᵧ);
    const s3 = get_coeffs_bez3_bez2_exact_em2(get_coeffs_bez3_bez2_exact_epr(c2d2, vₓₓᵧ));
    const s4 = get_coeffs_bez3_bez2_exact_em2(get_coeffs_bez3_bez2_exact_epr(c2d2, vₓᵧᵧ));
    const s5 = get_coeffs_bez3_bez2_exact_epr(d2d2, vₓᵧᵧ);
    const s6 = get_coeffs_bez3_bez2_exact_epr(t1, vᵧᵧᵧ);
    const s7 = get_coeffs_bez3_bez2_exact_fes(s1, s3);
    const s8 = get_coeffs_bez3_bez2_exact_fes(s2, s4);
    const s9 = get_coeffs_bez3_bez2_exact_fes(s7, s5);
    const sa = get_coeffs_bez3_bez2_exact_fes(s8, s6);
    const sb = get_coeffs_bez3_bez2_exact_epr(c1, s9);
    const sc = get_coeffs_bez3_bez2_exact_epr(d1, sa);
    const v5 = get_coeffs_bez3_bez2_exact_fes(sb, sc);
    // 3*a0*a2**2*v_xxx + 2*a0*a2*b2*v_xxy + a0*b2**2*v_xyy + 
    // 3*a1**2*a2*v_xxx + a1**2*b2*v_xxy + 2*a1*a2*b1*v_xxy + 
    // 2*a1*b1*b2*v_xyy + a2**2*b0*v_xxy + a2**2*v_xx + 
    // 2*a2*b0*b2*v_xyy + a2*b1**2*v_xyy + a2*b2*v_xy + 
    // 3*b0*b2**2*v_yyy + 3*b1**2*b2*v_yyy + b2**2*v_yy
    //const v4 =
    //    3*c2*(c0c2 + c1c1)*vₓₓₓ + 
    //    3*d2*(d0d2 + d1d1)*vᵧᵧᵧ + 
    //    (d2*(2*c0c2 + c1c1) + c2*(2*c1d1 + c2d0))*vₓₓᵧ +
    //    (d2*(2*c1d1 + c0d2) + c2*(2*d0d2 + d1d1))*vₓᵧᵧ +
    //    vₓₓ*c2c2 +
    //    vᵧᵧ*d2d2 +
    //    vₓᵧ*c2d2;
    //const v4 =
    //    (3*c2)*z1*vₓₓₓ + 
    //    (3*d2)*z2*vᵧᵧᵧ + 
    //    (d2*z3 + c2*z5)*vₓₓᵧ +
    //    (d2*z6 + c2*z4)*vₓᵧᵧ +
    //    vₓₓ*c2c2 +
    //    vᵧᵧ*d2d2 +
    //    vₓᵧ*c2d2;
    const sd = get_coeffs_bez3_bez2_exact_epr(d2, z3);
    const se = get_coeffs_bez3_bez2_exact_epr(d2, z6);
    const sf = get_coeffs_bez3_bez2_exact_epr(c2, z5);
    const sg = get_coeffs_bez3_bez2_exact_epr(c2, z4);
    const sh = get_coeffs_bez3_bez2_exact_epr(get_coeffs_bez3_bez2_exact_sce(3, c2), z1);
    const si = get_coeffs_bez3_bez2_exact_epr(get_coeffs_bez3_bez2_exact_sce(3, d2), z2);
    const sj = get_coeffs_bez3_bez2_exact_fes(sd, sf);
    const sk = get_coeffs_bez3_bez2_exact_fes(se, sg);
    const sl = get_coeffs_bez3_bez2_exact_epr(sh, vₓₓₓ);
    const sm = get_coeffs_bez3_bez2_exact_epr(si, vᵧᵧᵧ);
    const sn = get_coeffs_bez3_bez2_exact_epr(sj, vₓₓᵧ);
    const so = get_coeffs_bez3_bez2_exact_epr(sk, vₓᵧᵧ);
    const sp = get_coeffs_bez3_bez2_exact_fes(sl, sm);
    const sq = get_coeffs_bez3_bez2_exact_fes(sn, so);
    const sr = get_coeffs_bez3_bez2_exact_epr(c2c2, vₓₓ);
    const ss = get_coeffs_bez3_bez2_exact_epr(d2d2, vᵧᵧ);
    const st = get_coeffs_bez3_bez2_exact_epr(c2d2, vₓᵧ);
    const su = get_coeffs_bez3_bez2_exact_fes(sr, ss);
    const sv = get_coeffs_bez3_bez2_exact_fes(sp, sq);
    const sw = get_coeffs_bez3_bez2_exact_fes(su, st);
    const v4 = get_coeffs_bez3_bez2_exact_fes(sv, sw);
    // 6*a0*a1*a2*v_xxx + 2*a0*a1*b2*v_xxy + 2*a0*a2*b1*v_xxy + 
    // 2*a0*b1*b2*v_xyy + a1**3*v_xxx + a1**2*b1*v_xxy + 
    // 2*a1*a2*b0*v_xxy + 2*a1*a2*v_xx + 2*a1*b0*b2*v_xyy + 
    // a1*b1**2*v_xyy + a1*b2*v_xy + 2*a2*b0*b1*v_xyy + 
    // a2*b1*v_xy + 6*b0*b1*b2*v_yyy + b1**3*v_yyy + 
    // 2*b1*b2*v_yy
    //const v3 =
    //    c1*(6*c0c2 + c1c1)*vₓₓₓ +
    //    d1*(6*d0d2 + d1d1)*vᵧᵧᵧ +        
    //    (2*c0*(c1d2 + c2d1) + c1*(c1d1 + 2*c2d0))*vₓₓᵧ +
    //    (2*d1*(c0d2 + c2d0) + c1*(d1d1 + 2*d0d2))*vₓᵧᵧ +
    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +
    //    c1d2*vₓᵧ + c2d1*vₓᵧ;
    //const v3 =
    //    c1*z8*vₓₓₓ +
    //    d1*z9*vᵧᵧᵧ +        
    //    (2*c0*za + c1*z7)*vₓₓᵧ +
    //    (2*d1*zb + c1*z4)*vₓᵧᵧ +
    //    2*(d1d2*vᵧᵧ + c1c2*vₓₓ) +
    //    za*vₓᵧ;
    const sx = get_coeffs_bez3_bez2_exact_epr(c1, z8);
    const sy = get_coeffs_bez3_bez2_exact_epr(d1, z9);
    const sz = get_coeffs_bez3_bez2_exact_sce(2 * c0, za);
    const o1 = get_coeffs_bez3_bez2_exact_epr(get_coeffs_bez3_bez2_exact_em2(d1), zb);
    const o2 = get_coeffs_bez3_bez2_exact_epr(c1, z7);
    const o3 = get_coeffs_bez3_bez2_exact_epr(c1, z4);
    const o4 = get_coeffs_bez3_bez2_exact_fes(sz, o2);
    const o5 = get_coeffs_bez3_bez2_exact_fes(o1, o3);
    const o6 = get_coeffs_bez3_bez2_exact_epr(d1d2, vᵧᵧ);
    const o7 = get_coeffs_bez3_bez2_exact_epr(c1c2, vₓₓ);
    const o8 = get_coeffs_bez3_bez2_exact_epr(za, vₓᵧ);
    const o9 = get_coeffs_bez3_bez2_exact_fes(o6, o7);
    const oa = get_coeffs_bez3_bez2_exact_epr(sx, vₓₓₓ);
    const ob = get_coeffs_bez3_bez2_exact_epr(o4, vₓₓᵧ);
    const oc = get_coeffs_bez3_bez2_exact_epr(sy, vᵧᵧᵧ);
    const od = get_coeffs_bez3_bez2_exact_epr(o5, vₓᵧᵧ);
    const oe = get_coeffs_bez3_bez2_exact_fes(oa, oc);
    const og = get_coeffs_bez3_bez2_exact_fes(ob, od);
    const oh = get_coeffs_bez3_bez2_exact_fes(oe, og);
    const oi = get_coeffs_bez3_bez2_exact_fes(get_coeffs_bez3_bez2_exact_em2(o9), o8);
    const v3 = get_coeffs_bez3_bez2_exact_fes(oh, oi);
    // 3*a0**2*a2*v_xxx + a0**2*b2*v_xxy + 3*a0*a1**2*v_xxx + 2*a0*a1*b1*v_xxy + 2*a0*a2*b0*v_xxy + 
    // 2*a0*a2*v_xx + 2*a0*b0*b2*v_xyy + a0*b1**2*v_xyy + a0*b2*v_xy + a1**2*b0*v_xxy + a1**2*v_xx + 
    // 2*a1*b0*b1*v_xyy + a1*b1*v_xy + a2*b0**2*v_xyy + a2*b0*v_xy + a2*v_x + 3*b0**2*b2*v_yyy + 
    // 3*b0*b1**2*v_yyy + 2*b0*b2*v_yy + b1**2*v_yy + b2*v_y
    //const v2 =
    //    (3*c0*(c0c2 + c1c1))*vₓₓₓ +
    //    (3*d0*(d0d2 + d1d1))*vᵧᵧᵧ +
    //    (c0*(2*c1d1 + c0d2) + d0*(2*c0c2 + c1c1))*vₓₓᵧ +
    //    (c0*(2*d0d2 + d1d1) + d0*(2*c1d1 + c2d0))*vₓᵧᵧ +
    //    (2*c0c2 + c1c1)*vₓₓ +
    //    (2*d0d2 + d1d1)*vᵧᵧ +
    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +
    //    c2*vₓ    +
    //    d2*vᵧ;
    //const v2 =
    //    (3*c0*z1)*vₓₓₓ +
    //    (3*d0*z2)*vᵧᵧᵧ +
    //    (c0*z6 + d0*z3)*vₓₓᵧ +
    //    (c0*z4 + d0*z5)*vₓᵧᵧ +
    //    z3*vₓₓ +
    //    z4*vᵧᵧ +
    //    ze*vₓᵧ +
    //    c2*vₓ    +
    //    d2*vᵧ;
    const oj = get_coeffs_bez3_bez2_exact_sce(3 * c0, z1);
    const ok = get_coeffs_bez3_bez2_exact_sce(3 * d0, z2);
    const ol = get_coeffs_bez3_bez2_exact_sce(c0, z6);
    const om = get_coeffs_bez3_bez2_exact_sce(c0, z4);
    const on = get_coeffs_bez3_bez2_exact_sce(d0, z3);
    const oo = get_coeffs_bez3_bez2_exact_sce(d0, z5);
    const op = get_coeffs_bez3_bez2_exact_fes(ol, on);
    const oq = get_coeffs_bez3_bez2_exact_fes(om, oo);
    const or = get_coeffs_bez3_bez2_exact_epr(oj, vₓₓₓ);
    const os = get_coeffs_bez3_bez2_exact_epr(ok, vᵧᵧᵧ);
    const ot = get_coeffs_bez3_bez2_exact_epr(op, vₓₓᵧ);
    const ou = get_coeffs_bez3_bez2_exact_epr(oq, vₓᵧᵧ);
    const ov = get_coeffs_bez3_bez2_exact_epr(z3, vₓₓ);
    const ow = get_coeffs_bez3_bez2_exact_epr(z4, vᵧᵧ);
    const ox = get_coeffs_bez3_bez2_exact_epr(ze, vₓᵧ);
    const oy = get_coeffs_bez3_bez2_exact_epr(c2, vₓ);
    const oz = get_coeffs_bez3_bez2_exact_epr(d2, vᵧ);
    const p1 = get_coeffs_bez3_bez2_exact_fes(or, os);
    const p2 = get_coeffs_bez3_bez2_exact_fes(ot, ou);
    const p3 = get_coeffs_bez3_bez2_exact_fes(ov, ow);
    const p4 = get_coeffs_bez3_bez2_exact_fes(p1, p2);
    const p5 = get_coeffs_bez3_bez2_exact_fes(p3, ox);
    const p6 = get_coeffs_bez3_bez2_exact_fes(oy, oz);
    const p7 = get_coeffs_bez3_bez2_exact_fes(p4, p5);
    const v2 = get_coeffs_bez3_bez2_exact_fes(p7, p6);
    // 3*a0**2*a1*v_xxx + a0**2*b1*v_xxy + 2*a0*a1*b0*v_xxy + 2*a0*a1*v_xx + 2*a0*b0*b1*v_xyy + 
    // a0*b1*v_xy + a1*b0**2*v_xyy + a1*b0*v_xy + a1*v_x + 3*b0**2*b1*v_yyy + 2*b0*b1*v_yy + b1*v_y
    //const v1 =
    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +
    //    c0*(c0d1 + 2*c1d0)*vₓₓᵧ +
    //    d0*(c1d0 + 2*c0d1)*vₓᵧᵧ +
    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +
    //    c0d1*vₓᵧ + c1d0*vₓᵧ +
    //    c1*vₓ + d1*vᵧ;
    //const v1 =
    //    3*((c0*c0c1)*vₓₓₓ + (d0*d0d1)*vᵧᵧᵧ) +
    //    c0*zc*vₓₓᵧ +
    //    d0*zd*vₓᵧᵧ +
    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +
    //    c0d1*vₓᵧ + c1d0*vₓᵧ +
    //    c1*vₓ + d1*vᵧ;
    const p8 = get_coeffs_bez3_bez2_exact_sce(3 * c0, c0c1);
    const p9 = get_coeffs_bez3_bez2_exact_sce(3 * d0, d0d1);
    const pa = get_coeffs_bez3_bez2_exact_sce(c0, zc);
    const pb = get_coeffs_bez3_bez2_exact_sce(d0, zd);
    const pc = get_coeffs_bez3_bez2_exact_epr(c0c1, vₓₓ);
    const pd = get_coeffs_bez3_bez2_exact_epr(d0d1, vᵧᵧ);
    const pe = get_coeffs_bez3_bez2_exact_epr(c0d1, vₓᵧ);
    const pf = get_coeffs_bez3_bez2_exact_epr(c1d0, vₓᵧ);
    const pg = get_coeffs_bez3_bez2_exact_em2(get_coeffs_bez3_bez2_exact_fes(pc, pd));
    const ph = get_coeffs_bez3_bez2_exact_fes(pe, pf);
    const pi = get_coeffs_bez3_bez2_exact_epr(c1, vₓ);
    const pj = get_coeffs_bez3_bez2_exact_epr(d1, vᵧ);
    const pk = get_coeffs_bez3_bez2_exact_epr(p8, vₓₓₓ);
    const pl = get_coeffs_bez3_bez2_exact_epr(p9, vᵧᵧᵧ);
    const pm = get_coeffs_bez3_bez2_exact_epr(pa, vₓₓᵧ);
    const pn = get_coeffs_bez3_bez2_exact_epr(pb, vₓᵧᵧ);
    const po = get_coeffs_bez3_bez2_exact_fes(pk, pl);
    const pp = get_coeffs_bez3_bez2_exact_fes(pm, pn);
    const pq = get_coeffs_bez3_bez2_exact_fes(po, pp);
    const pr = get_coeffs_bez3_bez2_exact_fes(pg, ph);
    const ps = get_coeffs_bez3_bez2_exact_fes(pi, pj);
    const pt = get_coeffs_bez3_bez2_exact_fes(pq, pr);
    const v1 = get_coeffs_bez3_bez2_exact_fes(pt, ps);
    // a0**3*v_xxx + a0**2*b0*v_xxy + a0**2*v_xx + a0*b0**2*v_xyy + a0*b0*v_xy + a0*v_x + 
    // b0**3*v_yyy + b0**2*v_yy + b0*v_y + v_0
    //const v0 =
    //    c0c0*(c0*vₓₓₓ + d0*vₓₓᵧ + vₓₓ) +
    //    d0d0*(c0*vₓᵧᵧ + d0*vᵧᵧᵧ + vᵧᵧ) +
    //    c0d0*vₓᵧ +
    //    c0*vₓ +
    //    d0*vᵧ +
    //    v;
    const pu = get_coeffs_bez3_bez2_exact_sce(c0, vₓₓₓ);
    const pv = get_coeffs_bez3_bez2_exact_sce(c0, vₓᵧᵧ);
    const pw = get_coeffs_bez3_bez2_exact_sce(d0, vₓₓᵧ);
    const px = get_coeffs_bez3_bez2_exact_sce(d0, vᵧᵧᵧ);
    const py = get_coeffs_bez3_bez2_exact_fes(pu, pw);
    const pz = get_coeffs_bez3_bez2_exact_fes(pv, px);
    const u1 = get_coeffs_bez3_bez2_exact_fes(py, vₓₓ);
    const u2 = get_coeffs_bez3_bez2_exact_fes(pz, vᵧᵧ);
    const u3 = get_coeffs_bez3_bez2_exact_epr(c0c0, u1);
    const u4 = get_coeffs_bez3_bez2_exact_epr(d0d0, u2);
    const u5 = get_coeffs_bez3_bez2_exact_epr(c0d0, vₓᵧ);
    const u6 = get_coeffs_bez3_bez2_exact_sce(c0, vₓ);
    const u7 = get_coeffs_bez3_bez2_exact_sce(d0, vᵧ);
    const u8 = get_coeffs_bez3_bez2_exact_fes(u3, u4);
    const u9 = get_coeffs_bez3_bez2_exact_fes(u8, u5);
    const ua = get_coeffs_bez3_bez2_exact_fes(u6, u7);
    const ub = get_coeffs_bez3_bez2_exact_fes(u9, ua);
    const v0 = get_coeffs_bez3_bez2_exact_fes(ub, v);
    const r = [v6, v5, v4, v3, v2, v1, v0];
    // remove leading zero coefficients
    //while (r.length > 1 && eSign(r[0]) === 0) {
    //    r.shift();
    //}
    return r;
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez1-bez3-exact.ts



// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗


const get_coeffs_bez1_bez3_exact_sce = scale_expansion_scaleExpansion2;
const get_coeffs_bez1_bez3_exact_epr = expansion_product_expansionProduct;
const get_coeffs_bez1_bez3_exact_fes = fastExpansionSum;
const get_coeffs_bez1_bez3_exact_eSign = e_sign_eSign;
/**
 * Returns an error-free polynomial in 1 variable
 * whose roots are the parameter values of the intersection points of an order
 * 1 and order 3 bezier curve (i.e. a line and a cubic bezier curve).
 *
 * The returned polynomial degree will be 3
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:**  TODO - add underflow / overflow conditions
 * * **precondition:** TODO curve orders must be as stated
 * * the returned polynomial coefficients are exact (i.e. error-free)
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez1Bez3Exact(ps1, ps2) {
    /** ps1 in power bases */
    const ps1pb = getXY1Exact(ps1);
    //const [[e1,e0],[f1,f0]] = ps1pb;
    // if both polynomials' linear terms are exactly zero then it really is a point
    if (get_coeffs_bez1_bez3_exact_eSign(ps1pb[0][0]) === 0 && get_coeffs_bez1_bez3_exact_eSign(ps1pb[1][0]) === 0) {
        // the input bezier curve is in fact not a line but has order < 1,
        // i.e. it is a point
        // TODO
        //return getCoeffsBez0Bez3ExactAnyBitlength([ps1[0]], ps2]);
    }
    const [[c3, c2, c1, c0], [d3, d2, d1, d0]] = getXY3Exact(ps2);
    if (get_coeffs_bez1_bez3_exact_eSign(c3) === 0 && get_coeffs_bez1_bez3_exact_eSign(d3) === 0) {
        // the input bezier curve is in fact not cubic but has order < 3
        return getCoeffsBez1Bez2Exact(ps1, toQuadraticFromCubic(ps2));
    }
    // it is a precondition that the curve really has order 1
    // keep TypeScript happy; `getImplicitForm1ExactPb` cannot return `undefined` here
    const { vₓ, vᵧ, v } = getImplicitForm1ExactPb(ps1pb);
    // a3*v_x + b3*v_y
    //const v3 = c3*vₓ + d3*vᵧ;
    const p1 = get_coeffs_bez1_bez3_exact_epr(c3, vₓ);
    const p2 = get_coeffs_bez1_bez3_exact_epr(d3, vᵧ);
    const v3 = get_coeffs_bez1_bez3_exact_fes(p1, p2);
    // a2*v_x + b2*v_y
    //const v2 = c2*vₓ + d2*vᵧ;
    const p3 = get_coeffs_bez1_bez3_exact_epr(c2, vₓ);
    const p4 = get_coeffs_bez1_bez3_exact_epr(d2, vᵧ);
    const v2 = get_coeffs_bez1_bez3_exact_fes(p3, p4);
    // a1*v_x + b1*v_y
    //const v1 = c1*vₓ + d1*vᵧ;
    const p5 = get_coeffs_bez1_bez3_exact_epr(c1, vₓ);
    const p6 = get_coeffs_bez1_bez3_exact_epr(d1, vᵧ);
    const v1 = get_coeffs_bez1_bez3_exact_fes(p5, p6);
    // a0*v_x + b0*v_y + v_0
    //const v0 = c0*vₓ + d0*vᵧ + v;
    const p7 = get_coeffs_bez1_bez3_exact_sce(c0, vₓ);
    const p8 = get_coeffs_bez1_bez3_exact_sce(d0, vᵧ);
    const p9 = get_coeffs_bez1_bez3_exact_fes(p7, p8);
    const v0 = get_coeffs_bez1_bez3_exact_fes(p9, v);
    const r = [v3, v2, v1, v0];
    // remove leading zero coefficients
    //while (r.length > 1 && eSign(r[0]) === 0) {
    //    r.shift();
    //}
    return r;
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez2-bez3-exact.ts


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗




const get_coeffs_bez2_bez3_exact_tp = two_product_twoProduct; // error -> 0
const get_coeffs_bez2_bez3_exact_sce = scale_expansion_scaleExpansion2;
const get_coeffs_bez2_bez3_exact_epr = expansion_product_expansionProduct;
const get_coeffs_bez2_bez3_exact_fes = fastExpansionSum;
const get_coeffs_bez2_bez3_exact_em2 = eMultBy2;
const get_coeffs_bez2_bez3_exact_eSign = e_sign_eSign;
/**
 * Returns an error-free polynomial in 1 variable
 * whose roots are the parameter values of the intersection points of an order
 * 2 and 3 bezier curve (i.e. a quadratic bezier curve and a cubic bezier curve).
 *
 * The returned polynomial degree will be 6
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:**  TODO - add underflow / overflow conditions
 * * the returned polynomial coefficients are exact (i.e. error-free)
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez2Bez3Exact(ps1, ps2) {
    /** ps1 in power bases */
    const ps1pb = getXY2Exact(ps1);
    //const [[e2,e1,e0],[f2,f1,f0]] = ps1pb;
    // if both polynomials' quadratic terms are exactly zero then its really a line
    if (get_coeffs_bez2_bez3_exact_eSign(ps1pb[0][0]) === 0 && get_coeffs_bez2_bez3_exact_eSign(ps1pb[1][0]) === 0) {
        // the input bezier curve is in fact not quadratic but has order < 2
        return getCoeffsBez1Bez3Exact([ps1[0], ps1[2]], ps2);
    }
    const [[c3, c2, c1, c0], [d3, d2, d1, d0]] = getXY3Exact(ps2);
    if (get_coeffs_bez2_bez3_exact_eSign(c3) === 0 && get_coeffs_bez2_bez3_exact_eSign(d3) === 0) {
        // the input bezier curve is in fact not cubic but has order < 3
        return getCoeffsBez2Bez2Exact(ps1, toQuadraticFromCubic(ps2));
    }
    const { vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = 
    // this type coercion is justified since we already checked that the
    // curve really has order 2
    getImplicitForm2ExactPb(ps1pb);
    const c0c0 = get_coeffs_bez2_bez3_exact_tp(c0, c0);
    const c0c1 = get_coeffs_bez2_bez3_exact_sce(c0, c1);
    const c0c2 = get_coeffs_bez2_bez3_exact_sce(c0, c2);
    const c0c3 = get_coeffs_bez2_bez3_exact_sce(c0, c3);
    const c0d0 = get_coeffs_bez2_bez3_exact_tp(c0, d0);
    const c0d1 = get_coeffs_bez2_bez3_exact_sce(c0, d1);
    const c0d2 = get_coeffs_bez2_bez3_exact_sce(c0, d2);
    const c0d3 = get_coeffs_bez2_bez3_exact_sce(c0, d3);
    const c1c1 = get_coeffs_bez2_bez3_exact_epr(c1, c1);
    const c1c2 = get_coeffs_bez2_bez3_exact_epr(c1, c2);
    const c1c3 = get_coeffs_bez2_bez3_exact_epr(c1, c3);
    const c1d0 = get_coeffs_bez2_bez3_exact_sce(d0, c1);
    const c1d1 = get_coeffs_bez2_bez3_exact_epr(c1, d1);
    const c1d2 = get_coeffs_bez2_bez3_exact_epr(c1, d2);
    const c1d3 = get_coeffs_bez2_bez3_exact_epr(c1, d3);
    const c2d1 = get_coeffs_bez2_bez3_exact_epr(c2, d1);
    const c2c2 = get_coeffs_bez2_bez3_exact_epr(c2, c2);
    const c2c3 = get_coeffs_bez2_bez3_exact_epr(c2, c3);
    const c2d0 = get_coeffs_bez2_bez3_exact_sce(d0, c2);
    const c2d2 = get_coeffs_bez2_bez3_exact_epr(c2, d2);
    const c2d3 = get_coeffs_bez2_bez3_exact_epr(c2, d3);
    const c3c3 = get_coeffs_bez2_bez3_exact_epr(c3, c3);
    const c3d0 = get_coeffs_bez2_bez3_exact_sce(d0, c3);
    const c3d1 = get_coeffs_bez2_bez3_exact_epr(c3, d1);
    const c3d2 = get_coeffs_bez2_bez3_exact_epr(c3, d2);
    const c3d3 = get_coeffs_bez2_bez3_exact_epr(c3, d3);
    const d0d0 = get_coeffs_bez2_bez3_exact_tp(d0, d0);
    const d0d1 = get_coeffs_bez2_bez3_exact_sce(d0, d1);
    const d0d2 = get_coeffs_bez2_bez3_exact_sce(d0, d2);
    const d0d3 = get_coeffs_bez2_bez3_exact_sce(d0, d3);
    const d1d1 = get_coeffs_bez2_bez3_exact_epr(d1, d1);
    const d1d2 = get_coeffs_bez2_bez3_exact_epr(d1, d2);
    const d3d3 = get_coeffs_bez2_bez3_exact_epr(d3, d3);
    const d2d2 = get_coeffs_bez2_bez3_exact_epr(d2, d2);
    const d2d3 = get_coeffs_bez2_bez3_exact_epr(d2, d3);
    const d1d3 = get_coeffs_bez2_bez3_exact_epr(d1, d3);
    // a3**2*vₓₓ + a3*b3*vₓᵧ + b3**2*vᵧᵧ
    //const v6 =
    //    c3c3*vₓₓ +
    //    c3d3*vₓᵧ +
    //    d3d3*vᵧᵧ;
    const p1 = get_coeffs_bez2_bez3_exact_epr(c3c3, vₓₓ);
    const p2 = get_coeffs_bez2_bez3_exact_epr(c3d3, vₓᵧ);
    const p3 = get_coeffs_bez2_bez3_exact_epr(d3d3, vᵧᵧ);
    const p4 = get_coeffs_bez2_bez3_exact_fes(p1, p2);
    const v6 = get_coeffs_bez2_bez3_exact_fes(p4, p3);
    // 2*a2*a3*vₓₓ + a2*b3*vₓᵧ + a3*b2*vₓᵧ + 2*b2*b3*vᵧᵧ
    //const v5 =
    //    2*(c2c3*vₓₓ + d2d3*vᵧᵧ) +
    //    vₓᵧ*(c2d3 + c3d2);
    const p5 = get_coeffs_bez2_bez3_exact_epr(c2c3, vₓₓ);
    const p6 = get_coeffs_bez2_bez3_exact_epr(d2d3, vᵧᵧ);
    const p7 = get_coeffs_bez2_bez3_exact_fes(p5, p6);
    const p8 = get_coeffs_bez2_bez3_exact_fes(c2d3, c3d2);
    const p9 = get_coeffs_bez2_bez3_exact_epr(p8, vₓᵧ);
    const v5 = get_coeffs_bez2_bez3_exact_fes(get_coeffs_bez2_bez3_exact_em2(p7), p9);
    // 2*a1*a3*vₓₓ + a1*b3*vₓᵧ + a2**2*vₓₓ + a2*b2*vₓᵧ + a3*b1*vₓᵧ + 2*b1*b3*vᵧᵧ + b2**2*vᵧᵧ
    //const v4 =
    //    (2*c1c3 + c2c2)*vₓₓ +
    //    (2*d1d3 + d2d2)*vᵧᵧ +
    //    (c1d3 + c2d2 + c3d1)*vₓᵧ;
    const pa = get_coeffs_bez2_bez3_exact_fes(get_coeffs_bez2_bez3_exact_em2(c1c3), c2c2);
    const pb = get_coeffs_bez2_bez3_exact_fes(get_coeffs_bez2_bez3_exact_em2(d1d3), d2d2);
    const pc = get_coeffs_bez2_bez3_exact_fes(c1d3, c2d2);
    const pd = get_coeffs_bez2_bez3_exact_fes(pc, c3d1);
    const pe = get_coeffs_bez2_bez3_exact_epr(pa, vₓₓ);
    const pf = get_coeffs_bez2_bez3_exact_epr(pb, vᵧᵧ);
    const pg = get_coeffs_bez2_bez3_exact_fes(pe, pf);
    const rp = get_coeffs_bez2_bez3_exact_epr(pd, vₓᵧ);
    const v4 = get_coeffs_bez2_bez3_exact_fes(pg, rp);
    // 2*a0*a3*vₓₓ + a0*b3*vₓᵧ + 2*a1*a2*vₓₓ + 
    // a1*b2*vₓᵧ + a2*b1*vₓᵧ + a3*b0*vₓᵧ + 
    // a3*v_x + 2*b0*b3*vᵧᵧ + 2*b1*b2*vᵧᵧ + b3*v_y
    //const v3 =
    //    2*((c0c3 + c1c2)*vₓₓ + (d0d3 + d1d2)*vᵧᵧ) +
    //    (c0d3 + c1d2 + c2d1 + c3d0)*vₓᵧ +
    //    c3*vₓ +
    //    d3*vᵧ;
    const ph = get_coeffs_bez2_bez3_exact_fes(c0c3, c1c2);
    const pi = get_coeffs_bez2_bez3_exact_fes(d0d3, d1d2);
    const pj = get_coeffs_bez2_bez3_exact_fes(c0d3, c1d2);
    const pk = get_coeffs_bez2_bez3_exact_fes(c2d1, c3d0);
    const pl = get_coeffs_bez2_bez3_exact_fes(pj, pk);
    const pm = get_coeffs_bez2_bez3_exact_epr(ph, vₓₓ);
    const pn = get_coeffs_bez2_bez3_exact_epr(pi, vᵧᵧ);
    const po = get_coeffs_bez2_bez3_exact_em2(get_coeffs_bez2_bez3_exact_fes(pm, pn));
    const pp = get_coeffs_bez2_bez3_exact_epr(pl, vₓᵧ);
    const rn = get_coeffs_bez2_bez3_exact_epr(c3, vₓ);
    const ro = get_coeffs_bez2_bez3_exact_epr(d3, vᵧ);
    const pq = get_coeffs_bez2_bez3_exact_fes(rn, ro);
    const pr = get_coeffs_bez2_bez3_exact_fes(po, pp);
    const v3 = get_coeffs_bez2_bez3_exact_fes(pr, pq);
    // 2*a0*a2*vₓₓ + a0*b2*vₓᵧ + a1**2*vₓₓ + 
    // a1*b1*vₓᵧ + a2*b0*vₓᵧ + a2*v_x + 
    // 2*b0*b2*vᵧᵧ + b1**2*vᵧᵧ + b2*v_y
    //const v2 =
    //    (2*c0c2 + c1c1)*vₓₓ +
    //    (2*d0d2 + d1d1)*vᵧᵧ +
    //    (c0d2 + c1d1 + c2d0)*vₓᵧ +
    //    c2*vₓ +
    //    d2*vᵧ;
    const ps = get_coeffs_bez2_bez3_exact_fes(get_coeffs_bez2_bez3_exact_em2(c0c2), c1c1);
    const pt = get_coeffs_bez2_bez3_exact_fes(get_coeffs_bez2_bez3_exact_em2(d0d2), d1d1);
    const pu = get_coeffs_bez2_bez3_exact_fes(c0d2, c1d1);
    const pv = get_coeffs_bez2_bez3_exact_fes(pu, c2d0);
    const pw = get_coeffs_bez2_bez3_exact_epr(ps, vₓₓ);
    const px = get_coeffs_bez2_bez3_exact_epr(pt, vᵧᵧ);
    const py = get_coeffs_bez2_bez3_exact_epr(pv, vₓᵧ);
    const pz = get_coeffs_bez2_bez3_exact_fes(pw, px);
    const r1 = get_coeffs_bez2_bez3_exact_fes(pz, py);
    const r2 = get_coeffs_bez2_bez3_exact_epr(c2, vₓ);
    const r3 = get_coeffs_bez2_bez3_exact_epr(d2, vᵧ);
    const r4 = get_coeffs_bez2_bez3_exact_fes(r2, r3);
    const v2 = get_coeffs_bez2_bez3_exact_fes(r1, r4);
    // 2*a0*a1*vₓₓ + a0*b1*vₓᵧ + a1*b0*vₓᵧ + a1*v_x + 2*b0*b1*vᵧᵧ + b1*v_y
    //const v1 =
    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +
    //    (c0d1 + c1d0)*vₓᵧ +
    //    c1*vₓ +
    //    d1*vᵧ;
    const r5 = get_coeffs_bez2_bez3_exact_epr(c0c1, vₓₓ);
    const r6 = get_coeffs_bez2_bez3_exact_epr(d0d1, vᵧᵧ);
    const r7 = get_coeffs_bez2_bez3_exact_fes(c0d1, c1d0);
    const r8 = get_coeffs_bez2_bez3_exact_epr(r7, vₓᵧ);
    const r9 = get_coeffs_bez2_bez3_exact_em2(get_coeffs_bez2_bez3_exact_fes(r5, r6));
    const ra = get_coeffs_bez2_bez3_exact_fes(r9, r8);
    const rb = get_coeffs_bez2_bez3_exact_epr(c1, vₓ);
    const rc = get_coeffs_bez2_bez3_exact_epr(d1, vᵧ);
    const rd = get_coeffs_bez2_bez3_exact_fes(rb, rc);
    const v1 = get_coeffs_bez2_bez3_exact_fes(ra, rd);
    // a0**2*vₓₓ + a0*b0*vₓᵧ + a0*v_x + b0**2*vᵧᵧ + b0*v_y + v_0
    //const v0 =
    //    c0c0*vₓₓ +
    //    c0d0*vₓᵧ +
    //    d0d0*vᵧᵧ +
    //    c0*vₓ +
    //    d0*vᵧ +
    //    v;
    const re = get_coeffs_bez2_bez3_exact_epr(c0c0, vₓₓ);
    const rf = get_coeffs_bez2_bez3_exact_epr(c0d0, vₓᵧ);
    const rg = get_coeffs_bez2_bez3_exact_epr(d0d0, vᵧᵧ);
    const rh = get_coeffs_bez2_bez3_exact_sce(c0, vₓ);
    const ri = get_coeffs_bez2_bez3_exact_sce(d0, vᵧ);
    const rj = get_coeffs_bez2_bez3_exact_fes(re, rf);
    const rk = get_coeffs_bez2_bez3_exact_fes(rj, rg);
    const rl = get_coeffs_bez2_bez3_exact_fes(rh, ri);
    const rm = get_coeffs_bez2_bez3_exact_fes(rk, rl);
    const v0 = get_coeffs_bez2_bez3_exact_fes(rm, v);
    const r = [v6, v5, v4, v3, v2, v1, v0];
    // remove leading zero coefficients
    //while (r.length > 1 && eSign(r[0]) === 0) {
    //    r.shift();
    //}
    return r;
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/exact/get-coeffs-bez3-bez3-exact.ts


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗




const get_coeffs_bez3_bez3_exact_tp = two_product_twoProduct; // error -> 0
const get_coeffs_bez3_bez3_exact_sce = scale_expansion_scaleExpansion2;
const get_coeffs_bez3_bez3_exact_epr = expansion_product_expansionProduct;
const get_coeffs_bez3_bez3_exact_fes = fastExpansionSum;
const get_coeffs_bez3_bez3_exact_em2 = eMultBy2;
const get_coeffs_bez3_bez3_exact_eSign = e_sign_eSign;
/**
 * Returns an error-free polynomial in in 1 variable
 * whose roots are the parameter values of the intersection points of 2 order
 * 3 bezier curves (i.e. 2 cubic bezier curves).
 *
 * The returned polynomial degree will be 9
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:**  TODO - add underflow / overflow conditions
 * * the returned polynomial coefficients are exact (i.e. error-free)
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBez3Bez3Exact(ps1, ps2) {
    /** ps1 in power bases */
    const ps1pb = getXY3Exact(ps1);
    //const [[e3,e2,e1,e0],[f3,f2,f1,f0]] = ps1pb;
    // if both polynomials' cubic terms are exactly zero then its really a quadratic
    if (get_coeffs_bez3_bez3_exact_eSign(ps1pb[0][0]) === 0 && get_coeffs_bez3_bez3_exact_eSign(ps1pb[1][0]) === 0) {
        // the input bezier curve is in fact not cubic but has order < 3
        return getCoeffsBez2Bez3Exact(toQuadraticFromCubic(ps1), ps2);
    }
    const [[c3, c2, c1, c0], [d3, d2, d1, d0]] = getXY3Exact(ps2);
    if (get_coeffs_bez3_bez3_exact_eSign(c3) === 0 && get_coeffs_bez3_bez3_exact_eSign(d3) === 0) {
        // the input bezier curve is in fact not cubic but has order < 3
        return getCoeffsBez3Bez2Exact(ps1, toQuadraticFromCubic(ps2));
    }
    const { vₓₓₓ, vₓₓᵧ, vₓᵧᵧ, vᵧᵧᵧ, vₓₓ, vₓᵧ, vᵧᵧ, vₓ, vᵧ, v } = 
    // this type coercion is justified since we already checked that the
    // curve really has order 3
    getImplicitForm3ExactPb(ps1pb);
    const c0c0 = get_coeffs_bez3_bez3_exact_tp(c0, c0);
    const c0c1 = get_coeffs_bez3_bez3_exact_sce(c0, c1);
    const c0c2 = get_coeffs_bez3_bez3_exact_sce(c0, c2);
    const c0c3 = get_coeffs_bez3_bez3_exact_sce(c0, c3);
    const c0d0 = get_coeffs_bez3_bez3_exact_tp(c0, d0);
    const c0d1 = get_coeffs_bez3_bez3_exact_sce(c0, d1);
    const c0d2 = get_coeffs_bez3_bez3_exact_sce(c0, d2);
    const c0d3 = get_coeffs_bez3_bez3_exact_sce(c0, d3);
    const c1c1 = get_coeffs_bez3_bez3_exact_epr(c1, c1);
    const c1c2 = get_coeffs_bez3_bez3_exact_epr(c1, c2);
    const c1c3 = get_coeffs_bez3_bez3_exact_epr(c1, c3);
    const c1d0 = get_coeffs_bez3_bez3_exact_sce(d0, c1);
    const c1d1 = get_coeffs_bez3_bez3_exact_epr(c1, d1);
    const c1d2 = get_coeffs_bez3_bez3_exact_epr(c1, d2);
    const c1d3 = get_coeffs_bez3_bez3_exact_epr(c1, d3);
    const c2d1 = get_coeffs_bez3_bez3_exact_epr(c2, d1);
    const c2c2 = get_coeffs_bez3_bez3_exact_epr(c2, c2);
    const c2c3 = get_coeffs_bez3_bez3_exact_epr(c2, c3);
    const c2d0 = get_coeffs_bez3_bez3_exact_sce(d0, c2);
    const c2d2 = get_coeffs_bez3_bez3_exact_epr(c2, d2);
    const c2d3 = get_coeffs_bez3_bez3_exact_epr(c2, d3);
    const c3c3 = get_coeffs_bez3_bez3_exact_epr(c3, c3);
    const c3d0 = get_coeffs_bez3_bez3_exact_sce(d0, c3);
    const c3d1 = get_coeffs_bez3_bez3_exact_epr(c3, d1);
    const c3d2 = get_coeffs_bez3_bez3_exact_epr(c3, d2);
    const c3d3 = get_coeffs_bez3_bez3_exact_epr(c3, d3);
    const d0d0 = get_coeffs_bez3_bez3_exact_tp(d0, d0);
    const d0d1 = get_coeffs_bez3_bez3_exact_sce(d0, d1);
    const d0d2 = get_coeffs_bez3_bez3_exact_sce(d0, d2);
    const d0d3 = get_coeffs_bez3_bez3_exact_sce(d0, d3);
    const d1d1 = get_coeffs_bez3_bez3_exact_epr(d1, d1);
    const d1d2 = get_coeffs_bez3_bez3_exact_epr(d1, d2);
    const d3d3 = get_coeffs_bez3_bez3_exact_epr(d3, d3);
    const d2d2 = get_coeffs_bez3_bez3_exact_epr(d2, d2);
    const d2d3 = get_coeffs_bez3_bez3_exact_epr(d2, d3);
    const d1d3 = get_coeffs_bez3_bez3_exact_epr(d1, d3);
    //const v9 =  
    //    (c3*c3c3)*vₓₓₓ + 
    //    (c3*d3d3)*vₓᵧᵧ + 
    //    (d3*c3c3)*vₓₓᵧ + 
    //    (d3*d3d3)*vᵧᵧᵧ;  
    const g1 = get_coeffs_bez3_bez3_exact_epr(c3, c3c3); // c3*c3c3
    const g2 = get_coeffs_bez3_bez3_exact_epr(c3, d3d3); // c3*d3d3
    const g3 = get_coeffs_bez3_bez3_exact_epr(d3, c3c3); // d3*c3c3
    const g4 = get_coeffs_bez3_bez3_exact_epr(d3, d3d3); // d3*d3d3
    const g5 = get_coeffs_bez3_bez3_exact_epr(g1, vₓₓₓ); // g1*vₓₓₓ
    const g6 = get_coeffs_bez3_bez3_exact_epr(g2, vₓᵧᵧ); // g2*vₓᵧᵧ
    const g7 = get_coeffs_bez3_bez3_exact_epr(g3, vₓₓᵧ); // g3*vₓₓᵧ 
    const g8 = get_coeffs_bez3_bez3_exact_epr(g4, vᵧᵧᵧ); // g4*vᵧᵧᵧ
    const g9 = get_coeffs_bez3_bez3_exact_fes(g5, g6); // g5 + g6
    const ga = get_coeffs_bez3_bez3_exact_fes(g7, g8); // g7 + g8
    const v9 = get_coeffs_bez3_bez3_exact_fes(g9, ga); // g9 + ga
    //const v8 =  
    //    2*c2*c3d3*vₓₓᵧ + 
    //    2*c3*d2d3*vₓᵧᵧ + 
    //      c2*d3d3*vₓᵧᵧ + 
    //      d2*c3c3*vₓₓᵧ + 
    //    3*c2*c3c3*vₓₓₓ + 
    //    3*d2*d3d3*vᵧᵧᵧ;  
    const w1 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(c2d3), c3d2);
    const w2 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(c3d2), c2d3);
    const w3 = get_coeffs_bez3_bez3_exact_epr(c3, w1);
    const w4 = get_coeffs_bez3_bez3_exact_epr(d3, w2);
    const w5 = get_coeffs_bez3_bez3_exact_epr(c2, c3c3);
    const w6 = get_coeffs_bez3_bez3_exact_epr(d2, d3d3);
    const w7 = get_coeffs_bez3_bez3_exact_epr(vₓₓₓ, w5);
    const u1 = get_coeffs_bez3_bez3_exact_epr(vᵧᵧᵧ, w6);
    const u2 = get_coeffs_bez3_bez3_exact_epr(vₓₓᵧ, w3);
    const u3 = get_coeffs_bez3_bez3_exact_epr(vₓᵧᵧ, w4);
    const u4 = get_coeffs_bez3_bez3_exact_fes(u2, u3);
    const u5 = get_coeffs_bez3_bez3_exact_sce(3, get_coeffs_bez3_bez3_exact_fes(w7, u1));
    const v8 = get_coeffs_bez3_bez3_exact_fes(u4, u5);
    //const v7 =  
    //    vₓₓᵧ*(2*(c1*c3d3 + c2*c3d2) + (d1*c3c3 + d3*c2c2)) +
    //    vₓᵧᵧ*(2*(c2*d2d3 + c3*d1d3) + (c1*d3d3 + d2*c3d2)) +
    //    vₓₓₓ*3*c3*(c1c3 + c2c2) +
    //    vᵧᵧᵧ*3*d3*(d1d3 + d2d2);
    const o1 = get_coeffs_bez3_bez3_exact_epr(c1, c3d3);
    const o2 = get_coeffs_bez3_bez3_exact_epr(d1, c3c3);
    const o3 = get_coeffs_bez3_bez3_exact_epr(c2, d2d3);
    const o4 = get_coeffs_bez3_bez3_exact_epr(c1, d3d3);
    const o5 = get_coeffs_bez3_bez3_exact_epr(c2, c3d2);
    const o6 = get_coeffs_bez3_bez3_exact_epr(d3, c2c2);
    const o7 = get_coeffs_bez3_bez3_exact_epr(c3, d1d3);
    const o8 = get_coeffs_bez3_bez3_exact_epr(d2, c3d2);
    const w8 = get_coeffs_bez3_bez3_exact_fes(o1, o5);
    const w9 = get_coeffs_bez3_bez3_exact_fes(o2, o6);
    const wa = get_coeffs_bez3_bez3_exact_fes(o3, o7);
    const wb = get_coeffs_bez3_bez3_exact_fes(o4, o8);
    const wc = get_coeffs_bez3_bez3_exact_fes(c1c3, c2c2);
    const wd = get_coeffs_bez3_bez3_exact_fes(d1d3, d2d2);
    const we = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(w8), w9);
    const wf = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(wa), wb);
    const wg = get_coeffs_bez3_bez3_exact_epr(vₓₓᵧ, we);
    const wh = get_coeffs_bez3_bez3_exact_epr(vₓᵧᵧ, wf);
    const wi = get_coeffs_bez3_bez3_exact_epr(c3, wc);
    const wj = get_coeffs_bez3_bez3_exact_epr(d3, wd);
    const wk = get_coeffs_bez3_bez3_exact_epr(vₓₓₓ, wi);
    const wl = get_coeffs_bez3_bez3_exact_epr(vᵧᵧᵧ, wj);
    const wm = get_coeffs_bez3_bez3_exact_fes(wg, wh);
    const wn = get_coeffs_bez3_bez3_exact_sce(3, get_coeffs_bez3_bez3_exact_fes(wk, wl));
    const v7 = get_coeffs_bez3_bez3_exact_fes(wm, wn);
    //const v6 =
    //    vₓₓᵧ*(d2*c2c2 + 2*c1*(c2d3 + c3d2) + c3*(2*c0d3 + 2*c2d1 + c3d0)) +
    //    vₓᵧᵧ*(c2*d2d2 + 2*d1*(c2d3 + c3d2) + d3*(2*c1d2 + 2*c3d0 + c0d3)) +
    //    vₓₓₓ*(c2*c2c2 + 3*c3*(2*c1c2 + c0c3)) +
    //    vᵧᵧᵧ*(d2*d2d2 + 3*d3*(2*d1d2 + d0d3)) +
    //    vₓₓ *c3c3 +
    //    vᵧᵧ *d3d3 +
    //    vₓᵧ *c3d3;
    const wo = get_coeffs_bez3_bez3_exact_fes(c2d3, c3d2);
    const zc = get_coeffs_bez3_bez3_exact_epr(d2, c2c2);
    const zd = get_coeffs_bez3_bez3_exact_em2(get_coeffs_bez3_bez3_exact_epr(c1, wo));
    const wp = get_coeffs_bez3_bez3_exact_fes(zc, zd);
    const wq = get_coeffs_bez3_bez3_exact_em2(get_coeffs_bez3_bez3_exact_fes(c0d3, c2d1));
    const wr = get_coeffs_bez3_bez3_exact_fes(wq, c3d0);
    const ze = get_coeffs_bez3_bez3_exact_epr(c3, wr);
    const ws = get_coeffs_bez3_bez3_exact_fes(wp, ze);
    const zf = get_coeffs_bez3_bez3_exact_epr(c2, d2d2);
    const zg = get_coeffs_bez3_bez3_exact_em2(get_coeffs_bez3_bez3_exact_epr(d1, wo));
    const wt = get_coeffs_bez3_bez3_exact_fes(zf, zg);
    const wu = get_coeffs_bez3_bez3_exact_em2(get_coeffs_bez3_bez3_exact_fes(c1d2, c3d0));
    const wv = get_coeffs_bez3_bez3_exact_fes(wu, c0d3);
    const zh = get_coeffs_bez3_bez3_exact_epr(d3, wv);
    const ww = get_coeffs_bez3_bez3_exact_fes(wt, zh);
    const wx = get_coeffs_bez3_bez3_exact_epr(c2, c2c2);
    const wy = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(c1c2), c0c3);
    const wz = get_coeffs_bez3_bez3_exact_epr(get_coeffs_bez3_bez3_exact_sce(3, c3), wy);
    const z1 = get_coeffs_bez3_bez3_exact_fes(wx, wz);
    const z2 = get_coeffs_bez3_bez3_exact_epr(d2, d2d2);
    const z3 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(d1d2), d0d3);
    const z4 = get_coeffs_bez3_bez3_exact_epr(get_coeffs_bez3_bez3_exact_sce(3, d3), z3);
    const z5 = get_coeffs_bez3_bez3_exact_fes(z2, z4);
    const zi = get_coeffs_bez3_bez3_exact_epr(vₓₓᵧ, ws);
    const zj = get_coeffs_bez3_bez3_exact_epr(vₓᵧᵧ, ww);
    const z6 = get_coeffs_bez3_bez3_exact_fes(zi, zj);
    const zk = get_coeffs_bez3_bez3_exact_epr(vₓₓₓ, z1);
    const zl = get_coeffs_bez3_bez3_exact_epr(vᵧᵧᵧ, z5);
    const z7 = get_coeffs_bez3_bez3_exact_fes(zk, zl);
    const zm = get_coeffs_bez3_bez3_exact_epr(c3c3, vₓₓ);
    const zn = get_coeffs_bez3_bez3_exact_epr(d3d3, vᵧᵧ);
    const z8 = get_coeffs_bez3_bez3_exact_fes(zm, zn);
    const z9 = get_coeffs_bez3_bez3_exact_epr(c3d3, vₓᵧ);
    const za = get_coeffs_bez3_bez3_exact_fes(z6, z7);
    const zb = get_coeffs_bez3_bez3_exact_fes(z8, z9);
    const v6 = get_coeffs_bez3_bez3_exact_fes(za, zb);
    //const r4 = c2d2 + c3d1;
    //const r5 = c1d3 + c2d2;
    //const v5 =
    //    vₓₓᵧ*(2*(c0*wo + c1*r4) + d3*c1c1 + c2*(2*c3d0 + c2d1)) +
    //    vₓᵧᵧ*(2*(d0*wo + d1*r5) + c3*d1d1 + d2*(2*c0d3 + c1d2)) +
    //    3*(vₓₓₓ*(2*c0*c2c3 + c1*wc) + 
    //       vᵧᵧᵧ*(2*d0*d2d3 + d1*wd)) +
    //    vₓᵧ*wo +
    //    2*(vₓₓ*c2c3 + vᵧᵧ*d2d3);
    const r4 = get_coeffs_bez3_bez3_exact_fes(c2d2, c3d1);
    const r5 = get_coeffs_bez3_bez3_exact_fes(c1d3, c2d2);
    const k1 = get_coeffs_bez3_bez3_exact_sce(c0, wo);
    const k2 = get_coeffs_bez3_bez3_exact_sce(d0, wo);
    const k3 = get_coeffs_bez3_bez3_exact_epr(c1, r4);
    const k4 = get_coeffs_bez3_bez3_exact_epr(d1, r5);
    const k5 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(c3d0), c2d1);
    const k6 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(c0d3), c1d2);
    const k7 = get_coeffs_bez3_bez3_exact_epr(d3, c1c1);
    const k8 = get_coeffs_bez3_bez3_exact_epr(c3, d1d1);
    const k9 = get_coeffs_bez3_bez3_exact_epr(c2, k5);
    const ka = get_coeffs_bez3_bez3_exact_epr(d2, k6);
    const kb = get_coeffs_bez3_bez3_exact_em2(get_coeffs_bez3_bez3_exact_fes(k1, k3));
    const kc = get_coeffs_bez3_bez3_exact_em2(get_coeffs_bez3_bez3_exact_fes(k2, k4));
    const kd = get_coeffs_bez3_bez3_exact_em2(get_coeffs_bez3_bez3_exact_sce(c0, c2c3));
    const ke = get_coeffs_bez3_bez3_exact_em2(get_coeffs_bez3_bez3_exact_sce(d0, d2d3));
    const kf = get_coeffs_bez3_bez3_exact_epr(c1, wc);
    const kg = get_coeffs_bez3_bez3_exact_epr(d1, wd);
    const kh = get_coeffs_bez3_bez3_exact_epr(c2c3, vₓₓ);
    const ki = get_coeffs_bez3_bez3_exact_epr(d2d3, vᵧᵧ);
    const kj = get_coeffs_bez3_bez3_exact_fes(kb, k7);
    const kk = get_coeffs_bez3_bez3_exact_fes(kc, k8);
    const kl = get_coeffs_bez3_bez3_exact_fes(kj, k9);
    const km = get_coeffs_bez3_bez3_exact_fes(kk, ka);
    const kn = get_coeffs_bez3_bez3_exact_fes(kd, kf);
    const ko = get_coeffs_bez3_bez3_exact_fes(ke, kg);
    const kp = get_coeffs_bez3_bez3_exact_em2(get_coeffs_bez3_bez3_exact_fes(kh, ki));
    const kq = get_coeffs_bez3_bez3_exact_epr(vₓₓᵧ, kl);
    const kr = get_coeffs_bez3_bez3_exact_epr(vₓᵧᵧ, km);
    const ks = get_coeffs_bez3_bez3_exact_epr(vₓₓₓ, kn);
    const kt = get_coeffs_bez3_bez3_exact_epr(vᵧᵧᵧ, ko);
    const ku = get_coeffs_bez3_bez3_exact_fes(kq, kr);
    const kv = get_coeffs_bez3_bez3_exact_sce(3, get_coeffs_bez3_bez3_exact_fes(ks, kt));
    const kw = get_coeffs_bez3_bez3_exact_epr(vₓᵧ, wo);
    const kx = get_coeffs_bez3_bez3_exact_fes(ku, kv);
    const ky = get_coeffs_bez3_bez3_exact_fes(kw, kp);
    const v5 = get_coeffs_bez3_bez3_exact_fes(kx, ky);
    //const r1 = c1d3 + r4;
    //const r2 = 2*c1c3 + c2c2;
    //const r3 = 2*d1d3 + d2d2;
    //const v4 =
    //    vₓₓᵧ*(2*c0*r1 + d0*r2 + c1*(c1d2 + 2*c2d1)) +
    //    vₓᵧᵧ*(2*d0*r1 + c0*r3 + d1*(c2d1 + 2*c1d2)) +
    //    vₓₓₓ*3*(c0*r2 + c2*c1c1) +
    //    vᵧᵧᵧ*3*(d0*r3 + d2*d1d1) +
    //    vₓᵧ*r1 +
    //    vₓₓ*r2 +
    //    vᵧᵧ*r3;
    const r1 = get_coeffs_bez3_bez3_exact_fes(c1d3, r4);
    const r2 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(c1c3), c2c2);
    const r3 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(d1d3), d2d2);
    const s1 = get_coeffs_bez3_bez3_exact_sce((2 * c0), r1);
    const s2 = get_coeffs_bez3_bez3_exact_sce((2 * d0), r1);
    const s5 = get_coeffs_bez3_bez3_exact_fes(c1d2, get_coeffs_bez3_bez3_exact_em2(c2d1));
    const s6 = get_coeffs_bez3_bez3_exact_fes(c2d1, get_coeffs_bez3_bez3_exact_em2(c1d2));
    const s3 = get_coeffs_bez3_bez3_exact_sce(d0, r2);
    const s4 = get_coeffs_bez3_bez3_exact_sce(c0, r3);
    const s7 = get_coeffs_bez3_bez3_exact_epr(c1, s5);
    const s8 = get_coeffs_bez3_bez3_exact_epr(d1, s6);
    const s9 = get_coeffs_bez3_bez3_exact_sce(c0, r2);
    const sa = get_coeffs_bez3_bez3_exact_sce(d0, r3);
    const sb = get_coeffs_bez3_bez3_exact_epr(c2, c1c1);
    const sc = get_coeffs_bez3_bez3_exact_epr(d2, d1d1);
    const sd = get_coeffs_bez3_bez3_exact_fes(s1, s3);
    const se = get_coeffs_bez3_bez3_exact_fes(s2, s4);
    const sf = get_coeffs_bez3_bez3_exact_fes(sd, s7);
    const sg = get_coeffs_bez3_bez3_exact_fes(se, s8);
    const sh = get_coeffs_bez3_bez3_exact_fes(s9, sb);
    const si = get_coeffs_bez3_bez3_exact_fes(sa, sc);
    const sj = get_coeffs_bez3_bez3_exact_epr(vₓₓᵧ, sf);
    const sk = get_coeffs_bez3_bez3_exact_epr(vₓᵧᵧ, sg);
    const sl = get_coeffs_bez3_bez3_exact_epr(vₓₓₓ, sh);
    const sm = get_coeffs_bez3_bez3_exact_epr(vᵧᵧᵧ, si);
    const sn = get_coeffs_bez3_bez3_exact_fes(sl, sm);
    const so = get_coeffs_bez3_bez3_exact_fes(sj, sk);
    const sp = get_coeffs_bez3_bez3_exact_fes(so, get_coeffs_bez3_bez3_exact_sce(3, sn));
    const ss = get_coeffs_bez3_bez3_exact_epr(vₓᵧ, r1);
    const st = get_coeffs_bez3_bez3_exact_epr(vₓₓ, r2);
    const sq = get_coeffs_bez3_bez3_exact_fes(ss, st);
    const su = get_coeffs_bez3_bez3_exact_epr(vᵧᵧ, r3);
    const sr = get_coeffs_bez3_bez3_exact_fes(sq, su);
    const v4 = get_coeffs_bez3_bez3_exact_fes(sp, sr);
    //const r6 = c1d2 + c2d1;
    //const r7 = c3d0 + c0d3;
    //const r8 = c1c2 + c0c3;
    //const r9 = d1d2 + d0d3;
    //const v3 =
    //    vₓₓᵧ*(c0*(2*r6 + c3d0 + r7) + c1*(2*c2d0 + c1d1)) +
    //    vₓᵧᵧ*(d0*(2*r6 + c0d3 + r7) + d1*(2*c0d2 + c1d1)) +
    //    vₓₓₓ*(3*c0*(r8 + c1c2) + c1*c1c1) + 
    //    vᵧᵧᵧ*(3*d0*(r9 + d1d2) + d1*d1d1) +
    //    vₓᵧ*(r7 + r6) +
    //    2*(vₓₓ*r8 + vᵧᵧ*r9) +
    //    vₓ*c3 + vᵧ*d3;
    const r6 = get_coeffs_bez3_bez3_exact_fes(c1d2, c2d1);
    const r7 = get_coeffs_bez3_bez3_exact_fes(c3d0, c0d3);
    const r8 = get_coeffs_bez3_bez3_exact_fes(c1c2, c0c3);
    const r9 = get_coeffs_bez3_bez3_exact_fes(d1d2, d0d3);
    const m1 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(r6), c3d0);
    const m2 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(r6), c0d3);
    const m3 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(c2d0), c1d1);
    const m4 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(c0d2), c1d1);
    const m5 = get_coeffs_bez3_bez3_exact_fes(r8, c1c2);
    const m6 = get_coeffs_bez3_bez3_exact_fes(r9, d1d2);
    const m7 = get_coeffs_bez3_bez3_exact_epr(get_coeffs_bez3_bez3_exact_tp(3, c0), m5);
    const m8 = get_coeffs_bez3_bez3_exact_epr(get_coeffs_bez3_bez3_exact_tp(3, d0), m6);
    const m9 = get_coeffs_bez3_bez3_exact_epr(c1, c1c1);
    const ma = get_coeffs_bez3_bez3_exact_epr(d1, d1d1);
    const mb = get_coeffs_bez3_bez3_exact_epr(vₓₓ, r8);
    const mc = get_coeffs_bez3_bez3_exact_epr(vᵧᵧ, r9);
    const md = get_coeffs_bez3_bez3_exact_fes(m1, r7);
    const me = get_coeffs_bez3_bez3_exact_fes(m2, r7);
    const mf = get_coeffs_bez3_bez3_exact_sce(c0, md);
    const mg = get_coeffs_bez3_bez3_exact_sce(d0, me);
    const mh = get_coeffs_bez3_bez3_exact_epr(c1, m3);
    const mi = get_coeffs_bez3_bez3_exact_epr(d1, m4);
    const mj = get_coeffs_bez3_bez3_exact_epr(c3, vₓ);
    const mk = get_coeffs_bez3_bez3_exact_epr(d3, vᵧ);
    const ml = get_coeffs_bez3_bez3_exact_fes(mf, mh);
    const mm = get_coeffs_bez3_bez3_exact_fes(mg, mi);
    const mn = get_coeffs_bez3_bez3_exact_fes(m7, m9);
    const mo = get_coeffs_bez3_bez3_exact_fes(m8, ma);
    const mp = get_coeffs_bez3_bez3_exact_fes(r7, r6);
    const mq = get_coeffs_bez3_bez3_exact_em2(get_coeffs_bez3_bez3_exact_fes(mb, mc));
    const mr = get_coeffs_bez3_bez3_exact_epr(vₓₓᵧ, ml);
    const ms = get_coeffs_bez3_bez3_exact_epr(vₓᵧᵧ, mm);
    const mt = get_coeffs_bez3_bez3_exact_epr(vₓₓₓ, mn);
    const mu = get_coeffs_bez3_bez3_exact_epr(vᵧᵧᵧ, mo);
    const mv = get_coeffs_bez3_bez3_exact_epr(vₓᵧ, mp);
    const mw = get_coeffs_bez3_bez3_exact_fes(mr, ms);
    const mx = get_coeffs_bez3_bez3_exact_fes(mt, mu);
    const my = get_coeffs_bez3_bez3_exact_fes(mv, mq);
    const mz = get_coeffs_bez3_bez3_exact_fes(mj, mk);
    const n1 = get_coeffs_bez3_bez3_exact_fes(mw, mx);
    const n2 = get_coeffs_bez3_bez3_exact_fes(my, mz);
    const v3 = get_coeffs_bez3_bez3_exact_fes(n1, n2);
    //const ra = c1d1 + c2d0;
    //const rb = c1d1 + c0d2;
    //const v2 =
    //    vₓₓᵧ*(c0*(2*ra + c0d2) + d0*c1c1) +
    //    vₓᵧᵧ*(d0*(2*rb + c2d0) + c0*d1d1) +
    //    3*vₓₓₓ*(c0*c1c1 + c2*c0c0) + 
    //    3*vᵧᵧᵧ*(d0*d1d1 + d2*d0d0) +
    //    vₓᵧ*(ra + c0d2) +
    //    vₓₓ*(2*c0c2 + c1c1) + 
    //    vᵧᵧ*(2*d0d2 + d1d1) +
    //    c2*vₓ + d2*vᵧ;
    const ra = get_coeffs_bez3_bez3_exact_fes(c1d1, c2d0);
    const rb = get_coeffs_bez3_bez3_exact_fes(c1d1, c0d2);
    const l1 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(ra), c0d2);
    const l2 = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(rb), c2d0);
    const l3 = get_coeffs_bez3_bez3_exact_sce(c0, l1);
    const l4 = get_coeffs_bez3_bez3_exact_sce(d0, c1c1);
    const l5 = get_coeffs_bez3_bez3_exact_sce(d0, l2);
    const l6 = get_coeffs_bez3_bez3_exact_sce(c0, d1d1);
    const l7 = get_coeffs_bez3_bez3_exact_sce(c0, c1c1);
    const l8 = get_coeffs_bez3_bez3_exact_epr(c2, c0c0);
    const l9 = get_coeffs_bez3_bez3_exact_sce(d0, d1d1);
    const la = get_coeffs_bez3_bez3_exact_epr(d2, d0d0);
    const lb = get_coeffs_bez3_bez3_exact_fes(l3, l4);
    const lc = get_coeffs_bez3_bez3_exact_fes(l5, l6);
    const ld = get_coeffs_bez3_bez3_exact_fes(l7, l8);
    const le = get_coeffs_bez3_bez3_exact_fes(l9, la);
    const lf = get_coeffs_bez3_bez3_exact_epr(vₓₓₓ, ld);
    const lg = get_coeffs_bez3_bez3_exact_epr(vᵧᵧᵧ, le);
    const lh = get_coeffs_bez3_bez3_exact_sce(3, get_coeffs_bez3_bez3_exact_fes(lf, lg));
    const li = get_coeffs_bez3_bez3_exact_fes(ra, c0d2);
    const lj = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(c0c2), c1c1);
    const lk = get_coeffs_bez3_bez3_exact_fes(get_coeffs_bez3_bez3_exact_em2(d0d2), d1d1);
    const ll = get_coeffs_bez3_bez3_exact_epr(vₓₓᵧ, lb);
    const lm = get_coeffs_bez3_bez3_exact_epr(vₓᵧᵧ, lc);
    const ln = get_coeffs_bez3_bez3_exact_epr(vₓᵧ, li);
    const lo = get_coeffs_bez3_bez3_exact_epr(vₓₓ, lj);
    const lp = get_coeffs_bez3_bez3_exact_epr(vᵧᵧ, lk);
    const lq = get_coeffs_bez3_bez3_exact_epr(c2, vₓ);
    const lr = get_coeffs_bez3_bez3_exact_epr(d2, vᵧ);
    const ls = get_coeffs_bez3_bez3_exact_fes(lq, lr);
    const lt = get_coeffs_bez3_bez3_exact_fes(ll, lm);
    const lu = get_coeffs_bez3_bez3_exact_fes(lh, ln);
    const lv = get_coeffs_bez3_bez3_exact_fes(lo, lp);
    const lw = get_coeffs_bez3_bez3_exact_fes(lt, lu);
    const lx = get_coeffs_bez3_bez3_exact_fes(lv, ls);
    const v2 = get_coeffs_bez3_bez3_exact_fes(lw, lx);
    //const rc = c1d0 + c0d1;
    //const v1 =
    //    vₓₓᵧ*c0*(rc + c1d0) +
    //    vₓᵧᵧ*d0*(rc + c0d1) +
    //    3*(c1*c0c0*vₓₓₓ + d1*d0d0*vᵧᵧᵧ) +
    //    vₓᵧ*rc +
    //    2*(c0c1*vₓₓ + d0d1*vᵧᵧ) +
    //    c1*vₓ + d1*vᵧ ;
    const rc = get_coeffs_bez3_bez3_exact_fes(c1d0, c0d1);
    const rd = get_coeffs_bez3_bez3_exact_sce(c0, vₓₓᵧ);
    const re = get_coeffs_bez3_bez3_exact_sce(d0, vₓᵧᵧ);
    const rf = get_coeffs_bez3_bez3_exact_fes(rc, c1d0);
    const rg = get_coeffs_bez3_bez3_exact_fes(rc, c0d1);
    const rx = get_coeffs_bez3_bez3_exact_epr(c1, c0c0);
    const rh = get_coeffs_bez3_bez3_exact_epr(rx, vₓₓₓ);
    const ry = get_coeffs_bez3_bez3_exact_epr(d1, d0d0);
    const ri = get_coeffs_bez3_bez3_exact_epr(ry, vᵧᵧᵧ);
    const rj = get_coeffs_bez3_bez3_exact_epr(vₓᵧ, rc);
    const rk = get_coeffs_bez3_bez3_exact_epr(c0c1, vₓₓ);
    const rl = get_coeffs_bez3_bez3_exact_epr(d0d1, vᵧᵧ);
    const rm = get_coeffs_bez3_bez3_exact_fes(rk, rl);
    const rn = get_coeffs_bez3_bez3_exact_epr(c1, vₓ);
    const ro = get_coeffs_bez3_bez3_exact_epr(d1, vᵧ);
    const rp = get_coeffs_bez3_bez3_exact_fes(rn, ro);
    const rq = get_coeffs_bez3_bez3_exact_epr(rd, rf);
    const rr = get_coeffs_bez3_bez3_exact_epr(re, rg);
    const rs = get_coeffs_bez3_bez3_exact_fes(rq, rr);
    const rt = get_coeffs_bez3_bez3_exact_sce(3, get_coeffs_bez3_bez3_exact_fes(rh, ri));
    const ru = get_coeffs_bez3_bez3_exact_fes(rj, get_coeffs_bez3_bez3_exact_em2(rm));
    const rv = get_coeffs_bez3_bez3_exact_fes(rs, rt);
    const rw = get_coeffs_bez3_bez3_exact_fes(ru, rp);
    const v1 = get_coeffs_bez3_bez3_exact_fes(rv, rw);
    // v0
    const t1 = get_coeffs_bez3_bez3_exact_sce(c0, vₓₓₓ);
    const t2 = get_coeffs_bez3_bez3_exact_sce(d0, vₓₓᵧ);
    const p4 = get_coeffs_bez3_bez3_exact_fes(t1, t2);
    const t3 = get_coeffs_bez3_bez3_exact_sce(c0, vₓᵧᵧ);
    const t4 = get_coeffs_bez3_bez3_exact_sce(d0, vᵧᵧᵧ);
    const p5 = get_coeffs_bez3_bez3_exact_fes(t3, t4);
    const p7 = get_coeffs_bez3_bez3_exact_fes(p4, vₓₓ);
    const p8 = get_coeffs_bez3_bez3_exact_fes(p5, vᵧᵧ);
    const pc = get_coeffs_bez3_bez3_exact_epr(c0c0, p7);
    const pd = get_coeffs_bez3_bez3_exact_epr(d0d0, p8);
    const p6 = get_coeffs_bez3_bez3_exact_fes(pc, pd);
    const pe = get_coeffs_bez3_bez3_exact_epr(c0d0, vₓᵧ);
    const p9 = get_coeffs_bez3_bez3_exact_fes(p6, pe);
    const pf = get_coeffs_bez3_bez3_exact_sce(c0, vₓ);
    const pg = get_coeffs_bez3_bez3_exact_sce(d0, vᵧ);
    const pa = get_coeffs_bez3_bez3_exact_fes(pf, pg);
    const pb = get_coeffs_bez3_bez3_exact_fes(p9, pa);
    const v0 = get_coeffs_bez3_bez3_exact_fes(pb, v);
    const r = [v9, v8, v7, v6, v5, v4, v3, v2, v1, v0];
    // remove leading zero coefficients
    //while (r.length > 1 && eSign(r[0]) === 0) {
    //    r.shift();
    //}
    return r;
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/get-coefficients/get-coeffs-bez-bez.ts


















const coeffFunctionsDd = [
    [getCoeffsBez1Bez1Dd, getCoeffsBez1Bez2Dd, getCoeffsBez1Bez3Dd],
    [getCoeffsBez2Bez1Dd, getCoeffsBez2Bez2Dd, getCoeffsBez2Bez3Dd],
    [getCoeffsBez3Bez1Dd, getCoeffsBez3Bez2Dd, getCoeffsBez3Bez3Dd]
];
const coeffFunctionsExact = [
    [getCoeffsBez1Bez1Exact, getCoeffsBez1Bez2Exact, getCoeffsBez1Bez3Exact],
    [getCoeffsBez2Bez1Exact, getCoeffsBez2Bez2Exact, getCoeffsBez2Bez3Exact],
    [getCoeffsBez3Bez1Exact, getCoeffsBez3Bez2Exact, getCoeffsBez3Bez3Exact]
];
/**
 * Returns an object with properties containing (1) the coefficients (in double-double
 * precision) of a polynomial in 1 variable whose roots are the parameter values
 * (of the second curve) of the intersection points of two given order 1, 2 or 3 bezier curves (i.e. lines,
 * quadratic and cubic bezier curves), (2) the coefficientwise error bound of the polyomial,
 * and (3) a function that returns the *exact* polynomial coefficients as Shewchuck expansions.
 *
 * The returned polynomial coefficients are given densely as an array of
 * double-double precision floating point numbers from highest to lowest power,
 * e.g. `[[0,5],[0,-3],[0,0]]` represents the polynomial `5x^2 - 3x`.
 *
 * // TODO
 * * **precondition:** the coordinates of the given bezier curves must be
 * such that underflow / overflow cannot occur
 * * if there is an infinite number of intersections `undefined` is returned
 * * intermediate calculations are done in double-double precision with
 * fallback to infinite precision (bar underflow / overflow)
 *
 * @param ps1
 * @param ps2
 *
 * @doc mdx
 */
function getCoeffsBezBez(ps1, ps2) {
    const { coeffs, errBound } = coeffFunctionsDd[ps1.length - 2][ps2.length - 2](ps1, ps2);
    const getPExact = () => coeffFunctionsExact[ps1.length - 2][ps2.length - 2](ps1, ps2);
    return { coeffs, errBound, getPExact };
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/bezier-bezier-intersection-boundless.ts


/**
 * Returns the intersection between any of two linear, quadratic or cubic bezier
 * curves without limiting the `t` value in [0,1], i.e. `t ∈ [-∞,+∞]`.
 *
 * * if the two curves have an infinite number of intersections `undefined` is returned
 * * the second bezier curve's parameter `t` values are retuned
 *
 * * **precondition:** TODO underflow / overflow
 * * **precondition:** cubics are really cubics, etc. TODO
 *
 * @param ps1
 * @param ps2
 *
 * @internal
 */
function bezierBezierIntersectionBoundless(ps1, ps2) {
    let _coeffs = getCoeffsBezBez(ps1, ps2);
    if (_coeffs === undefined) {
        // infinite number of intersections
        // TODO
        //console.log('use endpoint Xs')
        return undefined;
    }
    let { coeffs, errBound, getPExact } = _coeffs;
    return allRootsCertified(coeffs, 0, 1, errBound, getPExact, true);
}


;// CONCATENATED MODULE: ./src/local-properties-to-t/t-from-xy.ts




const t_from_xy_twoDiff = two_diff_twoDiff;
const t_from_xy_min = Math.min;
/**
 * Performs certified inversion, i.e. returns the `t` parameter value
 * interval(s) for the given `x` and `y` coordinates on the specified bezier
 * curve. Only `t` values in `[0,1]` are returned.
 *
 * Returns `undefined` if the point is on the curve and the curve is a point.
 *
 * **precondition:** `p` must be *exactly* on the curve
 * * **certified** here means no `t` value can be missed but (in rare cases)
 * an extra 1 or 2 `t`s could be returned (e.g. for self-overlapping curves
 * and when the point is exactly on the point of self-intersection of the curve)
 *
 * @param ps
 * @param p
 */
function tFromXY(ps, p) {
    if (ps.length === 4) {
        return tFromXY3(ps, p);
    }
    if (ps.length === 3) {
        return tFromXY2(ps, p);
    }
    if (ps.length === 2) {
        return tFromXY1(ps, p);
    }
    // TODO - add case of degenerate point
    throw new Error('The given bezier curve is invalid.');
}
// TODO docs
/**
 * Performs certified inversion, i.e. returns the `t` parameter value
 * interval(s) for the given `x` and `y` coordinates on the specified bezier
 * curve.
 *
 * Returns `undefined` if the point is on the curve and the curve is a point.
 *
 * **precondition:** `p` must be *exactly* on the curve
 * * **certified** here means no `t` value can be missed but (in rare cases)
 * an extra 1 or 2 `t`s could be returned (e.g. for self-overlapping curves
 * and when the point is exactly on the point of self-intersection of the curve)
 *
 * @param ps
 * @param p
 */
function tFromXY3(ps, p) {
    const x = p[0];
    const y = p[1];
    // get power basis representation in double-double precision including error
    // bound
    const { coeffs: [_polyDdX, _polyDdY], errorBound: [polyX_, polyY_] } = get_xy_dd_with_running_error_getXY3DdWithRunningError(ps);
    // pop the constant term off `x(t)`
    const txDd = _polyDdX.pop();
    // subtract the x coordinate of the point
    const polyDdX = [..._polyDdX, t_from_xy_twoDiff(txDd, x)];
    // pop the constant term off `y(t)`
    const tyDd = _polyDdY.pop();
    // subtract the y coordinate of the point
    const polyDdY = [..._polyDdY, t_from_xy_twoDiff(tyDd, y)];
    let pExactXY = undefined;
    const getPExactX = () => {
        if (pExactXY === undefined) {
            pExactXY = getXY3Exact(ps);
        }
        const _pExactX = pExactXY[0]; // x coordinate
        // pop the constant term off `x(t)`
        const tx = _pExactX.pop();
        const pExactX = [..._pExactX, t_from_xy_twoDiff(tx, x)];
        return pExactX;
    };
    const getPExactY = () => {
        if (pExactXY === undefined) {
            pExactXY = getXY3Exact(ps);
        }
        const _pExactY = pExactXY[1]; // y coordinate
        // pop the constant term off `y(t)`
        const ty = _pExactY.pop();
        const pExactY = [..._pExactY, t_from_xy_twoDiff(ty, y)];
        return pExactY;
    };
    // max 3 roots
    const xrs = allRootsCertified(polyDdX, 0, 1, polyX_, getPExactX, true);
    // max 3 roots
    const yrs = allRootsCertified(polyDdY, 0, 1, polyY_, getPExactY, true);
    if (xrs === undefined) {
        // the `x` value of the point is on the curve for all `t` values
        // the curve must be a 'line' (can also be degenerate quadratic, etc.)
        if (yrs === undefined) {
            // the `y` value of the point is on the curve for all `t` values
            // the curve must be a point
            return undefined;
        }
        return yrs; //.map(r => [r.tS, r.tE]);
    }
    if (yrs === undefined) {
        // the `y` value of the point is on the curve for all `t` values
        // the curve must be a 'line' (can also be degenerate quadratic, etc.)        
        return xrs; //.map(r => [r.tS, r.tE]);;
    }
    // check for `t` value overlap 
    // - there can be 0 or 1 overlap (the usual case), 2 overlaps (at point of 
    // self-intersection), 3 overlaps (for self-overlapping curve (that looks 
    // like a line))
    // at this point `xrs !== undefined` and `yrs !== undefined`
    let rs = [];
    for (let i = 0; i < xrs.length; i++) {
        let xr = xrs[i];
        for (let j = 0; j < yrs.length; j++) {
            let yr = yrs[j];
            let r = combineRoots(xr, yr);
            if (r !== undefined) {
                rs.push(r);
            }
        }
    }
    return rs;
}
function tFromXY2(ps, p) {
    const x = p[0];
    const y = p[1];
    // get power basis representation in double-double precision including error
    // bound
    const { coeffs: [_polyDdX, _polyDdY], errorBound: [polyX_, polyY_] } = get_xy_dd_with_running_error_getXY2DdWithRunningError(ps);
    // pop the constant term off `x(t)`
    const txDd = _polyDdX.pop();
    // subtract the x coordinate of the point
    const polyDdX = [..._polyDdX, t_from_xy_twoDiff(txDd, x)];
    // pop the constant term off `y(t)`
    const tyDd = _polyDdY.pop();
    // subtract the y coordinate of the point
    const polyDdY = [..._polyDdY, t_from_xy_twoDiff(tyDd, y)];
    let pExactXY = undefined;
    const getPExactX = () => {
        if (pExactXY === undefined) {
            pExactXY = getXY2Exact(ps);
        }
        const _pExactX = pExactXY[0]; // x coordinate
        // pop the constant term off `x(t)`
        const tx = _pExactX.pop();
        const pExactX = [..._pExactX, t_from_xy_twoDiff(tx, x)];
        return pExactX;
    };
    const getPExactY = () => {
        if (pExactXY === undefined) {
            pExactXY = getXY2Exact(ps);
        }
        const _pExactY = pExactXY[1]; // y coordinate
        // pop the constant term off `y(t)`
        const ty = _pExactY.pop();
        const pExactY = [..._pExactY, t_from_xy_twoDiff(ty, y)];
        return pExactY;
    };
    // max 2 roots
    const xrs = allRootsCertified(polyDdX, 0, 1, polyX_, getPExactX, true);
    // max 2 roots
    const yrs = allRootsCertified(polyDdY, 0, 1, polyY_, getPExactY, true);
    if (xrs === undefined) {
        // the `x` value of the point is on the curve for all `t` values
        // the curve must be a 'line'
        if (yrs === undefined) {
            // the `y` value of the point is on the curve for all `t` values
            // the curve must be a point
            return undefined;
        }
        return yrs; //.map(r => ({ tS: r.tS, tE: r.tE, multiplicity: 1 }));
    }
    if (yrs === undefined) {
        // the `y` value of the point is on the curve for all `t` values
        // the curve must be a 'line'
        return xrs; //.map(r => ({ tS: r.tS, tE: r.tE, multiplicity: 1 }));
    }
    // check for `t` value overlap 
    // - there can be 0 or 1 overlap (the usual case), 2 overlaps (for 
    // self-overlapping curve (that looks like a line))
    // at this point `xrs !== undefined` and `yrs !== undefined`
    let rs = [];
    for (let i = 0; i < xrs.length; i++) {
        let xr = xrs[i];
        for (let j = 0; j < yrs.length; j++) {
            let yr = yrs[j];
            let r = combineRoots(xr, yr);
            if (r !== undefined) {
                rs.push(r);
            }
        }
    }
    return rs;
}
function tFromXY1(ps, p) {
    const x = p[0];
    const y = p[1];
    // get power basis representation in double-double precision including error
    // bound
    const [_polyDdX, _polyDdY] = get_xy_dd_with_running_error_getXY1DdWithRunningError(ps);
    // pop the constant term off `x(t)`
    const txDd = _polyDdX.pop();
    // subtract the x coordinate of the point
    const polyExactX = [..._polyDdX, t_from_xy_twoDiff(txDd, x)];
    // pop the constant term off `y(t)`
    const tyDd = _polyDdY.pop();
    // subtract the y coordinate of the point
    const polyExactY = [..._polyDdY, t_from_xy_twoDiff(tyDd, y)];
    // max 1 roots
    const xrs = allRootsCertified(polyExactX, 0, 1, undefined, undefined, true);
    // max 1 roots
    const yrs = allRootsCertified(polyExactY, 0, 1, undefined, undefined, true);
    if (xrs === undefined) {
        // the `x` value of the point is on the curve for all `t` values
        // the curve must be a vertical line
        if (yrs === undefined) {
            // the `y` value of the point is on the curve for all `t` values
            // the curve must be a point
            return undefined;
        }
        return yrs; //.map(r => ({ tS: r.tS, tE: r.tE, multiplicity: 1 }));
    }
    if (yrs === undefined) {
        // the `y` value of the point is on the curve for all `t` values
        // the curve must be horizontal line
        return xrs; //.map(r => ({ tS: r.tS, tE: r.tE, multiplicity: 1 }));
    }
    // check for `t` value overlap 
    // - there can be 0 or 1 overlap (the usual case), 2 overlaps (for 
    // self-overlapping curve (that looks like a line))
    // at this point `xrs !== undefined` and `yrs !== undefined`
    if (xrs.length === 0 || yrs.length === 0) {
        // this is actually not possible since a precondition is that the point
        // must be *exactly* on the line
        return [];
    }
    // at this point `xrs.length === 1` and `yrs.length === 1`
    const r = combineRoots(xrs[0], yrs[0]);
    if (r === undefined) {
        // this is actually not possible since a precondition is that the point
        // must be *exactly* on the line
        return undefined;
    }
    return [r];
}
function combineRoots(r, s) {
    // case 1
    if (r.tS <= s.tS) {
        if (r.tE < s.tS) {
            return undefined; // no overlap
        }
        return { tS: s.tS, tE: t_from_xy_min(r.tE, s.tE), multiplicity: r.multiplicity + s.multiplicity };
    }
    // case 2 - r.tS > s.tS
    if (s.tE < r.tS) {
        return undefined; // no overlap
    }
    return { tS: r.tS, tE: t_from_xy_min(r.tE, s.tE), multiplicity: r.multiplicity + s.multiplicity };
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-xy/eval-de-casteljau-error.ts
const eval_de_casteljau_error_abs = Math.abs;
// TODO - docs - we're not really returning error counters...
// TODO - add an example
/**
 * Returns a representation of the error (from which an absolute error bound
 * can be calculated) of evaluating the given bezier curve at the parameter `t`
 * using [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm).
 *
 * The returned error representation needs to be multiplied with
 * [Stewart error counters¹](https://www.amazon.ca/Introduction-Matrix-Computations-G-Stewart/dp/0126703507)
 * and an appropriate error function, γ, depending on the precision used (e.g. double
 * or double-double). This is explained in more detail below. See
 * also [Higham 2002](http://ftp.demec.ufpr.br/CFD/bibliografia/Higham_2002_Accuracy%20and%20Stability%20of%20Numerical%20Algorithms.pdf)
 * p. 68 near the bottom.
 *
 * (1) G. W. Stewart. Introduction to Matrix Computations. Academic Press, New York,
*  1973. xiii+441 pp. ISBN 0-12-670350-7
 *
 * * **precondition**: TODO underflow/overflow
 *
 * The absolute erros below can be calculated as follows (where `<E>` are the
 * error counters as indicated in the comments of the return value below):
 *  * double precision: `<E> * (γ(1)) * result_`
 *  * double-double precision: `<E> * (2*γγ(3)) * result_`
 *
 * where [[γ]] and [[γγ]] are the usual error functions.
 * The `T` in the error counter formula is the input error given as an error
 * counter on `t`. For example, if the exact `t` (let's call it `te`) is bounded
 * by `(|t| - 5u) < |te| < (|t| + 5u)` where `u === Number.EPSILON/2` then `T`
 * should be given as `5`. If `t` is exact then `T` should be given as `0`.
 *
 * ```
 * // for cubic bezier curves
 * return [
 * 	x_,  // <E> === 3T + 8
 * 	y_   // <E> === 3T + 8
 * ];
 * // for quadratic bezier curves
 * return [
 * 	x_,  // <E> === 2T + 5
 * 	y_   // <E> === 2T + 5
 * ];
 * // for linear bezier curves (i.e. lines)
 * return [
 * 	x_,  // <E> === T + 2
 * 	y_   // <E> === T + 2
 * ];
 * ```
 *
 * @param ps an order 1, 2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 * @param t the parameter value where the bezier should be evaluated (given in
 * double-double precision)
 *
 * @doc mdx
 **/
function evalDeCasteljauError(ps, t) {
    if (t[0] === 0 && t[1] === 0) {
        return [0, 0]; // No error
    }
    else if (t[0] === 0 && t[1] === 1) {
        return [0, 0]; // No error
    }
    const t_ = eval_de_casteljau_error_abs(t[1]); // <T>
    // <M> --> the cost of multiplication === <1> except for `qmq` in which
    // case it is <2>. One might as well just double the error in the end for
    // double-double precision calculations (thus losing 1 bit) and take 
    // <M> === 1 always. This simplifies the calculation a bit.
    if (ps.length === 4) {
        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        const _x0 = eval_de_casteljau_error_abs(x0); // <0>
        const _y0 = eval_de_casteljau_error_abs(y0); // <0>
        const _x1 = eval_de_casteljau_error_abs(x1); // <0>
        const _y1 = eval_de_casteljau_error_abs(y1); // <0>
        const _x2 = eval_de_casteljau_error_abs(x2); // <0>
        const _y2 = eval_de_casteljau_error_abs(y2); // <0>
        const _x3 = eval_de_casteljau_error_abs(x3); // <0>
        const _y3 = eval_de_casteljau_error_abs(y3); // <0>
        // a01<T+2> <-- <T+2>(x0 + <T+1>(<0>(x1 + x0)*t<T>));
        const a01_ = _x0 + (_x1 + _x0) * t_;
        // a11<T+2> <-- <T+2>(x1 + <1>(<0>(x2 + x1)*t<T>));
        const a11_ = _x1 + (_x2 + _x1) * t_;
        // a21<T+2> <-- <T+2>(x2 + <1>(<0>(x3 + x2)*t<T>));
        const a21_ = _x2 + (_x3 + _x2) * t_;
        // a02<2T+5> <-- <2T+5>(<T+2>a01 + <2T+4>(<T+3>(<T+2>a11 + <T+2>a01)*t<T>));
        const a02_ = a01_ + (a11_ + a01_) * t_;
        // a12<2T+5> <-- <2T+5>(<T+2>a11 + <2T+4>(<T+3>(<T+2>a21 + <T+2>a11)*t<T>));
        const a12_ = a11_ + (a21_ + a11_) * t_;
        // x<3T+8> <-- <3T+8>(<2T+5>a02 + <3T+7>(<2T+6>(<2T+5>a12 + <2T+5>a02)*t<T>));
        const x_ = a02_ + (a12_ + a02_) * t_;
        const b01_ = _y0 + (_y1 + _y0) * t_;
        const b11_ = _y1 + (_y2 + _y1) * t_;
        const b21_ = _y2 + (_y3 + _y2) * t_;
        const b02_ = b01_ + (b11_ + b01_) * t_;
        const b12_ = b11_ + (b21_ + b11_) * t_;
        const y_ = b02_ + (b12_ + b02_) * t_;
        return [x_, y_];
    }
    if (ps.length === 3) {
        const [[x0, y0], [x1, y1], [x2, y2]] = ps;
        const _x0 = eval_de_casteljau_error_abs(x0);
        const _y0 = eval_de_casteljau_error_abs(y0);
        const _x1 = eval_de_casteljau_error_abs(x1);
        const _y1 = eval_de_casteljau_error_abs(y1);
        const _x2 = eval_de_casteljau_error_abs(x2);
        const _y2 = eval_de_casteljau_error_abs(y2);
        // <T+2>a01 <-- <T+2>(x0 + <T+1>((x1 + x0)*<T>t));
        const a01_ = _x0 + (_x1 + _x0) * t_;
        // <T+2>a11 <-- <T+2>(x1 + <T+1>((x2 + x1)*<T>t));
        const a11_ = _x1 + (_x2 + _x1) * t_;
        // <2T+5>x <-- <2T+5>(<T+2>a01 + <2T+4>(<T+3>(<T+2>a11 + <T+2>a01)*<T>t));
        const x_ = a01_ + (a11_ + a01_) * t_;
        const b01_ = _y0 + (_y1 + _y0) * t_;
        const b11_ = _y1 + (_y2 + _y1) * t_;
        const y_ = b01_ + (b11_ + b01_) * t_;
        return [x_, y_];
    }
    if (ps.length === 2) {
        const [[x0, y0], [x1, y1]] = ps;
        const _x0 = eval_de_casteljau_error_abs(x0);
        const _y0 = eval_de_casteljau_error_abs(y0);
        const _x1 = eval_de_casteljau_error_abs(x1);
        const _y1 = eval_de_casteljau_error_abs(y1);
        // <T+2>x = <T+2>(x0 + <T+1>((x1 + x0)*<T>t));
        const x_ = _x0 + (_x1 + _x0) * t_;
        const y_ = _y0 + (_y1 + _y0) * t_;
        return [x_, y_];
    }
    if (ps.length === 1) {
        return [0, 0];
    }
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/global-properties/bounds/get-interval-box/get-interval-box.ts



const get_interval_box_eps = Number.EPSILON;
const get_interval_box_u = get_interval_box_eps / 2;
const get_interval_box_abs = Math.abs;
const get_interval_box_1 = error_analysis_(1);
/**
 * Returns an axis-aligned-box that is guaranteed to engulf the entire
 * given bezier curve from t1 to t2. The returned box is given as a pair
 * of points (the box corners) in double precision, e.g. `[[1,1], [2,2]]`.
 *
 * * **precondition:** t1 < t2
 * * **precondition:** t1,t2 >= 0 && t1,t2 <= 1
  * evalDeCasteljauWithErr - can easily be relaxed)
 *
 * @param ps an order 1, 2 or 3 bezier curve given as an array of control
 * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`
 * @param ts [first, second] parameter values, e.g. [0.11, 0.12]
 *
 * @doc mdx
 */
function getIntervalBox(ps, ts) {
    if (ts[0] !== ts[1]) {
        if (ps.length === 4) {
            return getIntervalBox3(ps, ts);
        }
        if (ps.length === 3) {
            return getIntervalBox2(ps, ts);
        }
        return getIntervalBox1(ps, ts);
    }
    // ts[0] === ts[1]
    return getIntervalBoxAtT(ps, ts[0]);
}
// TODO - this is (nearly) exactly the same as the (better?) `fromTo` used in `bezier3Intersection`
/**
 * Returns an axis-aligned-box that is guaranteed to engulf the entire given
 * bezier curve from t1 to t2.
 *
 * This is achieved by calculating the error bounds of a new curve calculated
 * form t1 to t2 using a splitting algorithm and then taking its extreme
 * control points and finally finding a box that engulfs the control points
 * @internal
 *
 * @param ps
 * @param ts
 */
function getIntervalBox3(ps, ts) {
    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    let [t1, t2] = ts;
    /* from split.py (Python - Sympy)
    const t2 = (t2-t1)/(1-t1);
    const x0_ = t1**3*x3 + 3*t1**2*x2*(1 - t1) + 3*t1*x1*(1 - t1)**2 + x0*(1 - t1)**3;
    const x1_ = t2*(t1**2*x3 + 2*t1*x2*(1 - t1) + x1*(1 - t1)**2) + (1 - t2)*(t1**3*x3 +
            3*t1**2*x2*(1 - t1) + 3*t1*x1*(1 - t1)**2 + x0*(1 - t1)**3);
    const x2_ = t2**2*(t1*x3 + x2*(1 - t1)) + t2*(1 - t2)*(2*t1**2*x3 + 4*t1*x2*(1 - t1) + 2*x1*(1 - t1)**2) +
        (1 - t2)**2*(t1**3*x3 + 3*t1**2*x2*(1 - t1) + 3*t1*x1*(1 - t1)**2 + x0*(1 - t1)**3);
    const x3_ = t2**3*x3 + t2**2*(1 - t2)*(3*t1*x3 + 3*x2*(1 - t1)) + t2*(1 - t2)**2*(3*t1**2*x3 +
            6*t1*x2*(1 - t1) + 3*x1*(1 - t1)**2) + (1 - t2)**3*(t1**3*x3 + 3*t1**2*x2*(1 - t1) +
            3*t1*x1*(1 - t1)**2 + x0*(1 - t1)**3);

    const y0_ = t1**3*y3 + 3*t1**2*y2*(1 - t1) + 3*t1*y1*(1 - t1)**2 + y0*(1 - t1)**3;
    const y1_ = t2*(t1**2*y3 + 2*t1*y2*(1 - t1) + y1*(1 - t1)**2) + (1 - t2)*(t1**3*y3 +
            3*t1**2*y2*(1 - t1) + 3*t1*y1*(1 - t1)**2 + y0*(1 - t1)**3);
    const y2_ = t2**2*(t1*y3 + y2*(1 - t1)) + t2*(1 - t2)*(2*t1**2*y3 + 4*t1*y2*(1 - t1) + 2*y1*(1 - t1)**2) +
        (1 - t2)**2*(t1**3*y3 + 3*t1**2*y2*(1 - t1) + 3*t1*y1*(1 - t1)**2 + y0*(1 - t1)**3);
    const y3_ = t2**3*y3 + t2**2*(1 - t2)*(3*t1*y3 + 3*y2*(1 - t1)) + t2*(1 - t2)**2*(3*t1**2*y3 +
            6*t1*y2*(1 - t1) + 3*y1*(1 - t1)**2) + (1 - t2)**3*(t1**3*y3 + 3*t1**2*y2*(1 - t1) +
            3*t1*y1*(1 - t1)**2 + y0*(1 - t1)**3);
    */
    t2 = ((t2 - t1) / (1 - t1)) * (1 + get_interval_box_eps); // <= fl(t2) > t2
    const s1 = (1 - t1); // <1>s1
    const tt1 = t1 * t1; // <1>tt1  <- error by counters
    const ts1 = t1 * s1; // <2>(<0>t1<1>s1)
    const ss1 = s1 * s1; // <3>(<1>s1<1>s1)
    const ttt1 = tt1 * t1; // <2>(<1>tt1<0>t1)
    const tts1 = tt1 * s1; // <3>(<1>tt1<1>s1)
    const tss1 = ss1 * t1; // <4>(<3>ss1<0>t1)
    const sss1 = ss1 * s1; // <5>(<3>ss1<1>s1)
    const s2 = (1 - t2); // <1>s2 <= relative error bounded by u*(1 - t2)
    const tt2 = t2 * t2; // <1>tt2
    const ts2 = t2 * s2; // <2>(<0>t2<1>s2)
    const ss2 = s2 * s2; // <3>(<1>s2<1>s2)
    const ttt2 = tt2 * t2; // <2>(<1>tt2<0>t2)
    const tts2 = tt2 * s2; // <3>(<1>tt2<1>s2)
    const tss2 = ss2 * t2; // <4>(<3>ss2<0>t2)
    const sss2 = ss2 * s2; // <5>(<3>ss2<1>s2)
    // all of t1,s1,ts1,... are all positive so simpler to use a relative error
    // bound (using e.g. counters <k>):
    // counter rules:
    //   <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   <k>a<l>b = <k + l + 1>ab
    //   fl(a) === <1>a
    let _x0 = get_interval_box_abs(x0);
    let _y0 = get_interval_box_abs(y0);
    let _x1 = get_interval_box_abs(x1);
    let _y1 = get_interval_box_abs(y1);
    let _x2 = get_interval_box_abs(x2);
    let _y2 = get_interval_box_abs(y2);
    let _x3 = get_interval_box_abs(x3);
    let _y3 = get_interval_box_abs(y3);
    //---- x - calculation
    const q8 = x3 * t1 + x2 * s1;
    const q7 = (x3 * tt1 + 2 * x2 * ts1) + x1 * ss1;
    x0 = (x3 * ttt1 + x0 * sss1) + 3 * (x2 * tts1 + x1 * tss1);
    x1 = q7 * t2 + x0 * s2;
    x2 = (q8 * tt2 + x0 * ss2) + 2 * q7 * ts2;
    x3 = (x3 * ttt2 + x0 * sss2) + 3 * (q8 * tts2 + q7 * tss2);
    //---- error / abs value calculation
    const _q8 = _x3 * t1 + _x2 * s1; // <= <3>
    // q8: <3>(<1>(x3*t1) + <2>(x2*<1>s1))
    const _q7 = _x3 * tt1 + 2 * _x2 * ts1 + _x1 * ss1; // <= <5> 
    // q7: <5>(<4>(<2>(x3*<1>tt1) + <3>(2*x2*<2>ts1)) + <4>(x1*<3>ss1));
    _x0 = (_x3 * ttt1 + _x0 * sss1) + 3 * (_x2 * tts1 + _x1 * tss1); // <= <8>
    // x0: <8>(<7>(x3*<2>ttt1 + x0*<5>sss1) + <7>(3*<6>(<4>(x2*<3>tts1) + <5>(x1*<4>tss1))));
    _x1 = _q7 * t2 + _x0 * s2; // <= <7>
    // x1: <11>(<6>(<5>q7*t2) + <10>(<8>x0*<1>s2));
    _x2 = _q8 * tt2 + _x0 * ss2 + 2 * _q7 * ts2; // <= <9>
    // x2: <14>(<13>(<5>(<3>q8*<1>tt2) + <12>(<8>x0*<3>ss2)) + <8>(2*<5>q7*<2>ts2));
    _x3 = _x3 * ttt2 + _x0 * sss2 + 3 * (_q8 * tts2 + _q7 * tss2); // <= <13>
    // x3: <16>(<15>(<3>(x3*<2>ttt2) + <14>(<8>x0*<5>sss2)) + <12>(3*<11>(<7>(<3>q8*<3>tts2 + <10>(<5>q7*<4>tss2)))));
    // max errors: 
    _x0 = 8 * get_interval_box_u * _x0;
    _x1 = 11 * get_interval_box_u * _x1;
    _x2 = 14 * get_interval_box_u * _x2;
    _x3 = 16 * get_interval_box_u * _x3;
    //---- y - calculation
    const r8 = y3 * t1 + y2 * s1;
    const r7 = (y3 * tt1 + 2 * y2 * ts1) + y1 * ss1;
    y0 = (y3 * ttt1 + y0 * sss1) + 3 * (y2 * tts1 + y1 * tss1);
    y1 = r7 * t2 + y0 * s2;
    y2 = (r8 * tt2 + y0 * ss2) + 2 * r7 * ts2;
    y3 = (y3 * ttt2 + y0 * sss2) + 3 * (r8 * tts2 + r7 * tss2);
    const _r8 = _y3 * t1 + _y2 * s1;
    const _r7 = _y3 * tt1 + 2 * _y2 * ts1 + _y1 * ss1;
    _y0 = _y3 * ttt1 + _y0 * sss1 + 3 * (_y2 * tts1 + _y1 * tss1);
    _y1 = _r7 * t2 + _y0 * s2;
    _y2 = _r8 * tt2 + _y0 * ss2 + 2 * _r7 * ts2;
    _y3 = (_y3 * ttt2 + _y0 * sss2) + 3 * (_r8 * tts2 + _r7 * tss2);
    // max errors: 
    _y0 = 8 * get_interval_box_u * _y0;
    _y1 = 11 * get_interval_box_u * _y1;
    _y2 = 14 * get_interval_box_u * _y2;
    _y3 = 16 * get_interval_box_u * _y3;
    const minX = Math.min(x0 - _x0, x1 - _x1, x2 - _x2, x3 - _x3);
    const maxX = Math.max(x0 + _x0, x1 + _x1, x2 + _x2, x3 + _x3);
    const minY = Math.min(y0 - _y0, y1 - _y1, y2 - _y2, y3 - _y3);
    const maxY = Math.max(y0 + _y0, y1 + _y1, y2 + _y2, y3 + _y3);
    return [[minX, minY], [maxX, maxY]];
}
/**
 * Returns an axis-aligned-box that is guaranteed to engulf the entire given
 * bezier curve from t1 to t2.
 *
 * This is achievied by calculating the error bounds of a new curve calculated
 * form t1 to t2 using a splitting algorithm and then taking its extreme
 * control points and finally finding a box that engulfs the control points
 *
 * @param param0
 * @param param1
 *
 * @internal
 */
function getIntervalBox2([[x0, y0], [x1, y1], [x2, y2]], [t1, t2]) {
    /* from split.py (Python - Sympy)
    const t2 = (t2-t1)/(1-t1);

    const x0_ = t1**2*x2 + 2*t1*x1*(1 - t1) + x0*(1 - t1)**2;
    const x1_ = t2*(t1*x2 + x1*(1 - t1)) + (1 - t2)*(t1**2*x2 + 2*t1*x1*(1 - t1) + x0*(1 - t1)**2);
    const x2_ = t2**2*x2 + t2*(1 - t2)*(2*t1*x2 + 2*x1*(1 - t1)) + (1 - t2)**2*(t1**2*x2 + 2*t1*x1*(1 - t1) + x0*(1 - t1)**2);

    const y0_ = t1**2*y2 + 2*t1*y1*(1 - t1) + y0*(1 - t1)**2;
    const y1_ = t2*(t1*y2 + y1*(1 - t1)) + (1 - t2)*(t1**2*y2 + 2*t1*y1*(1 - t1) + y0*(1 - t1)**2);
    const y2_ = t2**2*y2 + t2*(1 - t2)*(2*t1*y2 + 2*y1*(1 - t1)) + (1 - t2)**2*(t1**2*y2 + 2*t1*y1*(1 - t1) + y0*(1 - t1)**2);
    */
    t2 = ((t2 - t1) / (1 - t1)) * (1 + get_interval_box_eps); // <= fl(t2) > t2
    const s1 = (1 - t1); // <1>s1
    const tt1 = t1 * t1; // <1>tt1  <- error by counters
    const ts1 = t1 * s1; // <2>(<0>t1<1>s1)
    const ss1 = s1 * s1; // <3>(<1>s1<1>s1)
    const s2 = (1 - t2); // <1>s2 <= relative error bounded by u*(1 - t2)
    const tt2 = t2 * t2; // <1>tt2
    const ts2 = t2 * s2; // <2>(<0>t2<1>s2)
    const ss2 = s2 * s2; // <3>(<1>s2<1>s2)
    // all of t1,s1,ts1,... are all positive so simpler to use a relative error
    // bound (using e.g. counters <k>):
    // counter rules:
    //   <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   <k>a<l>b = <k + l + 1>ab
    //   fl(a) === <1>a
    let _x0 = get_interval_box_abs(x0);
    let _y0 = get_interval_box_abs(y0);
    let _x1 = get_interval_box_abs(x1);
    let _y1 = get_interval_box_abs(y1);
    let _x2 = get_interval_box_abs(x2);
    let _y2 = get_interval_box_abs(y2);
    //---- x - calculation
    const q1 = (x2 * tt1 + 2 * x1 * ts1) + x0 * ss1;
    const q2 = x2 * t1 + x1 * s1;
    x0 = q1;
    x1 = t2 * q2 + s2 * q1;
    x2 = (tt2 * x2 + 2 * ts2 * q2) + ss2 * q1;
    let _q1 = _x2 * tt1 + 2 * _x1 * ts1 + _x0 * ss1; // <= <5>
    // q1: <5>(<4>(<2>(x2*<1>tt1) + <3>(2*x1*<2>ts1)) + <4>(x0*<3>ss1));
    let _q2 = _x2 * t1 + _x1 * s1; // <= <3>
    // q2: <3>(<1>(x2*t1) + <2>(x1*<1>s1));
    _x0 = _q1; // <= <5>
    // x0: <5>q1;
    _x1 = t2 * _q2 + s2 * _q1; // <= <8>
    // x1: <8>(<4>(t2*<3>q2) + <7>(<1>s2*<5>q1));
    _x2 = (tt2 * x2 + 2 * ts2 * _q2) + ss2 * _q1; // <= <10>
    // x2: <10>(<9>(<2>(<1>tt2*x2) + <6>(2*<2>ts2*<3>q2)) + <9>(<3>ss2*<5>q1));
    // max errors: 
    _x0 = 5 * get_interval_box_u * _x0;
    _x1 = 8 * get_interval_box_u * _x1;
    _x2 = 10 * get_interval_box_u * _x2;
    //---- y - calculation
    const r1 = (y2 * tt1 + 2 * y1 * ts1) + y0 * ss1;
    const r2 = y2 * t1 + y1 * s1;
    y0 = r1;
    y1 = t2 * r2 + s2 * r1;
    y2 = (tt2 * y2 + 2 * ts2 * r2) + ss2 * r1;
    const _r1 = _y2 * tt1 + 2 * _y1 * ts1 + _y0 * ss1; // <= <5>
    const _r2 = _y2 * t1 + _y1 * s1; // <= <3>
    _y0 = _r1; // <= <5>
    _y1 = t2 * _r2 + s2 * _r1; // <= <8>
    _y2 = (tt2 * y2 + 2 * ts2 * _r2) + ss2 * _r1; // <= <10>
    // max errors: 
    _y0 = 5 * get_interval_box_u * _y0;
    _y1 = 8 * get_interval_box_u * _y1;
    _y2 = 10 * get_interval_box_u * _y2;
    const minX = Math.min(x0 - _x0, x1 - _x1, x2 - _x2);
    const maxX = Math.max(x0 + _x0, x1 + _x1, x2 + _x2);
    const minY = Math.min(y0 - _y0, y1 - _y1, y2 - _y2);
    const maxY = Math.max(y0 + _y0, y1 + _y1, y2 + _y2);
    return [[minX, minY], [maxX, maxY]];
}
/**
 * Returns an axis-aligned-box that is guaranteed to engulf the entire given
 * bezier curve from t1 to t2.
 *
 * This is achievied by calculating the error bounds of a new curve calculated
 * form t1 to t2 using a splitting algorithm and then taking its extreme
 * control points and finally finding a box that engulfs the control points
 *
 * @param param0
 * @param param1
 *
 * @internal
 */
function getIntervalBox1([[x0, y0], [x1, y1]], [t1, t2]) {
    // Implementation for lines kept for symmetry - there are obviously much
    // simpler ways to calculate the required box in the case of a line.
    /* from split.py (Python - Sympy)
    const t2 = (t2-t1)/(1-t1);

    const x0_ = t1*x1 + x0*(1 - t1)
    const x1_ = t2*x1 + (1 - t2)*(t1*x1 + x0*(1 - t1))

    const y0_ = t1*y1 + y0*(1 - t1)
    const y1_ = t2*y1 + (1 - t2)*(t1*y1 + y0*(1 - t1))
    */
    t2 = ((t2 - t1) / (1 - t1)) * (1 + get_interval_box_eps); // <= fl(t2) > t2
    const s1 = (1 - t1); // <1>s1
    const s2 = (1 - t2); // <1>s2 <= relative error bounded by u*(1 - t2)
    // use a relative error bound (using e.g. counters <k>):
    // counter rules:
    //   <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   <k>a<l>b = <k + l + 1>ab
    //   fl(a) === <1>a
    let _x0 = get_interval_box_abs(x0);
    let _y0 = get_interval_box_abs(y0);
    let _x1 = get_interval_box_abs(x1);
    let _y1 = get_interval_box_abs(y1);
    //---- x - calculation
    x0 = x1 * t1 + x0 * s1;
    x1 = x1 * t2 + x0 * s2;
    _x0 = _x1 * t1 + _x0 * s1; // <= <3>
    // x0: <3>(<1>(x1*t1) + <2>(x0*s1));
    _x1 = _x1 * t2 + _x0 * s2; // <= <3>
    // x1: <6>(<1>(x1*t2) + <5>(<3>x0*<1>s2));
    // max errors: 
    _x0 = 3 * get_interval_box_u * _x0;
    _x1 = 6 * get_interval_box_u * _x1;
    //---- y - calculation
    y0 = y1 * t1 + y0 * s1;
    y1 = y1 * t2 + y0 * s2;
    _y0 = _y1 * t1 + _y0 * s1; // <= <3>
    _y1 = _y1 * t2 + _y0 * s2; // <= <6>
    // max errors: 
    _y0 = 3 * get_interval_box_u * _y0;
    _y1 = 6 * get_interval_box_u * _y1;
    const minX = Math.min(x0 - _x0, x1 - _x1);
    const maxX = Math.max(x0 + _x0, x1 + _x1);
    const minY = Math.min(y0 - _y0, y1 - _y1);
    const maxY = Math.max(y0 + _y0, y1 + _y1);
    return [[minX, minY], [maxX, maxY]];
}
/**
 * @param ps
 * @param t
 *
 * @internal
 */
function getIntervalBoxAtT(ps, t) {
    const _pS = ps[0];
    const _pE = ps[ps.length - 1];
    if (t === 0) {
        return [_pS, _pS];
    }
    else if (t === 1) {
        return [_pE, _pE];
    }
    const p = evalDeCasteljau(ps, t);
    let pE;
    if (ps.length === 4) {
        pE = evalDeCasteljauError(ps, [0, t]).map(c_ => 8 * get_interval_box_1 * c_);
    }
    else if (ps.length === 3) {
        pE = evalDeCasteljauError(ps, [0, t]).map(c_ => 5 * get_interval_box_1 * c_);
    }
    else if (ps.length === 2) {
        pE = evalDeCasteljauError(ps, [0, t]).map(c_ => 2 * get_interval_box_1 * c_);
    }
    else if (ps.length === 1) {
        pE = [0, 0];
    }
    else {
        throw new Error('The given bezier curve is invalid.');
    }
    return [
        [p[0] - pE[0], p[1] - pE[1]],
        [p[0] + pE[0], p[1] + pE[1]]
    ];
}


;// CONCATENATED MODULE: ./src/boxes/intersect-boxes.ts
const intersect_boxes_min = Math.min;
const intersect_boxes_max = Math.max;
/**
 * Returns the intersection of 2 given axis-aligned rectangular boxes (or
 * `undefined` if they don't intersect).
 *
 * * **exact** - not susceptible to floating point round-off
 * * **closed** - interpret boxes as being closed (i.e. they contain their border).
 *
 * @param a an axis-aligned rectangular box (given by an array of two [[Point]]s,
 * e.g. `[[1,2], [3,4]]` )
 * @param b another box
 *
 * @doc mdx
 */
function intersectBoxes(a, b) {
    let [[ax0, ay0], [ax1, ay1]] = a;
    let [[bx0, by0], [bx1, by1]] = b;
    // Swap so smaller coordinate comes first
    if (ax0 > ax1) {
        [ax0, ax1] = [ax1, ax0];
    }
    ;
    if (bx0 > bx1) {
        [bx0, bx1] = [bx1, bx0];
    }
    ;
    if (ay0 > ay1) {
        [ay0, ay1] = [ay1, ay0];
    }
    ;
    if (by0 > by1) {
        [by0, by1] = [by1, by0];
    }
    ;
    if (!(ax0 <= bx1 && ax1 >= bx0 &&
        by0 <= ay1 && by1 >= ay0)) {
        // they don't intersect
        return undefined;
    }
    return [
        [intersect_boxes_max(ax0, bx0), intersect_boxes_max(ay0, by0)],
        [intersect_boxes_min(ax1, bx1), intersect_boxes_min(ay1, by1)]
    ];
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-xy/double/get-xy-with-running-error.ts
const get_xy_with_running_error_abs = Math.abs;
// TODO - modify docs (the doc below is from `getXY`)
/**
 * Returns the power basis representation of a line, quadratic or cubic bezier.
 *
 * * **non-exact:** if certain preconditions are met (see below) it returns the
 * exact result, else round-off may have occured during intermediate calculation.
 * * returns the power basis polynomial from highest power to lowest,
 * e.g. `at^3 + bt^2 + ct + d` is returned as `[a,b,c,d]`
 *
 * * **bitlength:** If the coordinates of the control points are bit-aligned then:
 *  * max bitlength increase = 4 (for cubics)
 * (due to 'multiplication' by 9 (3x 6x 3x)
 *  * max bitlength increase = 2 (for quadratics)
 * (due to 'multiplication' by 4 (1x 2x 1x)
 *  * max bitlength increase = 1 (for lines)
 * (due to 'multiplication' by 4 (1x 1x)
 *
 * @param ps an order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getXY3WithRunningError(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    // ----------------------------
    // xx3 = (x3 - x0) + 3*(x1 - x2)
    // ----------------------------
    const xa = x3 - x0;
    const _xa_ = get_xy_with_running_error_abs(xa);
    const xb = x1 - x2;
    const _xb_ = get_xy_with_running_error_abs(xb);
    const xc = 3 * xb;
    const xc_ = 6 * _xb_; // === 3*_xb_ + 3*abs(xc)
    const xx3 = xa + xc;
    const xx3_ = _xa_ + xc_ + get_xy_with_running_error_abs(xx3);
    // ----------------------------
    // xx2 = 3*((x2 + x0) - 2*x1)
    // ----------------------------
    const xd = x2 + x0;
    const _xd_ = get_xy_with_running_error_abs(xd);
    const xe = xd - 2 * x1;
    const _xe_ = _xd_ + get_xy_with_running_error_abs(xe);
    const xx2 = 3 * xe;
    const xx2_ = 6 * _xe_; // 3*_xe_ + abs(xx2)
    // ----------------------------
    // xx1 = 3*(x1 - x0)
    // ----------------------------
    const xg = x1 - x0;
    const _xg_ = get_xy_with_running_error_abs(xg);
    const xx1 = 3 * xg;
    const xx1_ = 6 * _xg_; // 3*_xg_ + abs(3*xg)
    // ------------------------------
    // yy3 = (y3 - y0) + 3*(y1 - y2)
    // ------------------------------
    const ya = y3 - y0;
    const _ya_ = get_xy_with_running_error_abs(ya);
    const yb = y1 - y2;
    const _yb_ = get_xy_with_running_error_abs(yb);
    const yc = 3 * yb;
    const yc_ = 6 * _yb_; // === 3*_yb_ + 3*abs(yc)
    const yy3 = ya + yc;
    const yy3_ = _ya_ + yc_ + get_xy_with_running_error_abs(yy3);
    // ----------------------------
    // yy2 = 3*((y2 + y0) - 2*y1)
    // ----------------------------
    const yd = y2 + y0;
    const _yd_ = get_xy_with_running_error_abs(yd);
    const ye = yd - 2 * y1;
    const _ye_ = _yd_ + get_xy_with_running_error_abs(ye);
    const yy2 = 3 * ye;
    const yy2_ = 6 * _ye_; // 3*_ye_ + abs(yy2)
    // ----------------------------
    // yy1 = 3*(y1 - y0)
    // ----------------------------
    const yg = y1 - y0;
    const _yg_ = get_xy_with_running_error_abs(yg);
    const yy1 = 3 * yg;
    const yy1_ = 6 * _yg_; // 3*_yg_ + abs(3*yg)
    return {
        coeffs: [[xx3, xx2, xx1, x0], [yy3, yy2, yy1, y0]],
        errorBound: [[xx3_, xx2_, xx1_, 0], [yy3_, yy2_, yy1_, 0]]
    };
}
/**
 * only quadratic monomial coefficient has an error, the others are exact
 * @param ps
 */
function getXY2WithRunningError(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    // ---------------------
    // xx2 = (x2 + x0) - 2*x1
    // ---------------------
    const xa = x2 + x0;
    const _xa_ = get_xy_with_running_error_abs(xa);
    const xx2 = xa - 2 * x1;
    const xx2_ = _xa_ + get_xy_with_running_error_abs(xx2);
    // ---------------------
    // xx1 = 2*(x1 - x0)
    // ---------------------
    const xx1 = 2 * (x1 - x0);
    const xx1_ = get_xy_with_running_error_abs(xx1);
    // ---------------------
    // yy2 = (y2 + y0) - 2*y1
    // ---------------------
    const ya = y2 + y0;
    const _ya_ = get_xy_with_running_error_abs(ya);
    const yy2 = ya - 2 * y1;
    const yy2_ = _ya_ + get_xy_with_running_error_abs(yy2);
    // ---------------------
    // yy1 = 2*(y1 - y0)
    // ---------------------
    const yy1 = 2 * (y1 - y0);
    const yy1_ = get_xy_with_running_error_abs(yy1);
    return {
        coeffs: [[xx2, xx1, x0], [yy2, yy1, y0]],
        errorBound: [[xx2_, xx1_, 0], [yy2_, yy1_, 0]]
    };
}
/**
 * * exact for any bitlength
 * @param ps linear bezier curve
 */
function getXY1WithRunningError(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    const xx1 = x1 - x0;
    const xx1_ = get_xy_with_running_error_abs(xx1);
    const yy1 = y1 - y0;
    const yy1_ = get_xy_with_running_error_abs(yy1);
    return {
        coeffs: [[xx1, x0], [yy1, y0]],
        errorBound: [[xx1_, 0], [yy1_, 0]]
    };
}


;// CONCATENATED MODULE: ./src/intersection/self-intersection/get-coefficients/double/get-coeffs-bez3-with-running-error.ts


const get_coeffs_bez3_with_running_error_abs = Math.abs;
const get_coeffs_bez3_with_running_error_1 = error_analysis_(1);
/**
 * Returns a polynomial in 1 variable (including coefficientwise error bound)
 * whose roots are the parameter values of the self-intersection points of the
 * given cubic bezier curve.
 *
 * The returned polynomial coefficients are given densely as an array of double
 * precision floating point numbers from highest to lowest power,
 * e.g. `[5,-3,0]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** TODO - overflow/underflow
 * * intermediate calculations are done in double precision and this is
 * reflected in the output error bound (which is approximately equal to
 * `n * Number.EPSILON * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned need **not** be scaled before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps an order 3 bezier curve.
 *
 * @doc
 */
function getCoeffsBez3WithRunningError(ps) {
    const { coeffs: [[a3, a2, a1], [b3, b2, b1]], errorBound: [[a3_, a2_], [b3_, b2_]] } = getXY3WithRunningError(ps);
    const _a3 = get_coeffs_bez3_with_running_error_abs(a3);
    const _a2 = get_coeffs_bez3_with_running_error_abs(a2);
    const _a1 = get_coeffs_bez3_with_running_error_abs(a1);
    const _b3 = get_coeffs_bez3_with_running_error_abs(b3);
    const _b2 = get_coeffs_bez3_with_running_error_abs(b2);
    const _b1 = get_coeffs_bez3_with_running_error_abs(b1);
    const a2b3 = a2 * b3;
    const a3b2 = a3 * b2;
    const a3b1 = a3 * b1;
    const a1b3 = a1 * b3;
    const a2b1 = a2 * b1;
    const a1b2 = a1 * b2;
    // Note: a variable prepended with and underscore is an absolute value,
    // postpended with an underscore denotes an absolute error (before 
    // multiplication by the round-off unit `u`) - both underscores present 
    // means it is both an absolute value and a round-off error.
    const _a2b3 = get_coeffs_bez3_with_running_error_abs(a2b3);
    const _a3b2 = get_coeffs_bez3_with_running_error_abs(a3b2);
    const _a3b1 = get_coeffs_bez3_with_running_error_abs(a3b1);
    const _a1b3 = get_coeffs_bez3_with_running_error_abs(a1b3);
    const _a2b1 = get_coeffs_bez3_with_running_error_abs(a2b1);
    const _a1b2 = get_coeffs_bez3_with_running_error_abs(a1b2);
    const a2b3_ = a2_ * _b3 + _a2 * b3_ + _a2b3;
    const a3b2_ = a3_ * _b2 + _a3 * b2_ + _a3b2;
    const a3b1_ = a3_ * _b1 + _a3b1;
    const a1b3_ = _a1 * b3_ + _a1b3;
    const a2b1_ = a2_ * _b1 + _a2b1;
    const a1b2_ = _a1 * b2_ + _a1b2;
    const f4 = a2b3 - a3b2;
    const _f4 = get_coeffs_bez3_with_running_error_abs(f4);
    const f4_ = a2b3_ + a3b2_ + _f4;
    const f5 = a1b3 - a3b1;
    const _f5 = get_coeffs_bez3_with_running_error_abs(f5);
    const f5_ = a1b3_ + a3b1_ + _f5;
    const f6 = a2b1 - a1b2;
    const _f6 = get_coeffs_bez3_with_running_error_abs(f6);
    const f6_ = a2b1_ + a1b2_ + _f6;
    //const u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2
    //const u2 = a2b3*(-2*a3b2 + a2b3) + a3b2*a3b2
    //const u2 = (a2b3 - a3b2)*(a2b3 - a3b2)
    const u2 = f4 * f4;
    const u2_ = 2 * f4_ * _f4 + get_coeffs_bez3_with_running_error_abs(u2);
    //const u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3
    //const u1 = a1*b3*-a3*b2 + a1*b3*a2*b3 + a3*b1*-a2*b3 + a3*b1*a3*b2
    //const u1 = a1b3*(a2b3 - a3b2) - a3b1*(a2b3 - a3b2)
    //const u1 = a1b3*f4 - a3b1*f4 = f4*(a1b3 - a3b1);
    const u1 = f4 * f5;
    const u1_ = f4_ * _f5 + _f4 * f5_ + get_coeffs_bez3_with_running_error_abs(u1);
    //const u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2
    //const u0 = 
    //       a2b3*(a2b1 - a1b2) - a3b2*(a2b1 - a1b2) +
    //       a1b3*(-2*a3b1 + a1b3) + a3b1*a3b1;
    //const u0 = 
    //       f6*f4 + 
    //       (a1b3 - a3b1)*(a1b3 - a3b1);
    //const u0 = f6*f4 + f5*f5;
    const g7 = f6 * f4;
    const g7_ = f6_ * _f4 + _f6 * f4_ + get_coeffs_bez3_with_running_error_abs(g7);
    const g9 = f5 * f5;
    const g9_ = 2 * _f5 * f5_ + get_coeffs_bez3_with_running_error_abs(g9);
    const u0 = g7 + g9;
    const u0_ = g7_ + g9_ + get_coeffs_bez3_with_running_error_abs(u0);
    // Solve: u2*t**2 + u1*t + u0 = 0
    return {
        coeffs: [u2, u1, u0],
        errBound: [u2_, u1_, u0_].map(c => get_coeffs_bez3_with_running_error_1 * c)
    };
}


;// CONCATENATED MODULE: ./src/intersection/self-intersection/get-coefficients/exact/get-coeffs-bez3-exact.ts


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_bez3_exact_epr = expansion_product_expansionProduct;
const get_coeffs_bez3_exact_fes = fastExpansionSum;
const ede = e_diff_eDiff;
/**
 * Returns an error-free polynomial in 1 variable whose roots are the parameter
 * values of the self-intersection points of the given cubic bezier curve.
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** TODO underflow/overflow
 * * the returned polynomial coefficients are exact (i.e. error-free)
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps An order 3 bezier curve.
 *
 * @doc
 */
function getCoeffsBez3Exact(ps) {
    const [[a3, a2, a1], [b3, b2, b1]] = getXY3Exact(ps);
    const a2b3 = get_coeffs_bez3_exact_epr(a2, b3);
    const a3b2 = get_coeffs_bez3_exact_epr(a3, b2);
    const a3b1 = get_coeffs_bez3_exact_epr(a3, b1);
    const a1b3 = get_coeffs_bez3_exact_epr(a1, b3);
    const a2b1 = get_coeffs_bez3_exact_epr(a2, b1);
    const a1b2 = get_coeffs_bez3_exact_epr(a1, b2);
    const f4 = ede(a2b3, a3b2);
    const f5 = ede(a1b3, a3b1);
    const f6 = ede(a2b1, a1b2);
    //const u2 = -2*a2*a3*b2*b3 + a2*a2*b3*b3 + a3*a3*b2*b2
    const u2 = get_coeffs_bez3_exact_epr(f4, f4);
    //const u1 = -a1*a3*b2*b3 - a2*a3*b1*b3 + a1*a2*b3*b3 + b1*b2*a3*a3
    const u1 = get_coeffs_bez3_exact_epr(f4, f5);
    //const u0 = -a1*a2*b2*b3 - a2*a3*b1*b2 - 2*a1*a3*b1*b3 + a1*a1*b3*b3 + a3*a3*b1*b1 + a1*a3*b2*b2 + b1*b3*a2*a2
    const g7 = get_coeffs_bez3_exact_epr(f4, f6);
    const g9 = get_coeffs_bez3_exact_epr(f5, f5);
    const u0 = get_coeffs_bez3_exact_fes(g7, g9);
    // Solve: u2*t**2 + u1*t + u0 = 0
    return [u2, u1, u0];
}


;// CONCATENATED MODULE: ./src/intersection/self-intersection/bezier-self-intersection.ts







// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const { eSign: bezier_self_intersection_eSign, eAbs: bezier_self_intersection_eAbs, eToDd: bezier_self_intersection_eToDd, eMultByNeg2: bezier_self_intersection_eMultByNeg2, eEstimate: bezier_self_intersection_eEstimate, eCompare: bezier_self_intersection_eCompare } = operators;
const { sqrtWithErr: bezier_self_intersection_sqrtWithErr, divWithErr: bezier_self_intersection_divWithErr, ddSqrt: bezier_self_intersection_ddSqrt } = node_operators;
const bezier_self_intersection_edif = e_diff_eDiff;
const bezier_self_intersection_epr = expansion_product_expansionProduct;
const bezier_self_intersection_sce = scale_expansion_scaleExpansion2;
const bezier_self_intersection_td = node_twoDiff;
const bezier_self_intersection_ts = node_twoSum;
const bezier_self_intersection_qno = node_ddNegativeOf;
const bezier_self_intersection_qaq = node_ddAddDd;
const bezier_self_intersection_qm2 = node_ddMultBy2;
const qdivq = node_ddDivDd;
const bezier_self_intersection_fes = fastExpansionSum;
const bezier_self_intersection_ge = growExpansion;
const bezier_self_intersection_eps = Number.EPSILON;
const eps2 = 2 * bezier_self_intersection_eps;
const bezier_self_intersection_abs = Math.abs;
const bezier_self_intersection_1 = error_analysis_(1);
/**
 * Returns the unique self-intersection parameter `t` values of the given
 * bezier curve if they exist, else return `[]` (see also the `inRange`
 * parameter below).
 *
 * * only cubic (or higher order) bezier curves can have unique self-intersections
 * * * **precondition:** TODO - underflow/overflow
 * * this algorithm is mathematically guaranteed accurate to within an absolute
 * error of `4 * Number.EPSILON` for the returned `t` values satisfying `|t| <= 1`
 * or a relative error of the same `4 * Number.EPSILON` otherwise.
 * * **special case:** a cusp is considered a degenerate self-intersection and
 * the (duplicate) `t` values *will* be returned (if they're in [0,1])
 *
 * @param ps a bezier curve given as an array of its control points
 * @param inRange If `inRange === true` (the default) then return the 2 `t`
 * parameter values only if both are in [0,1] else return `[]`.
 * If `inRange === false` then return the (0, 1 or 2) `t` values in [0,1].
 *
 * @doc mdx
 */
function bezierSelfIntersection(ps, inRange = true) {
    if (ps.length < 4) {
        // lines and quadratics don't have uniqure self-intersections.
        return [];
    }
    // First get fast naively calculated coefficients
    const { coeffs: [a, b, c], errBound: [a_, b_, c_] } = getCoeffsBez3WithRunningError(ps);
    // if error in `a` cannot discern it from zero
    if (bezier_self_intersection_abs(a) <= a_) {
        // it is rare to get here 
        // check for sure if a === 0 exactly
        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        //const a3 = (x3 - x0) + 3*(x1 - x2);
        //const a2 = (x2 + x0) - 2*x1;
        //const b3 = (y3 - y0) + 3*(y1 - y2);
        //const b2 = (y2 + y0) - 2*y1;
        const a3 = bezier_self_intersection_fes(bezier_self_intersection_td(x3, x0), bezier_self_intersection_sce(3, (bezier_self_intersection_td(x1, x2))));
        const a2 = bezier_self_intersection_ge(bezier_self_intersection_ts(x2, x0), -2 * x1);
        const b3 = bezier_self_intersection_fes(bezier_self_intersection_td(y3, y0), bezier_self_intersection_sce(3, (bezier_self_intersection_td(y1, y2))));
        const b2 = bezier_self_intersection_ge(bezier_self_intersection_ts(y2, y0), -2 * y1);
        const a2b3 = bezier_self_intersection_epr(a2, b3);
        const a3b2 = bezier_self_intersection_epr(a3, b2);
        if (bezier_self_intersection_eCompare(a2b3, a3b2) === 0) {
            // a === 0 => no roots possible!
            // This type of curve is usually shaped like an S where both 
            // extreme curvatures are identical or sometimes it is shaped 
            // looking similar to a quadratic bezier curve.
            return [];
        }
    }
    // `Discr` = discriminant = b^2 - 4ac
    // calculate `Discr` and its absolute error Discr_
    const bb = b * b;
    const bb_ = 2 * b_ * bezier_self_intersection_abs(b) + bezier_self_intersection_1 * bb; // the error in b**2
    const ac4 = 4 * a * c;
    const ac4_ = 4 * (a_ * bezier_self_intersection_abs(c) + bezier_self_intersection_abs(a) * c_) + bezier_self_intersection_1 * bezier_self_intersection_abs(ac4);
    const Discr = bb - ac4;
    const Discr_ = bb_ + ac4_ + bezier_self_intersection_1 * bezier_self_intersection_abs(Discr);
    // if the discriminant is smaller than negative the error bound then
    // certainly there are no roots, i.e. no cusp and no self-intersections
    if (Discr < -Discr_) {
        // discriminant is definitely negative
        return [];
    }
    // if the discriminant is definitely positive
    if (Discr > Discr_) {
        // calculate roots naively as a fast pre-filter
        const { est: D, err: D_ } = bezier_self_intersection_sqrtWithErr(Discr, Discr_);
        let q1;
        if (b >= 0) {
            // const r1 = (-b - D) / 2*a;
            // const r2 = (2*c) / (-b - D);
            q1 = -b - D;
        }
        else {
            // const r2 = (-b + D) / 2*a;
            // const r1 = (2*c) / (-b + D);
            q1 = -b + D;
        }
        const q1_ = b_ + D_ + bezier_self_intersection_1 * bezier_self_intersection_abs(q1);
        const { est: r1, err: r1_ } = bezier_self_intersection_divWithErr(q1, 2 * a, q1_, 2 * a_);
        const { est: r2, err: r2_ } = bezier_self_intersection_divWithErr(2 * c, q1, 2 * c_, q1_);
        // the actual 'filter' follows
        if (inRange) {
            // IF at least one root is not in [0,1]
            // THEN no self-intersection (in [0,1])
            if (r1 + r1_ < 0 || r1 - r1_ > 1 ||
                r2 + r2_ < 0 || r2 - r2_ > 1) {
                return [];
            }
        }
        else {
            // IF both roots not in [0,1] 
            // THEN no self-intersection (in [0,1])
            if ((r1 + r1_ < 0 || r1 - r1_ > 1) &&
                (r2 + r2_ < 0 || r2 - r2_ > 1)) {
                return [];
            }
        }
    }
    // we need to check exactly - (a !== 0) at this point - tested for earlier
    let [A, B, C] = getCoeffsBez3Exact(ps);
    // exact - Discr = b^2 - 4ac
    const eDiscr = bezier_self_intersection_edif(bezier_self_intersection_epr(B, B), bezier_self_intersection_sce(4, bezier_self_intersection_epr(A, C)));
    const sgnDiscr = bezier_self_intersection_eSign(eDiscr);
    if (sgnDiscr < 0) {
        // sgn < 0 => no real roots => no cusp or double point for t in [0,1]
        return [];
    }
    if (sgnDiscr > 0) {
        const D = bezier_self_intersection_ddSqrt(bezier_self_intersection_eToDd(eDiscr));
        A = bezier_self_intersection_eToDd(A);
        B = bezier_self_intersection_eToDd(B);
        C = bezier_self_intersection_eToDd(C);
        let nBD;
        if (bezier_self_intersection_eSign(B) >= 0) {
            nBD = bezier_self_intersection_qno(bezier_self_intersection_qaq(B, D));
            //t1 = (-B - D) / (2*A);
            //t2 = (2*C) / (-B - D);
        }
        else {
            nBD = bezier_self_intersection_qaq(bezier_self_intersection_qno(B), D);
            //t1 = (2*C) / (-B + D);
            //t2 = (-B + D) / (2*A);
        }
        let t1 = bezier_self_intersection_eEstimate(qdivq(nBD, bezier_self_intersection_qm2(A))); // max 1 ulps out
        let t2 = bezier_self_intersection_eEstimate(qdivq(bezier_self_intersection_qm2(C), nBD)); // max 1 ulps out
        if (inRange) {
            // if any root is outside the range => no double point for t in [0,1]
            if (t1 < -eps2 || t1 > 1 + eps2 ||
                t2 < -eps2 || t2 > 1 + eps2) {
                return [];
            }
        }
        else {
            // if both roots are outside the range => no double point for t in [0,1]
            if ((t1 < -eps2 || t1 > 1 + eps2) &&
                (t2 < -eps2 || t2 > 1 + eps2)) {
                return [];
            }
        }
        // coerce to 0/1
        //t1 = (t1 >= -eps4 && t1 < 0)
        //    ? 0
        //    : (t1 > 1 && t1 <= 1 + eps4) ? 1 : t1;
        //t2 = (t2 >= -eps4 && t2 < 0)
        //    ? 0
        //    : (t2 > 1 && t2 <= 1 + eps4) ? 1 : t2;
        [t1, t2] = t1 < t2 ? [t1, t2] : [t2, t1];
        return t1 >= 0 - eps2 && t1 <= 1 + eps2
            ? t2 >= 0 - eps2 && t2 <= 1 + eps2
                ? [t1, t2]
                : [t1]
            : t2 >= 0 - eps2 && t2 <= 1 + eps2
                ? [t2]
                : [];
    }
    // sign === 0 => cusp
    // set t = b/d = b/-2a
    const d = bezier_self_intersection_eMultByNeg2(A);
    const sgnB = bezier_self_intersection_eSign(B);
    const sgnD = bezier_self_intersection_eSign(d);
    // if result is negative the cusp is outside the bezier endpoints
    const sgn_ = sgnB * sgnD;
    if (sgn_ < 0) {
        return [];
    }
    // if result is > 1 the cusp is outside the bezier endpoints
    if (bezier_self_intersection_eCompare(bezier_self_intersection_eAbs(B), bezier_self_intersection_eAbs(d)) > 0) {
        return [];
    }
    const qB = bezier_self_intersection_eToDd(B);
    const qd = bezier_self_intersection_eToDd(d);
    const qt = qdivq(qB, qd);
    const t = qt[1] + qt[0];
    return [t, t];
}


;// CONCATENATED MODULE: ./src/intersection/get-endpoint-intersections.ts



/**
 * Returns the parameter `t` values where the endpoints of the two
 * given *algebraically identical* curves overlap.
 *
 * * **precondition:** the two given curves must be *algebraically identical*
 * (i.e. in the same k-family, in other words identical except possibly for
 * endpoints). This can be checked for by calling [[areBeziersInSameKFamily]].
 * * **precondition:** neither bezier curve may be of order 1 (a point)
 *
 * @param ps1 an order 1,2 or 3 bezier curve
 * @param ps2 another order 1,2 or 3 bezier curve
 * @param minD an error bound given as a distance
 *
 * @doc mdx
 */
function getEndpointIntersections(ps1, ps2) {
    const p1S = ps1[0];
    const p1E = ps1[ps1.length - 1];
    const p2S = ps2[0];
    const p2E = ps2[ps2.length - 1];
    // // keep TypeScript happy; `tFromXY` cannot return `undefined` at this stage
    const t2S1 = tFromXY(ps2, p1S);
    const t2E1 = tFromXY(ps2, p1E);
    const t1S2 = tFromXY(ps1, p2S);
    const t1E2 = tFromXY(ps1, p2E);
    const xs = [];
    xs.push(...t2S1.map(ri => {
        const box = getIntervalBox(ps2, [ri.tS, ri.tE]);
        return [
            { ri: createRootExact(0), kind: 5, box },
            { ri, kind: 5, box }
        ];
    }), ...t2E1.map(ri => {
        const box = getIntervalBox(ps2, [ri.tS, ri.tE]);
        return [
            { ri: createRootExact(1), kind: 5, box },
            { ri, kind: 5, box }
        ];
    }), ...t1S2.map(ri => {
        const box = getIntervalBox(ps1, [ri.tS, ri.tE]);
        return [
            { ri, kind: 5, box },
            { ri: createRootExact(0), kind: 5, box }
        ];
    }), ...t1E2.map(ri => {
        const box = getIntervalBox(ps1, [ri.tS, ri.tE]);
        return [
            { ri, kind: 5, box },
            { ri: createRootExact(1), kind: 5, box }
        ];
    }));
    return xs;
}


;// CONCATENATED MODULE: ./src/global-properties/type/is-line.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const { orient2d: is_line_orient2d } = operators;
/**
 * Returns true if the given bezier curve is a line or if all control points
 * are collinear.
 *
 * * if you need to know whether a given bezier curve can be converted to an
 * order 1 bezier curve (a line) such that the same `(x,y)` point is returned
 * for the same `t` value then use e.g. [[isQuadReallyLine]] instead.
 * * **exact:** for any bitlength of the given coordinates.
 *
 * @param ps An order 1, 2 or 3 bezier curve.
 *
 * @doc mdx
 */
function isLine(ps) {
    if (ps.length === 4) {
        // Cubic bezier
        return (is_line_orient2d(ps[0], ps[1], ps[2]) === 0 &&
            is_line_orient2d(ps[1], ps[2], ps[3]) === 0 &&
            // The below check is necessary for if ps[1] === ps[2]
            is_line_orient2d(ps[0], ps[2], ps[3]) === 0);
    }
    if (ps.length === 3) {
        // Quadratic bezier
        return is_line_orient2d(ps[0], ps[1], ps[2]) === 0;
    }
    if (ps.length === 2 || ps.length === 1) {
        // Line (or point)
        return true;
    }
    throw new Error('The given bezier curve is invalid.');
}
/**
 * Returns true if the given bezier degenerates to a horizontal line (possibly
 * self-overlapping)
 *
 * @param ps An order 1, 2 or 3 bezier curve.
 *
 * @doc
 */
function isHorizontalLine(ps) {
    const y = ps[0][1];
    for (let i = 1; i < ps.length; i++) {
        if (ps[i][1] !== y) {
            return false;
        }
    }
    return true;
}
/**
 * Returns true if the given bezier degenerates to a vertical line (possibly
 * self-overlapping)
 *
 * @param ps An order 1, 2 or 3 bezier curve.
 *
 * @doc
 */
function isVerticalLine(ps) {
    const x = ps[0][0];
    for (let i = 1; i < ps.length; i++) {
        if (ps[i][0] !== x) {
            return false;
        }
    }
    return true;
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-dxy/exact/get-dxy-exact.ts

const get_dxy_exact_td = two_diff_twoDiff;
const get_dxy_exact_ts = two_sum_twoSum;
const get_dxy_exact_sce = scale_expansion_scaleExpansion2;
const eadd = eAdd;
const get_dxy_exact_ge = growExpansion;
/**
 * Returns the derivative of the power basis representation of a line, quadratic
 * or cubic bezier.
 *
 * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getDxyExact(ps) {
    if (ps.length === 4) {
        return getDxy3Exact(ps);
    }
    if (ps.length === 3) {
        return getDxy2Exact(ps);
    }
    if (ps.length === 2) {
        return getDxy1Exact(ps);
    }
    // TODO - add case of degenerate point
    throw new Error('The given bezier curve is invalid.');
}
function getDxy3Exact(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    return [[
            get_dxy_exact_sce(3, eadd(get_dxy_exact_td(x3, x0), get_dxy_exact_sce(3, get_dxy_exact_td(x1, x2)))),
            get_dxy_exact_sce(6, get_dxy_exact_ge(get_dxy_exact_ts(x2, x0), -2 * x1)),
            get_dxy_exact_sce(3, get_dxy_exact_td(x1, x0))
        ], [
            get_dxy_exact_sce(3, eadd(get_dxy_exact_td(y3, y0), get_dxy_exact_sce(3, get_dxy_exact_td(y1, y2)))),
            get_dxy_exact_sce(6, get_dxy_exact_ge(get_dxy_exact_ts(y2, y0), -2 * y1)),
            get_dxy_exact_sce(3, get_dxy_exact_td(y1, y0))
        ]];
}
function getDxy2Exact(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    return [[
            get_dxy_exact_ge(get_dxy_exact_ts(2 * x2, 2 * x0), -4 * x1),
            get_dxy_exact_td(2 * x1, 2 * x0),
        ], [
            get_dxy_exact_ge(get_dxy_exact_ts(2 * y2, 2 * y0), -4 * y1),
            get_dxy_exact_td(2 * y1, 2 * y0),
        ]];
}
function getDxy1Exact(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    return [[
            get_dxy_exact_td(x1, x0),
        ], [
            get_dxy_exact_td(y1, y0),
        ]];
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-dxy/double-double/get-dxy-dd.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_dxy_dd_ts = node_twoSum; // error -> 0
const get_dxy_dd_td = node_twoDiff; // error -> 0
const get_dxy_dd_qmd = node_ddMultDouble2; // error -> 3*u²
const get_dxy_dd_qaq = node_ddAddDd;
const get_dxy_dd_qad = node_ddAddDouble; // error -> 2*u²
const get_dxy_dd_abs = Math.abs;
/**
 * TODO docs
 * Returns the derivative of the power basis representation of a line, quadratic
 * or cubic bezier's.
 *
 * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getDxyDd(ps) {
    if (ps.length === 4) {
        return getDxy3Dd(ps);
    }
    if (ps.length === 3) {
        return getDxy2Dd(ps);
    }
    if (ps.length === 2) {
        return getDxy1Dd(ps);
    }
    throw new Error('The given bezier curve must be of order 1, 2 or 3.');
}
function getDxy3Dd(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    return [[
            get_dxy_dd_qmd(3, get_dxy_dd_qaq(get_dxy_dd_td(x3, x0), get_dxy_dd_qmd(3, get_dxy_dd_td(x1, x2)))),
            get_dxy_dd_qmd(6, get_dxy_dd_qad(get_dxy_dd_ts(x2, x0), -2 * x1)),
            get_dxy_dd_qmd(3, get_dxy_dd_td(x1, x0))
        ], [
            get_dxy_dd_qmd(3, get_dxy_dd_qaq(get_dxy_dd_td(y3, y0), get_dxy_dd_qmd(3, get_dxy_dd_td(y1, y2)))),
            get_dxy_dd_qmd(6, get_dxy_dd_qad(get_dxy_dd_ts(y2, y0), -2 * y1)),
            get_dxy_dd_qmd(3, get_dxy_dd_td(y1, y0))
        ]];
}
function getDxy2Dd(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    return [[
            get_dxy_dd_qad(get_dxy_dd_ts(2 * x2, 2 * x0), -4 * x1),
            get_dxy_dd_td(2 * x1, 2 * x0),
        ], [
            get_dxy_dd_qad(get_dxy_dd_ts(2 * y2, 2 * y0), -4 * y1),
            get_dxy_dd_td(2 * y1, 2 * y0),
        ]];
}
function getDxy1Dd(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    return [[
            get_dxy_dd_td(x1, x0),
        ], [
            get_dxy_dd_td(y1, y0),
        ]];
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-dxy/get-dxy-error-counters.ts
// For double precision the error bound === γ * <counter> * `error_`
// For double-double precision the error bound === γγ3 * <counter> * `error_`
const get_dxy_error_counters_abs = Math.abs;
// TODO - fix docs - uses Wilkinson error counters
/**
 * TODO
 * Returns the derivative of the power basis representation of a line, quadratic or cubic bezier.
 *
 * * returns the derivative of the tpower basis polynomial from highest power to lowest,
 * e.g. `at^3 + bt^2 + ct + d` is returned as `[a,b,c,d]`
 *
 * TODO
 * ```
 * errorBound: [[
 *		dx0,  // <D>
 * ], [
 *		dy0,  // <D>
 * ]]
 * ```
 * @param ps an order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getDxy1ErrorCounters(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    const _x0 = get_dxy_error_counters_abs(x0);
    const _x1 = get_dxy_error_counters_abs(x1);
    const _y0 = get_dxy_error_counters_abs(y0);
    const _y1 = get_dxy_error_counters_abs(y1);
    // If intermediate calculations are done in double precision then:
    // `<D> === <1>` else if double-double precision then `<D> === <0>`.
    return [
        [
            // <D> <= <D>(<0>x1 - <0>x0)
            _x1 + _x0, // <D>
        ], [
            _y1 + _y0, // <D>
        ]
    ];
}
// TODO - fix docs
/**
 *
 * TODO
 * ```
 * errorBound: [[
 *		dx1,  // <D+1>
 *		dx0,  // <D>
 * ],[
 *		dy1,  // <D+1>
 *		dy0,  // <D>
 * ]]
 * ```
 *
 * @param ps
 */
function getDxy2ErrorCounters(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    const _x0 = get_dxy_error_counters_abs(x0);
    const _x1 = get_dxy_error_counters_abs(x1);
    const _x2 = get_dxy_error_counters_abs(x2);
    const _y0 = get_dxy_error_counters_abs(y0);
    const _y1 = get_dxy_error_counters_abs(y1);
    const _y2 = get_dxy_error_counters_abs(y2);
    // If intermediate calculations are done in double precision then:
    // `<D> === <1>` else if double-double precision then `<D> === <0>`.
    return [
        [
            // <D+1> <-- <D+1>(<D>(x2 + x0) - 2*x1)
            2 * ((_x2 + _x0) + 2 * _x1),
            // <D> <-- 2*<D>(x1 - x0)
            2 * (_x1 + _x0)
        ], [
            2 * ((_y2 + _y0) + 2 * _y1),
            2 * (_y1 + _y0)
        ]
    ];
}
// TODO - fix docs
/**
 *
 * TODO
 * ```
 * errorBound: [[
 *		dx2,  // <D+3>
 *		dx1,  // <D+2>
 *		dx0,  // <D+1>
 * ],[
 *		dy2,  // <D+3>
 *		dy1,  // <D+2>
 *		dy0,  // <D+1>
 * ]]
 * ```
 *
 * @param ps
 */
function getDxy3ErrorCounters(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    const _x0 = get_dxy_error_counters_abs(x0);
    const _x1 = get_dxy_error_counters_abs(x1);
    const _x2 = get_dxy_error_counters_abs(x2);
    const _x3 = get_dxy_error_counters_abs(x3);
    const _y0 = get_dxy_error_counters_abs(y0);
    const _y1 = get_dxy_error_counters_abs(y1);
    const _y2 = get_dxy_error_counters_abs(y2);
    const _y3 = get_dxy_error_counters_abs(y3);
    // If intermediate calculations are done in double precision then:
    // `<D> === <1>` else if double-double precision then `<D> === <0>`.
    return [
        [
            // <D+3> <-- <D+3>(3*(<D+2>(<D>(x3 - x0) + <D+1>(3*<D>(x1 - x2)))))
            3 * ((_x3 + _x0) + 3 * (_x1 + _x2)),
            // <D+2> <-- <D+2>(6*<D+1>(<D>(x2 + x0) - 2*x1))
            6 * ((_x2 + _x0) + 2 * _x1),
            // <D+1> <-- <D+1>(3*<D>(x1 - x0))
            3 * (_x1 + _x0)
        ], [
            3 * ((_y3 + _y0) + 3 * (_y1 + _y2)),
            6 * ((_y2 + _y0) + 2 * _y1),
            3 * (_y1 + _y0)
        ]
    ];
}


;// CONCATENATED MODULE: ./src/global-properties/type/is-cubic-really-quad.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const is_cubic_really_quad_tp = two_product_twoProduct;
const is_cubic_really_quad_fes = fastExpansionSum;
const esign = e_sign_eSign;
const ediff = e_diff_eDiff;
const is_cubic_really_quad_u = Number.EPSILON / 2;
const is_cubic_really_quad_abs = Math.abs;
/**
 * Returns true if the given cubic bezier curve is really a quadratic curve.
 *
 * * **exact:** for any bitlength of the coefficients
 *
 * @param ps a cubic bezier curve
 *
 * @doc mdx
 */
function isCubicReallyQuad(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    // The line below is unrolled (uses a toHybridQuadratic condition (points same?))
    //if ((x3 + 3*x1) - (x0 + 3*x2) === 0 && 
    //    (y3 + 3*y1) - (y0 + 3*y2) === 0) {
    // Calculate an approximation of the above with error bounds and use it as
    // a fast filter.
    const u1 = 3 * x1;
    const u1_ = is_cubic_really_quad_abs(3 * x1); // the absolute error in u1
    const u2 = x3 + u1;
    const u2_ = u1_ + is_cubic_really_quad_abs(u2); // the absolute error in u2
    const v1 = 3 * x2;
    const v1_ = is_cubic_really_quad_abs(3 * x2); // the absolute error in v1
    const v2 = x0 + v1;
    const v2_ = v1_ + is_cubic_really_quad_abs(v2); // the absolute error in v2
    const w = u2 - v2;
    const w_ = u2_ + v2_ + is_cubic_really_quad_abs(w); // the absolute error in w
    // if w cannot possibly be zero, i.e. if the error is smaller than the value
    if (is_cubic_really_quad_abs(w) - is_cubic_really_quad_u * w_ > 0) {
        // fast filter 1 passed
        return false;
    }
    const q1 = 3 * y1;
    const q1_ = is_cubic_really_quad_abs(3 * y1); // the absolute error in q1
    const q2 = y3 + q1;
    const q2_ = q1_ + is_cubic_really_quad_abs(q2); // the absolute error in q2
    const r1 = 3 * y2;
    const r1_ = is_cubic_really_quad_abs(3 * y2); // the absolute error in r1
    const r2 = y0 + r1;
    const r2_ = r1_ + is_cubic_really_quad_abs(r2); // the absolute error in r2
    const s = q2 - r2;
    const s_ = q2_ + r2_ + is_cubic_really_quad_abs(s); // the absolute error in s
    if (is_cubic_really_quad_abs(s) - is_cubic_really_quad_u * s_ > 0) {
        // fast filter 2 passed
        return false;
    }
    // unable to filter - go slow and exact
    return (esign(ediff(is_cubic_really_quad_fes([x3], is_cubic_really_quad_tp(3, x1)), is_cubic_really_quad_fes([x0], is_cubic_really_quad_tp(3, x2)))) === 0 &&
        esign(ediff(is_cubic_really_quad_fes([y3], is_cubic_really_quad_tp(3, y1)), is_cubic_really_quad_fes([y0], is_cubic_really_quad_tp(3, y2)))) === 0);
}


;// CONCATENATED MODULE: ./src/global-properties/type/is-quad-really-line.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗
const is_quad_really_line_ediff = e_diff_eDiff;
const is_quad_really_line_esign = e_sign_eSign;
const is_quad_really_line_ts = two_sum_twoSum;
const is_quad_really_line_u = Number.EPSILON / 2;
const is_quad_really_line_abs = Math.abs;
/**
 * Returns true if the given quadratic bezier curve is really a linear curve.
 *
 * * the required condition is met if: `x0 + x2 = 2*x1` and `y0 + y2 = 2*y1`
 * * **exact:** for any input
 *
 * @param ps a quadratic bezier curve
 *
 * @doc mdx
 */
function isQuadReallyLine(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    //if (x0 + x2 === 2*x1) && (y0 + y2 === 2*y1)
    // Calculate an approximation of the above with error bounds and use it as
    // a fast filter.
    const q = x0 + x2;
    const _q_ = is_quad_really_line_abs(q); // the absolute error bound in q (after multipliciation by `u`)
    const w = q - 2 * x1;
    const w_ = _q_ + is_quad_really_line_abs(w); // the absolute error bound in w
    // if w cannot possibly be zero, i.e. if the error is smaller than the value
    if (is_quad_really_line_abs(w) - w_ > 0) {
        // fast filter passed
        return false;
    }
    const r = y0 + y2;
    const _r_ = is_quad_really_line_abs(r); // the absolute error bound in r (after multipliciation by `u`)
    const z = r - 2 * y1;
    const z_ = _r_ + is_quad_really_line_abs(z); // the absolute error bound in w
    // if the error is smaller than the value
    if (is_quad_really_line_abs(z) - z_ > 0) {
        // fast filter passed
        return false;
    }
    // unable to filter - go slow and exact
    return (is_quad_really_line_esign(is_quad_really_line_ediff(is_quad_really_line_ts(x0, x2), [2 * x1])) === 0 &&
        is_quad_really_line_esign(is_quad_really_line_ediff(is_quad_really_line_ts(y0, y2), [2 * y1])) === 0);
}


;// CONCATENATED MODULE: ./src/global-properties/type/is-line-really-point.ts
/**
 * Returns true if the given linear bezier curve is really a point.
 *
 * * the required condition is met if: `x0 === x1` and `y0 === y1`
 * * **exact:** for any input
 *
 * @param ps a linear bezier curve
 *
 * @doc mdx
 */
function isLineReallyPoint(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    //if (x0 === x1) && (y0 === y1)
    return (x0 === x1 && y0 === y1);
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/reduce-order-if-possible.ts




/**
 * Returns a reduced order version of the given bezier curve if it can be
 * represented as such without loss.
 *
 * Crucially, the reduced order bezier will have exactly the same `t` values
 * at specific `x` and `y` coordinates as the originals.
 *
 * @param ps1
 * @param ps2
 *
 * @internal
 */
function reduceOrderIfPossible(ps) {
    if (ps.length === 4 && isCubicReallyQuad(ps)) {
        ps = toQuadraticFromCubic(ps);
    }
    if (ps.length === 3 && isQuadReallyLine(ps)) {
        ps = [ps[0], ps[2]];
    }
    if (ps.length === 2 && isLineReallyPoint(ps)) {
        ps = [ps[0]];
    }
    return ps;
}


;// CONCATENATED MODULE: ./src/intersection/bezier-bezier-intersection/bezier-bezier-intersection.ts















const bezier_bezier_intersection_eps = Number.EPSILON;
const bezier_bezier_intersection_eps2 = 2 * bezier_bezier_intersection_eps;
const bezier_bezier_intersection_3 = error_analysis_error_analysis_(3);
/**
 * Returns the intersection between two bezier curves up to cubic order (i.e.
 * points, linear, quadratic or cubic bezier curves (i.e. order 0, 1, 2 or 3
 * curves).
 *
 * The algorithm employed uses advanced techniques such
 * as floating point error bounding, adaptive multi-precision floating
 * point arithmetic, pre-filtering of easy cases, certified root finding and
 * algebraic implicitization of the curves in order to find *guaranteed*
 * accurate results.
 *
 * TODO - make sure below points are correct (add to tests)
 * * if the two curves have an infinite number of intersections `undefined` is
 * returned
 * * TODO the second bezier curve's parameter `t` values are returned; call [[getOtherTs]] to
 * get the first bezier's `t` values.
 * // TODO
 * * * **precondition:** the coordinates of the given bezier curves must be
 * such that underflow / overflow does not occur
 * * this algorithm is mathematically guaranteed accurate to within
 * `4 * Number.EPSILON` in the t values of the *second* bezier curve (provided
 * the precondition is met).
 *
 * @param ps
 *
 * @doc mdx
 */
function bezierBezierIntersection(ps1, ps2) {
    ps1 = reduceOrderIfPossible(ps1);
    ps2 = reduceOrderIfPossible(ps2);
    if (ps1.length === 1 || ps2.length === 1) {
        return handlePointDegenerateCases(ps1, ps2);
    }
    const ris2 = bezierBezierIntersectionBoundless(ps1, ps2);
    if (ris2 === undefined) {
        return handleInfiniteIntersections(ps1, ps2);
    }
    if (ris2.length === 0) {
        return [];
    }
    // keep TypeScript happy; `ris1` cannot be `undefined` here (bar any 🐛s!)
    const ris1 = bezierBezierIntersectionBoundless(ps2, ps1);
    if (ris1.length === 0) {
        return [];
    }
    let is1 = ris1.map(ri => getIntervalBox(ps1, [ri.tS, ri.tE]));
    let is2 = ris2.map(ri => getIntervalBox(ps2, [ri.tS, ri.tE]));
    let xPairs = [];
    for (let i = 0; i < ris1.length; i++) {
        let box1 = is1[i];
        for (let j = 0; j < ris2.length; j++) {
            let box2 = is2[j];
            let box = intersectBoxes(box1, box2);
            if (box !== undefined) {
                let x1 = { ri: ris1[i], box, kind: 1 };
                let x2 = { ri: ris2[j], box, kind: 1 };
                xPairs.push([x1, x2]);
            }
        }
    }
    return xPairs;
}
/**
 * * **precondition:** the bezier curves must be of lowest possible
 * representable order
 * * **precondition:** `bezierBezierIntersectionBoundless(ps1, ps2)` must
 * return `undefined` to represent the fact of an infinite number of
 * intersections exist
 * * **precondition:** neither bezier curve may be of order 1 (a point)
 *
 * @param ps1
 * @param ps2
 *
 * @internal
 */
function handleInfiniteIntersections(ps1, ps2) {
    // At this point there are an infinite number of intersections, i.e.:
    // `bezierBezierIntersectionBoundless(ps1, ps2) === undefined`
    if (isLine(ps1)) {
        // `ps2` must also be a line
        return handleCollinearIntersections(ps1, ps2);
    }
    const xPairs = [];
    xPairs.push(...getEndpointIntersections(ps1, ps2));
    xPairs.push(...getCoincidingSelfIntersections(ps1, ps2));
    return xPairs;
}
/**
 * Get the intersection (if it exist) that is the double-point of both given
 * algebraically identical curves if both the double-points are given for `t`
 * values in `[0,1]` for each curve.
 *
 * * **precondition:** the bezier curves must be of lowest possible
 * representable order
 * * **precondition:** `bezierBezierIntersectionBoundless(ps1, ps2)` must
 * return `undefined` to represent the fact of an infinite number of
 * intersections exist
 * * **precondition:** neither curve is allowed to have all points collinear
 *
 * @param ps1
 * @param ps2
 *
 * @internal
 */
function getCoincidingSelfIntersections(ps1, ps2) {
    const ts1 = bezierSelfIntersection(ps1, false);
    const ts2 = bezierSelfIntersection(ps2, false);
    const len1 = ts1.length;
    const len2 = ts2.length;
    if (len1 < 1 || len2 < 1) {
        return [];
    }
    const xPairs = [];
    // this is a *very* rare case
    for (let t1 of ts1) {
        for (let t2 of ts2) {
            xPairs.push([{
                    kind: 1,
                    ri: { tS: t1 - bezier_bezier_intersection_eps2, tE: t1 + bezier_bezier_intersection_eps2, multiplicity: 1 },
                    box: getIntervalBox(ps1, [t1 - bezier_bezier_intersection_eps2, t1 + bezier_bezier_intersection_eps2])
                }, {
                    kind: 1,
                    ri: { tS: t1 - bezier_bezier_intersection_eps2, tE: t1 + bezier_bezier_intersection_eps2, multiplicity: 1 },
                    box: getIntervalBox(ps2, [t2 - bezier_bezier_intersection_eps2, t2 + bezier_bezier_intersection_eps2])
                }]);
        }
    }
    return xPairs;
}
/**
 * * **precondition:** the bezier curves must be of lowest possible
 * representable order
 * * **precondition:** `bezierBezierIntersectionBoundless(ps1, ps2)` must
 * return `undefined` to represent the fact of an infinite number of
 * intersections exist
 * * **precondition:** all points (from both curves) must be collinear
 *
 * @param ps1
 * @param ps2
 *
 * @internal
 */
function handleCollinearIntersections(ps1, ps2) {
    // Get curve 'turn-around points' when extending `t` from negative to 
    // positive infinity.
    const ris1 = getTurnaroundPoints(ps1);
    const ris2 = getTurnaroundPoints(ps2);
    //aaa TODO
    return [];
}
/**
 * Get curve 'turn-around points' when extending `t` from negative to positive
 * infinity.
 *
 * This is a helper function and is used by [[handleCollinearIntersections]]
 * only.
 *
 * @param ps
 *
 * @internal
 */
function getTurnaroundPoints(ps) {
    // Get curve 'turn-around points' when extending `t` from negative to 
    // positive infinity.
    // Since we're already constrained to a line we only need look at either
    // `x(t)` or `y(t)`.
    // # of 'turn-around points': 
    //  * line: 0
    //  * quadratic: 0,1
    //  * cubic: 0,1 or 2
    let ris;
    if (ps.length === 4) {
        const coeffs1 = getDxy3Dd(ps)[0]; // x-coordinate only
        let [dx2_, dx1_, dx0_] = getDxy3ErrorCounters(ps)[0];
        dx2_ = 3 * bezier_bezier_intersection_3 * dx2_;
        dx1_ = 2 * bezier_bezier_intersection_3 * dx1_;
        dx0_ = 1 * bezier_bezier_intersection_3 * dx0_;
        // keep TypeScript happy; `allRootsCertified` cannot return `undefined` here
        ris = allRootsCertified(coeffs1, 0, 1, [dx2_, dx1_, dx0_], () => getDxy3Exact(ps)[0]);
    }
    else if (ps.length === 3) {
        const coeffs1 = getDxy2Dd(ps)[0]; // x-coordinate only
        let [dx1_, dx0_] = getDxy2ErrorCounters(ps)[0];
        dx1_ = bezier_bezier_intersection_3 * dx1_;
        dx0_ = 0;
        // keep TypeScript happy; `allRootsCertified` cannot return `undefined` here
        ris = allRootsCertified(coeffs1, 0, 1, [dx1_, dx0_], () => getDxy2Exact(ps)[0]);
    }
    else if (ps.length === 2 || ps.length === 1) {
        ris = []; // no 'turn-around points' possible (its a line)
    }
    else {
        throw new Error('The given bezier curve is invalid.');
    }
    // keep TypeScript happy; `ris` cannot be `undefined` here if 
    // preconditions are met
    return ris;
}
function getXYDdWithRunningError(ps) {
    if (ps.length === 4) {
        return getXY3DdWithRunningError(ps);
    }
    if (ps.length === 3) {
        return getXY2DdWithRunningError(ps);
    }
    if (ps.length === 2) {
        return {
            coeffs: getXY1DdWithRunningError(ps),
            errorBound: [[0, 0], [0, 0]]
        };
    }
}
/**
 * Handles the degenerate cases where either bezier curve is really a point and
 * returns the relevant intersections if any.
 *
 * * **precondition:** either or both bezier curves must be a point
 * * **precondition:** the bezier curves must be of lowest possible
 * representable order
 *
 * @param ps1
 * @param ps2
 *
 * @internal
 */
function handlePointDegenerateCases(ps1, ps2) {
    if (ps1.length === 1) {
        const p1 = ps1[0];
        const box = [p1, p1];
        if (ps2.length === 1) {
            const p2 = ps2[0];
            if (p1[0] === p2[0] && p1[1] === p2[1]) {
                // literally the same points - very degenerate
                return [
                    [
                        { ri: { tS: 0, tE: 1, multiplicity: Number.POSITIVE_INFINITY }, kind: 6, box },
                        { ri: { tS: 0, tE: 1, multiplicity: Number.POSITIVE_INFINITY }, kind: 6, box },
                    ]
                ];
            }
            return [];
        }
        if (isPointOnBezierExtension(ps2, [[p1[0]], [p1[1]]])) {
            // keep TypeScript happy; at this point `tFromXY` cannot return `undefined`
            return tFromXY(ps2, p1).map(ri => [
                { ri: { tS: 0, tE: 1, multiplicity: Number.POSITIVE_INFINITY }, kind: 6, box },
                { ri, kind: 6, box },
            ]);
        }
        return [];
    }
    const p2 = ps2[0];
    const box = [p2, p2];
    if (isPointOnBezierExtension(ps1, [[p2[0]], [p2[1]]])) {
        // keep TypeScript happy; at this point `tFromXY` cannot return `undefined`
        return tFromXY(ps1, p2).map(ri => [
            { ri, kind: 6, box },
            { ri: { tS: 0, tE: 1, multiplicity: Number.POSITIVE_INFINITY }, kind: 6, box },
        ]);
    }
    return [];
}


;// CONCATENATED MODULE: ./src/intersection/bezier3-intersection/bezier3-intersection.ts


const bezier3_intersection_debug_ = (typeof globalThis !== 'undefined' && globalThis.__debug__)
    ? globalThis.__debug__
    : undefined;
const bezier3_intersection_checkIntersectionInRanges = checkIntersectionInRanges;
const bezier3_intersection_bezierBezierIntersection = bezierBezierIntersection;
const bezier3_intersection_min = Math.min;
const bezier3_intersection_max = Math.max;
const bezier3_intersection_abs = Math.abs;
/**
 * The guarantee in accuracy of the `t` parameter value chosen to be reasonable
 * for this type of intersection algorithm.
 */
const δ = 2 ** (-33); // 2**(-33) === 1.1641532182693481e-10
/** a heuristic value for the minimum t-span of the final iteration */
const Δ = 2 ** (-43); // 2**(-43) === 1.1368683772161603e-13
/**
 * Accurate, fast (*eventually* cubically convergent) algorithm that returns
 * the intersections between two bezier curves.
 *
 * * returns an array that contains the `t` paramater pairs at intersection
 * of the first and second bezier curves respectively.
 * * returns `undefined` if there are an infinite number of intersections (i.e
 * when the curves overlap *exactly*)
 *
 * * the algorithm is based on a paper at http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd
 * that finds the intersection of a fat line and a so-called geometric interval
 * making it faster than the standard fat-line intersection algorithm (that
 * is *eventually* quadratically convergent)
 * * *eventually* cubically convergent (usually converging in about 4 to 8
 * iterations for typical intersections) but for hard intersections can become
 * extremely slow due to sub-linear convergence (and similarly for all fatline
 * algorithms) in those cases; luckily this algorithm detects those cases and
 * reverts to implicitization with strict error bounds to guarantee accuracy
 * and efficiency (implicitization is roughly 5x slower but is rare)
 *
 * @param ps1 a bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]
 * @param ps2 another bezier curve
 */
function bezier3Intersection(ps1, ps2) {
    if (ps1.length <= 2 || ps2.length <= 2) {
        // revert to implicit form when it's going to be fast anyway
        return implicit(ps1, ps2);
    }
    /** Intersection `t` values for both beziers */
    let xs = [];
    /** an iteration still left to check for intersections */
    let iteration = {
        F: ps1,
        G: ps2,
        fRange: [0, 1],
        gRange: [0, 1],
        last: undefined
    };
    let stack = [iteration];
    if (bezier3_intersection_debug_ !== undefined && !bezier3_intersection_debug_.already) {
        bezier3_intersection_debug_.tree = iteration;
    }
    let iters = 0;
    // A slight improvement to the algorithm may be possible by doing a 
    // breath-first (rather than depth-first) traversal and reverting to 
    // implicitization once the tree reaches a certain width
    /** max iteration heuristic before reverting to implicitization */
    const maxIters = 60;
    while (stack.length !== 0 && iters < maxIters) {
        iters++;
        // keep TypeScript happy; `stack` cannot be empty here
        const iter = stack.pop();
        if (bezier3_intersection_debug_ !== undefined && !bezier3_intersection_debug_.already) {
            bezier3_intersection_debug_.currentIter = iter;
            iter.uid = bezier3_intersection_debug_.uid++;
        }
        let newIterations = bezier3_intersection_checkIntersectionInRanges(iter);
        if (newIterations.length === 1) {
            const newIter = newIterations[0];
            const fRange = newIter.fRange;
            const δδ = bezier3_intersection_abs(fRange[1] - fRange[0]);
            // if the previous iteration was precise enough
            if (newIter.last) {
                const lfRange = newIter.last.fRange;
                if (δδ > δ) {
                    // This case can occur when the geometric interval clips a
                    // piece of the other bezier very far away but is by 
                    // coincidence of length < δ.
                    // It can also occur in some other edge cases such as 
                    // self-overlapping cubic curves, etc.
                    // revert to implicitization
                    return implicit(ps1, ps2);
                }
                xs.push(iter.F === ps2
                    ? [fRange, lfRange]
                    : [lfRange, fRange]);
                // else if this iteration is precise enough
            }
            else {
                if (δδ < δ) {
                    if (bezier3_intersection_debug_ !== undefined && !bezier3_intersection_debug_.already) {
                        newIter.foundX = true;
                    }
                    if (δδ < Δ) {
                        // destructively change the `fRange` as a heuristic so its not
                        // too narrow for the final clip; this might only be a 
                        // problem if `fRange === 0` 
                        fRange[0] = bezier3_intersection_max(0, fRange[0] - Δ);
                        fRange[1] = bezier3_intersection_min(1, fRange[1] + Δ);
                    }
                    newIter.last = newIter;
                }
                stack.push(newIter); // push the (possibly) final iteration
            }
        }
        else if (newIterations.length === 2) {
            //stack.push(...newIterations);
            stack.push(newIterations[0], newIterations[1]);
        }
    }
    if (iters === maxIters) {
        if (bezier3_intersection_debug_ !== undefined /* && !__debug__.already*/) {
            bezier3_intersection_debug_.maxItersCount++;
        }
        return implicit(ps1, ps2);
    }
    if (bezier3_intersection_debug_ !== undefined) {
        // prevent further debugging
        bezier3_intersection_debug_.already = true;
    }
    //---------------------------------------------------------------
    // check for possible duplicate intersections at split points
    //---------------------------------------------------------------
    xs.sort((x1, x2) => x1[0][0] - x2[0][0]);
    combineXs(xs);
    return xs;
}
function combineXs(xs) {
    let testAgain = true;
    while (testAgain) {
        testAgain = false;
        for (let i = 1; i < xs.length; i++) {
            const x1bez1 = xs[i - 1][0];
            const x2bez1 = xs[i][0];
            // if the prior tmax value is higher than the next t value's tmin
            // then they overlap
            if (x1bez1[1] >= x2bez1[0]) { // if overlap found
                // Check if the second bezier's `t` values also overlap, else we
                // have a loop getting intersected at its self-intersection point.
                const x1bez2 = xs[i - 1][1];
                const x2bez2 = xs[i][1];
                const x1min = x1bez2[0];
                const x1max = x1bez2[1];
                const x2min = x2bez2[0];
                const x2max = x2bez2[1];
                const overlap = (x1min <= x2max && x1max >= x2min) ||
                    (x2min <= x1max && x2max >= x1min);
                if (overlap) {
                    // combine ranges and test agin
                    testAgain = true;
                    const tMinBez2 = bezier3_intersection_min(x1min, x1max, x2min, x2max);
                    const tMaxBez2 = bezier3_intersection_max(x1min, x1max, x2min, x2max);
                    const x1min1 = x1bez1[0];
                    const x1max1 = x1bez1[1];
                    const x2min1 = x2bez1[0];
                    const x2max1 = x2bez1[1];
                    const tMinBez1 = bezier3_intersection_min(x1min1, x1max1, x2min1, x2max1);
                    const tMaxBez1 = bezier3_intersection_max(x1min1, x1max1, x2min1, x2max1);
                    const x = [
                        [tMinBez1, tMaxBez1],
                        [tMinBez2, tMaxBez2]
                    ];
                    // insert new combined intersection
                    xs.splice(i - 1, 2, x);
                    break; // break out of inner loop
                }
            }
        }
    }
}
function implicit(ps1, ps2) {
    const xPairs = bezier3_intersection_bezierBezierIntersection(ps1, ps2);
    // TODO
    if (xPairs === undefined) {
        // infinite intersections
        return undefined;
        // TODO - bang above
        //return undefined;
    }
    return xPairs.map(xPair => {
        const xPair0ri = xPair[0].ri;
        const xPair1ri = xPair[1].ri;
        return [
            [xPair0ri.tS, xPair0ri.tE],
            [xPair1ri.tS, xPair1ri.tE]
        ];
    });
}


;// CONCATENATED MODULE: ./src/boxes/are-boxes-intersecting.ts
/**
 * Returns true if the 2 given axis-aligned rectangular boxes intersect.
 *
 * * **exact** - not susceptible to floating point round-off
 *
 * @param closed If true, interpret boxes as being closed (i.e. they contain
 * their border) or open.
 * @param a an axis-aligned rectangular box (given by an array of two [[Point]]s,
 * e.g. `[[1,2], [3,4]]` )
 * @param b another axis-aligned rectangular box
 *
 * @doc mdx curry
 */
function areBoxesIntersecting(closed) {
    return (a, b) => {
        let [[ax0, ay0], [ax1, ay1]] = a;
        let [[bx0, by0], [bx1, by1]] = b;
        // Swap so smaller coordinate comes first
        if (ay0 > ay1) {
            [ay0, ay1] = [ay1, ay0];
        }
        ;
        if (by0 > by1) {
            [by0, by1] = [by1, by0];
        }
        ;
        if (ax0 > ax1) {
            [ax0, ax1] = [ax1, ax0];
        }
        ;
        if (bx0 > bx1) {
            [bx0, bx1] = [bx1, bx0];
        }
        ;
        return closed
            ? (ax0 <= bx1 && ax1 >= bx0 &&
                by0 <= ay1 && by1 >= ay0)
            : (ax0 < bx1 && ax1 > bx0 &&
                by0 < ay1 && by1 > ay0);
    };
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-dxy/double/evaluate-dxy.ts


function evaluateDxy(ps, t) {
    const [dX, dY] = getDxy(ps);
    const f = (t) => [Horner(dX, t), Horner(dY, t)];
    return t === undefined ? f : f(t); // Curry
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-ddxy/double/get-ddxy.ts
/**
 * Returns the 2nd derivative of the power basis representation of a line,
 * quadratic or cubic bezier's x-coordinates.
 *
 * Bitlength: If the coordinates of the control points are grid-aligned then
 * * max bitlength increase === max shift === 6 (for cubics)
 * * max bitlength increase === max shift === 3 (for quadratics)
 * * max bitlength increase === max shift === 0 (for lines)
 *
 * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getDdxy(ps) {
    if (ps.length === 4) {
        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        return [[
                6 * (x3 + 3 * (x1 - x2) - x0),
                6 * (x2 - 2 * x1 + x0) // t^0 - max bitlength increase 5
            ], [
                6 * (y3 + 3 * (y1 - y2) - y0),
                6 * (y2 - 2 * y1 + y0) // t^0 - max bitlength increase 5
            ]];
    }
    if (ps.length === 3) {
        const [[x0, y0], [x1, y1], [x2, y2]] = ps;
        return [[
                2 * (x2 - 2 * x1 + x0) // t^0 - max bitlength increase 3
            ], [
                2 * (y2 - 2 * y1 + y0) // t^0 - max bitlength increase 3
            ]];
    }
    if (ps.length === 2) {
        return [[0], [0]];
    }
    // TODO - add case of degenerate point
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-ddxy/double/evaluate-ddxy.ts


function evaluateDdxy(ps, t) {
    const [ddPsX, ddPsY] = getDdxy(ps);
    const f = (t) => [Horner(ddPsX, t), Horner(ddPsY, t)];
    return t === undefined ? f : f(t); // Curry
}


;// CONCATENATED MODULE: ./src/global-properties/total-curvature.ts



/**
 * TODO - replace this function with a more sane version where total curvature
 * is tallied by looking for inflection points and adding curvature over those
 * pieces by looking at tangent at beginning and end of the pieces.
 * Returns the total absolute curvature of the bezier over [0,1] using Gaussian
 * Quadrature integration with 16 wieghts and abscissas which is generally very
 * accurate and fast. Returns the result in radians.
 *
 * @param ps a cubic bezier
 * @param interval
 *
 * @doc mdx
 */
function totalAbsoluteCurvature(ps, interval) {
    // Numerically integrate the absolute curvature
    return gaussQuadrature(t => Math.abs(κds(ps, t)), interval);
}
// TODO - replace this function by simply checking tangents at beginning and
// end of curve.
/**
 * Returns the total curvature of the bezier over the given interval using
 * Gaussian Quadrature integration with 16 wieghts and abscissas which is
 * generally very accurate and fast. This function is curried.
 * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 * @param interval - The interval of integration (often === [0,1])
 * @returns The total curvature.
 *
 * @doc mdx
 */
function totalCurvature(ps, interval) {
    //const tanPs = tangent(ps);
    return gaussQuadrature(t => κds(ps, t), interval);
    // TODO
    /*
    const [a,b] = interval;
    const tangentA = tanPs(a);
    const tangentB = tanPs(b);
    const sinθ = Vector.cross(tanA, tanB)
    */
}
/**
 * Helper function.
 *
 * @internal
 */
function κds(ps, t) {
    const [dx, dy] = evaluateDxy(ps, t);
    const [ddx, ddy] = evaluateDdxy(ps, t);
    const a = dx * ddy - dy * ddx;
    const b = dx * dx + dy * dy;
    return a / b;
}


;// CONCATENATED MODULE: ./src/transformation/reverse.ts
/**
 * Returns the given points (e.g. bezier) in reverse order.
 *
 * @param ps
 *
 * @doc
 */
function reverse(ps) {
    return ps.slice().reverse();
}


;// CONCATENATED MODULE: ./src/global-properties/get-inflections.ts

/**
 * Returns the given order 1, 2 or 3 bezier curve's inflection points.
 *
 * * see [Caffeine Owl](http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html)
 *
 * @param ps an order 1, 2 or 3 bezier curve
 *
 * @doc mdx
 */
function getInflections(ps) {
    if (ps.length < 4) {
        // Neither lines, nor parabolas have inflection points
        return [];
    }
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4
    const ax = x1 - x0;
    const ay = y1 - y0;
    const bx = x2 - x1 - ax;
    const by = y2 - y1 - ay;
    const cx = x3 - x2 - ax - (2 * bx);
    const cy = y3 - y2 - ay - (2 * by);
    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:
    //   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);
    // We find the roots of the quadratic - a,b,c are the quadratic coefficients
    const a = bx * cy - by * cx;
    const b = ax * cy - ay * cx;
    const c = ax * by - ay * bx;
    return allRoots([a, b, c], 0, 1);
}


;// CONCATENATED MODULE: ./src/implicit-form/double/get-implicit-form1.ts

/**
 * Returns the implicit form of the given linear bezier.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓx + vᵧy + v = 0`
 * * intermediate calculations are done in **double** precision
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm1(ps) {
    // The implicit form is given by:
    // vₓx + vᵧy + v = 0
    const [[a1, a0], [b1, b0]] = getXY1(ps);
    const vₓ = -b1;
    const vᵧ = a1;
    const v = a0 * b1 - a1 * b0;
    return { vₓ, vᵧ, v };
}


;// CONCATENATED MODULE: ./src/implicit-form/get-error-counters/get-implicit-form1-error-counters.ts

const get_implicit_form1_error_counters_abs = Math.abs;
// TODO - docs
/**
 * Returns the implicit form of the given linear bezier and a coefficientwise
 * error bound.
 *
 * Returned coefficients are subscripted to match their monomial's variables,
 * e.g. `vₓᵧ` is the coefficient of the monomial `vₓᵧxy`
 *
 * * the implicit form is given by: `vₓx + vᵧy + v = 0`
 * * **precondition:** TODO - add underflow / overflow conditions + docs below
 * * intermediate calculations are done in **double** precision and this is
 * reflected in the output error bound (which is approximately equal to
 * `n * Number.EPSILON * the condition number`, where roughly `1 < n < 100` and
 * depends on the specific calculation)
 * * the error bound returned first needs to be scaled `γ === u/(1 - u)`,
 * where `u === Number.EPSILON / 2` before use
 * * adapted from [Indrek Mandre](http://www.mare.ee/indrek/misc/2d.pdf)
 *
 * TODO
 *
 * ```
 * return {
 *      vₓ_,  // <1>
 *      vᵧ_,  // <1>
 *      v_    // <3>
 * }
 * ```
 *
 * @param ps
 *
 * @doc mdx
 */
function getImplicitForm1ErrorCounters(ps) {
    // The implicit form is given by:
    // vₓx + vᵧy + v = 0
    //const [[a1, a0], [b1, b0]] = getXY(ps);
    const [a0, b0] = ps[0];
    const [[a1_], // <1>a1
    [b1_] // <1>b1
    ] = getXY1ErrorCounters(ps);
    // <3>v <-- <3>(<2>(<0>a0*<1>b1) - <2>(<1>a1*<0>b0))
    const v_ = get_implicit_form1_error_counters_abs(a0) * b1_ + get_implicit_form1_error_counters_abs(b0) * a1_; // <3>
    return {
        vₓ_: b1_,
        vᵧ_: a1_,
        v_ // <3>
    };
}


;// CONCATENATED MODULE: ./src/transformation/to-expansion.ts
function toExpansion(ps) {
    return ps.map(p => p.map(c => [c]));
}


;// CONCATENATED MODULE: ./src/transformation/to-estimation.ts

const to_estimation_estimate = e_estimate_eEstimate;
function toEstimation(ps) {
    return ps.map(p => p.map(c => to_estimation_estimate(c)));
}


;// CONCATENATED MODULE: ./src/from-power-basis/from-power-basis.ts
/**
 * Returns the Bernstein basis representation (i.e. control points) of a line,
 * quadratic or cubic bezier given its power bases.
 * * **non-exact** - due to floating-point round-off (see implementation to
 * understand under what conditions the result would be exact)
 *
 * @param cs An order 1, 2 or 3 parametric curve in power bases with the
 * x-coordinate coefficients given first (as an array representing the
 * polynomial from highest to lowest power coefficient), e.g. `[[1,2,3,4],
 * [5,6,7,8]]` represents a cubic parametric curve given by
 * `x(t) = t^3 + 2t^2 + 3t^3 + 4t^4, y(t) = 5t^3 + 6t^2 + 7t + 8`.
 *
 * @doc
 */
function fromPowerBasis(cs) {
    const len = cs[0].length;
    if (len === 4) {
        const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = cs;
        return [
            [a0,
                b0],
            [a0 + a1 / 3,
                b0 + b1 / 3],
            [a0 + 2 * a1 / 3 + a2 / 3,
                b0 + 2 * b1 / 3 + b2 / 3],
            [a0 + a1 + a2 + a3,
                b0 + b1 + b2 + b3]
        ];
    }
    if (len === 3) {
        const [[a2, a1, a0], [b2, b1, b0]] = cs;
        return [
            [a0,
                b0],
            [a0 + a1 / 2,
                b0 + b1 / 2],
            [a0 + a1 + a2,
                b0 + b1 + b2]
        ];
    }
    if (len === 2) {
        const [[a1, a0], [b1, b0]] = cs;
        return [
            [a0,
                b0],
            [a0 + a1,
                b0 + b1]
        ];
    }
    if (len === 1) {
        const [[a0], [b0]] = cs;
        return [
            [a0,
                b0]
        ];
    }
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/transformation/get-hodograph.ts
/**
 * Returns an approximation of the hodograph of the given bezier curve.
 * * **bitlength**: If the coordinates of the control points are bit-aligned then
 * * max bitlength increase === 3, max shift === 3 (for cubics)
 * * max bitlength increase === 1, max shift === 2 (for quadratics)
 * * max bitlength increase === 1, max shift === 1 (for lines)
 *
 * @param ps An order 1, 2 or 3 bezier curve.
 *
 * @doc
 */
function getHodograph(ps) {
    if (ps.length === 4) {
        // cubic
        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        return [
            [3 * (x1 - x0), 3 * (y1 - y0)],
            [3 * (x2 - x1), 3 * (y2 - y1)],
            [3 * (x3 - x2), 3 * (y3 - y2)]
        ];
    }
    if (ps.length === 3) {
        // quadratic
        const [[x0, y0], [x1, y1], [x2, y2]] = ps;
        return [
            [2 * (x1 - x0), 2 * (y1 - y0)],
            [2 * (x2 - x1), 2 * (y2 - y1)]
        ];
    }
    if (ps.length === 2) {
        // a line
        const [[x0, y0], [x1, y1]] = ps;
        return [
            [x1 - x0, y1 - y0]
        ];
    }
}


;// CONCATENATED MODULE: ./src/create/generate-cusp-at-half-t.ts
/**
 * Returns the cubic bezier curve control points with a zero tangent vector
 * (i.e. `[0,0]`) at `t = 0.5` (i.e. a 'cusp') at the given [[Point]] with
 * given starting and ending control [Point]s.
 * * **non-exact** - due to floating-point round-off the cusp is not necessarily
 * *exactly* at the given point, nor does the tangent vector necessarily vanish
 * *exactly*.
 *
 * @param p0 the bezier start point
 * @param pz the point at which the vanishing tangent should occur
 * @param pE the bezier end point
 *
 * @doc mdx
 */
function generateCuspAtHalf3(p0, pz, pE) {
    // x3 - 3x2 + 3x1 - x0, // := a = coefficent of t^3
    // 3x2 - 6x1 + 3x0,     // := b = coefficent of t^2
    // 3x1 - 3x0,           // := c = coefficent of t^1
    // x0,                  // := d = coefficent of t^0
    // y3 - 3y2 + 3y1 - y0, // := e = coefficent of t^3
    // 3y2 - 6y1 + 3y0,     // := f = coefficent of t^2
    // 3y1 - 3y0,           // := g = coefficent of t^1
    // y0,                  // := h = coefficent of t^0
    // const x = at^3 + bt^2 + ct + d
    // const y = et^3 + ft^2 + gt + h
    // x` = 3at^2 + 2bt + c
    // y` = 3et^2 + 2ft + g
    // d = x0 and h = y0
    const [x0, y0] = p0;
    const [xz, yz] = pz;
    const [xE, yE] = pE;
    // We must have x` = y` = 0 at t = 1/2:
    // 3a/4 + b + c = 0            =>  3a  + 4b  + 4c  =  0       (1)
    // 3e/4 + f + g = 0            =>  3e  + 4f  + 4g  =  0       (2)
    // Also, x(1/2) === pz[0]:
    // a/8 + b/4 + c/2 + d = pz[0] => a + 2b + 4c + 8d = 8xz      (3)
    // and y(1/2) === pz[1]:
    // e/8 + f/4 + g/2 + h = pz[1] => e + 2f + 4g + 8h = 8yz      (4)
    // and by definitition:
    // a = x3 - 3x2 + 3x1 - x0     => -3x2 + 3x1 - a   =  x0 - x3 (5)
    // b = 3x2 - 6x1 + 3x0         =>  3x2 - 6x1 - b   = -3x0     (6)
    // c = 3x1 - 3x0               =>  3x1       - c   =  3x0     (7)
    // e = y3 - 3y2 + 3y1 - y0     => -3y2 + 3y1 - e   =  y0 - y3 (8)
    // f = 3y2 - 6y1 + 3y0         =>  3y2 - 6y1 - f   = -3y0     (9) 
    // g = 3y1 - 3y0               =>  3y1       - g   =  3y0     (10)
    // Solving the above linear system gives:
    //const a = 4*xE-4*x0;
    //const b = 4*x0-4*xz-4*xE+4*x0;
    //const c = -4*x0+4*xz+xE-x0;
    //const e = 4*yE-4*y0;
    //const f = 4*y0-4*yz-4*yE+4*y0;
    //const g = -4*y0+4*yz+yE-y0;
    const x1 = -(4 * x0 - 4 * xz - xE - 2 * x0) / 3;
    const y1 = -(4 * y0 - 4 * yz - yE - 2 * y0) / 3;
    const x2 = -(4 * x0 - 4 * xz + 2 * xE - 5 * x0) / 3;
    const y2 = -(4 * y0 - 4 * yz + 2 * yE - 5 * y0) / 3;
    return [p0, [x1, y1], [x2, y2], pE];
}

/*
3*a  + 4*b  + 4*c   = 0
3*e  + 4*f  + 4*g   = 0
a + 2*b + 4*c + 8*d = 8*xz
e + 2*f + 4*g + 8*h = 8*yz
-3*x2 + 3*x1 - a =  x0 - x3
3*x2 - 6*x1 - b = -3*x0
3*x1 - c = 3*x0
-3*y2 + 3*y1 - e = y0 - y3
3*y2 - 6*y1  - f = -3*y0
3*y1 - g = 3*y0
*/

;// CONCATENATED MODULE: ./src/create/cubic-through-point-given013.ts
/**
 * Generates and returns a cubic bezier curve going through a specific point
 * given control points 0, 1 and 3.
 * * **non-exact:** the returned bezier does not necessarily go through the
 * point *exactly* (due to floating-point round-off).
 *
 * @param ps cubic bezier points given as `[[x0,y0], [x1,y1], , [x3,y3]]`,
 * e.g. `[[1,2], [3,4], ,[5,6]]` (note the 3rd point is not given)
 * @param p a point through which the bezier should go
 * @param t a t parameter value at which the bezier should go through the
 * point - this is necessary due to a degree of freedom still left
 *
 * @example
 * ```typescript
 * cubicThroughPointGiven013([[1,1], [10.53125,4.8125], ,[18,0.5]], [14.6875,3.34375], 0.75);
 * //=> [[1, 1], [10.53125, 4.8125], [13.26736111111111, 5.784722222222222], [18, 0.5]]
 * ```
 *
 * @doc mdx
 */
function cubicThroughPointGiven013(ps, p, t) {
    const [[x0, y0], [x1, y1], , [x3, y3]] = ps;
    const [x, y] = p;
    const x2 = (t ** 3 * (-x0 + 3 * x1 + x3) + 3 * t ** 2 * (x0 - 2 * x1) - 3 * t * (x0 - x1) - x + x0) / (3 * t ** 2 * (t - 1));
    const y2 = (t ** 3 * (-y0 + 3 * y1 + y3) + 3 * t ** 2 * (y0 - 2 * y1) - 3 * t * (y0 - y1) - y + y0) / (3 * t ** 2 * (t - 1));
    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-dxy/double/get-dxy-at-1.ts
/**
 * Returns the result (`[x,y]`) of evaluating the derivative of a linear,
 * quadratic or cubic bezier curve at `t === 1`.
 *
 * Bitlength: If the coordinates of the control points are grid-aligned then
 * * max bitlength (incl bit shift) increase === 3 (for cubics)
 * * max bitlength (incl bit shift) increase === 2 (for quadratics)
 * * max bitlength (incl bit shift) increase === 1 (for lines)
 *
 * @param ps An order 1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 *
 * @doc mdx
 */
function getDxyAt1(ps) {
    if (ps.length === 4) {
        const [x2, y2] = ps[2];
        const [x3, y3] = ps[3];
        return [
            3 * (x3 - x2),
            3 * (y3 - y2),
        ]; // max bitlength increase 3
    }
    if (ps.length === 3) {
        const [x1, y1] = ps[1];
        const [x2, y2] = ps[2];
        return [
            2 * (x2 - x1),
            2 * (y2 - y1),
        ]; // max bitlength increase 2
    }
    if (ps.length === 2) {
        const [[x0, y0], [x1, y1]] = ps;
        return [
            x1 - x0,
            y1 - y0
        ]; // max bitlength increase 1
    }
    if (ps.length === 1) {
        return [0, 0];
    }
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-ddxy/double/get-ddxy-at-1.ts
/**
 * Returns the result (`[x,y]`) of evaluating the 2nd derivative of a linear,
 * quadratic or cubic bezier curve at `t === 1`.
 *
 * Bitlength: If the coordinates of the control points are bit-aligned then the
 * * max bitlength (incl bit shift) increase === 5 (for cubics)
 * * max bitlength (incl bit shift) increase === 3 (for quadratics)
 * * max bitlength (incl bit shift) increase === 0 (for lines)
 *
 * @param ps An order 1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 *
 * @doc mdx
 */
function getDdxyAt1(ps) {
    if (ps.length === 4) {
        const [, [x1, y1], [x2, y2], [x3, y3]] = ps;
        return [
            6 * ((x3 + x1) - 2 * x2),
            6 * ((y3 + y1) - 2 * y2),
        ]; // max bitlength increase 5
    }
    if (ps.length === 3) {
        const [[x0, y0], [x1, y1], [x2, y2]] = ps;
        return [
            2 * ((x2 + x0) - 2 * x1),
            2 * ((y2 + y0) - 2 * y1), // t^0
        ]; // max bitlength increase 3
    }
    if (ps.length === 2 || ps.length === 1) {
        return [0, 0]; // max bitlength increase 0
    }
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-dxy/double/get-dxy-at-0.ts
/**
 * Returns the result (`[x,y]`) of evaluating the derivative of a linear,
 * quadratic or cubic bezier curve at `t === 0`.
 *
 * Bitlength: If the coordinates of the control points are grid-aligned then
 * * max bitlength (incl bit shift) increase === 3 (for cubics)
 * * max bitlength (incl bit shift) increase === 2 (for quadratics)
 * * max bitlength (incl bit shift) increase === 1 (for lines)
 *
 * @param ps An order 1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 *
 * @doc mdx
 */
function getDxyAt0(ps) {
    if (ps.length === 4) {
        const [[x0, y0], [x1, y1]] = ps;
        return [
            3 * (x1 - x0),
            3 * (y1 - y0)
        ]; // max bitlength increase 3
    }
    if (ps.length === 3) {
        const [[x0, y0], [x1, y1]] = ps;
        return [
            2 * (x1 - x0),
            2 * (y1 - y0),
        ]; // max bitlength increase 2
    }
    if (ps.length === 2) {
        const [[x0, y0], [x1, y1]] = ps;
        return [
            x1 - x0,
            y1 - y0,
        ]; // max bitlength increase 1
    }
    if (ps.length === 1) {
        return [0, 0];
    }
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-ddxy/double/get-ddxy-at-0.ts
/**
 * Returns the result (`[x,y]`) of evaluating the 2nd derivative of a linear,
 * quadratic or cubic bezier curve at `t === 0`.
 *
 * Bitlength: If the coordinates of the control points are bit-aligned then the
 * * max bitlength (incl bit shift) increase === 5 (for cubics)
 * * max bitlength (incl bit shift) increase === 3 (for quadratics)
 * * max bitlength (incl bit shift) increase === 0 (for lines)
 *
 * @param ps An order 1,2 or 3 bezier, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 *
 * @doc mdx
 */
function getDdxyAt0(ps) {
    if (ps.length === 4) {
        const [[x0, y0], [x1, y1], [x2, y2]] = ps;
        return [
            6 * ((x2 + x0) - 2 * x1),
            6 * ((y2 + y0) - 2 * y1)
        ]; // max bitlength increase 5
    }
    if (ps.length === 3) {
        const [[x0, y0], [x1, y1], [x2, y2]] = ps;
        return [
            2 * ((x2 + x0) - 2 * x1),
            2 * ((y2 + y0) - 2 * y1)
        ]; // max bitlength increase 3
    }
    if (ps.length === 2 || ps.length === 1) {
        return [0, 0];
    }
    throw new Error('The given bezier curve is invalid.');
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-dddxy/double/get-dddxy.ts
/**
 * Returns the 3rd derivative of the power basis representation of a line,
 * quadratic or cubic bezier's x and y-coordinates.
 *
 * Note: this is a constant value and the same for all t-values and, in
 * particular, zero for a line or quadratic.
 *
 * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * Bitlength: If the coordinates of the control points are bit-aligned then
 * * max bitlength increase === max shift === 6 (for cubics)
 * * max bitlength increase === max shift === 0 (for quadratics)
 * * max bitlength increase === max shift === 0 (for lines)
 *
 * @param ps An order 1,2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getDddxy(ps) {
    if (ps.length === 4) {
        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        return [
            6 * ((x3 - x0) + 3 * (x1 - x2)),
            6 * ((y3 - y0) + 3 * (y1 - y2))
        ]; // max bitlength increase 6
    }
    if (ps.length === 3 || ps.length === 2 || ps.length === 1) {
        return [0, 0];
    }
    throw new Error('The given bezier curve is invalid.');
    // Side note: if x0,x1,x2,x3 <= X (for some X) and t is an element of [0,1], 
    // then max(dddx)(t) <= 48*X for all t.
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/tangent.ts


function tangent(ps, t) {
    const [dX, dY] = getDxy(ps);
    function f(t) {
        return [
            Horner(dX, t),
            Horner(dY, t)
        ];
    }
    // Curry
    return t === undefined ? f : f(t);
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/normal.ts


function normal(ps, t) {
    const [dX, dY] = getDxy(ps);
    function f(t) {
        return [
            Horner(dY, t),
            -Horner(dX, t)
        ];
    }
    // Curry
    return t === undefined ? f : f(t);
}


;// CONCATENATED MODULE: ./src/transformation/split-merge-clone/from-to.ts


/**
 * Returns a bezier curve that starts and ends at the given t parameters.
 * Uses de Casteljau's algorithm.
 *
 * A loose bound on the accuracy of the resultant points is given by:
 * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (for a cubic), b_k are the control
 * points and η is Number.EPSILON.
 *
 * @param ps a cubic bezier curve
 * @param t1 the t parameter where the resultant bezier should start
 * @param t2 the t parameter where the resultant bezier should end
 *
 * @doc
 */
function split_merge_clone_from_to_fromTo(ps) {
    return (t1, t2) => {
        const reverse = t1 > t2;
        if (t1 > t2) {
            [t1, t2] = [t2, t1];
        }
        let ps_;
        if (t1 === 0 && t2 === 1) {
            ps_ = ps;
        }
        else if (t1 === 0) {
            ps_ = splitAt(ps, t2)[0];
        }
        else if (t2 === 1) {
            ps_ = splitAt(ps, t1)[1];
        }
        else if (t1 === t2) {
            // Degenerate case
            const p = evalDeCasteljau(ps, t1);
            if (ps.length === 1) {
                return [p];
            }
            if (ps.length === 2) {
                return [p, p];
            }
            if (ps.length === 3) {
                return [p, p, p];
            }
            if (ps.length === 4) {
                return [p, p, p, p];
            }
            throw new Error('The given bezier curve is invalid.');
        }
        else {
            ps_ = splitAt(splitAt(ps, t1)[1], (t2 - t1) / (1 - t1))[0];
        }
        return reverse ? ps_.slice().reverse() : ps_;
    };
}
/**
 * Returns a bezier curve that starts at the given curve and ends at the
 * given t parameter. Uses de Casteljau's algorithm.
 *
 * A loose bound on the accuracy of the resultant points is given by:
 * |δP| = 2*2n*max_k(|b_k|)η, where n = 3 (for a cubic), b_k are the control
 * points and η is Number.EPSILON.
 * @param ps - A cubic bezier curve
 * @param t1 - The t parameter where the resultant bezier should start
 * @param t2 - The t parameter where the resultant bezier should end
 */
function fromToPrecise(ps) {
    return function (t1, t2) {
        const reverse = t1 > t2;
        if (t1 > t2) {
            [t1, t2] = [t2, t1];
        }
        let ps_;
        if (t1 === 0 && t2 === 1) {
            ps_ = ps;
        }
        else if (t1 === 0) {
            ps_ = splitAtPrecise(ps, t2)[0];
        }
        else if (t2 === 1) {
            ps_ = splitAtPrecise(ps, t1)[1];
        }
        else if (t1 === t2) {
            // Degenerate case
            const p = evalDeCasteljau(ps, t1);
            if (ps.length === 1) {
                return [p];
            }
            if (ps.length === 2) {
                return [p, p];
            }
            if (ps.length === 3) {
                return [p, p, p];
            }
            if (ps.length === 4) {
                return [p, p, p, p];
            }
            throw new Error('The given bezier curve is invalid.');
        }
        else {
            ps_ = splitAtPrecise(splitAtPrecise(ps, t1)[1], (t2 - t1) / (1 - t1))[0];
        }
        return reverse ? ps_.slice().reverse() : ps_;
    };
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/curvature.ts



function curvature(ps, t) {
    const [dX, dY] = getDxy(ps);
    const [ddX, ddY] = getDdxy(ps);
    function f(t) {
        const dx = Horner(dX, t);
        const dy = Horner(dY, t);
        const ddx = Horner(ddX, t);
        const ddy = Horner(ddY, t);
        const a = dx * ddy - dy * ddx;
        const b = Math.sqrt((dx * dx + dy * dy) ** 3);
        return a / b;
    }
    // Curry
    return t === undefined ? f : f(t);
}
/**
 * Alias for [[κ]].
 *
 * Returns the curvature `κ` of the given linear, quadratic or cubic bezier
 * curve at a specific given parameter value `t`. This function is curried.
 *
 * * **alias**: [[curvature]]
 *
 * @param ps an order 1, 2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 * @param t the parameter value where the curvature should be evaluated
 *
 * @doc
 */
const κ = curvature;


;// CONCATENATED MODULE: ./src/global-properties/type/is-quad-obtuse.ts

/**
 * Returns true if the given quadratic bezier is obtuse, false otherwise (i.e.
 * false if acute).
 * Obtuse here is defined as follows: const the quad form a triangle through its
 * control points P0, P1, P2 where P0 and P2 are the endpoints. If both interior
 * angles ∠P0 and ∠P2 are <= 90 degrees then the quad is considered acute,
 * otherwise it is considered obtuse.
 *
 * @doc mdx
 */
function isQuadObtuse(ps) {
    const v0 = fromTo(ps[0], ps[1]);
    const v1 = fromTo(ps[1], ps[2]);
    const v2 = fromTo(ps[2], ps[0]);
    const angleP0Obtuse = dot(v2, v0) > 0;
    const angleP2Obtuse = dot(v1, v2) > 0;
    return angleP0Obtuse || angleP2Obtuse;
}


;// CONCATENATED MODULE: ./src/global-properties/type/is-quad-flat.ts



/**
 * Returns true if the given quadratic bezier curve is acute (see isQuadObtuse)
 * and can be approximated with a line segment with maximum Hausdorff distance
 * <= the given tolerance.
 *
 * @param ps A quadratic bezier curve.
 *
 * @internal
 */
function isQuadFlat(ps, tolerance) {
    if (isQuadObtuse(ps)) {
        return false;
    }
    const [[x1, y1], , [x2, y2]] = ps;
    if (x1 === x2 && y1 === y2) {
        return true;
    }
    const [x0, y0] = evalDeCasteljau(ps, 0.5);
    const numerator = ((y2 - y1) * x0 - (x2 - x1) * y0 + x2 * y1 - y2 * x1) ** 2;
    const denominator = squared_distance_between_squaredDistanceBetween(ps[0], ps[2]);
    const dSquared = Math.abs(numerator / denominator);
    return dSquared < tolerance ** 2;
}


;// CONCATENATED MODULE: ./src/transformation/quad-to-polyline.ts


/**
 * Transforms the given quadratic bezier into a polyline approximation to within
 * a given tolerance.
 *
 * @param ps A quadratic bezier curve given as an array of points.
 *
 * @doc
 */
function quadToPolyline(ps, tolerance) {
    // A quad bezier has the following useful properties (Let the control
    // points be labeled P0, P1 and P2 respectively and const the point at t = 0.5
    // be labeled M1):
    // -------------------------------------------------------------------------
    // * At t = 0.5 P1 has its maximum influence of 0.5 and P0 and P2 each an 
    // influence of 0.25.
    // * The tangent at t = 0.5 is given by P2 - P0.
    // * The line implied by the tangent at t = 0.5 cuts the line segments P0-P1
    // and P2-P1 in half. Lets call these points M0 and M2.
    // * The polygon P0-M0-M2-P2 bounds the curve.
    // * The curve can be cut into two quad bezier curves. 
    // * If it is cut at t = 0.5, i.e. at M1 so that we have two quad beziers 
    // defined by the triangles Q1 = P0-M0-M1 and Q2 = M0-M2-P2 then both 
    // the interior angles at P0 and P2 are < 90 degrees (acute). Lets call such
    // a quad acute, otherwise obtuse.
    // * If we split an obtuse quad at t = 0.5 then the resulting quads are both
    // acute.
    // * Acute quads is such that the point at t = 0.5, i.e. at M1) is the 
    // furthest away from the line P0-P2.
    // Note: In our algorithm the above property can be used to measure the 
    // flatness of the quad reliably.
    // The algorithm: q: quad => lines[] such that the Hausdorff distance 
    // between the polyline and the quad < tolerance.
    // Strategy: Use linked list for polyline - makes splitting easier
    // -------------------------------------------------------------------------
    // quad obtuse ? 
    //   no  : Push the quad onto the stack
    //   yes : Split the quad at t = 0.5 and push both halves onto the stack
    // Loop while stack not empty
    //   pop from stack => q
    //   d <= calculate distance from t = 0.5 to line p0-p2
    //   tolerance < tol ?
    //     yes : do nothing
    //     no  : split quad at t = 0.5 and push both halves onto the stack
    // Loop end
    // Stack with nodes still to be checked
    const stack = [];
    // Polyline linked list
    let head = {
        ps,
        prev: undefined,
        next: undefined // keep TypeScript happy - it's ok, we'll set it later
    };
    stack.push(head);
    while (stack.length) {
        // keep TypeScript happy; of course there'se something in the stack
        const node = stack.pop();
        if (isQuadFlat(node.ps, tolerance)) {
            continue;
        }
        const quads = splitAt(node.ps, 0.5);
        const prev = node.prev;
        const next = node.next;
        const node1 = {
            ps: quads[0],
            prev,
            next: undefined // keep TypeScript happy - it's ok, we'll set it later
        };
        const node2 = {
            ps: quads[1],
            prev: undefined,
            next
        };
        node1.next = node2;
        node2.prev = node1;
        if (prev) {
            prev.next = node1;
        }
        if (next) {
            next.prev = node2;
        }
        if (head === node) {
            head = node1;
        }
        stack.push(node1);
        stack.push(node2);
    }
    const linePs = [];
    let node = head;
    linePs.push(head.ps[0]);
    while (node) {
        linePs.push(node.ps[2]);
        node = node.next;
    }
    return linePs;
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-xy/double-double/eval-de-casteljau-dd.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const eval_de_casteljau_dd_qmq = node_ddMultDd;
const eval_de_casteljau_dd_qaq = node_ddAddDd;
const eval_de_casteljau_dd_qdq = node_ddDiffDd;
const eval_de_casteljau_dd_td = node_twoDiff;
const eval_de_casteljau_dd_qad = node_ddAddDouble;
/**
 * Returns the result of evaluating the given bezier curve at the parameter `t`
 * (given as a double-double precision floating point number)
 * using [De Casteljau's algorithm](https://en.wikipedia.org/wiki/De_Casteljau%27s_algorithm)
 * with intermediate calculations done in double-double precision floating point
 * arithmetic.
 *
 * * **precondition**: TODO underflow/overflow
 * * to get an absolute error bound on the result call [[evalDeCasteljauErrorCounters]]
 *
 * @param ps an order 1, 2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 * @param t the parameter value where the bezier should be evaluated (given in
 * double-double precision)
 *
 * @doc mdx
 **/
function evalDeCasteljauDd(ps, t) {
    if (t[0] === 0 && t[1] === 0) {
        return ps[0].map(c => [c]);
    }
    else if (t[0] === 0 && t[1] === 1) {
        return ps[ps.length - 1].map(c => [c]);
    }
    if (ps.length === 4) {
        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        const a01 = eval_de_casteljau_dd_qad(eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(x1, x0), t), x0);
        const a11 = eval_de_casteljau_dd_qad(eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(x2, x1), t), x1);
        const a21 = eval_de_casteljau_dd_qad(eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(x3, x2), t), x2);
        const a02 = eval_de_casteljau_dd_qaq(a01, eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_qdq(a11, a01), t));
        const a12 = eval_de_casteljau_dd_qaq(a11, eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_qdq(a21, a11), t));
        const x = eval_de_casteljau_dd_qaq(a02, eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_qdq(a12, a02), t));
        const b01 = eval_de_casteljau_dd_qad(eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(y1, y0), t), y0);
        const b11 = eval_de_casteljau_dd_qad(eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(y2, y1), t), y1);
        const b21 = eval_de_casteljau_dd_qad(eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(y3, y2), t), y2);
        const b02 = eval_de_casteljau_dd_qaq(b01, eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_qdq(b11, b01), t));
        const b12 = eval_de_casteljau_dd_qaq(b11, eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_qdq(b21, b11), t));
        const y = eval_de_casteljau_dd_qaq(b02, eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_qdq(b12, b02), t));
        return [x, y];
    }
    else if (ps.length === 3) {
        const [[x0, y0], [x1, y1], [x2, y2]] = ps;
        const a01 = eval_de_casteljau_dd_qaq([0, x0], eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(x1, x0), t));
        const a11 = eval_de_casteljau_dd_qaq([0, x1], eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(x2, x1), t));
        const x = eval_de_casteljau_dd_qaq(a01, eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_qdq(a11, a01), t));
        const b01 = eval_de_casteljau_dd_qaq([0, y0], eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(y1, y0), t));
        const b11 = eval_de_casteljau_dd_qaq([0, y1], eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(y2, y1), t));
        const y = eval_de_casteljau_dd_qaq(b01, eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_qdq(b11, b01), t));
        return [x, y];
    }
    else if (ps.length === 2) {
        const [[x0, y0], [x1, y1]] = ps;
        const x = eval_de_casteljau_dd_qad(eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(x1, x0), t), x0);
        const y = eval_de_casteljau_dd_qad(eval_de_casteljau_dd_qmq(eval_de_casteljau_dd_td(y1, y0), t), y0);
        return [x, y];
    }
    else {
        // TODO - add case of degenerate point
        throw new Error('The given bezier curve is invalid.');
    }
}


;// CONCATENATED MODULE: ./src/global-properties/bounds/get-interval-box/get-interval-box-dd.ts




const get_interval_box_dd_ddDiffDd = node_ddDiffDd;
const get_interval_box_dd_ddDivDdWithError = node_ddDivDdWithError;
const get_interval_box_dd_ddAddDouble = node_ddAddDouble;
const get_interval_box_dd_ddMultDd = node_ddMultDd;
const get_interval_box_dd_ddMultDouble2 = node_ddMultDouble2;
const get_interval_box_dd_ddAddDd = node_ddAddDd;
const get_interval_box_dd_ddMultBy2 = node_ddMultBy2;
const get_interval_box_dd_ddMin = node_ddMin;
const get_interval_box_dd_ddMax = node_ddMax;
const get_interval_box_dd_u = Number.EPSILON / 2;
const get_interval_box_dd_uu = get_interval_box_dd_u * get_interval_box_dd_u;
const get_interval_box_dd_abs = Math.abs;
const get_interval_box_dd_qdq = get_interval_box_dd_ddDiffDd;
const qOne = [0, 1];
const get_interval_box_dd_qad = get_interval_box_dd_ddAddDouble;
const get_interval_box_dd_qaq = get_interval_box_dd_ddAddDd;
const get_interval_box_dd_qmq = get_interval_box_dd_ddMultDd;
const get_interval_box_dd_qmd = get_interval_box_dd_ddMultDouble2;
const get_interval_box_dd_qm2 = get_interval_box_dd_ddMultBy2;
const qDivQuadWithError = get_interval_box_dd_ddDivDdWithError;
const qMin = get_interval_box_dd_ddMin;
const qMax = get_interval_box_dd_ddMax;
const get_interval_box_dd_3 = error_analysis_error_analysis_(3);
/**
 * Returns an axis-aligned-box that is guaranteed to engulf the entire
 * given bezier curve from `t1` to `t2`. The returned box is given as an array
 * of points in double-double precision, e.g. `[[[0,1],[0,1]], [[0,2],[0,2]]]`.
 *
 * * **precondition:** t1 < t2
 * * **precondition:** t1,t2 >= 0 && t1,t2 <= 1
 *
 * @param ps an order 1, 2 or 3 bezier curve given as an array of control
 * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`
 * @param ts [first, second] parameter values, given in double-double
 * precision, e.g. [[0,0.11], [0,0.12]]. (Use [[getIntervalBox]] instead for
 * double precision)
 *
 * @doc mdx
 */
function getIntervalBoxDd(ps, ts) {
    if (ts[0] !== ts[1]) {
        if (ps.length === 4) {
            return getIntervalBox3Dd(ps, ts);
        }
        if (ps.length === 3) {
            return getIntervalBox2Dd(ps, ts);
        }
        return getIntervalBox1Dd(ps, ts);
    }
    else { // ts[0] === ts[1]
        return getIntervalBoxAtTDd(ps, ts[0]);
    }
}
/**
 * quad precision t1, t2
 *
 * @param param0
 * @param param1
 *
 * @internal
 */
function getIntervalBox3Dd([[x0, y0], [x1, y1], [x2, y2], [x3, y3]], [t1, t2]) {
    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2
    const tDel = get_interval_box_dd_qdq(t2, t1);
    const tDel_ = 3 * get_interval_box_dd_uu * get_interval_box_dd_abs(tDel[1]); // max absolute error in tDel
    const oMt1 = get_interval_box_dd_qdq(qOne, t1);
    const oMt1_ = 3 * get_interval_box_dd_uu * get_interval_box_dd_abs(oMt1[1]); // max absolute error in oMt1
    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2
    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);
    t2 = get_interval_box_dd_qad($t2.est, $t2.err); // the max t2 can possibly be
    const s1 = get_interval_box_dd_qdq(qOne, t1); // <1>s1
    // below uses error by counters - also note qmq is different than other operators in that it is 2ice as inaccurate
    const tt1 = get_interval_box_dd_qmq(t1, t1); // <2>tt1  
    const ts1 = get_interval_box_dd_qmq(t1, s1); // <3>(<0>t1<1>s1)  <3> === <0+1+2>
    const ss1 = get_interval_box_dd_qmq(s1, s1); // <4>(<1>s1<1>s1)  <4> === <1+1+2>
    const ttt1 = get_interval_box_dd_qmq(tt1, t1); // <4>(<2>tt1<0>t1)
    const tts1 = get_interval_box_dd_qmq(tt1, s1); // <5>(<2>tt1<1>s1)
    const tss1 = get_interval_box_dd_qmq(ss1, t1); // <6>(<4>ss1<0>t1)
    const sss1 = get_interval_box_dd_qmq(ss1, s1); // <7>(<4>ss1<1>s1)
    const s2 = get_interval_box_dd_qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)
    const tt2 = get_interval_box_dd_qmq(t2, t2); // <2>tt2
    const ts2 = get_interval_box_dd_qmq(t2, s2); // <3>(<0>t2<1>s2)
    const ss2 = get_interval_box_dd_qmq(s2, s2); // <4>(<1>s2<1>s2)
    const ttt2 = get_interval_box_dd_qmq(tt2, t2); // <4>(<1>tt2<0>t2)
    const tts2 = get_interval_box_dd_qmq(tt2, s2); // <5>(<1>tt2<1>s2)
    const tss2 = get_interval_box_dd_qmq(ss2, t2); // <6>(<3>ss2<0>t2)
    const sss2 = get_interval_box_dd_qmq(ss2, s2); // <7>(<3>ss2<1>s2)
    const _t1 = get_interval_box_dd_abs(t1[1]);
    const _s1 = get_interval_box_dd_abs(s1[1]);
    const _tt1 = get_interval_box_dd_abs(tt1[1]);
    const _ts1 = get_interval_box_dd_abs(ts1[1]);
    const _ss1 = get_interval_box_dd_abs(ss1[1]);
    const _ttt1 = get_interval_box_dd_abs(ttt1[1]);
    const _tts1 = get_interval_box_dd_abs(tts1[1]);
    const _tss1 = get_interval_box_dd_abs(tss1[1]);
    const _sss1 = get_interval_box_dd_abs(sss1[1]);
    const _t2 = get_interval_box_dd_abs(t2[1]);
    const _s2 = get_interval_box_dd_abs(s2[1]);
    const _tt2 = get_interval_box_dd_abs(tt2[1]);
    const _ts2 = get_interval_box_dd_abs(ts2[1]);
    const _ss2 = get_interval_box_dd_abs(ss2[1]);
    const _ttt2 = get_interval_box_dd_abs(ttt2[1]);
    const _tts2 = get_interval_box_dd_abs(tts2[1]);
    const _tss2 = get_interval_box_dd_abs(tss2[1]);
    const _sss2 = get_interval_box_dd_abs(sss2[1]);
    // all of t1,s1,ts1,... are all positive so simpler to use a relative error
    // bound (using e.g. counters <k>):
    // counter rules:
    //   <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   <k>a<l>b = <k + l + 1>ab
    //   fl(a) === <1>a
    let _x0 = get_interval_box_dd_abs(x0);
    let _y0 = get_interval_box_dd_abs(y0);
    let _x1 = get_interval_box_dd_abs(x1);
    let _y1 = get_interval_box_dd_abs(y1);
    let _x2 = get_interval_box_dd_abs(x2);
    let _y2 = get_interval_box_dd_abs(y2);
    let _x3 = get_interval_box_dd_abs(x3);
    let _y3 = get_interval_box_dd_abs(y3);
    //---- x - calculation
    const q8 = get_interval_box_dd_qaq(get_interval_box_dd_qmd(x3, t1), get_interval_box_dd_qmd(x2, s1));
    const q7 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmd(x3, tt1), get_interval_box_dd_qmd(2 * x2, ts1)), get_interval_box_dd_qmd(x1, ss1));
    const qx0 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmd(x3, ttt1), get_interval_box_dd_qmd(x0, sss1)), get_interval_box_dd_qmd(3, (get_interval_box_dd_qaq(get_interval_box_dd_qmd(x2, tts1), get_interval_box_dd_qmd(x1, tss1)))));
    const qx1 = get_interval_box_dd_qaq(get_interval_box_dd_qmq(q7, t2), get_interval_box_dd_qmq(qx0, s2));
    const qx2 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmq(q8, tt2), get_interval_box_dd_qmq(qx0, ss2)), get_interval_box_dd_qmq(get_interval_box_dd_qm2(q7), ts2));
    const qx3 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmd(x3, ttt2), get_interval_box_dd_qmq(qx0, sss2)), get_interval_box_dd_qmd(3, get_interval_box_dd_qaq(get_interval_box_dd_qmq(q8, tts2), get_interval_box_dd_qmq(q7, tss2))));
    const _qx0 = get_interval_box_dd_abs(qx0[1]);
    //---- error / abs value calculation
    const _q8 = _x3 * _t1 + _x2 * _s1; // <= <3>
    // q8: <3>(<1>(x3*t1) + <2>(x2*<1>s1))
    const _q7 = _x3 * _tt1 + 2 * _x2 * _ts1 + _x1 * _ss1; // <= <6> 
    // q7: <6>(<5>(<3>(x3*<2>tt1) + <4>(2*x2*<3>ts1)) + <5>(x1*<4>ss1));
    _x0 = (_x3 * _ttt1 + _x0 * _sss1) + 3 * (_x2 * _tts1 + _x1 * _tss1); // <= <11>
    // x0: <11>(<9>(x3*<4>ttt1 + x0*<7>sss1) + <10>(3*<9>(<8>(<6>(x2*<5>tts1) + <7>(x1*<6>tss1)))));
    _x1 = _q7 * _t2 + _qx0 * _s2; // <= <15>
    // x1: <15>(<7>(<6>q7*t2) + <14>(<11>x0*<1>s2));
    _x2 = _q8 * _tt2 + _qx0 * _ss2 + 2 * _q7 * _ts2; // <= <20>
    // x2: <20>(<19>(<18>(<3>q8*<2>tt2) + <17>(<11>x0*<4>ss2)) + <11>(2*<6>q7*<3>ts2));
    _x3 = _x3 * _ttt2 + _qx0 * _sss2 + 3 * (_q8 * _tts2 + _q7 * _tss2); // <= <22>
    // x3: <22>(<21>(<5>(x3*<4>ttt2) + <20>(<11>x0*<7>sss2)) + <16>(3*<15>(<10>(<3>q8*<5>tts2) + <14>(<6>q7*<6>tss2)))));
    // max errors: 
    _x0 = 11 * get_interval_box_dd_uu * _x0;
    _x1 = 15 * get_interval_box_dd_uu * _x1;
    _x2 = 20 * get_interval_box_dd_uu * _x2;
    _x3 = 22 * get_interval_box_dd_uu * _x3;
    //---- y - calculation
    const r8 = get_interval_box_dd_qaq(get_interval_box_dd_qmd(y3, t1), get_interval_box_dd_qmd(y2, s1));
    const r7 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmd(y3, tt1), get_interval_box_dd_qmd(2 * y2, ts1)), get_interval_box_dd_qmd(y1, ss1));
    const qy0 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmd(y3, ttt1), get_interval_box_dd_qmd(y0, sss1)), get_interval_box_dd_qmd(3, (get_interval_box_dd_qaq(get_interval_box_dd_qmd(y2, tts1), get_interval_box_dd_qmd(y1, tss1)))));
    const qy1 = get_interval_box_dd_qaq(get_interval_box_dd_qmq(r7, t2), get_interval_box_dd_qmq(qy0, s2));
    const qy2 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmq(r8, tt2), get_interval_box_dd_qmq(qy0, ss2)), get_interval_box_dd_qmq(get_interval_box_dd_qm2(r7), ts2));
    const qy3 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmd(y3, ttt2), get_interval_box_dd_qmq(qy0, sss2)), get_interval_box_dd_qmd(3, get_interval_box_dd_qaq(get_interval_box_dd_qmq(r8, tts2), get_interval_box_dd_qmq(r7, tss2))));
    const _qy0 = get_interval_box_dd_abs(qy0[1]);
    //---- error / abs value calculation
    const _r8 = _y3 * _t1 + _y2 * _s1; // <= <3>
    const _r7 = _y3 * _tt1 + 2 * _y2 * _ts1 + _y1 * _ss1; // <= <6> 
    _y0 = (_y3 * _ttt1 + _y0 * _sss1) + 3 * (_y2 * _tts1 + _y1 * _tss1); // <= <11>
    _y1 = _r7 * _t2 + _qy0 * _s2; // <= <15>
    _y2 = _r8 * _tt2 + _qy0 * _ss2 + 2 * _r7 * _ts2; // <= <20>
    _y3 = _y3 * _ttt2 + _qy0 * _sss2 + 3 * (_r8 * _tts2 + _r7 * _tss2); // <= <22>
    // max errors: 
    _y0 = 11 * get_interval_box_dd_uu * _y0;
    _y1 = 15 * get_interval_box_dd_uu * _y1;
    _y2 = 20 * get_interval_box_dd_uu * _y2;
    _y3 = 22 * get_interval_box_dd_uu * _y3;
    const minX = qMin(qMin(get_interval_box_dd_qad(qx0, -_x0), get_interval_box_dd_qad(qx1, -_x1)), qMin(get_interval_box_dd_qad(qx2, -_x2), get_interval_box_dd_qad(qx3, -_x3)));
    const maxX = qMax(qMax(get_interval_box_dd_qad(qx0, +_x0), get_interval_box_dd_qad(qx1, +_x1)), qMax(get_interval_box_dd_qad(qx2, +_x2), get_interval_box_dd_qad(qx3, +_x3)));
    const minY = qMin(qMin(get_interval_box_dd_qad(qy0, -_y0), get_interval_box_dd_qad(qy1, -_y1)), qMin(get_interval_box_dd_qad(qy2, -_y2), get_interval_box_dd_qad(qy3, -_y3)));
    const maxY = qMax(qMax(get_interval_box_dd_qad(qy0, +_y0), get_interval_box_dd_qad(qy1, +_y1)), qMax(get_interval_box_dd_qad(qy2, +_y2), get_interval_box_dd_qad(qy3, +_y3)));
    return [[minX, minY], [maxX, maxY]];
}
/**
 * quad precision t1, t2
 *
 * @param param0
 * @param param1
 *
 * @internal
 */
function getIntervalBox2Dd([[x0, y0], [x1, y1], [x2, y2]], [t1, t2]) {
    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2
    const tDel = get_interval_box_dd_qdq(t2, t1);
    const tDel_ = 3 * get_interval_box_dd_uu * get_interval_box_dd_abs(tDel[1]); // max absolute error in tDel
    const oMt1 = get_interval_box_dd_qdq(qOne, t1);
    const oMt1_ = 3 * get_interval_box_dd_uu * get_interval_box_dd_abs(oMt1[1]); // max absolute error in oMt1
    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2
    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);
    t2 = get_interval_box_dd_qad($t2.est, $t2.err); // the max t2 can possibly be
    //const s1 = (1 - t1);  // <= exact by precondition - not anymore
    const s1 = get_interval_box_dd_qdq(qOne, t1); // <1>s1
    // below uses error by counters - also note qmq is different than other operators in that it is 2ice as inaccurate
    const tt1 = get_interval_box_dd_qmq(t1, t1); // <2>tt1  
    const ts1 = get_interval_box_dd_qmq(t1, s1); // <3>(<0>t1<1>s1)  <3> === <0+1+2>
    const ss1 = get_interval_box_dd_qmq(s1, s1); // <4>(<1>s1<1>s1)  <4> === <1+1+2>
    const s2 = get_interval_box_dd_qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)
    const tt2 = get_interval_box_dd_qmq(t2, t2); // <2>tt2
    const ts2 = get_interval_box_dd_qmq(t2, s2); // <3>(<0>t2<1>s2)
    const ss2 = get_interval_box_dd_qmq(s2, s2); // <4>(<1>s2<1>s2)
    const _t1 = get_interval_box_dd_abs(t1[1]);
    const _s1 = get_interval_box_dd_abs(s1[1]);
    const _tt1 = get_interval_box_dd_abs(tt1[1]);
    const _ts1 = get_interval_box_dd_abs(ts1[1]);
    const _ss1 = get_interval_box_dd_abs(ss1[1]);
    const _t2 = get_interval_box_dd_abs(t2[1]);
    const _s2 = get_interval_box_dd_abs(s2[1]);
    const _tt2 = get_interval_box_dd_abs(tt2[1]);
    const _ts2 = get_interval_box_dd_abs(ts2[1]);
    const _ss2 = get_interval_box_dd_abs(ss2[1]);
    // all of t1,s1,ts1,... are all positive so simpler to use a relative error
    // bound (using e.g. counters <k>):
    // counter rules:
    //   <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   <k>a<l>b = <k + l + 1>ab
    //   fl(a) === <1>a
    let _x0 = get_interval_box_dd_abs(x0);
    let _y0 = get_interval_box_dd_abs(y0);
    let _x1 = get_interval_box_dd_abs(x1);
    let _y1 = get_interval_box_dd_abs(y1);
    let _x2 = get_interval_box_dd_abs(x2);
    let _y2 = get_interval_box_dd_abs(y2);
    //---- x - calculation
    const q1 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmd(x2, tt1), get_interval_box_dd_qmd(2 * x1, ts1)), get_interval_box_dd_qmd(x0, ss1));
    const q2 = get_interval_box_dd_qaq(get_interval_box_dd_qmd(x2, t1), get_interval_box_dd_qmd(x1, s1));
    const qx0 = q1;
    const qx1 = get_interval_box_dd_qaq(get_interval_box_dd_qmq(t2, q2), get_interval_box_dd_qmq(s2, q1));
    const qx2 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmd(x2, tt2), get_interval_box_dd_qmq(get_interval_box_dd_qm2(ts2), q2)), get_interval_box_dd_qmq(ss2, q1));
    const _q1 = _x2 * _tt1 + 2 * _x1 * _ts1 + _x0 * _ss1; // <= <7>
    // q1: <7>(<6>(<5>(x2*<2>tt1) + <4>(2*x1*<3>ts1)) + <5>(x0*<4>ss1));
    const _q2 = _x2 * _t1 + _x1 * _s1; // <= <3>
    // q2: <3>(<1>(x2*t1) + <2>(x1*<1>s1));
    _x0 = _q1; // <= <7>
    // x0: <7>q1;
    _x1 = _t2 * _q2 + _s2 * _q1; // <= <11>
    // x1: <11>(<5>(t2*<3>q2) + <10>(<1>s2*<7>q1));
    _x2 = (_tt2 * x2 + 2 * _ts2 * _q2) + _ss2 * _q1; // <= <14>
    // x2: <14>(<9>(<3>(<2>tt2*x2) + <8>(2*<3>ts2*<3>q2)) + <13>(<4>ss2*<7>q1));
    // max errors: 
    _x0 = 7 * get_interval_box_dd_uu * _x0;
    _x1 = 11 * get_interval_box_dd_uu * _x1;
    _x2 = 14 * get_interval_box_dd_uu * _x2;
    //---- y - calculation
    const r1 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmd(y2, tt1), get_interval_box_dd_qmd(2 * y1, ts1)), get_interval_box_dd_qmd(y0, ss1));
    const r2 = get_interval_box_dd_qaq(get_interval_box_dd_qmd(y2, t1), get_interval_box_dd_qmd(y1, s1));
    const qy0 = r1;
    const qy1 = get_interval_box_dd_qaq(get_interval_box_dd_qmq(t2, r2), get_interval_box_dd_qmq(s2, r1));
    const qy2 = get_interval_box_dd_qaq(get_interval_box_dd_qaq(get_interval_box_dd_qmd(y2, tt2), get_interval_box_dd_qmq(get_interval_box_dd_qm2(ts2), r2)), get_interval_box_dd_qmq(ss2, r1));
    const _r1 = _y2 * _tt1 + 2 * _y1 * _ts1 + _y0 * _ss1; // <= <7>
    // r1: <7>(<6>(<5>(y2*<2>tt1) + <4>(2*y1*<3>ts1)) + <5>(y0*<4>ss1));
    const _r2 = _y2 * _t1 + _y1 * _s1; // <= <3>
    // r2: <3>(<1>(y2*t1) + <2>(y1*<1>s1));
    _y0 = _r1; // <= <7>
    // y0: <7>r1;
    _y1 = _t2 * _r2 + _s2 * _r1; // <= <11>
    // y1: <11>(<5>(t2*<3>r2) + <10>(<1>s2*<7>r1));
    _y2 = (_tt2 * y2 + 2 * _ts2 * _r2) + _ss2 * _r1; // <= <14>
    // y2: <14>(<9>(<3>(<2>tt2*y2) + <8>(2*<3>ts2*<3>r2)) + <13>(<4>ss2*<7>r1));
    // max errors: 
    _y0 = 7 * get_interval_box_dd_uu * _y0;
    _y1 = 11 * get_interval_box_dd_uu * _y1;
    _y2 = 14 * get_interval_box_dd_uu * _y2;
    const minX = qMin(qMin(get_interval_box_dd_qad(qx0, -_x0), get_interval_box_dd_qad(qx1, -_x1)), get_interval_box_dd_qad(qx2, -_x2));
    const maxX = qMax(qMax(get_interval_box_dd_qad(qx0, +_x0), get_interval_box_dd_qad(qx1, +_x1)), get_interval_box_dd_qad(qx2, +_x2));
    const minY = qMin(qMin(get_interval_box_dd_qad(qy0, -_y0), get_interval_box_dd_qad(qy1, -_y1)), get_interval_box_dd_qad(qy2, -_y2));
    const maxY = qMax(qMax(get_interval_box_dd_qad(qy0, +_y0), get_interval_box_dd_qad(qy1, +_y1)), get_interval_box_dd_qad(qy2, +_y2));
    return [[minX, minY], [maxX, maxY]];
}
/**
 * quad precision t1, t2
 *
 * @param param0
 * @param param1
 *
 * @internal
 */
function getIntervalBox1Dd([[x0, y0], [x1, y1]], [t1, t2]) {
    // Implementation for lines kept for symmetry - there are obviously much
    // simpler ways to calculate the required box in the case of a line.
    //t2 = ((t2-t1) / (1-t1)) * (1 + Number.EPSILON); // <= fl(t2) > t2
    const tDel = get_interval_box_dd_qdq(t2, t1);
    const tDel_ = 3 * get_interval_box_dd_uu * get_interval_box_dd_abs(tDel[1]); // max absolute error in tDel
    const oMt1 = get_interval_box_dd_qdq(qOne, t1);
    const oMt1_ = 3 * get_interval_box_dd_uu * get_interval_box_dd_abs(oMt1[1]); // max absolute error in oMt1
    //t2 = qdivq(t2m1,omt1) //* (1 + Number.EPSILON); // <= fl(t2) > t2
    const $t2 = qDivQuadWithError(tDel, oMt1, tDel_, oMt1_);
    t2 = get_interval_box_dd_qad($t2.est, $t2.err); // the max t2 can possibly be
    const s1 = get_interval_box_dd_qdq(qOne, t1); // <1>s1
    const s2 = get_interval_box_dd_qdq(qOne, t2); // <1>s2 <= relative error bounded by u*(1 - t2)
    const _t1 = get_interval_box_dd_abs(t1[1]);
    const _s1 = get_interval_box_dd_abs(s1[1]);
    const _t2 = get_interval_box_dd_abs(t2[1]);
    const _s2 = get_interval_box_dd_abs(s2[1]);
    // counter rules:
    //   <k>a + <l>b = <max(k,l) + 1>(a + b)
    //   <k>a<l>b = <k + l + 1>ab
    //   fl(a) === <1>a
    let _x0 = get_interval_box_dd_abs(x0);
    let _y0 = get_interval_box_dd_abs(y0);
    let _x1 = get_interval_box_dd_abs(x1);
    let _y1 = get_interval_box_dd_abs(y1);
    //---- x - calculation
    const qx0 = get_interval_box_dd_qaq(get_interval_box_dd_qmd(x1, t1), get_interval_box_dd_qmd(x0, s1));
    const qx1 = get_interval_box_dd_qaq(get_interval_box_dd_qmd(x1, t2), get_interval_box_dd_qmq(qx0, s2));
    _x0 = _x1 * _t1 + _x0 * _s1; // <= <3>
    // x0: <3>(<1>(x1*t1) + <2>(x0*s1));
    _x1 = _x1 * _t2 + _x0 * _s2; // <= <7>
    // x1: <7>(<1>(x1*t2) + <6>(<3>x0*<1>s2));
    // max errors: 
    _x0 = 3 * get_interval_box_dd_u * _x0;
    _x1 = 7 * get_interval_box_dd_u * _x1;
    //---- y - calculation
    const qy0 = get_interval_box_dd_qaq(get_interval_box_dd_qmd(y1, t1), get_interval_box_dd_qmd(y0, s1));
    const qy1 = get_interval_box_dd_qaq(get_interval_box_dd_qmd(y1, t2), get_interval_box_dd_qmq(qy0, s2));
    _y0 = _y1 * _t1 + _y0 * _s1; // <= <3>
    _y1 = _y1 * _t2 + _y0 * _s2; // <= <7>
    // max errors: 
    _y0 = 3 * get_interval_box_dd_u * _y0;
    _y1 = 7 * get_interval_box_dd_u * _y1;
    const minX = qMin(get_interval_box_dd_qad(qx0, -_x0), get_interval_box_dd_qad(qx1, -_x1));
    const maxX = qMax(get_interval_box_dd_qad(qx0, +_x0), get_interval_box_dd_qad(qx1, +_x1));
    const minY = qMin(get_interval_box_dd_qad(qy0, -_y0), get_interval_box_dd_qad(qy1, -_y1));
    const maxY = qMax(get_interval_box_dd_qad(qy0, +_y0), get_interval_box_dd_qad(qy1, +_y1));
    //return [[x0,y0],[x1,y1]];
    return [[minX, minY], [maxX, maxY]];
}
/**
 * quad precision t1, t2
 *
 * @param ps
 * @param t
 *
 * @internal
 */
function getIntervalBoxAtTDd(ps, t) {
    const _pS = ps[0];
    const _pE = ps[ps.length - 1];
    if (t[0] === 0 && t[1] === 0) {
        const pSx = [0, _pS[0]];
        const pSy = [0, _pS[1]];
        return [
            [pSx, pSy],
            [pSx, pSy]
        ];
    }
    else if (t[0] === 0 && t[1] === 1) {
        const pEx = [0, _pE[0]];
        const pEy = [0, _pE[1]];
        return [
            [pEx, pEy],
            [pEx, pEy]
        ];
    }
    const p = evalDeCasteljauDd(ps, t);
    let pE;
    if (ps.length === 4) {
        pE = evalDeCasteljauError(ps, t).map(c_ => 8 * 2 * get_interval_box_dd_3 * c_);
    }
    else if (ps.length === 3) {
        pE = evalDeCasteljauError(ps, t).map(c_ => 5 * 2 * get_interval_box_dd_3 * c_);
    }
    else if (ps.length === 2) {
        pE = evalDeCasteljauError(ps, t).map(c_ => 2 * 2 * get_interval_box_dd_3 * c_);
    }
    else {
        // TODO - add case of degenerate point
        throw new Error('The given bezier curve is invalid.');
    }
    return [
        [get_interval_box_dd_qad(p[0], -pE[0]), get_interval_box_dd_qad(p[1], -pE[1])],
        [get_interval_box_dd_qad(p[0], +pE[0]), get_interval_box_dd_qad(p[1], +pE[1])]
    ];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/closest-point-on-bezier/get-coeffs/double-double/get-closest-on-bezier3-from-point-dd.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_closest_on_bezier3_from_point_dd_td = node_twoDiff;
const get_closest_on_bezier3_from_point_dd_qaq = node_ddAddDd;
const get_closest_on_bezier3_from_point_dd_qmd = node_ddMultDouble2;
const get_closest_on_bezier3_from_point_dd_qmq = node_ddMultDd;
const get_closest_on_bezier3_from_point_dd_qm2 = node_ddMultBy2;
const qm4 = node_ddMultBy4;
const qmn2 = (/* unused pure expression or super */ null && (ddMultByNeg2));
const get_closest_on_bezier3_from_point_dd_qdq = node_ddDiffDd;
/**
 * * **precondition** TODO underflow/overflow
 * @param ps
 * @param p
 */
function getClosestOnBezier3FromPointDd(ps, p) {
    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    const p0 = ps[0];
    const p1 = ps[1];
    const p2 = ps[2];
    const p3 = ps[3];
    const x0 = p0[0];
    const y0 = p0[1];
    const x1 = p1[0];
    const y1 = p1[1];
    const x2 = p2[0];
    const y2 = p2[1];
    const x3 = p3[0];
    const y3 = p3[1];
    const [x, y] = p;
    const xx0 = get_closest_on_bezier3_from_point_dd_td(x0, x); // exact
    const xx1 = get_closest_on_bezier3_from_point_dd_td(x1, x); // exact
    const xx2 = get_closest_on_bezier3_from_point_dd_td(x2, x); // exact
    const xx3 = get_closest_on_bezier3_from_point_dd_td(x3, x); // exact
    const yy0 = get_closest_on_bezier3_from_point_dd_td(y0, y); // exact
    const yy1 = get_closest_on_bezier3_from_point_dd_td(y1, y); // exact
    const yy2 = get_closest_on_bezier3_from_point_dd_td(y2, y); // exact
    const yy3 = get_closest_on_bezier3_from_point_dd_td(y3, y); // exact
    const x00 = get_closest_on_bezier3_from_point_dd_qmq(xx0, xx0);
    const x01 = get_closest_on_bezier3_from_point_dd_qmd(6, get_closest_on_bezier3_from_point_dd_qmq(xx0, xx1));
    const x02 = get_closest_on_bezier3_from_point_dd_qmd(6, get_closest_on_bezier3_from_point_dd_qmq(xx0, xx2));
    const x03 = get_closest_on_bezier3_from_point_dd_qm2(get_closest_on_bezier3_from_point_dd_qmq(xx0, xx3));
    const x11 = get_closest_on_bezier3_from_point_dd_qmd(9, get_closest_on_bezier3_from_point_dd_qmq(xx1, xx1));
    const x12 = get_closest_on_bezier3_from_point_dd_qmd(18, get_closest_on_bezier3_from_point_dd_qmq(xx1, xx2));
    const x13 = get_closest_on_bezier3_from_point_dd_qmd(6, get_closest_on_bezier3_from_point_dd_qmq(xx1, xx3));
    const x22 = get_closest_on_bezier3_from_point_dd_qmd(9, get_closest_on_bezier3_from_point_dd_qmq(xx2, xx2));
    const x23 = get_closest_on_bezier3_from_point_dd_qmd(6, get_closest_on_bezier3_from_point_dd_qmq(xx2, xx3));
    const x33 = get_closest_on_bezier3_from_point_dd_qmq(xx3, xx3);
    const y00 = get_closest_on_bezier3_from_point_dd_qmq(yy0, yy0);
    const y01 = get_closest_on_bezier3_from_point_dd_qmd(6, get_closest_on_bezier3_from_point_dd_qmq(yy0, yy1));
    const y02 = get_closest_on_bezier3_from_point_dd_qmd(6, get_closest_on_bezier3_from_point_dd_qmq(yy0, yy2));
    const y03 = get_closest_on_bezier3_from_point_dd_qm2(get_closest_on_bezier3_from_point_dd_qmq(yy0, yy3));
    const y11 = get_closest_on_bezier3_from_point_dd_qmd(9, get_closest_on_bezier3_from_point_dd_qmq(yy1, yy1));
    const y12 = get_closest_on_bezier3_from_point_dd_qmd(18, get_closest_on_bezier3_from_point_dd_qmq(yy1, yy2));
    const y13 = get_closest_on_bezier3_from_point_dd_qmd(6, get_closest_on_bezier3_from_point_dd_qmq(yy1, yy3));
    const y22 = get_closest_on_bezier3_from_point_dd_qmd(9, get_closest_on_bezier3_from_point_dd_qmq(yy2, yy2));
    const y23 = get_closest_on_bezier3_from_point_dd_qmd(6, get_closest_on_bezier3_from_point_dd_qmq(yy2, yy3));
    const y33 = get_closest_on_bezier3_from_point_dd_qmq(yy3, yy3);
    const q1 = get_closest_on_bezier3_from_point_dd_qaq(x13, x22);
    const q2 = get_closest_on_bezier3_from_point_dd_qaq(x03, x12);
    const q3 = get_closest_on_bezier3_from_point_dd_qaq(x02, x11);
    const r1 = get_closest_on_bezier3_from_point_dd_qaq(y13, y22);
    const r2 = get_closest_on_bezier3_from_point_dd_qaq(y03, y12);
    const r3 = get_closest_on_bezier3_from_point_dd_qaq(y02, y11);
    // const t5 = 6*(((((x33 - x23) + (x00 - x01)) + q1) + (q3 - q2)) + 
    //               ((((y33 - y23) + (y00 - y01)) + r1) + (r3 - r2)));
    const t5 = get_closest_on_bezier3_from_point_dd_qmd(6, get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qdq(x33, x23), get_closest_on_bezier3_from_point_dd_qdq(x00, x01)), q1), get_closest_on_bezier3_from_point_dd_qdq(q3, q2)), get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qdq(y33, y23), get_closest_on_bezier3_from_point_dd_qdq(y00, y01)), r1), get_closest_on_bezier3_from_point_dd_qdq(r3, r2))));
    //const t4 = 5*((((x23 + 5*x01) + 3*q2) - 2*(q1 + 2*q3 + 3*x00)) +
    //              (((y23 + 5*y01) + 3*r2) - 2*(r1 + 2*r3 + 3*y00)));
    const t4 = get_closest_on_bezier3_from_point_dd_qmd(5, get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qdq(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qaq(x23, get_closest_on_bezier3_from_point_dd_qmd(5, x01)), get_closest_on_bezier3_from_point_dd_qmd(3, q2)), get_closest_on_bezier3_from_point_dd_qm2(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qaq(q1, get_closest_on_bezier3_from_point_dd_qm2(q3)), get_closest_on_bezier3_from_point_dd_qmd(3, x00)))), get_closest_on_bezier3_from_point_dd_qdq(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qaq(y23, get_closest_on_bezier3_from_point_dd_qmd(5, y01)), get_closest_on_bezier3_from_point_dd_qmd(3, r2)), get_closest_on_bezier3_from_point_dd_qm2(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qaq(r1, get_closest_on_bezier3_from_point_dd_qm2(r3)), get_closest_on_bezier3_from_point_dd_qmd(3, y00))))));
    //const t3 = 4*(((q1 - 3*(q2 - 2*q3)) - 5*(2*x01 - 3*x00)) +
    //              ((r1 - 3*(r2 - 2*r3)) - 5*(2*y01 - 3*y00)));
    const t3 = qm4(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qdq(get_closest_on_bezier3_from_point_dd_qdq(q1, get_closest_on_bezier3_from_point_dd_qmd(3, (get_closest_on_bezier3_from_point_dd_qdq(q2, get_closest_on_bezier3_from_point_dd_qm2(q3))))), get_closest_on_bezier3_from_point_dd_qmd(5, get_closest_on_bezier3_from_point_dd_qdq(get_closest_on_bezier3_from_point_dd_qm2(x01), get_closest_on_bezier3_from_point_dd_qmd(3, x00)))), get_closest_on_bezier3_from_point_dd_qdq(get_closest_on_bezier3_from_point_dd_qdq(r1, get_closest_on_bezier3_from_point_dd_qmd(3, (get_closest_on_bezier3_from_point_dd_qdq(r2, get_closest_on_bezier3_from_point_dd_qm2(r3))))), get_closest_on_bezier3_from_point_dd_qmd(5, get_closest_on_bezier3_from_point_dd_qdq(get_closest_on_bezier3_from_point_dd_qm2(y01), get_closest_on_bezier3_from_point_dd_qmd(3, y00))))));
    //const t2 = 3*((q2 - 2*(2*q3 - 5*(x01 - 2*x00))) +
    //              (r2 - 2*(2*r3 - 5*(y01 - 2*y00))));
    const t2 = get_closest_on_bezier3_from_point_dd_qmd(3, get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qdq(q2, get_closest_on_bezier3_from_point_dd_qm2(get_closest_on_bezier3_from_point_dd_qdq(get_closest_on_bezier3_from_point_dd_qm2(q3), get_closest_on_bezier3_from_point_dd_qmd(5, get_closest_on_bezier3_from_point_dd_qdq(x01, get_closest_on_bezier3_from_point_dd_qm2(x00)))))), get_closest_on_bezier3_from_point_dd_qdq(r2, get_closest_on_bezier3_from_point_dd_qm2(get_closest_on_bezier3_from_point_dd_qdq(get_closest_on_bezier3_from_point_dd_qm2(r3), get_closest_on_bezier3_from_point_dd_qmd(5, get_closest_on_bezier3_from_point_dd_qdq(y01, get_closest_on_bezier3_from_point_dd_qm2(y00))))))));
    //const t1 = 2*((q3 - 5*(x01 - 3*x00)) +
    //              (r3 - 5*(y01 - 3*y00)));
    const t1 = get_closest_on_bezier3_from_point_dd_qm2(get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qdq(q3, get_closest_on_bezier3_from_point_dd_qmd(5, (get_closest_on_bezier3_from_point_dd_qdq(x01, get_closest_on_bezier3_from_point_dd_qmd(3, x00))))), get_closest_on_bezier3_from_point_dd_qdq(r3, get_closest_on_bezier3_from_point_dd_qmd(5, (get_closest_on_bezier3_from_point_dd_qdq(y01, get_closest_on_bezier3_from_point_dd_qmd(3, y00)))))));
    //const t0 = ((x01 - 6*x00) +
    //            (y01 - 6*y00));
    const t0 = get_closest_on_bezier3_from_point_dd_qaq(get_closest_on_bezier3_from_point_dd_qdq(x01, get_closest_on_bezier3_from_point_dd_qmd(6, x00)), get_closest_on_bezier3_from_point_dd_qdq(y01, get_closest_on_bezier3_from_point_dd_qmd(6, y00)));
    return [t5, t4, t3, t2, t1, t0];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/closest-point-on-bezier/get-coeffs/double-double/get-closest-on-bezier2-from-point-dd.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_closest_on_bezier2_from_point_dd_td = node_twoDiff;
const get_closest_on_bezier2_from_point_dd_qaq = node_ddAddDd;
const get_closest_on_bezier2_from_point_dd_qmd = node_ddMultDouble2;
const get_closest_on_bezier2_from_point_dd_qmq = node_ddMultDd;
const get_closest_on_bezier2_from_point_dd_qm2 = node_ddMultBy2;
const qdifq = node_ddDiffDd;
const get_closest_on_bezier2_from_point_dd_qm4 = node_ddMultBy4;
/**
 * * **precondition** TODO - overflow/underflow
 * @param ps
 * @param p
 */
function getClosestOnBezier2FromPointDd(ps, p) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    const [x, y] = p;
    const xx0 = get_closest_on_bezier2_from_point_dd_td(x0, x);
    const xx1 = get_closest_on_bezier2_from_point_dd_td(x1, x);
    const xx2 = get_closest_on_bezier2_from_point_dd_td(x2, x);
    const yy0 = get_closest_on_bezier2_from_point_dd_td(y0, y);
    const yy1 = get_closest_on_bezier2_from_point_dd_td(y1, y);
    const yy2 = get_closest_on_bezier2_from_point_dd_td(y2, y);
    const x00 = get_closest_on_bezier2_from_point_dd_qmq(xx0, xx0);
    const x01 = get_closest_on_bezier2_from_point_dd_qmq(xx0, xx1);
    const x02 = get_closest_on_bezier2_from_point_dd_qmq(xx0, xx2);
    const x11 = get_closest_on_bezier2_from_point_dd_qmq(xx1, xx1);
    const x12 = get_closest_on_bezier2_from_point_dd_qmq(xx1, xx2);
    const x22 = get_closest_on_bezier2_from_point_dd_qmq(xx2, xx2);
    const y00 = get_closest_on_bezier2_from_point_dd_qmq(yy0, yy0);
    const y01 = get_closest_on_bezier2_from_point_dd_qmq(yy0, yy1);
    const y02 = get_closest_on_bezier2_from_point_dd_qmq(yy0, yy2);
    const y11 = get_closest_on_bezier2_from_point_dd_qmq(yy1, yy1);
    const y12 = get_closest_on_bezier2_from_point_dd_qmq(yy1, yy2);
    const y22 = get_closest_on_bezier2_from_point_dd_qmq(yy2, yy2);
    const q1 = get_closest_on_bezier2_from_point_dd_qaq(y02, get_closest_on_bezier2_from_point_dd_qm2(y11));
    const r1 = get_closest_on_bezier2_from_point_dd_qaq(x02, get_closest_on_bezier2_from_point_dd_qm2(x11));
    //const t3 = ((y22 + y00) + 2*q1 - 4*(y12 + y01)) + 
    //           ((x22 + x00) + 2*r1 - 4*(x12 + x01));
    const t3 = get_closest_on_bezier2_from_point_dd_qaq(qdifq(get_closest_on_bezier2_from_point_dd_qaq(get_closest_on_bezier2_from_point_dd_qaq(y22, y00), get_closest_on_bezier2_from_point_dd_qm2(q1)), get_closest_on_bezier2_from_point_dd_qm4(get_closest_on_bezier2_from_point_dd_qaq(y12, y01))), qdifq(get_closest_on_bezier2_from_point_dd_qaq(get_closest_on_bezier2_from_point_dd_qaq(x22, x00), get_closest_on_bezier2_from_point_dd_qm2(r1)), get_closest_on_bezier2_from_point_dd_qm4(get_closest_on_bezier2_from_point_dd_qaq(x12, x01))));
    //const t2 = 3*(((y12 - q1) + (3*y01 - y00)) + 
    //              ((x12 - r1) + (3*x01 - x00)));
    const t2 = get_closest_on_bezier2_from_point_dd_qmd(3, get_closest_on_bezier2_from_point_dd_qaq(get_closest_on_bezier2_from_point_dd_qaq(qdifq(y12, q1), qdifq(get_closest_on_bezier2_from_point_dd_qmd(3, y01), y00)), get_closest_on_bezier2_from_point_dd_qaq(qdifq(x12, r1), qdifq(get_closest_on_bezier2_from_point_dd_qmd(3, x01), x00))));
    //const t1 = (q1 - 3*(2*y01 - y00)) + 
    //           (r1 - 3*(2*x01 - x00));
    const t1 = get_closest_on_bezier2_from_point_dd_qaq(qdifq(q1, get_closest_on_bezier2_from_point_dd_qmd(3, qdifq(get_closest_on_bezier2_from_point_dd_qm2(y01), y00))), qdifq(r1, get_closest_on_bezier2_from_point_dd_qmd(3, qdifq(get_closest_on_bezier2_from_point_dd_qm2(x01), x00))));
    //const t0 = (y01 - y00) + 
    //           (x01 - x00);
    const t0 = get_closest_on_bezier2_from_point_dd_qaq(qdifq(y01, y00), qdifq(x01, x00));
    return [t3, t2, t1, t0];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/closest-point-on-bezier/get-coeffs/double-double/get-closest-on-bezier1-from-point-dd.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_closest_on_bezier1_from_point_dd_tp = node_twoProduct;
const get_closest_on_bezier1_from_point_dd_qaq = node_ddAddDd;
const get_closest_on_bezier1_from_point_dd_qmn2 = node_ddMultByNeg2;
const get_closest_on_bezier1_from_point_dd_qdifq = node_ddDiffDd;
/**
 * * **precondition** TODO underflow/overflow
 * @param ps
 * @param p
 */
function getClosestOnBezier1FromPointDd(ps, p) {
    const [[x0, y0], [x1, y1]] = ps;
    const [x, y] = p;
    const xx0 = x0 - x;
    const xx1 = x1 - x;
    const yy0 = y0 - y;
    const yy1 = y1 - y;
    const x00 = get_closest_on_bezier1_from_point_dd_tp(xx0, xx0);
    const x01 = get_closest_on_bezier1_from_point_dd_tp(xx0, xx1);
    const x11 = get_closest_on_bezier1_from_point_dd_tp(xx1, xx1);
    const y00 = get_closest_on_bezier1_from_point_dd_tp(yy0, yy0);
    const y01 = get_closest_on_bezier1_from_point_dd_tp(yy0, yy1);
    const y11 = get_closest_on_bezier1_from_point_dd_tp(yy1, yy1);
    const s1 = get_closest_on_bezier1_from_point_dd_qaq(x01, y01);
    const s2 = get_closest_on_bezier1_from_point_dd_qaq(y00, x00);
    //const t1 = (x11 + y11) + (s2 - 2*s1)
    const t1 = get_closest_on_bezier1_from_point_dd_qaq(get_closest_on_bezier1_from_point_dd_qaq(x11, y11), get_closest_on_bezier1_from_point_dd_qaq(s2, get_closest_on_bezier1_from_point_dd_qmn2(s1)));
    //const t0 = s1 - s2;
    const t0 = get_closest_on_bezier1_from_point_dd_qdifq(s1, s2);
    return [t1, t0];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/closest-point-on-bezier/get-coeffs/exact/get-closest-on-bezier-from-point-exact.ts
// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗

const get_closest_on_bezier_from_point_exact_td = two_diff_twoDiff;
const emult = eMult;
const get_closest_on_bezier_from_point_exact_sce = scale_expansion_scaleExpansion2;
const get_closest_on_bezier_from_point_exact_em2 = eMultBy2;
const emn2 = eMultByNeg2;
const get_closest_on_bezier_from_point_exact_eadd = eAdd;
const get_closest_on_bezier_from_point_exact_ediff = e_diff_eDiff;
/**
 * Returns the result of multiplying a floating point expansion by 4.
 * * **error free**
 * * see [Shewchuk](https://people.eecs.berkeley.edu/~jrs/papers/robustr.pdf)
 *
 * @param e a floating point expansion
 */
function em4(e) {
    const e_ = [];
    for (let i = 0; i < e.length; i++) {
        e_.push(4 * e[i]);
    }
    return e_;
}
/**
 *  * TODO - not really tangent??, but closest?
 * Returns the polynomial whose roots are all the `t` values on the given bezier
 * curve such that the line from the given point to the point on the bezier
 * evaluated at `t` is tangent to the bezier at `t`.
 * * **precondition** TODO - underflow/overflow (106 bits - see experiments-new)
 * * if the coefficients of the curve and point is bit-aligned bitlength <= 46
 * then the resulting coefficients are guaranteed to have max bitlength 106 (so it
 * can fit in a double-double)
 *
 * @param ps
 * @param p
 */
function getClosestOnBezier3FromPointExact(ps, p) {
    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    const p0 = ps[0];
    const p1 = ps[1];
    const p2 = ps[2];
    const p3 = ps[3];
    const x0 = p0[0];
    const y0 = p0[1];
    const x1 = p1[0];
    const y1 = p1[1];
    const x2 = p2[0];
    const y2 = p2[1];
    const x3 = p3[0];
    const y3 = p3[1];
    const [x, y] = p;
    const xx0 = get_closest_on_bezier_from_point_exact_td(x0, x);
    const xx1 = get_closest_on_bezier_from_point_exact_td(x1, x);
    const xx2 = get_closest_on_bezier_from_point_exact_td(x2, x);
    const xx3 = get_closest_on_bezier_from_point_exact_td(x3, x);
    const yy0 = get_closest_on_bezier_from_point_exact_td(y0, y);
    const yy1 = get_closest_on_bezier_from_point_exact_td(y1, y);
    const yy2 = get_closest_on_bezier_from_point_exact_td(y2, y);
    const yy3 = get_closest_on_bezier_from_point_exact_td(y3, y);
    const x00 = emult(xx0, xx0);
    const x01 = get_closest_on_bezier_from_point_exact_sce(6, emult(xx0, xx1));
    const x02 = get_closest_on_bezier_from_point_exact_sce(6, emult(xx0, xx2));
    const x03 = get_closest_on_bezier_from_point_exact_em2(emult(xx0, xx3));
    const x11 = get_closest_on_bezier_from_point_exact_sce(9, emult(xx1, xx1));
    const x12 = get_closest_on_bezier_from_point_exact_sce(18, emult(xx1, xx2));
    const x13 = get_closest_on_bezier_from_point_exact_sce(6, emult(xx1, xx3));
    const x22 = get_closest_on_bezier_from_point_exact_sce(9, emult(xx2, xx2));
    const x23 = get_closest_on_bezier_from_point_exact_sce(6, emult(xx2, xx3));
    const x33 = emult(xx3, xx3);
    const y00 = emult(yy0, yy0);
    const y01 = get_closest_on_bezier_from_point_exact_sce(6, emult(yy0, yy1));
    const y02 = get_closest_on_bezier_from_point_exact_sce(6, emult(yy0, yy2));
    const y03 = get_closest_on_bezier_from_point_exact_em2(emult(yy0, yy3));
    const y11 = get_closest_on_bezier_from_point_exact_sce(9, emult(yy1, yy1));
    const y12 = get_closest_on_bezier_from_point_exact_sce(18, emult(yy1, yy2));
    const y13 = get_closest_on_bezier_from_point_exact_sce(6, emult(yy1, yy3));
    const y22 = get_closest_on_bezier_from_point_exact_sce(9, emult(yy2, yy2));
    const y23 = get_closest_on_bezier_from_point_exact_sce(6, emult(yy2, yy3));
    const y33 = emult(yy3, yy3);
    const q1 = get_closest_on_bezier_from_point_exact_eadd(x13, x22);
    const q2 = get_closest_on_bezier_from_point_exact_eadd(x03, x12);
    const q3 = get_closest_on_bezier_from_point_exact_eadd(x02, x11);
    const r1 = get_closest_on_bezier_from_point_exact_eadd(y13, y22);
    const r2 = get_closest_on_bezier_from_point_exact_eadd(y03, y12);
    const r3 = get_closest_on_bezier_from_point_exact_eadd(y02, y11);
    //const t5 = 6*((x33 - x23 + q1 - q2 + q3 - x01 + x00) + 
    //              (y33 - y23 + r1 - r2 + r3 - y01 + y00));
    const t5a = get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(x33, x00), get_closest_on_bezier_from_point_exact_eadd(q1, q3)), (get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(q2, x23), x01)));
    const t5b = get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(y33, y00), get_closest_on_bezier_from_point_exact_eadd(r1, r3)), (get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(r2, y23), y01)));
    const t5 = get_closest_on_bezier_from_point_exact_sce(6, get_closest_on_bezier_from_point_exact_eadd(t5a, t5b));
    //const t4 = 5*((x23 - 2*(q1 + 2*q3 + 3*x00) + 3*q2 + 5*x01) +
    //              (y23 - 2*(r1 + 2*r3 + 3*y00) + 3*r2 + 5*y01));
    const t4a = get_closest_on_bezier_from_point_exact_eadd(emn2(get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(q1, get_closest_on_bezier_from_point_exact_em2(q3)), get_closest_on_bezier_from_point_exact_sce(3, x00))), get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(x23, get_closest_on_bezier_from_point_exact_sce(3, q2)), get_closest_on_bezier_from_point_exact_sce(5, x01)));
    const t4b = get_closest_on_bezier_from_point_exact_eadd(emn2(get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(r1, get_closest_on_bezier_from_point_exact_em2(r3)), get_closest_on_bezier_from_point_exact_sce(3, y00))), get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(y23, get_closest_on_bezier_from_point_exact_sce(3, r2)), get_closest_on_bezier_from_point_exact_sce(5, y01)));
    const t4 = get_closest_on_bezier_from_point_exact_sce(5, get_closest_on_bezier_from_point_exact_eadd(t4a, t4b));
    //const t3 = 4*((q1 - 3*(q2 - 2*q3) - 5*(2*x01 - 3*x00)) +
    //              (r1 - 3*(r2 - 2*r3) - 5*(2*y01 - 3*y00)));
    const t3a = get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(q1, get_closest_on_bezier_from_point_exact_sce(3, (get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_em2(q3), q2)))), get_closest_on_bezier_from_point_exact_sce(5, (get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_sce(3, x00), get_closest_on_bezier_from_point_exact_em2(x01)))));
    const t3b = get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(r1, get_closest_on_bezier_from_point_exact_sce(3, (get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_em2(r3), r2)))), get_closest_on_bezier_from_point_exact_sce(5, (get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_sce(3, y00), get_closest_on_bezier_from_point_exact_em2(y01)))));
    const t3 = get_closest_on_bezier_from_point_exact_sce(4, get_closest_on_bezier_from_point_exact_eadd(t3a, t3b));
    //const t2 = 3*((q2 - 2*(2*q3 - 5*(x01 - 2*x00))) +
    //              (r2 - 2*(2*r3 - 5*(y01 - 2*y00))));
    const t2a = get_closest_on_bezier_from_point_exact_ediff(q2, get_closest_on_bezier_from_point_exact_em2(get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_em2(q3), get_closest_on_bezier_from_point_exact_sce(5, (get_closest_on_bezier_from_point_exact_ediff(x01, get_closest_on_bezier_from_point_exact_em2(x00)))))));
    const t2b = get_closest_on_bezier_from_point_exact_ediff(r2, get_closest_on_bezier_from_point_exact_em2(get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_em2(r3), get_closest_on_bezier_from_point_exact_sce(5, (get_closest_on_bezier_from_point_exact_ediff(y01, get_closest_on_bezier_from_point_exact_em2(y00)))))));
    const t2 = get_closest_on_bezier_from_point_exact_sce(3, get_closest_on_bezier_from_point_exact_eadd(t2a, t2b));
    //const t1 = 2*((q3 - 5*(x01 - 3*x00)) +
    //              (r3 - 5*(y01 - 3*y00)));
    const t1a = get_closest_on_bezier_from_point_exact_ediff(q3, get_closest_on_bezier_from_point_exact_sce(5, (get_closest_on_bezier_from_point_exact_ediff(x01, get_closest_on_bezier_from_point_exact_sce(3, x00)))));
    const t1b = get_closest_on_bezier_from_point_exact_ediff(r3, get_closest_on_bezier_from_point_exact_sce(5, (get_closest_on_bezier_from_point_exact_ediff(y01, get_closest_on_bezier_from_point_exact_sce(3, y00)))));
    const t1 = get_closest_on_bezier_from_point_exact_em2(get_closest_on_bezier_from_point_exact_eadd(t1a, t1b));
    //const t0 = ((x01 - 6*x00) +
    //            (y01 - 6*y00));
    const t0a = get_closest_on_bezier_from_point_exact_ediff(x01, get_closest_on_bezier_from_point_exact_sce(6, x00));
    const t0b = get_closest_on_bezier_from_point_exact_ediff(y01, get_closest_on_bezier_from_point_exact_sce(6, y00));
    const t0 = get_closest_on_bezier_from_point_exact_eadd(t0a, t0b);
    return [t5, t4, t3, t2, t1, t0];
}
/**
 * * **precondition** TODO underflow/overflow
 * @param ps
 * @param p
 */
function getClosestOnBezier2FromPointExact(ps, p) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    const [x, y] = p;
    const xx0 = get_closest_on_bezier_from_point_exact_td(x0, x);
    const xx1 = get_closest_on_bezier_from_point_exact_td(x1, x);
    const xx2 = get_closest_on_bezier_from_point_exact_td(x2, x);
    const yy0 = get_closest_on_bezier_from_point_exact_td(y0, y);
    const yy1 = get_closest_on_bezier_from_point_exact_td(y1, y);
    const yy2 = get_closest_on_bezier_from_point_exact_td(y2, y);
    const x00 = emult(xx0, xx0);
    const x01 = emult(xx0, xx1);
    const x02 = emult(xx0, xx2);
    const x11 = emult(xx1, xx1);
    const x12 = emult(xx1, xx2);
    const x22 = emult(xx2, xx2);
    const y00 = emult(yy0, yy0);
    const y01 = emult(yy0, yy1);
    const y02 = emult(yy0, yy2);
    const y11 = emult(yy1, yy1);
    const y12 = emult(yy1, yy2);
    const y22 = emult(yy2, yy2);
    const q1 = get_closest_on_bezier_from_point_exact_eadd(y02, get_closest_on_bezier_from_point_exact_em2(y11));
    const r1 = get_closest_on_bezier_from_point_exact_eadd(x02, get_closest_on_bezier_from_point_exact_em2(x11));
    //const t3 = y22 + 2*q1 - 4*(y12 + y01) + y00 + 
    //           x22 + 2*r1 - 4*(x12 + x01) + x00;
    const t3a = get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_eadd(x22, get_closest_on_bezier_from_point_exact_em2(r1)), em4(get_closest_on_bezier_from_point_exact_eadd(x12, x01))), x00);
    const t3b = get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_eadd(y22, get_closest_on_bezier_from_point_exact_em2(q1)), em4(get_closest_on_bezier_from_point_exact_eadd(y12, y01))), y00);
    const t3 = get_closest_on_bezier_from_point_exact_eadd(t3a, t3b);
    //const t2 = 3*(y12 - q1 + 3*y01 - y00 + 
    //              x12 - r1 + 3*x01 - x00);
    const t2a = get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_ediff(x12, r1), get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_sce(3, x01), x00));
    const t2b = get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_ediff(y12, q1), get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_sce(3, y01), y00));
    const t2 = get_closest_on_bezier_from_point_exact_sce(3, get_closest_on_bezier_from_point_exact_eadd(t2a, t2b));
    //const t1 = q1 - 3*(2*y01 - y00) + 
    //           r1 - 3*(2*x01 - x00);
    const t1a = get_closest_on_bezier_from_point_exact_ediff(q1, get_closest_on_bezier_from_point_exact_sce(3, get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_em2(y01), y00)));
    const t1b = get_closest_on_bezier_from_point_exact_ediff(r1, get_closest_on_bezier_from_point_exact_sce(3, get_closest_on_bezier_from_point_exact_ediff(get_closest_on_bezier_from_point_exact_em2(x01), x00)));
    const t1 = get_closest_on_bezier_from_point_exact_eadd(t1a, t1b);
    //const t0 = y01 - y00 + 
    //           x01 - x00;
    const t0a = get_closest_on_bezier_from_point_exact_ediff(y01, y00);
    const t0b = get_closest_on_bezier_from_point_exact_ediff(x01, x00);
    const t0 = get_closest_on_bezier_from_point_exact_eadd(t0a, t0b);
    return [t3, t2, t1, t0];
}
/**
 * * **precondition** TODO underflow/overflow
 * @param ps
 * @param p
 */
function getClosestOnBezier1FromPointExact(ps, p) {
    const [[x0, y0], [x1, y1]] = ps;
    const [x, y] = p;
    const xx0 = get_closest_on_bezier_from_point_exact_td(x0, x);
    const xx1 = get_closest_on_bezier_from_point_exact_td(x1, x);
    const yy0 = get_closest_on_bezier_from_point_exact_td(y0, y);
    const yy1 = get_closest_on_bezier_from_point_exact_td(y1, y);
    const x00 = emult(xx0, xx0);
    const x01 = emult(xx0, xx1);
    const x11 = emult(xx1, xx1);
    const y00 = emult(yy0, yy0);
    const y01 = emult(yy0, yy1);
    const y11 = emult(yy1, yy1);
    const s1 = get_closest_on_bezier_from_point_exact_eadd(x01, y01);
    const s2 = get_closest_on_bezier_from_point_exact_eadd(y00, x00);
    //const t1 = x11 + y11 - 2*s1 + s2;
    const t1 = get_closest_on_bezier_from_point_exact_eadd(get_closest_on_bezier_from_point_exact_eadd(x11, y11), get_closest_on_bezier_from_point_exact_eadd(emn2(s1), s2));
    //const t0 = s1 - s2;
    const t0 = get_closest_on_bezier_from_point_exact_ediff(s1, s2);
    return [t1, t0];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/closest-point-on-bezier/get-coeffs/get-closest-on-bezier-from-point-error-counters.ts
const get_closest_on_bezier_from_point_error_counters_abs = Math.abs;
/**
 * Returns the polynomial whose roots are all the t values on the given bezier
 * curve such that the line from the given point to the point on the bezier
 * evaluated at t is tangent to the bezier at t.
 *
 * @param ps An order 1, 2 or 3 bezier curve given by its control points.
 * @param p
 *
 * @doc
 */
//function getClosestOnBezierFromPointErrorCounters(
//        ps: number[][], p: number[]) {
//
//    if (ps.length === 4) {
//        return getClosestOnBezier3FromPointErrorCounters(ps, p);
//    } else if (ps.length === 3) {
//        return getClosestOnBezier2FromPointErrorCounters(ps, p);
//    } else if (ps.length === 2) {
//        return getClosestOnBezier1FromPointErrorCounters(ps, p);
//    }
//}
/**
 *
 * @param ps
 * @param p
 *
 * ```
 * return [
 *      t5_,  // <9>
 *      t4_,  // <10>
 *      t3_,  // <10>
 *      t2_,  // <10>
 *      t1_,  // <9>
 *      t0_   // <7>
 * ];
 * ```
 */
function getClosestOnBezier3FromPointErrorCounters(ps, p) {
    //const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    //const [xp, yp] = p;
    const p0 = ps[0];
    const p1 = ps[1];
    const p2 = ps[2];
    const p3 = ps[3];
    const x0_ = get_closest_on_bezier_from_point_error_counters_abs(p0[0]); // <0>  (error counters)
    const y0_ = get_closest_on_bezier_from_point_error_counters_abs(p0[1]); // <0>
    const x1_ = get_closest_on_bezier_from_point_error_counters_abs(p1[0]); // <0>
    const y1_ = get_closest_on_bezier_from_point_error_counters_abs(p1[1]); // <0>
    const x2_ = get_closest_on_bezier_from_point_error_counters_abs(p2[0]); // <0>
    const y2_ = get_closest_on_bezier_from_point_error_counters_abs(p2[1]); // <0>
    const x3_ = get_closest_on_bezier_from_point_error_counters_abs(p3[0]); // <0>
    const y3_ = get_closest_on_bezier_from_point_error_counters_abs(p3[1]); // <0>
    const xp_ = get_closest_on_bezier_from_point_error_counters_abs(p[0]); // <0>
    const yp_ = get_closest_on_bezier_from_point_error_counters_abs(p[1]); // <0>
    // <1>xx0 <-- <1>(x0 - xp);
    const xx0_ = x0_ + xp_;
    // <1>xx1 <-- <1>(x1 - xp);
    const xx1_ = x1_ + xp_;
    // <1>xx2 <-- <1>(x2 - xp);
    const xx2_ = x2_ + xp_;
    // <1>xx3 <-- <1>(x3 - xp);
    const xx3_ = x3_ + xp_;
    // <1>yy0 <-- <1>(y0 - yp);
    const yy0_ = y0_ + yp_;
    // <1>yy1 <-- <1>(y1 - yp);
    const yy1_ = y1_ + yp_;
    // <1>yy2 <-- <1>(y2 - yp);
    const yy2_ = y2_ + yp_;
    // <1>yy3 <-- <1>(y3 - yp);
    const yy3_ = y3_ + yp_;
    // <3>x00 <-- <3>(<1>xx0*<1>xx0);
    const x00_ = xx0_ * xx0_;
    // <4>x01 <-- <4>(6 *<3>(<1>xx0*<1>xx1));
    const x01_ = 6 * xx0_ * xx1_;
    // <4>x02 <-- <4>(6 *<3>(<1>xx0*<1>xx2));
    const x02_ = 6 * xx0_ * xx2_;
    // <3>x03 <-- 2 *<3>(<1>xx0*<1>xx3);
    const x03_ = 2 * xx0_ * xx3_;
    // <4>x11 <-- <4>(9 *<3>(<1>xx1*<1>xx1));
    const x11_ = 9 * xx1_ * xx1_;
    // <4>x12 <-- <4>(18*<3>(<1>xx1*<1>xx2));
    const x12_ = 18 * xx1_ * xx2_;
    // <4>x13 <-- <4>(6 *<3>(<1>xx1*<1>xx3));
    const x13_ = 6 * xx1_ * xx3_;
    // <4>x22 <-- <4>(9 *<3>(<1>xx2*<1>xx2));
    const x22_ = 9 * xx2_ * xx2_;
    // <4>x23 <-- <4>(6 *<3>(<1>xx2*<1>xx3));
    const x23_ = 6 * xx2_ * xx3_;
    // <3>x33 <--    <3>(<1>xx3*<1>xx3);
    const x33_ = xx3_ * xx3_;
    const y00_ = yy0_ * yy0_;
    const y01_ = 6 * yy0_ * yy1_;
    const y02_ = 6 * yy0_ * yy2_;
    const y03_ = 2 * yy0_ * yy3_;
    const y11_ = 9 * yy1_ * yy1_;
    const y12_ = 18 * yy1_ * yy2_;
    const y13_ = 6 * yy1_ * yy3_;
    const y22_ = 9 * yy2_ * yy2_;
    const y23_ = 6 * yy2_ * yy3_;
    const y33_ = yy3_ * yy3_;
    // <5>q1 <-- (5>(<4>x13 + <4>x22);
    const q1_ = x13_ + x22_;
    // <5>q2 <-- (5>(<3>x03 + <4>x12);
    const q2_ = x03_ + x12_;
    // <5>q3 <-- (5>(<4>x02 + <4>x11);
    const q3_ = x02_ + x11_;
    const r1_ = y13_ + y22_; // <5>
    const r2_ = y03_ + y12_; // <5>
    const r3_ = y02_ + y11_; // <5>
    // <9>t5 <-- <9>(6*<8>(<7>(<6>(<5>(<4>(x33 - x23) + <4>(x00 - x01)) + <5>q1) + <6>(q3 - q2)) + 
    //                     <7>(<6>(<5>(<4>(y33 - y23) + <4>(y00 - y01)) + <5>r1) + <6>(r3 - r2))));
    const t5_ = 6 * (((((x33_ + x23_) + (x00_ + x01_)) + q1_) + (q3_ + q2_)) +
        ((((y33_ + y23_) + (y00_ + y01_)) + r1_) + (r3_ + r2_)));
    // <10>t4 <-- <10>(5*<9>(<8>(<7>(<6>(x23 + <5>(5*x01)) + <6>(3*q2)) - 2*<7>(<6>(q1 + 2*q3) + <5>(3*x00))) +
    //                       <8>(<7>(<6>(y23 + <5>(5*y01)) + <6>(3*r2)) - 2*<7>(<6>(r1 + 2*r3) + <5>(3*y00)))));
    const t4_ = 5 * ((((x23_ + 5 * x01_) + 3 * q2_) + 2 * (q1_ + 2 * q3_ + 3 * x00_)) +
        (((y23_ + 5 * y01_) + 3 * r2_) + 2 * (r1_ + 2 * r3_ + 3 * y00_)));
    // <10>t3 <-- 4*<10>(<9>(<8>(q1 - <7>(3*<6>(q2 - 2*q3))) - <7>(5*<6>(2*x01 - <5>(3*x00)))) +
    //                 <9>(<8>(r1 - <7>(3*<6>(r2 - 2*r3))) - <7>(5*<6>(2*y01 - <5>(3*y00)))))
    const t3_ = 4 * (((q1_ + 3 * (q2_ + 2 * q3_)) + 5 * (2 * x01_ + 3 * x00_)) +
        ((r1_ + 3 * (r2_ + 2 * r3_)) + 5 * (2 * y01_ + 3 * y00_)));
    // <10>t2 <-- <10>(3*<9>(<8>(q2 - 2*<7>(2*q3 - <6>(5*<5>(x01 - 2*x00)))) +
    //                       <8>(r2 - 2*<7>(2*r3 - <6>(5*<5>(y01 - 2*y00))))));
    const t2_ = 3 * ((q2_ + 2 * (2 * q3_ + 5 * (x01_ + 2 * x00_))) +
        (r2_ + 2 * (2 * r3_ + 5 * (y01_ + 2 * y00_))));
    // <9>t1 <-- 2*<9>(<8>(q3 - <7>(5*<6>(x01 - <5>(3*x00)))) +
    //                 <8>(r3 - <7>(5*<6>(y01 - <5>(3*y00)))));
    const t1_ = 2 * ((q3_ + 5 * (x01_ + 3 * x00_)) +
        (r3_ + 5 * (y01_ + 3 * y00_)));
    // <7>t0 <-- <7>(<6>(x01 - <5>(6*x00)) +
    //              <6>(y01 - <5>(6*y00)));
    const t0_ = ((x01_ + 6 * x00_) +
        (y01_ + 6 * y00_));
    return [
        t5_,
        t4_,
        t3_,
        t2_,
        t1_,
        t0_ // <7>
    ];
}
/**
 *
 * @param ps
 * @param p
 * ```
 * return [
 *      t3_,  // <7>
 *      t2_,  // <8>
 *      t1_,  // <7>
 *      t0_   // <5>
 * ];
 * ```
 */
function getClosestOnBezier2FromPointErrorCounters(ps, p) {
    //const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    //const [xp, yp] = p;
    const p0 = ps[0];
    const p1 = ps[1];
    const p2 = ps[2];
    const x0_ = get_closest_on_bezier_from_point_error_counters_abs(p0[0]); // <0>
    const y0_ = get_closest_on_bezier_from_point_error_counters_abs(p0[1]); // <0>
    const x1_ = get_closest_on_bezier_from_point_error_counters_abs(p1[0]); // <0>
    const y1_ = get_closest_on_bezier_from_point_error_counters_abs(p1[1]); // <0>
    const x2_ = get_closest_on_bezier_from_point_error_counters_abs(p2[0]); // <0>
    const y2_ = get_closest_on_bezier_from_point_error_counters_abs(p2[1]); // <0>
    const xp_ = get_closest_on_bezier_from_point_error_counters_abs(p[0]); // <0>
    const yp_ = get_closest_on_bezier_from_point_error_counters_abs(p[1]); // <0>
    // <1>xx0 <-- <1>(x0 - xp);
    const xx0_ = x0_ + xp_;
    // <1>xx1 <-- <1>(x1 - xp);
    const xx1_ = x1_ + xp_;
    // <1>xx2 <-- <1>(x2 - xp);
    const xx2_ = x2_ + xp_;
    // <1>yy0 <-- <1>(y0 - yp);
    const yy0_ = y0_ + yp_;
    // <1>yy1 <-- <1>(y1 - yp);
    const yy1_ = y1_ + yp_;
    // <1>yy2 <-- <1>(y2 - yp);
    const yy2_ = y2_ + yp_;
    // <3>x00 <-- <3>(xx0*xx0);
    const x00_ = xx0_ * xx0_;
    // <3>x01 <-- <3>(xx0*xx1);
    const x01_ = xx0_ * xx1_;
    // <3>x02 <-- <3>(xx0*xx2);
    const x02_ = xx0_ * xx2_;
    // <3>x11 <-- <3>(xx1*xx1);
    const x11_ = xx1_ * xx1_;
    // <3>x12 <-- <3>(xx1*xx2);
    const x12_ = xx1_ * xx2_;
    // <3>x22 <-- <3>(xx2*xx2);
    const x22_ = xx2_ * xx2_;
    const y00_ = yy0_ * yy0_;
    const y01_ = yy0_ * yy1_;
    const y02_ = yy0_ * yy2_;
    const y11_ = yy1_ * yy1_;
    const y12_ = yy1_ * yy2_;
    const y22_ = yy2_ * yy2_;
    // <4>q1 <-- <4>(y02 + 2*y11);
    const q1_ = y02_ + 2 * y11_;
    // <4>r1 <-- <4>(x02 + 2*x11);
    const r1_ = x02_ + 2 * x11_;
    // <7>t3 <-- <7>(<6>(<5>(<4>(y22 + y00) + 2*q1) - 4*<4>(y12 + y01))) + 
    //              (<6>(<5>(<4>(x22 + x00) + 2*r1) - 4*<4>(x12 + x01)));
    const t3_ = ((y22_ + y00_) + 2 * q1_ + 4 * (y12_ + y01_)) +
        ((x22_ + x00_) + 2 * r1_ + 4 * (x12_ + x01_));
    // <8>t2 <-- <8>(3*<7>(<6>(<5>(y12 - q1) + <5>(<4>(3*y01) - y00)) + 
    //                     <6>(<5>(x12 - r1) + <5>(<4>(3*x01) - x00))));
    const t2_ = 3 * (((y12_ + q1_) + (3 * y01_ + y00_)) +
        ((x12_ + r1_) + (3 * x01_ + x00_)));
    // <7>t1 <-- <7>(<6>(<4>q1 - <5>(3*<4>(2*y01 - y00))) + 
    //               <6>(<4>r1 - <5>(3*<4>(2*x01 - x00))));
    const t1_ = (q1_ + 3 * (2 * y01_ + y00_)) +
        (r1_ + 3 * (2 * x01_ + x00_));
    // <5>t0 <-- <5>(<4>(y01 - y00) + 
    //              <4>(x01 - x00));
    const t0_ = (y01_ + y00_) +
        (x01_ + x00_);
    return [
        t3_,
        t2_,
        t1_,
        t0_ // <5>
    ];
}
/**
 *
 * @param ps
 * @param p
 *
 * ```
 * return [
 *     t1,  // <6>
 *     t0   // <5>
 * ];
 * ```
 */
function getClosestOnBezier1FromPointErrorCounters(ps, p) {
    //const [[x0, y0], [x1, y1]] = ps;
    //const [xp, yp] = p;
    const p0 = ps[0];
    const p1 = ps[1];
    const x0_ = get_closest_on_bezier_from_point_error_counters_abs(p0[0]); // <0>
    const y0_ = get_closest_on_bezier_from_point_error_counters_abs(p0[1]); // <0>
    const x1_ = get_closest_on_bezier_from_point_error_counters_abs(p1[0]); // <0>
    const y1_ = get_closest_on_bezier_from_point_error_counters_abs(p1[1]); // <0>
    const xp_ = get_closest_on_bezier_from_point_error_counters_abs(p[0]); // <0>
    const yp_ = get_closest_on_bezier_from_point_error_counters_abs(p[1]); // <0>
    // <1>xx0 <-- <1>(x0 - xp);
    const xx0_ = x0_ + xp_;
    // <1>xx1 <-- <1>(x1 - xp);    
    const xx1_ = x1_ + xp_;
    // <1>yy0 <-- <1>(y0 - yp);    
    const yy0_ = y0_ + yp_;
    // <1>yy1 <-- <1>(y1 - yp);    
    const yy1_ = y1_ + yp_;
    // <3>x00 <-- <3>(xx0*xx0);
    const x00_ = xx0_ * xx0_;
    // <3>x01 <-- <3>(xx0*xx1);
    const x01_ = xx0_ * xx1_;
    // <3>x11 <-- <3>(xx1*xx1);
    const x11_ = xx1_ * xx1_;
    const y00_ = yy0_ * yy0_;
    const y01_ = yy0_ * yy1_;
    const y11_ = yy1_ * yy1_;
    // <4>s1 <-- <4>(x01 + y01);
    const s1_ = x01_ + y01_;
    // <4>s2 <-- <4>(y00 + x00);
    const s2_ = y00_ + x00_;
    // <6>t1 = <6>(<4>(x11 + y11) + <5>(s2 - 2*s1));
    const t1 = x11_ + y11_ + 2 * s1_ + s2_;
    // <5>t0 = <5>(s1 - s2);
    const t0 = s1_ + s2_;
    return [
        t1,
        t0 // <5>
    ];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/closest-point-on-bezier/closest-point-on-bezier-certified.ts













// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const closest_point_on_bezier_certified_estimate = e_estimate_eEstimate;
const closest_point_on_bezier_certified_td = two_diff_twoDiff;
const closest_point_on_bezier_certified_emult = eMult;
const closest_point_on_bezier_certified_eadd = eAdd;
const closest_point_on_bezier_certified_eps = Number.EPSILON;
const γγ6 = error_analysis_error_analysis_(6);
/**
 * Returns the closest point(s) (and parameter `t` value(s)) on the given
 * bezier curve to the given point.
 *
 * * guaranteed accurate to 4 ulps in `t` value
 *
 * @param ps
 * @param p
 *
 * @doc
 */
function closestPointOnBezierCertified(ps, p) {
    const order = ps.length - 1;
    let ris;
    if (order === 3) {
        // keep TypeScript happy; `ris` cannot be `undefined` here
        ris = allRootsCertified(getClosestOnBezier3FromPointDd(ps, p), 0, 1, getClosestOnBezier3FromPointErrorCounters(ps, p).map(e => 10 * γγ6 * e), () => getClosestOnBezier3FromPointExact(ps, p));
    }
    else if (order === 2) {
        // keep TypeScript happy; `ris` cannot be `undefined` here
        ris = allRootsCertified(getClosestOnBezier2FromPointDd(ps, p), 0, 1, getClosestOnBezier2FromPointErrorCounters(ps, p).map(e => 8 * γγ6 * e), () => getClosestOnBezier2FromPointExact(ps, p));
    }
    else if (order === 1) {
        // keep TypeScript happy; `ris` cannot be `undefined` here
        ris = allRootsCertified(getClosestOnBezier1FromPointDd(ps, p), 0, 1, getClosestOnBezier1FromPointErrorCounters(ps, p).map(e => 6 * γγ6 * e), () => getClosestOnBezier1FromPointExact(ps, p));
    }
    else if (order === 0) {
        ris = [];
    }
    else {
        throw new Error('The given bezier curve is invalid.');
    }
    ris.push({ tS: 0, tE: 0, multiplicity: 1 });
    ris.push({ tS: 1, tE: 1, multiplicity: 1 });
    const infos = ris.map(ri => {
        const intervalBox = getIntervalBox(ps, [ri.tS, ri.tE]);
        return {
            di: rootIntervalToDistanceInterval(intervalBox, p),
            intervalBox,
            ri
        };
    });
    /** the minimum max interval value */
    let minMax = Number.POSITIVE_INFINITY;
    for (let i = 0; i < infos.length; i++) {
        const diMax = infos[i].di[1];
        if (diMax < minMax) {
            minMax = diMax;
        }
    }
    const closestPointInfos = [];
    for (let i = 0; i < infos.length; i++) {
        const info = infos[i];
        if (info.di[0] <= minMax) {
            closestPointInfos.push(info);
        }
    }
    return closestPointInfos;
}
/**
 * Returns the distance interval from the given root interval (currently
 * ignoring multiplicity)
 *
 * @param ps1 the first bezier
 * @param ps2 the second bezier
 * @param ts2 the `t` values of the second bezier
 */
function rootIntervalToDistanceInterval(intervalBox, p) {
    const bl = intervalBox[0];
    const tr = intervalBox[1];
    const minX = bl[0];
    const minY = bl[1];
    const maxX = tr[0];
    const maxY = tr[1];
    const x = p[0]; // <0>
    const y = p[1]; // <0>
    let minD = Number.POSITIVE_INFINITY;
    let maxD = Number.NEGATIVE_INFINITY;
    // for each corner of the interval box
    for (const [a, b] of [[minX, minY], [minX, maxY], [maxX, minY], [maxX, maxY]]) {
        /*
        // distance to 1st corner of interval box - `distance² = x² + y²`
        const dc1 = (a - x)**2 + (b - y)**2;
        // max absolute roundoff error of `dc1`
        // <4>dc1 <-- <4>(<3>(<1>(a - x)**2) + <3>(<1>((b - y)**2))
        const dc1E = 4*γ1*((a + x)**2 + (b + y)**2);
        const dc1Min = dc1 - dc1E;  // distance minus max error
        const dc1Max = dc1 + dc1E;  // distance plus max error
        */
        /** distance to 1st corner of interval box - `distance² = x² + y²` */
        const ax = closest_point_on_bezier_certified_td(a, x);
        const by = closest_point_on_bezier_certified_td(b, y);
        const dc1Exact = closest_point_on_bezier_certified_eadd(closest_point_on_bezier_certified_emult(ax, ax), closest_point_on_bezier_certified_emult(by, by));
        const dc1 = closest_point_on_bezier_certified_estimate(dc1Exact);
        const dc1Min = dc1 * (1 - closest_point_on_bezier_certified_eps); // distance minus max error
        const dc1Max = dc1 * (1 + closest_point_on_bezier_certified_eps); // distance plus max error
        if (dc1Min <= minD) {
            minD = dc1Min;
        }
        if (dc1Max >= maxD) {
            maxD = dc1Max;
        }
    }
    return [minD, maxD];
}


;// CONCATENATED MODULE: ./src/global-properties/length/length-upper-bound.ts

/**
 * Returns an upper bound for the length of the given bezier curve - this bound
 * is not very strict as it uses the sum of the straight-line distances between
 * control points as a measure.
 *
 * @param ps
 *
 * @doc mdx
 */
function lengthUpperBound(ps) {
    let totalLength = 0;
    for (let i = 0; i < ps.length - 1; i++) {
        totalLength += distanceBetween(ps[i], ps[i + 1]);
    }
    return totalLength;
}


;// CONCATENATED MODULE: ./src/transformation/split-merge-clone/split-by-max-curve-length.ts


/**
 * Split the order 1, 2 or 3 bezier into pieces (given as an array of parameter
 * (t) values) such that the longest curve length is guaranteed to be lower than
 * the given max length.
 *
 * @param ps
 * @param maxLength
 *
 * @doc
 */
function splitByMaxCurveLength(ps, maxLength) {
    const ts = [0, 1]; // include endpoints
    const tStack = [[0, 1]];
    const fromTo_ = split_merge_clone_from_to_fromTo(ps);
    while (tStack.length) {
        const ts_ = tStack.pop();
        const ps_ = fromTo_(ts_[0], ts_[1]);
        if (lengthUpperBound(ps_) > maxLength) {
            const t = (ts_[0] + ts_[1]) / 2;
            tStack.push([ts_[0], t]);
            tStack.push([t, ts_[1]]);
            ts.push(t);
        }
    }
    ts.sort((a, b) => a - b);
    return ts;
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/hausdorff-distance.ts




function hausdorffDistanceCandidates(ps1, ps2, maxLength) {
    let ts = splitByMaxCurveLength(ps1, maxLength);
    let candidates = [];
    for (let i = 0; i < ts.length; i++) {
        let t = ts[i];
        let p = evalDeCasteljau(ps1, t);
        let v = closestPointOnBezier(ps2, p);
        candidates.push({
            p1: p,
            p2: v.p,
            d: distanceBetween(p, v.p)
        });
    }
    return candidates;
}
/**
 * Calculates and returns an approximation to the one-sided Hausdorff distance
 * from ps1 to ps2 between two bezier curves.
 *
 * @param ps1
 * @param ps2
 * @param maxLength The first curve (ps1) will be split into pieces such that
 * each piece is shorter than maxLength. All endpoints of the smaller curves
 * are then used to check the distance to the other curve. The max of these
 * are given as an estimate of the Hausdorff distance.
 *
 * @doc
 */
function hausdorffDistance(ps1, ps2, maxLength) {
    let candidates = hausdorffDistanceCandidates(ps1, ps2, maxLength);
    let maxD = Number.NEGATIVE_INFINITY;
    for (let candidate of candidates) {
        if (candidate.d > maxD) {
            maxD = candidate.d;
        }
    }
    return maxD;
}


;// CONCATENATED MODULE: ./src/global-properties/length/length-squared-upper-bound.ts

/**
 * Returns an upper bound for the length of the given order 1, 2 or 3 bezier
 * curve.
 *
 * The curve has lenhth 0 iff this bound is zero.
 *
 * This bound is quite loose as it uses the sum of the straight-line distances
 * between control points as a measure.
 * @param ps
 *
 * @doc mdx
 */
function lengthSquaredUpperBound(ps) {
    let totalLength = 0;
    for (let i = 0; i < ps.length - 1; i++) {
        totalLength += squared_distance_between_squaredDistanceBetween(ps[i], ps[i + 1]);
    }
    return totalLength;
}


;// CONCATENATED MODULE: ./src/get-curvature-extrema/get-abs-curvature-extrema-polys.ts



/**
 * Returns the polynomials whose zeros are the t values of the local
 * minima / maxima of the absolute curvature for the given bezier curve.
 *
 * The polynomials are in the form p1*p2 where the zeros
 * of p1 are the inflection points and the zeros of p2 are the other minima /
 * maxima.
 *
 * * **precondition:** must be a true cubic bezier (not degenerate to line or
 * quadratic)
 * * see [MvG](https://math.stackexchange.com/a/1956264/130809)'s excellent
 * * **non-exact:** there is floating point roundof during calculation
 *
 * @param ps an order 1, 2 or 3 bezier curve given as an array of control
 * points, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 *
 * @internal
 */
function getAbsCurvatureExtremaPolys(ps) {
    // It is a real cubic - use the excellent answer from the description:
    // dd(kappa^2)/dt === (x′′y′ − x′y′′)*((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))
    // Inflection points at: (x′′y′ − x′y′′) === 0
    // Max abs curvature at: ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′)) === 0
    const [[dx2, dx1, dx0], [dy2, dy1, dy0]] = getDxy(ps); // max bitlength increase === 5
    const [[ddx1, ddx0], [ddy1, ddy0]] = getDdxy(ps); // max bitlength increase === 6
    const [dddx, dddy] = getDddxy(ps); // max bitlength increase === 6
    // ((x′′′y′ − x′y′′′)(x′2 + y′2) − 3(x′x′′ + y′y′′)(x′′y′ − x′y′′))
    // or 
    // x′′′x′x′y′ + x′′′y′y′y′ - y′′′x′x′x′ - y′′′x′y′y′ + 
    // 3(x′′y′′x′x′ - x′′x′′x′y′ - x′′y′′y′y′ + y′′y′′x′y′)
    // The above line becomes
    // ((dddx*dy(t) − dx(t)*dddy)(dx(t)dx(t) + dy(t)dy(t)) − 3(dx(t)ddx(t) + dy(t)ddy(t))(ddx(t)dy(t) − dx(t)ddy(t)))
    // or 
    // dddx*dxt**2*dyt + dddx*dyt**3 - dddy*dxt**3 - dddy*dxt*dyt**2 - 
    // 3*ddxt**2*dxt*dyt + 3*ddxt*ddyt*dxt**2 - 3*ddxt*ddyt*dyt**2 + 3*ddyt**2*dxt*dyt
    // which becomes: (after substituting e.g. dy(t) = dy2*t^2 + dy1*t + dy0, etc. using Python and
    // then expanding and collecting terms)
    const dddx_dy1 = dddx * dy1;
    const dddy_dx1 = dddy * dx1;
    const ddx0_dy0 = ddx0 * dy0;
    const ddx0_dy1 = ddx0 * dy1;
    const ddy1_ddy1 = ddy1 * ddy1;
    const ddx1_dy0 = ddx1 * dy0;
    const ddy0_dx0 = ddy0 * dx0;
    const ddy0_dx1 = ddy0 * dx1;
    const ddy1_dx0 = ddy1 * dx0;
    const dx0_dx1 = dx0 * dx1;
    const dx0_dx2 = dx0 * dx2;
    const dx0_dy2 = dx0 * dy2;
    const dx1_dx1 = dx1 * dx1;
    const dx1_dx2 = dx1 * dx2;
    const dx1_dy1 = dx1 * dy1;
    const dx2_dy0 = dx2 * dy0;
    const dx2_dy2 = dx2 * dy2;
    const dx2_dx2 = dx2 * dx2;
    const dy0_dy1 = dy0 * dy1;
    const dy0_dy2 = dy0 * dy2;
    const dy1_dy1 = dy1 * dy1;
    const dy1_dy2 = dy1 * dy2;
    const dy2_dy2 = dy2 * dy2;
    const ss = dddx * dy0 - dddy * dx0;
    const uu = dddx_dy1 - dddy_dx1;
    const vv = ddx0 * dx0 + ddy0 * dy0;
    const ww = ddx0 * dx1 + ddx1 * dx0 + ddy0 * dy1 + ddy1 * dy0;
    const xx = ddx0_dy0 - ddy0_dx0;
    const yy = ddx0_dy1 + ddx1_dy0 - ddy0_dx1 - ddy1_dx0;
    const qq = dx0 * dx0 + dy0 * dy0;
    const rr = dx0_dx1 + dy0_dy1;
    // t6 cancels! see https://math.stackexchange.com/a/1956264/130809
    const z1 = dx1_dy1 + dx2_dy0;
    const z2 = dy0_dy2 + dy1_dy1;
    const z3 = dx0_dx2 + dx1_dx1;
    const z4 = dx1 * dy2 + dx2 * dy1;
    const z5 = dx2_dx2 - dy2_dy2;
    const z6 = dx1_dx2 - dy1_dy2;
    const z7 = dx0_dy2 + dx1_dy1;
    const z8 = dx0_dx1 - dy0_dy1;
    const z9 = dx0 * dy1 + dx1 * dy0;
    const x1 = dy0_dy2 + z2;
    const x2 = dx0_dx2 + z3;
    const x3 = dx0_dy2 + z1;
    const x4 = dx1_dy1 + z1;
    const x5 = x2 - x1;
    const x6 = z1 + dx2_dy0;
    const x7 = z7 + dx2_dy0;
    const x8 = 2 * ddy0_dx1 + ddy1_dx0;
    const t5 = dx2_dx2 * (dddx_dy1 - 3 * dddy_dx1) +
        dy2_dy2 * (3 * dddx_dy1 - dddy_dx1) +
        2 * ((dx2_dy2) * ((dddx * dx1 - dddy * dy1) + 3 * (ddy0 * ddy1 - ddx0 * ddx1)) + 3 * ddx1 * ddy1 * z6) +
        3 * (z4 * (ddy1_ddy1 - ddx1 * ddx1) + z5 * (ddx0 * ddy1 + ddy0 * ddx1));
    const t4 = dddx * (dy2 * (x2 + 3 * z2) + dx2 * x4) -
        dddy * (dx0 * (3 * dx2_dx2 + dy2_dy2) + dx1 * (3 * dx1_dx2 + 2 * dy1_dy2) + dx2 * x1) +
        3 * (ddx0 * ((ddy0 * z5 - ddx0 * dx2_dy2) + 2 * (ddy1 * z6 - ddx1 * z4)) +
            ddx1 * (2 * ddy0 * z6 + ddy1 * (2 * (dx0_dx2 - dy0_dy2) + (dx1_dx1 - dy1_dy1)) - ddx1 * x7) +
            ddy0 * (ddy0 * dx2_dy2 + 2 * ddy1 * z4) +
            ddy1_ddy1 * x3);
    const t3 = dddx * (2 * dx0 * z4 + dx1 * x6 + dy1 * (4 * dy0_dy2 + x1)) -
        dddy * (2 * dx0 * (3 * dx1_dx2 + dy1_dy2) + dx1 * (dx1_dx1 + 2 * dy0_dy2) + dy1 * x6) +
        3 * (ddx0 * (2 * (ddy0 * z6 - ddx1 * x7) + ddy1 * x5 - ddx0 * z4) +
            ddx1 * (2 * ddy1 * z8 - ddx1 * z9) +
            ddy0 * (ddy0 * z4 + 2 * ddy1 * x3 + ddx1 * x5) +
            ddy1_ddy1 * z9);
    const t2 = dddx * (dx0 * (dx0_dy2 + 2 * z1) + dy0 * (dx1_dx1 + 3 * z2)) -
        dddy * (dx0 * (3 * z3 + x1) + dy0 * x4) +
        3 * (ddx0 * (ddy0 * x5 - ddx0 * x3 + 2 * (ddy1 * z8 - ddx1 * z9)) +
            ddx1 * (dx0 * (x8 - ddx1 * dy0) - dy0 * (2 * ddy0 * dy1 + ddy1 * dy0)) +
            ddy0 * (ddy0 * z1 + dx0 * (2 * ddy1 * dy1 + ddy0 * dy2)) +
            ddy1 * dy0 * x8);
    const t1 = (qq * uu + 2 * rr * ss) - 3 * (vv * yy + ww * xx);
    const t0 = ss * qq - 3 * vv * xx;
    const r3 = ddx1 * dy2 - ddy1 * dx2;
    const r2 = ddx0 * dy2 + ddx1 * dy1 - ddy0 * dx2 - ddy1 * dx1;
    const r1 = ddx0_dy1 + ddx1_dy0 - ddy0_dx1 - ddy1_dx0;
    const r0 = ddx0_dy0 - ddy0_dx0;
    return {
        inflectionPoly: [r3, r2, r1, r0],
        otherExtremaPoly: [t5, t4, t3, t2, t1, t0]
    };
}


;// CONCATENATED MODULE: ./src/get-curvature-extrema/get-curvature-extrema.ts





/**
 * Returns the parameter `t` values (in `[0,1]`) of local minimum / maximum
 * absolute curvature for the given bezier curve.
 *
 * If there are an infinite number of such t values (such as is the case for a
 * line), an empty array is returned.
 *
 * * see [MvG](https://math.stackexchange.com/a/1956264/130809)'s excellent
 * answer on math.stackexchange
 *
 * @param ps an order 1, 2 or 3 bezier curve given as an array of control
 * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`
 *
 * @doc mdx
 */
function getCurvatureExtrema(ps) {
    if (isLine(ps)) {
        return { minima: [], maxima: [], inflections: [] };
    }
    if (ps.length === 4 && isCubicReallyQuad(ps)) {
        ps = toQuadraticFromCubic(ps);
    }
    if (ps.length === 3) {
        const poly = getCurvatureExtremaQuadraticPoly(ps);
        const maxima = allRoots(poly, 0, 1);
        return {
            minima: [],
            maxima,
            inflections: []
        };
    }
    const polys = getAbsCurvatureExtremaPolys(ps);
    const p1 = polys.inflectionPoly;
    const p2 = polys.otherExtremaPoly;
    const ts = allRoots(p2, 0, 1);
    // get second derivative (using product rule) to see if it is a local 
    // minimum or maximum, i.e. diff(p1*p2) = p1'*p2 + p1*p2' = dp1*p2 + p1*dp2
    // = p1*dp2 (since dp1*p2 === 0)
    const dp2 = differentiate(p2);
    const minima = [];
    const maxima = [];
    for (let i = 0; i < ts.length; i++) {
        const t = ts[i];
        const dp2_ = Horner(dp2, t);
        const p1_ = Horner(p1, t);
        const secondDerivative = p1_ * dp2_;
        if (secondDerivative >= 0) {
            minima.push(t);
        }
        else {
            maxima.push(t);
        }
    }
    const inflections = allRoots(p1, 0, 1);
    return { minima, maxima, inflections };
}
/**
 * Returns the polynomial whose zero is the t value of maximum absolute
 * curvature for the given *quadratic* bezier curve.
 *
 * * **precondition:** the given parabola is not degenerate to a line
 * * **non-exact:** there is floating point roundof during calculation
 * * see e.g. [math.stackexchange](https://math.stackexchange.com/a/2971112)'s
 * answer by [KeithWM](https://math.stackexchange.com/a/2971112/130809)
 *
 * @param ps an order 2 bezier curve given as an array of control points,
 * e.g. `[[0,0],[1,1],[2,1]]`
 *
 * @internal
 */
function getCurvatureExtremaQuadraticPoly(ps) {
    // Find the point of max curvature (of the parabola)
    // calculate t*
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    const x10 = x1 - x0;
    const x21 = x2 - x1;
    const wx = x21 - x10;
    const y10 = y1 - y0;
    const y21 = y2 - y1;
    const wy = y21 - y10;
    const n = x0 * (wx - x1) - x1 * (x21 - x1) +
        y0 * (wy - y1) - y1 * (y21 - y1);
    const d = wx * wx + wy * wy;
    return [d, -n];
}


;// CONCATENATED MODULE: ./src/global-properties/flatness.ts


/**
 * Returns a flatness measure of the given curve - calculated as the total
 * distance between consecutive control points divided by the distance between
 * the endpoints.
 *
 * @param ps An order 1,2 or 3 bezier curve.
 *
 * @doc mdx
 */
function flatness(ps) {
    return lengthUpperBound(ps) / distanceBetween(ps[0], ps[ps.length - 1]);
}


;// CONCATENATED MODULE: ./src/transformation/split-merge-clone/split-by-max-curvature.ts


/**
 * Split the order 1, 2 or 3 bezier into pieces (given as an array of parameter
 * (t) values) such that each piece is flat within a given tolerance given by
 * the flatness function.
 *
 * @param ps
 * @param tolerance maximum tolerance (must be > 1) for flatness measure.
 *
 * @doc
 */
function splitByMaxCurvature(ps, tolerance = 1.1) {
    const ts = [0, 1]; // include endpoints
    const tStack = [[0, 1]];
    const fromTo_ = split_merge_clone_from_to_fromTo(ps);
    while (tStack.length) {
        const ts_ = tStack.pop();
        const ps_ = fromTo_(ts_[0], ts_[1]);
        //lengthUpperBound(ps) / distanceBetween(ps[0], ps[ps.length-1])
        if (flatness(ps_) > tolerance) {
            const t = (ts_[0] + ts_[1]) / 2;
            tStack.push([ts_[0], t]);
            tStack.push([t, ts_[1]]);
            ts.push(t);
        }
    }
    ts.sort((a, b) => a - b);
    return ts;
}


;// CONCATENATED MODULE: ./src/transformation/split-merge-clone/split-by-curvature-and-length.ts



/**
 * Split the order 1, 2 or 3 bezier into pieces (given as an array of parameter
 * (t) values) such that each piece is flat within a given tolerance given by
 * maxFlatness and maxLength.
 *
 * @param ps
 * @param maxFlatness
 * @param maxLength
 *
 * @doc
 */
function splitByCurvatureAndLength(ps, maxFlatness = 1.001, maxLength = 10) {
    const ts = [0, 1]; // include endpoints
    const tStack = [[0, 1]];
    const fromTo_ = split_merge_clone_from_to_fromTo(ps);
    while (tStack.length) {
        // Tell TypeScript there *is* something in the stack.
        const ts_ = tStack.pop();
        const ps_ = fromTo_(ts_[0], ts_[1]);
        const l1 = lengthUpperBound(ps_);
        const l2 = distanceBetween(ps_[0], ps_[ps_.length - 1]);
        const flatness_ = 1 + (l1 / l2 - 1) * (l1 / maxLength);
        if (flatness_ > maxFlatness) {
            const t = (ts_[0] + ts_[1]) / 2;
            tStack.push([ts_[0], t]);
            tStack.push([t, ts_[1]]);
            ts.push(t);
        }
    }
    ts.sort((a, b) => a - b);
    return ts;
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-xy/exact/evaluate-exact.ts


/**
 * Returns the result of evaluating the given bezier curve at the parameter `t`
 * exactly (up to underflow / overflow).
 *
 * * **precondition:** TODO underflow/overflow
 * * the result is returned as `[x,y]`, where `x` and `y` are Shewchuk floating
 * point expansions
 *
 * @param ps
 * @param t
 *
 * @doc
 */
function evaluateExact(ps, t) {
    const len = ps.length;
    if (t === 0) {
        return [[ps[0][0]], [ps[0][1]]];
    }
    if (t === 1) {
        return [[ps[len - 1][0]], [ps[len - 1][1]]];
    }
    const [X, Y] = getXYExact(ps);
    // wrap the last number as a Shewchuck expansion of length 1
    // @ts-ignore
    X[len - 1] = [X[len - 1]];
    // @ts-ignore
    Y[len - 1] = [Y[len - 1]];
    return [
        eHorner(X, t),
        eHorner(Y, t)
    ];
}


;// CONCATENATED MODULE: ./src/simultaneous-properties/are-beziers-in-same-k-family.ts


// TODO - bitlength calculation below is wrong due to evaluation.
// TODO - this algorithm is wrong - it actually checks for infinite number
// of intersections (which includes same-k-family cases) - could implicitizion provide a solution??
// TODO - also consider order 1 and 2 (and 0?) cases
/**
 * Returns true if two beziers are in the same K-family, i.e. when their infinte
 * extensions is the same curve.
 *
 * * probably better to use the bezierBezierIntersection function and see if it
 * returns undefined which is the case iff the two beziers are in the same
 * k-family.
 * * **precondition:** neither given bezier curve may have *all* its control
 * points the same point (i.e. neither bezier curve may effectively be a point)
 * * **precondition:** underflow / overflow
 *
 * @param ps1 A bezier curve
 * @param ps2 Another bezier curve
 *
 * @doc
 */
function areBeziersInSameKFamily(ps1, ps2) {
    // Get `(ps1.length * ps2.length) + 1` points on the first bezier or its 
    // extension. This number is chosen because there are a maximum of 
    // `(ps1.length * ps2.length)` intersections between the two bezier curves
    // according to Bezout's Theorem. Thus if say 10 (for 2 cubics) unique 
    // points on one curve are also on the other then they are algebraically
    // identical.
    const len = (ps1.length - 1) * (ps2.length - 1) + 1;
    const mid = Math.ceil(len / 2);
    for (let i = 1; i < len + 1; i++) {
        // Make each parametric `t`-value an integer power of two to keep the 
        // bitlength a minimum (1 in this case).
        // For 2 cubics for example we will have t values of:
        // `[0.0625, 0.125, 0.25, 0.5, 1, 2, 4, 8, 16, 32]`
        const t = 2 ** (i - mid);
        const p = evaluateExact(ps1, t);
        if (!isPointOnBezierExtension(ps2, p)) {
            return false;
        }
    }
    return true;
}


;// CONCATENATED MODULE: ./src/global-properties/type/is-self-overlapping.ts

/**
 * Returns true if the given bezier is a line and self-overlapping, i.e. if it
 * intersects itself at an infinite number of points.
 *
 * * a bezier curve can only intersect itself at an infinite number of
 * points if is a self-overlapping line.
 *
 * * **Robust** via adaptive infinite precision floating point arithmetic.
 *
 * @param ps An order 1, 2 or 3 bezier curve
 *
 * @doc mdx
 */
function isSelfOverlapping(ps) {
    if (!isLine(ps)) {
        return false;
    }
    // Check if control points are non-strict monotone
    const xs = ps.map(p => p[0]);
    const ys = ps.map(p => p[1]);
    return !(isMonotone(xs) && isMonotone(ys));
}
/**
 * Returns true if the given array of numbers are non-strict monotone increasing.
 * @param xs An array of numbers
 */
function isMonotoneIncreasing(xs) {
    for (let i = 1; i < xs.length; i++) {
        if (xs[i - 1] > xs[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Returns true if the given array of numbers are non-strict monotone decreasing.
 * @param xs An array of numbers
 */
function isMonotoneDecreasing(xs) {
    for (let i = 1; i < xs.length; i++) {
        if (xs[i - 1] < xs[i]) {
            return false;
        }
    }
    return true;
}
function isMonotone(xs) {
    return isMonotoneIncreasing(xs) || isMonotoneDecreasing(xs);
}


;// CONCATENATED MODULE: ./src/global-properties/bounds/get-bounds.ts






const { sqrtWithErr: get_bounds_sqrtWithErr, divWithErr: get_bounds_divWithErr } = node_operators;
const get_bounds_abs = Math.abs;
const get_bounds_u = Number.EPSILON / 2;
const get_bounds_1 = error_analysis_(1);
/**
 * Returns a tight axis-aligned bounding box bound of the given bezier curve.
 *
 * @param ps an order 1, 2 or 3 bezier curve given as an array of control
 * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`
 *
 * @internal
 */
function getXBoundsTight(ps) {
    const pS = ps[0];
    const pE = ps[ps.length - 1];
    let minX;
    let maxX;
    if (pS[0] < pE[0]) {
        minX = { ts: [0, 0], box: [pS, pS] };
        maxX = { ts: [1, 1], box: [pE, pE] };
    }
    else {
        minX = { ts: [1, 1], box: [pE, pE] };
        maxX = { ts: [0, 0], box: [pS, pS] };
    }
    if (ps.length === 2) {
        return { minX, maxX };
    }
    const [dx,] = getDxy(ps);
    // Roots of derivative
    let rootsX;
    if (ps.length === 4) {
        rootsX = quadRoots(dx);
    }
    else { // ps.length === 3
        rootsX = getLinearRoots(dx);
    }
    // Test points
    for (let i = 0; i < rootsX.length; i++) {
        const r = rootsX[i];
        const ts = [r.r - r.rE, r.r + r.rE];
        const box = getIntervalBox(ps, ts);
        if (box[0][0] < minX.box[0][0]) {
            minX = { ts, box };
        }
        if (box[1][0] > maxX.box[0][0]) {
            maxX = { ts, box };
        }
    }
    return { minX, maxX };
}
/**
 * Returns a tight axis-aligned bounding box bound of the given bezier curve.
 * @param ps an order 1, 2 or 3 bezier curve given as an array of control
 * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`
 *
 * @internal
 */
function getYBoundsTight(ps) {
    const pS = ps[0];
    const pE = ps[ps.length - 1];
    let minY;
    let maxY;
    if (pS[1] < pE[1]) {
        minY = { ts: [0, 0], box: [pS, pS] };
        maxY = { ts: [1, 1], box: [pE, pE] };
    }
    else {
        minY = { ts: [1, 1], box: [pE, pE] };
        maxY = { ts: [0, 0], box: [pS, pS] };
    }
    if (ps.length === 2) {
        return { minY, maxY };
    }
    const [, dy] = getDxy(ps);
    // Roots of derivative
    let rootsY;
    if (ps.length === 4) {
        rootsY = quadRoots(dy);
    }
    else { // ps.length === 3
        rootsY = getLinearRoots(dy);
    }
    // Test points
    for (let i = 0; i < rootsY.length; i++) {
        const r = rootsY[i];
        const ts = [r.r - r.rE, r.r + r.rE];
        const box = getIntervalBox(ps, ts);
        if (box[0][1] < minY.box[0][1]) {
            minY = { ts, box };
        }
        if (box[1][1] > maxY.box[0][1]) {
            maxY = { ts, box };
        }
    }
    return { minY, maxY };
}
/**
 * @internal
 */
function getLinearRoots([a, b]) {
    const r = -b / a;
    const rE = get_bounds_u * get_bounds_abs(b / a);
    if (r + rE > 0 && r - rE < 1) {
        return [{ r, rE }];
    }
    return [];
}
/**
 * Return quad roots in range [0,1] with error assuming input coefficients
 * are exact.
 *
 * @internal
 */
function quadRoots([a, b, c]) {
    // first check a !== 0, else get root of the line 'bt + c = 0'
    if (a === 0) {
        return getLinearRoots([b, c]);
    }
    // DD = discriminant = b^2 - 4ac
    // calculate DD and its absolute error DD_
    const bb = b * b;
    const bb_ = get_bounds_u * bb; // the error bound in b**2
    const ac4 = 4 * a * c;
    const ac4_ = 4 * get_bounds_u * get_bounds_abs(a * c);
    const DD = bb - ac4;
    const DD_ = bb_ + ac4_ + get_bounds_1 * get_bounds_abs(DD);
    // If the discriminant is smaller than negative the error bound then
    // certainly there are no roots.
    if (DD <= -DD_) {
        // discriminant is definitely negative
        return [];
    }
    // discriminant is definitely positive
    const { est: D, err: D_ } = get_bounds_sqrtWithErr(DD, DD_);
    let q1;
    if (b >= 0) {
        // const r1 = (-b - D) / 2*a;
        // const r2 = (2*c) / (-b - D);
        q1 = -b - D;
    }
    else {
        // const r2 = (-b + D) / 2*a;
        // const r1 = (2*c) / (-b + D);
        q1 = -b + D;
    }
    const q1_ = D_ + get_bounds_1 * get_bounds_abs(q1);
    const { est: r1, err: r1_ } = get_bounds_divWithErr(q1, 2 * a, q1_, 0);
    const { est: r2, err: r2_ } = get_bounds_divWithErr(2 * c, q1, 0, q1_);
    const res = [];
    if (r1 + r1_ > 0 && r1 - r1_ < 1) {
        res.push({ r: r1, rE: r1_ });
    }
    if (r2 + r2_ > 0 && r2 - r2_ < 1) {
        res.push({ r: r2, rE: r2_ });
    }
    return res;
}
/**
 * Returns the axis-aligned bounding box together with the t values where the
 * bounds on the bezier are reached.
 *
 * @param ps an order 1, 2 or 3 bezier curve given as an array of control
 * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`
 *
 * @doc mdx
 */
function getBounds(ps) {
    // Roots of derivative
    const dxy = getDxy(ps);
    const rootsX = allRoots(dxy[0], 0, 1);
    const rootsY = allRoots(dxy[1], 0, 1);
    // Endpoints
    rootsX.push(0, 1);
    rootsY.push(0, 1);
    let minX = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    let tMinX;
    let tMaxX;
    let tMinY;
    let tMaxY;
    // Test points
    for (let i = 0; i < rootsX.length; i++) {
        const t = rootsX[i];
        const [x,] = evalDeCasteljau(ps, t);
        if (x < minX) {
            minX = x;
            tMinX = t;
        }
        if (x > maxX) {
            maxX = x;
            tMaxX = t;
        }
    }
    for (let i = 0; i < rootsY.length; i++) {
        const t = rootsY[i];
        const [, y] = evalDeCasteljau(ps, t);
        if (y < minY) {
            minY = y;
            tMinY = t;
        }
        if (y > maxY) {
            maxY = y;
            tMaxY = t;
        }
    }
    // `tMinX`, ... is guaranteed defined below - TS was (understandably) 
    // unable to follow the logic.
    const ts = [[tMinX, tMinY], [tMaxX, tMaxY]];
    const box = [[minX, minY], [maxX, maxY]];
    return { ts, box };
}


;// CONCATENATED MODULE: ./src/global-properties/bounds/get-bounding-box.ts

/**
 * Returns an axis-aligned bounding box of the given order 1, 2 or 3 bezier
 * curve given as an array of 2 points, e.g. `[[1,2], [3,4]]`.
 *
 * * **certified:** the box is guaranteed to engulf the given bezier curve.
 *
 * * returns the axis-aligned bounding box in the form `[[minX, minY], [maxX, maxY]`
 *
 * @param ps an order 1, 2 or 3 bezier curve given as an array of control
 * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`
 *
 * @doc mdx
 */
// TODO - why not just use getIntervalBox
function getBoundingBox(ps) {
    const xBounds = getXBoundsTight(ps);
    const yBounds = getYBoundsTight(ps);
    return [
        [xBounds.minX.box[0][0], yBounds.minY.box[0][1]],
        [xBounds.maxX.box[1][0], yBounds.maxY.box[1][1]]
    ];
}


;// CONCATENATED MODULE: ./src/global-properties/bounds/get-bounding-box-tight.ts




/**
 * Returns a **non-certified**, **rotated**, **tight** bounding box of the given
 * order 1, 2 or 3 bezier curve as four ordered points of a rotated rectangle.
 * (Each point is given as `[x,y]`)
 *
 * @param ps an order 1, 2 or 3 bezier curve given as an array of control
 * points, e.g. `[[0,0], [1,1], [2,1], [2,0]]`
 *
 * @doc mdx
 */
function getBoundingBoxTight(ps) {
    const [xS, yS] = ps[0];
    const [xE, yE] = ps[ps.length - 1];
    let sinθ;
    let cosθ;
    // take care of the case the endpoints are close together
    const len = lengthSquaredUpperBound(ps);
    if (squared_distance_between_squaredDistanceBetween(ps[0], ps[ps.length - 1]) * 2 ** 8 < len) {
        const [xE_, yE_] = evalDeCasteljau(ps, 0.5);
        const hypotenuse = Math.sqrt((xE_ - xS) * (xE_ - xS) + (yE_ - yS) * (yE_ - yS));
        sinθ = (yE_ - yS) / hypotenuse;
        cosθ = (xE_ - xS) / hypotenuse;
    }
    else {
        const hypotenuse = Math.sqrt((xE - xS) * (xE - xS) + (yE - yS) * (yE - yS));
        sinθ = (yE - yS) / hypotenuse;
        cosθ = (xE - xS) / hypotenuse;
    }
    const box = getNormalizedBoundingBox(ps, sinθ, cosθ);
    const [[p0x, p0y], [p1x, p1y]] = box;
    const axisAlignedBox = [
        box[0], [p1x, p0y],
        box[1], [p0x, p1y]
    ];
    const rotate_ = rotate(sinθ, cosθ);
    return axisAlignedBox.map(p => translate(ps[0], rotate_(p)));
}
/**
 * Helper function. Returns the bounding box of the normalized (i.e. first point
 * moved to origin and rotated so that last point lies on x-axis) given cubic
 * bezier.
 *
 * * returns the bounding box in the form [[minX, minY], [maxX,maxY]
 *
 * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 * @param sinθ - Sine of angle made by line from first bezier point to
 * last with x-axis.
 * @param cosθ - Cosine of angle made by line from first bezier point
 * to last with x-axis.
 *
 * @internal
 */
function getNormalizedBoundingBox(ps, sinθ, cosθ) {
    const vectorToOrigin = ps[0].map(x => -x);
    const f = translate(vectorToOrigin);
    const boundingPs = ps.map(p => rotate(-sinθ, cosθ, f(p)));
    return getBoundingBox(boundingPs);
}


;// CONCATENATED MODULE: ./src/transformation/degree-or-type/to-hybrid-quadratic.ts
/**
 * Returns the hybrid quadratic version of the given cubic bezier. For a
 * definition of hybrid quadratic bezier curves please see this paper:
 * http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd
 *
 * * returns an array of three quadratic bezier points where the
 * middle point is a 'hybrid' point represented as a line (itself represented
 * by two points (a linear bezier curve)) which can be evaluated at a different
 * t value (call it th). If evaluated at the same t value the result is the same
 * as evaluating the original cubic bezier at t. The set generated by evaluating
 * the hybrid quadratic curve for all (t,th) value pairs forms a geometric area
 * bound around the orginal cubic bezier curve. The length of the linear bezier
 * curve mentioned above is a measure of how closely the cubic can be
 * represented as a quadratic bezier curve.
 *
 * @param ps a cubic bezier curve.
 *
 * @doc mdx
 */
function to_hybrid_quadratic_toHybridQuadratic(ps) {
    if (ps.length === 4) {
        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        return [
            [x0, y0],
            [
                [(3 * x1 - x0) / 2, (3 * y1 - y0) / 2],
                [(3 * x2 - x3) / 2, (3 * y2 - y3) / 2] // evaluated at t
            ],
            [x3, y3] // evaluated at t
        ];
    }
    throw new Error('The given bezier curve is invalid (it must be a cubic)');
}


;// CONCATENATED MODULE: ./src/to-power-basis/get-xy/double-double/get-xy-dd.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_xy_dd_td = node_twoDiff; // error -> 0
const get_xy_dd_qmd = node_ddMultDouble2; // error -> 3*u²
const get_xy_dd_qaq = node_ddAddDd;
const get_xy_dd_qad = node_ddAddDouble; // error -> 2*u²
const get_xy_dd_ts = node_twoSum;
// TODO - modify docs (the doc below is from `getXY`)
/**
 * Returns the power basis representation of a line, quadratic or cubic bezier.
 *
 * * **non-exact:** if certain preconditions are met (see below) it returns the
 * exact result, else round-off may have occured during intermediate calculation.
 * * returns the power basis polynomial from highest power to lowest,
 * e.g. `at^3 + bt^2 + ct + d` is returned as `[a,b,c,d]`
 *
 * * **bitlength:** If the coordinates of the control points are bit-aligned then:
 *  * max bitlength increase = 4 (for cubics)
 * (due to 'multiplication' by 9 (3x 6x 3x)
 *  * max bitlength increase = 2 (for quadratics)
 * (due to 'multiplication' by 4 (1x 2x 1x)
 *  * max bitlength increase = 1 (for lines)
 * (due to 'multiplication' by 4 (1x 1x)
 *
 * @param ps an order 1, 2 or 3 bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]
 *
 * @doc
 */
function getXY3Dd(ps) {
    const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    // ----------------------------
    // xx3 = (x3 - x0) + 3*(x1 - x2)
    // ----------------------------
    const xx3 = get_xy_dd_qaq(get_xy_dd_td(x3, x0), get_xy_dd_qmd(3, get_xy_dd_td(x1, x2)));
    // ----------------------------
    // xx2 = 3*((x2 + x0) - 2*x1)
    // ----------------------------
    const xx2 = get_xy_dd_qmd(3, get_xy_dd_qad(get_xy_dd_ts(x2, x0), -2 * x1));
    // ----------------------------
    // xx1 = 3*(x1 - x0)
    // ----------------------------
    const xx1 = get_xy_dd_qmd(3, get_xy_dd_td(x1, x0));
    // ----------------------------
    // yy3 = (y3 - y0) + 3*(y1 - y2)
    // ----------------------------
    const yy3 = get_xy_dd_qaq(get_xy_dd_td(y3, y0), get_xy_dd_qmd(3, get_xy_dd_td(y1, y2)));
    // ----------------------------
    // yy2 = 3*((y2 + y0) - 2*y1)
    // ----------------------------
    const yy2 = get_xy_dd_qmd(3, get_xy_dd_qad(get_xy_dd_ts(y2, y0), -2 * y1));
    // ----------------------------
    // yy1 = 3*(y1 - y0)
    // ----------------------------
    const yy1 = get_xy_dd_qmd(3, get_xy_dd_td(y1, y0));
    return [[xx3, xx2, xx1, x0], [yy3, yy2, yy1, y0]];
}
/**
 * only quadratic monomial coefficient has an error, the others are exact
 * @param ps
 */
function getXY2Dd(ps) {
    const [[x0, y0], [x1, y1], [x2, y2]] = ps;
    // ---------------------
    // xx2 = x2 + x0 - 2*x1
    // ---------------------
    const xx2 = get_xy_dd_qad(get_xy_dd_ts(x2, x0), -2 * x1);
    // ---------------------
    // xx1 = 2*(x1 - x0)
    // ---------------------
    const xx1 = get_xy_dd_td(2 * x1, 2 * x0); // error free
    // ---------------------
    // yy2 = y2 + y0 - 2*y1
    // ---------------------
    const yy2 = get_xy_dd_qad(get_xy_dd_ts(y2, y0), -2 * y1);
    // ---------------------
    // yy1 = 2*(y1 - y0)
    // ---------------------
    const yy1 = get_xy_dd_td(2 * y1, 2 * y0); // error free
    return [[xx2, xx1, x0], [yy2, yy1, y0]];
}
/**
 * * exact for any bitlength
 * @param ps linear bezier curve
 */
function getXY1Dd(ps) {
    const [[x0, y0], [x1, y1]] = ps;
    return [[
            get_xy_dd_td(x1, x0),
            x0,
        ], [
            get_xy_dd_td(y1, y0),
            y0,
        ]];
}


;// CONCATENATED MODULE: ./src/intersection/circle-bezier-intersection/double-double/get-coeffs-dd.ts


// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
const get_coeffs_dd_tp = node_twoProduct;
const get_coeffs_dd_qaq = node_ddAddDd;
const get_coeffs_dd_qm2 = node_ddMultBy2;
const get_coeffs_dd_qmn2 = node_ddMultByNeg2;
const get_coeffs_dd_qdifq = node_ddDiffDd;
const get_coeffs_dd_qmq = node_ddMultDd;
const get_coeffs_dd_qmd = node_ddMultDouble2;
/**
 * * **precondition** TODO - underflow/overflow conditions
 *
 * @param circle a circle
 * @param ps a cubic bezier curve
 *
 * @internal
 */
function getCoeffsCubicDd(circle, ps) {
    const { radius: r, center: [cx, cy] } = circle;
    const [[a3, a2, a1, a0], [b3, b2, b1, b0]] = getXY3Dd(ps);
    // a3*a3 + b3*b3
    const t6 = get_coeffs_dd_qaq(get_coeffs_dd_qmq(a3, a3), get_coeffs_dd_qmq(b3, b3));
    // 2*(a2*a3 + b2*b3)
    const t5 = get_coeffs_dd_qm2(get_coeffs_dd_qaq(get_coeffs_dd_qmq(a2, a3), get_coeffs_dd_qmq(b2, b3)));
    // 2*(a1*a3 + b1*b3) + (a2*a2 + b2*b2)
    const t4 = get_coeffs_dd_qaq(get_coeffs_dd_qm2(get_coeffs_dd_qaq(get_coeffs_dd_qmq(a1, a3), get_coeffs_dd_qmq(b1, b3))), get_coeffs_dd_qaq(get_coeffs_dd_qmq(a2, a2), get_coeffs_dd_qmq(b2, b2)));
    // ((2*a0*a3 + 2*a1*a2) + (2*b0*b3 + 2*b1*b2)) + (-2*a3*cx + -2*b3*cy)
    const t3 = get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_qmd(2 * a0, a3), get_coeffs_dd_qmq(get_coeffs_dd_qm2(a1), a2)), get_coeffs_dd_qaq(get_coeffs_dd_qmd(2 * b0, b3), get_coeffs_dd_qmq(get_coeffs_dd_qm2(b1), b2))), get_coeffs_dd_qaq(get_coeffs_dd_qmd(-2 * cx, a3), get_coeffs_dd_qmd(-2 * cy, b3)));
    // ((2*a0*a2 + 2*b0*b2) + (a1*a1 + b1*b1)) + (-2*a2*cx + -2*b2*cy)
    const t2 = get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_qmd(2 * a0, a2), get_coeffs_dd_qmd(2 * b0, b2)), get_coeffs_dd_qaq(get_coeffs_dd_qmq(a1, a1), get_coeffs_dd_qmq(b1, b1))), get_coeffs_dd_qaq(get_coeffs_dd_qmd(-2 * cx, a2), get_coeffs_dd_qmd(-2 * cy, b2)));
    // (2*a0*a1 + 2*b0*b1) - (2*a1*cx + 2*b1*cy)
    const t1 = get_coeffs_dd_qdifq(get_coeffs_dd_qaq(get_coeffs_dd_qmd(2 * a0, a1), get_coeffs_dd_qmd(2 * b0, b1)), get_coeffs_dd_qaq(get_coeffs_dd_qmd(2 * cx, a1), get_coeffs_dd_qmd(2 * cy, b1)));
    // - 2*(a0*cx + b0*cy) + (((a0**2 + b0**2) + (cx**2 + cy**2)) - r**2)
    const t0 = get_coeffs_dd_qaq(get_coeffs_dd_qmn2(get_coeffs_dd_qaq(get_coeffs_dd_tp(a0, cx), get_coeffs_dd_tp(b0, cy))), // -2*(a0*cx + b0*cy)
    get_coeffs_dd_qdifq(get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_tp(a0, a0), get_coeffs_dd_tp(b0, b0)), // a0**2 + b0**2
    get_coeffs_dd_qaq(get_coeffs_dd_tp(cx, cx), get_coeffs_dd_tp(cy, cy)) // cx**2 + cy**2
    ), get_coeffs_dd_tp(r, r) // r**2
    ));
    return [t6, t5, t4, t3, t2, t1, t0];
}
/**
 * * **precondition** TODO - underflow/overflow conditions
 *
 * @param circle a circle
 * @param ps a quadratic bezier curve
 *
 * @internal
 */
function getCoeffsQuadraticDd(circle, ps) {
    const { radius: r, center: [cx, cy] } = circle;
    const [[a2, a1, a0], [b2, b1, b0]] = getXY2Dd(ps);
    // a2*a2 + b2*b2
    const t4 = get_coeffs_dd_qaq(get_coeffs_dd_qmq(a2, a2), get_coeffs_dd_qmq(b2, b2));
    // 2*a1*a2 + 2*b1*b2 
    const t3 = get_coeffs_dd_qaq(get_coeffs_dd_qmq(get_coeffs_dd_qm2(a1), a2), get_coeffs_dd_qmq(get_coeffs_dd_qm2(b1), b2));
    // ((2*a0*a2 + 2*b0*b2) + (a1*a1 + b1*b1)) + (-2*a2*cx + -2*b2*cy)
    const t2 = get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_qmd(2 * a0, a2), get_coeffs_dd_qmd(2 * b0, b2)), get_coeffs_dd_qaq(get_coeffs_dd_qmq(a1, a1), get_coeffs_dd_qmq(b1, b1))), get_coeffs_dd_qaq(get_coeffs_dd_qmd(-2 * cx, a2), get_coeffs_dd_qmd(-2 * cy, b2)));
    // (2*a0*a1 + 2*b0*b1) + (-2*a1*cx + -2*b1*cy)
    const t1 = get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_qmd(2 * a0, a1), get_coeffs_dd_qmd(2 * b0, b1)), get_coeffs_dd_qaq(get_coeffs_dd_qmd(-2 * cx, a1), get_coeffs_dd_qmd(-2 * cy, b1)));
    // ((a0*a0 + b0*b0) + (-2*a0*cx + -2*b0*cy)) + ((cx*cx + cy*cy) - r*r)
    const t0 = get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_tp(a0, a0), get_coeffs_dd_tp(b0, b0)), get_coeffs_dd_qaq(get_coeffs_dd_tp(-2 * a0, cx), get_coeffs_dd_tp(-2 * b0, cy))), get_coeffs_dd_qdifq(get_coeffs_dd_qaq(get_coeffs_dd_tp(cx, cx), get_coeffs_dd_tp(cy, cy)), get_coeffs_dd_tp(r, r)));
    return [t4, t3, t2, t1, t0];
}
/**
 * * **precondition** TODO - underflow/overflow conditions
 *
 * @param circle a circle
 * @param ps a linear bezier curve
 *
 * @internal
 */
function getCoeffsLinearDd(circle, ps) {
    const { radius: r, center: [cx, cy] } = circle;
    const [[a1, a0], [b1, b0]] = getXY1Dd(ps);
    // a1**2 + b1**2
    const t2 = get_coeffs_dd_qaq(get_coeffs_dd_qmq(a1, a1), get_coeffs_dd_qmq(b1, b1));
    // 2*((a0*a1 + b0*b1) - (a1*cx + b1*cy))
    const t1 = get_coeffs_dd_qm2(get_coeffs_dd_qdifq(get_coeffs_dd_qaq(get_coeffs_dd_qmd(a0, a1), get_coeffs_dd_qmd(b0, b1)), get_coeffs_dd_qaq(get_coeffs_dd_qmd(cx, a1), get_coeffs_dd_qmd(cy, b1))));
    // ((-2*a0*cx + -2*b0*cy) + (a0*a0 + b0*b0)) + ((cx*cx + cy*cy) - r*r)
    const t0 = get_coeffs_dd_qaq(get_coeffs_dd_qaq(get_coeffs_dd_qmn2(get_coeffs_dd_qaq(get_coeffs_dd_tp(a0, cx), get_coeffs_dd_tp(b0, cy))), get_coeffs_dd_qaq(get_coeffs_dd_tp(a0, a0), get_coeffs_dd_tp(b0, b0))), get_coeffs_dd_qdifq(get_coeffs_dd_qaq(get_coeffs_dd_tp(cx, cx), get_coeffs_dd_tp(cy, cy)), get_coeffs_dd_tp(r, r)));
    return [t2, t1, t0];
}


;// CONCATENATED MODULE: ./src/intersection/circle-bezier-intersection/exact/get-coeffs-exact.ts

// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗

const get_coeffs_exact_tp = two_product_twoProduct;
const calc = eCalculate;
const get_coeffs_exact_sce = scaleExpansion;
/**
 * Returns an error-free polynomial in 1 variable
 * whose roots are the parameter values of the intersection points of a circle
 * and a cubic bezier curve.
 *
 * The returned polynomial degree will be 6
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** TODO - overflow/underflow
 * * the returned polynomial coefficients are exact (i.e. error-free)
 *
 * @param circle a circle
 * @param ps a cubic bezier curve
 *
 * @internal
 */
function getCoeffsCubicExact(circle, ps) {
    const { radius: r, center: c } = circle;
    const [cx, cy] = c;
    const [[a3, a2, a1, x0], [b3, b2, b1, y0]] = getXY3Exact(ps);
    const a0 = [x0];
    const b0 = [y0];
    // (a3**2 + b3**2)*t**6 + 
    const t6 = calc([
        [a3, a3],
        [b3, b3]
    ]);
    // (2*a2*a3 + 2*b2*b3)*t**5 + 
    const t5 = get_coeffs_exact_sce(calc([
        [a2, a3],
        [b2, b3]
    ]), 2);
    // (2*a1*a3 + a2**2 + 2*b1*b3 + b2**2)*t**4 + 
    const t4 = calc([
        [[2], a1, a3], [a2, a2], [[2], b1, b3], [b2, b2]
    ]);
    // (2*a0*a3 + 2*a1*a2 - 2*a3*cx + 2*b0*b3 + 2*b1*b2 - 2*b3*cy)*t**3 + 
    const t3 = get_coeffs_exact_sce(calc([
        [a0, a3], [a1, a2], [[-1], a3, [cx]], [b0, b3], [b1, b2], [[-1], b3, [cy]]
    ]), 2);
    // (2*a0*a2 + a1**2 - 2*a2*cx + 2*b0*b2 + b1**2 - 2*b2*cy)*t**2 + 
    const t2 = calc([
        [[2], a0, a2], [a1, a1], [[-2], a2, [cx]], [[2], b0, b2], [b1, b1], [[-2], b2, [cy]]
    ]);
    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + 
    const t1 = get_coeffs_exact_sce(calc([
        [a0, a1], [[-1], a1, [cx]], [b0, b1], [[-1], b1, [cy]]
    ]), 2);
    // a0**2 - 2*a0*cx + b0**2 - 2*b0*cy + cx**2 + cy**2 - r**2
    const t0 = calc([
        [a0, a0], [[-2], a0, [cx]], [b0, b0], [[-2], b0, [cy]],
        [get_coeffs_exact_tp(cx, cx)], [get_coeffs_exact_tp(cy, cy)], [get_coeffs_exact_tp(-r, r)]
    ]);
    return [t6, t5, t4, t3, t2, t1, t0];
}
/**
 * Returns an error-free polynomial in 1 variable
 * whose roots are the parameter values of the intersection points of a circle
 * and a quadratic bezier curve.
 *
 * The returned polynomial degree will be 4
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** none
 * * the returned polynomial coefficients are exact (i.e. error-free)
 *
 * @param circle a circle
 * @param ps a quadratic bezier curve
 */
function getCoeffsQuadraticExact(circle, ps) {
    const { radius: r, center: c } = circle;
    const [cx, cy] = c;
    const [[a2, a1, x0], [b2, b1, y0]] = getXY2Exact(ps);
    const a0 = [x0];
    const b0 = [y0];
    // (a2**2 + b2**2)*t**4 + 
    const t4 = calc([
        [a2, a2],
        [b2, b2]
    ]);
    // (2*a1*a2 + 2*b1*b2)*t**3 + 
    const t3 = get_coeffs_exact_sce(calc([
        [a1, a2],
        [b1, b2]
    ]), 2);
    // (2*a0*a2 + a1**2 - 2*a2*cx + 2*b0*b2 + b1**2 - 2*b2*cy)*t**2 + 
    const t2 = calc([
        [[2], a0, a2], [a1, a1], [[-2], a2, [cx]], [[2], b0, b2], [b1, b1], [[-2], b2, [cy]]
    ]);
    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + 
    const t1 = get_coeffs_exact_sce(calc([
        [a0, a1], [[-1], a1, [cx]], [b0, b1], [[-1], b1, [cy]]
    ]), 2);
    // a0**2 - 2*a0*cx + b0**2 - 2*b0*cy + cx**2 + cy**2 - r**2
    const t0 = calc([
        [a0, a0], [[-2], a0, [cx]], [b0, b0], [[-2], b0, [cy]],
        [get_coeffs_exact_tp(cx, cx)], [get_coeffs_exact_tp(cy, cy)], [get_coeffs_exact_tp(-r, r)]
    ]);
    return [t4, t3, t2, t1, t0];
}
/**
 * Returns an error-free polynomial in 1 variable
 * whose roots are the parameter values of the intersection points of a circle
 * and a linear bezier curve (i.e. a line).
 *
 * The returned polynomial degree will be 2
 * (see [Bézout's theorem](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_theorem))
 *
 * The returned polynomial coefficients are given densely as an array of
 * Shewchuk floating point expansions from highest to lowest power,
 * e.g. `[[5],[-3],[0]]` represents the polynomial `5x^2 - 3x`.
 *
 * * **precondition:** none
 * * the returned polynomial coefficients are exact (i.e. error-free)
 *
 * @param circle a circle
 * @param ps a linear bezier curve
 */
function getCoeffsLinearExact(circle, ps) {
    const { radius: r, center: c } = circle;
    const [cx, cy] = c;
    const [[a1, x0], [b1, y0]] = getXY1Exact(ps);
    const a0 = [x0];
    const b0 = [y0];
    // (a1**2 + b1**2)*t**2 +
    const t2 = calc([
        [a1, a1],
        [b1, b1]
    ]);
    // (2*a0*a1 - 2*a1*cx + 2*b0*b1 - 2*b1*cy)*t + 
    const t1 = get_coeffs_exact_sce(calc([
        [a0, a1], [[-1], a1, [cx]], [b0, b1], [[-1], b1, [cy]]
    ]), 2);
    // a0**2 - 2*a0*cx + b0**2 - 2*b0*cy + cx**2 + cy**2 - r**2
    const t0 = calc([
        [a0, a0], [[-2], a0, [cx]], [b0, b0], [[-2], b0, [cy]],
        [get_coeffs_exact_tp(cx, cx)], [get_coeffs_exact_tp(cy, cy)], [get_coeffs_exact_tp(-r, r)]
    ]);
    return [t2, t1, t0];
}


;// CONCATENATED MODULE: ./src/intersection/circle-bezier-intersection/get-circle-bezier-intersection-error-counters.ts

const get_circle_bezier_intersection_error_counters_abs = Math.abs;
/**
 * * **precondition** TODO - underflow/overflow conditions
 *
 * @param circle a circle
 * @param ps a cubic bezier curve
 *
 * ```
 * // (1 x γ) the error counters for double precision!
 * // (6 x γγ) the error counters for double-double precision!
 * return [
 *      t6_,  // <8>
 *      t5_,  // <8>
 *      t4_,  // <9>
 *      t3_,  // <9>
 *      t2_,  // <8>
 *      t1_,  // <5>
 *      t0_   // <5>
 * ];
 * ```
 *
 * @internal
 */
function getCoeffsCubicErrorCounters(circle, ps) {
    const { radius: r, center: [cx, cy] } = circle;
    const [[a3_, a2_, a1_, /*0*/], // <3>a3_, <3>a2_, <2>a1_, <0>a0_  (a0_ is just abs(a0))
    [b3_, b2_, b1_, /*0*/] // <3>b3_, <3>b2_, <2>b1_, <0>b0_  (b0_ is just abs(b0))
    ] = getXY3ErrorCounters(ps);
    const p0 = ps[0];
    const a0_ = get_circle_bezier_intersection_error_counters_abs(p0[0]);
    const b0_ = get_circle_bezier_intersection_error_counters_abs(p0[1]);
    const cx_ = get_circle_bezier_intersection_error_counters_abs(cx);
    const cy_ = get_circle_bezier_intersection_error_counters_abs(cy);
    // a3*a3 + b3*b3
    // <8> <-- <8>(<7>(<3>a3*<3>a3) + <7>(<3>b3*<3>b3))
    const t6_ = a3_ * a3_ + b3_ * b3_;
    // 2*a2*a3 + 2*b2*b3
    // <8> <-- 2*a2*a3 + 2*b2*b3
    const t5_ = 2 * (a2_ * a3_ + b2_ * b3_);
    // (2*a1*a3 + 2*b1*b3) + (a2*a2 + b2*b2)
    // <9> <-- <9>(<7>(2*(<6>a1*a3 + <6>b1*b3)) + <8>(<7>a2*a2 + <7>b2*b2))
    const t4_ = 2 * (a1_ * a3_ + b1_ * b3_) + (a2_ * a2_ + b2_ * b2_);
    // ((2*a0*a3 + 2*a1*a2) + (2*b0*b3 + 2*b1*b2)) + (-2*a3*cx + -2*b3*cy)
    // 2*(((a0*a3 + a1*a2) + (b0*b3 + b1*b2)) + (a3*cx + b3*cy))
    // <9> <-- 2*<9>(<8>(<7>(<4>a0*a3 + <6>a1*a2) + <7>(<4>b0*b3 + <6>b1*b2)) + <5>(<4>(a3*cx) + <4>(b3*cy)))
    const t3_ = 2 * (((a0_ * a3_ + a1_ * a2_) + (b0_ * b3_ + b1_ * b2_)) + (a3_ * cx_ + b3_ * cy_));
    // ((2*a0*a2 + 2*b0*b2) + (a1*a1 + b1*b1)) + (-2*a2*cx + -2*b2*cy)
    // (2*(a0*a2 + b0*b2) + (a1*a1 + b1*b1)) + -2*(a2*cx + b2*cy)
    // <8> <-- <8>(<7>(2*<5>(<4>(a0*a2) + <4>(b0*b2)) + <6>(<5>(a1*a1) + <5>(b1*b1))) + <5>(-2*(<4>(a2*cx) + <4>(b2*cy))))
    const t2_ = (2 * (a0_ * a2_ + b0_ * b2_) + (a1_ * a1_ + b1_ * b1_)) + 2 * (a2_ * cx_ + b2_ * cy_);
    // (2*a0*a1 + 2*b0*b1) - (2*a1*cx + 2*b1*cy)
    // 2*(a0*a1 + b0*b1) - 2*(a1*cx + b1*cy);
    // <5> <-- <5>(<4>(2*(<3>(a0*a1) + <3>b0*b1)) - <4>(2*(<3>(a1*cx) + <3>(b1*cy))));
    const t1_ = 2 * ((a0_ * a1_ + b0_ * b1_) + (a1_ * cx_ + b1_ * cy_));
    // - 2*(a0*cx + b0*cy) + (((a0**2 + b0**2) + (cx**2 + cy**2)) - r**2)
    // <5> <--  <5>(<2>(-2*(<1>(a0*cx) + <1>(b0*cy))) + <4>(<3>(<2>(<1>(a0**2) + <1>(b0**2)) + <2>(<1>(cx**2) + <1>(cy**2))) - <1>(r**2)));
    const t0_ = 2 * (a0_ * cx_ + b0_ * cy_) + (((a0_ * a0_ + b0_ * b0_) + (cx_ * cx_ + cy_ * cy_)) + r * r);
    return [
        t6_,
        t5_,
        t4_,
        t3_,
        t2_,
        t1_,
        t0_ // <5>
    ];
}
/**
 * * **precondition** TODO - underflow/overflow conditions
 *
 * @param circle a circle
 * @param ps a quadratic bezier curve
 *
 * @internal
 *
 * ```
 * return [
 *      t4_,  // <6>
 *      t3_,  // <5>
 *      t2_,  // <6>
 *      t1_,  // <4>
 *      t0_   // <4>
 * ];
 * ```
 */
function getCoeffsQuadraticErrorCounters(circle, ps) {
    const { radius: r, center: [cx, cy] } = circle;
    const [[a2_, a1_, /*0*/], // <2>a2_, <1>a1_, <0>a0_  (a0_ is just abs(a0))
    [b2_, b1_, /*0*/] // <2>b2_, <1>b1_, <0>b0_  (b0_ is just abs(b0))
    ] = getXY2ErrorCounters(ps);
    const p0 = ps[0];
    const a0_ = get_circle_bezier_intersection_error_counters_abs(p0[0]);
    const b0_ = get_circle_bezier_intersection_error_counters_abs(p0[1]);
    const cx_ = get_circle_bezier_intersection_error_counters_abs(cx);
    const cy_ = get_circle_bezier_intersection_error_counters_abs(cy);
    // <6> <-- <6>(<5>(a2*a2) + <5>(b2*b2))
    const t4_ = a2_ * a2_ + b2_ * b2_;
    // 2*a1*a2 + 2*b1*b2
    // <5> <-- <5>(2*(<4>(a1*a2) + <4>(b1*b2)))
    const t3_ = 2 * (a1_ * a2_ + b1_ * b2_);
    // <6> <-- <6>(<5>(2*<4>(<3<(a0*a2) + <3<(b0*b2)) + <4>(<3<(a1*a1) + <3<(b1*b1))) + -2*<4>(<3>(a2*cx) + <3>(b2*cy)))
    const t2_ = (2 * (a0_ * a2_ + b0_ * b2_) + (a1_ * a1_ + b1_ * b1_)) + 2 * (a2_ * cx_ + b2_ * cy_);
    // <4> <-- <4>(2*(<3>(<2>(a0*a1) + <2>(b0*b1))) + -2*<3>(<2>(a1*cx) + <2>(b1*cy)))
    const t1_ = 2 * ((a0_ * a1_ + b0_ * b1_) + (a1_ * cx_ + b1_ * cy_));
    // (a0*a0 + b0*b0) + (-2*a0*cx + -2*b0*cy) + (cx*cx + cy*cy) - r*r
    // <4> <-- <4>(<3>(<2>(<1>(a0*a0) + <1>(b0*b0)) + <2>(-2*(<1>(a0*cx) + <1>(b0*cy)))) + <3>(<2>(<1>(cx*cx) + <1>(cy*cy)) - <1>(r*r)))
    const t0_ = ((a0_ * a0_ + b0_ * b0_) + 2 * (a0_ * cx_ + b0_ * cy_)) + ((cx_ * cx_ + cy_ * cy_) + r * r);
    return [t4_, t3_, t2_, t1_, t0_];
}
/**
 * * **precondition** TODO - underflow/overflow conditions
 *
 * @param circle a circle
 * @param ps a linear bezier curve
 *
 * @internal
 *
 * ```
 * return [
 *      t2_,  // <4>
 *      t1_,  // <4>
 *      t0_   // <4>
 * ];
 * ```
 */
function getCoeffsLinearErrorCounters(circle, ps) {
    const { radius: r, center: [cx, cy] } = circle;
    const [[a1_, /*0*/], // <1>a1_, <0>a0_  (a0_ is just abs(a0))
    [b1_, /*0*/] // <1>b1_, <0>b0_  (b0_ is just abs(b0))
    ] = getXY1ErrorCounters(ps);
    const p0 = ps[0];
    const a0_ = get_circle_bezier_intersection_error_counters_abs(p0[0]);
    const b0_ = get_circle_bezier_intersection_error_counters_abs(p0[1]);
    const cx_ = get_circle_bezier_intersection_error_counters_abs(cx);
    const cy_ = get_circle_bezier_intersection_error_counters_abs(cy);
    // <4> <-- <4>(<3>(a1*a1) + <3>(b1*b1))
    const t2_ = a1_ * a1_ + b1_ * b1_;
    // <4> <-- <4>(2*(<3>(<2>(a0*a1) + <2>(b0*b1)) - <3>(<2>(a1*cx) + <2>(b1*cy))))
    const t1_ = 2 * ((a0_ * a1_ + b0_ * b1_) + (a1_ * cx_ + b1_ * cy_));
    // <4> <-- <4>(<3>(-2*<2>(<1>(a0*cx) + <1>(b0*cy)) + <2>(a0*a0 + b0*b0)) + <3>(<2>(cx*cx + cy*cy) - <1>(r*r)))
    const t0_ = (2 * (a0_ * cx_ + b0_ * cy_) + (a0_ * a0_ + b0_ * b0_)) + ((cx_ * cx_ + cy_ * cy_) + r * r);
    return [t2_, t1_, t0_];
}


;// CONCATENATED MODULE: ./src/intersection/circle-bezier-intersection/circle-bezier-intersection.ts





const circle_bezier_intersection_6 = error_analysis_error_analysis_(6);
/**
 * Returns the intersection between a circle and linear, quadratic or cubic bezier
 * curve.
 *
 * The algorithm employed uses advanced techniques such
 * as floating point error bounding, adaptive multi-precision floating
 * point arithmetic, pre-filtering of easy cases, certified root finding and
 * algebraic implicitization of the curves in order to find *guaranteed* accurate
 * results (see points below)
 *
 * * the bezier curve's parameter `t` values are retuned
 * * * **precondition:** TODO - underflow/overflow conditions
 * * this algorithm is mathematically guaranteed accurate to within
 * `4 * Number.EPSILON` in the t values of the bezier curve
 *
 * @param circle
 * @param ps
 *
 * @doc mdx
 */
function circleBezierIntersection(circle, ps) {
    let poly;
    let _polyE;
    let getCoeffsExact;
    if (ps.length === 4) {
        poly = getCoeffsCubicDd(circle, ps);
        _polyE = getCoeffsCubicErrorCounters(circle, ps);
        getCoeffsExact = getCoeffsCubicExact;
    }
    else if (ps.length === 3) {
        poly = getCoeffsQuadraticDd(circle, ps);
        _polyE = getCoeffsQuadraticErrorCounters(circle, ps);
        getCoeffsExact = getCoeffsQuadraticExact;
    }
    else if (ps.length === 2) {
        poly = getCoeffsLinearDd(circle, ps);
        _polyE = getCoeffsLinearErrorCounters(circle, ps);
        getCoeffsExact = getCoeffsLinearExact;
    }
    else {
        // TODO - handle case of bezier curve being degenerate to a point
        throw new Error('The given bezier curve is invalid');
    }
    const polyE = _polyE.map(e => circle_bezier_intersection_6 * e);
    const ts = allRootsCertified(poly, 0, 1, polyE, () => getCoeffsExact(circle, ps));
    return ts;
    //return ts.map(t => {
    //    return {
    //        t: mid(t),
    //        p: evalDeCasteljau(ps, mid(t))
    //    }
    //});
}


;// CONCATENATED MODULE: ./src/local-properties-at-t/t-to-xy/double/evaluate.ts


/**
 * Returns the result of evaluating the given bezier curve at the parameter `t`
 * using power bases conversion and subsequently [Horner's Method](https://en.wikipedia.org/wiki/Horner%27s_method)
 * to evaluate the polynomial in double precision floating point arithmetic.
 *
 * The resulting point `p` is returned as the pair `[x,y]`, where `x` and `y` are
 * double precision floating point numbers.
 *
 * @param ps an order 1, 2 or 3 bezier curve, e.g. `[[0,0],[1,1],[2,1],[2,0]]`
 * @param t the parameter value where the bezier should be evaluated
 *
 * @doc mdx
 */
function evaluate(ps, t) {
    const len = ps.length;
    if (t === 0) {
        return ps[0];
    }
    if (t === 1) {
        return ps[len - 1];
    }
    const [X, Y] = getXY(ps);
    return [
        Horner(X, t),
        Horner(Y, t)
    ];
}


;// CONCATENATED MODULE: ./src/index.ts










// TODO - remove - just for testing









































//import { getCoeffsBez3Dd } from './intersection/self-intersection/get-coefficients/double-double/get-coeffs-bez3-dd.js';








//import { getEndpointIntersections } from './intersection/get-endpoint-intersections.js';














//import { getOtherTs } from './intersection/bezier-bezier-intersection/get-other-ts.js';




























// TODO - ADD!!!





/**
 * Returns the convex hull of a bezier's control points. This hull bounds the
 * bezier curve.
 *
 * The tolerance at which the cross product of two nearly collinear lines of the
 * hull are considered collinear is 1e-12.
 * @param ps - A bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]
 * @returns An ordered array of convex hull points.
 */
const getBoundingHull = grahamScan;
/** Alias of κ. */
//const curvature = κ;
/**
 * Returns a human readable string representation of the given bezier.
 * @param ps - A bezier curve
 */
function src_toString(ps) {
    if (ps.length === 4) {
        const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
        return `[[${x0},${y0}],[${x1},${y1}],[${x2},${y2}],[${x3},${y3}]]`;
    }
    if (ps.length === 3) {
        const [[x0, y0], [x1, y1], [x2, y2]] = ps;
        return `[[${x0},${y0}],[${x1},${y1}],[${x2},${y2}]]`;
    }
    if (ps.length === 2) {
        const [[x0, y0], [x1, y1]] = ps;
        return `[[${x0},${y0}],[${x1},${y1}]]`;
    }
    if (ps.length === 1) {
        const [[x0, y0]] = ps;
        return `[[${x0},${y0}]]`;
    }
}


FloBezier = __webpack_exports__;
/******/ })()
;