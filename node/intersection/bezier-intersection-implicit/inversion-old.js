"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const flo_numerical_1 = require("flo-numerical");
/**
 * Returns the t parameter value of the point closest to the given point of the
 * given bezier curve.
 * * **don't use**: This function has numeric stability issues when the cubic is very close to
 * a line, e.g. 0 0 1 1 2 2 3 3.00000000000001. The same problem would occur by
 * following the example by Tom Sederberg, to quote: "If P1, P2, and P3 are
 * not collinear", and it turns out sometimes they *are* collinear. Use closestPointOnBezierPrecise
 * or closestPointOnBezier instead
 * @param ps
 * @param p
 */
function inversion(ps, p) {
    if (ps.length === 4) {
        return inversion3(ps, p);
    }
    if (ps.length === 3) {
        return inversion2(ps, p);
    }
    if (ps.length === 2) {
        return inversion1(ps, p);
    }
}
exports.inversion = inversion;
/**
 * Returns the t parameter value of the point closest to the given point of the
 * given cubic bezier curve.
 * * **don't use**: This function has numeric stability issues when the cubic is very close to
 * a line, e.g. 0 0 1 1 2 2 3 3.00000000000001. The same problem would occur by
 * following the example by Tom Sederberg, to quote: "If P1, P2, and P3 are
 * not collinear", and it turns out sometimes they *are* collinear.
 * * The bitlength of the control point coordinates of the bezier must <= 49
 * @param ps an order 3 bezier curve
 * @param p a point
 */
function inversion3(ps, p) {
    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;
    let [x, y] = p;
    // The formulas below was generated by the Python Sympy script.
    // Each matrix row below is an inversion formula, but only one of the roots
    // of the polynomials in t is correct. Also, only 2 of the rows are linearly
    // independent.
    //---- Matrix top row
    //let t12 = 
    // -x*y0 + 3*x*y1 - 3*x*y2 + x*y3 + x0*y - x0*y3 - 3*x1*y + 3*x1*y3 + 
    // 3*x2*y - 3*x2*y3 - x3*y + x3*y0 - 3*x3*y1 + 3*x3*y2;
    let t12 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, -y0),
        flo_numerical_1.scaleExpansion(x, 3 * y1),
        flo_numerical_1.scaleExpansion(x, -3 * y2),
        flo_numerical_1.scaleExpansion(x, y3),
        flo_numerical_1.scaleExpansion(y, x0),
        flo_numerical_1.twoProduct(-x0, y3),
        flo_numerical_1.scaleExpansion(y, -3 * x1),
        flo_numerical_1.twoProduct(3 * x1, y3),
        flo_numerical_1.scaleExpansion(y, 3 * x2),
        flo_numerical_1.twoProduct(-3 * x2, y3),
        flo_numerical_1.scaleExpansion(y, -x3),
        flo_numerical_1.twoProduct(x3, y0),
        flo_numerical_1.twoProduct(-3 * x3, y1),
        flo_numerical_1.twoProduct(3 * x3, y2)
    ]);
    //let t11 = 
    // 2*x*y0 - 3*x*y1 + x*y3 - 2*x0*y + 2*x0*y3 + 3*x1*y - 
    // 3*x1*y3 - x3*y - 2*x3*y0 + 3*x3*y1;
    let t11 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, 2 * y0),
        flo_numerical_1.scaleExpansion(x, -3 * y1),
        flo_numerical_1.scaleExpansion(x, y3),
        flo_numerical_1.scaleExpansion(y, -2 * x0),
        flo_numerical_1.twoProduct(2 * x0, y3),
        flo_numerical_1.scaleExpansion(y, 3 * x1),
        flo_numerical_1.twoProduct(-3 * x1, y3),
        flo_numerical_1.scaleExpansion(y, -x3),
        flo_numerical_1.twoProduct(-2 * x3, y0),
        flo_numerical_1.twoProduct(+3 * x3, y1)
    ]);
    //let t10 = -x*y0 + x*y3 + x0*y - x0*y3 - x3*y + x3*y0;
    let t10 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, -y0),
        flo_numerical_1.scaleExpansion(x, y3),
        flo_numerical_1.scaleExpansion(y, x0),
        flo_numerical_1.twoProduct(-x0, y3),
        flo_numerical_1.scaleExpansion(y, -x3),
        flo_numerical_1.twoProduct(x3, y0)
    ]);
    //---- Matrix middle row
    //let t22 = 
    // -2*x*y0 + 6*x*y1 - 6*x*y2 + 2*x*y3 + 2*x0*y - 3*x0*y2 + 
    // x0*y3 - 6*x1*y + 9*x1*y2 - 3*x1*y3 + 6*x2*y + 3*x2*y0 - 9*x2*y1
    // -2*x3*y - x3*y0 + 3*x3*y1;
    let t22 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, -2 * y0),
        flo_numerical_1.scaleExpansion(x, 6 * y1),
        flo_numerical_1.scaleExpansion(x, -6 * y2),
        flo_numerical_1.scaleExpansion(x, 2 * y3),
        flo_numerical_1.scaleExpansion(y, 2 * x0),
        flo_numerical_1.twoProduct(-3 * x0, y2),
        flo_numerical_1.twoProduct(x0, y3),
        flo_numerical_1.scaleExpansion(y, -6 * x1),
        flo_numerical_1.twoProduct(9 * x1, y2),
        flo_numerical_1.twoProduct(-3 * x1, y3),
        flo_numerical_1.scaleExpansion(y, 6 * x2),
        flo_numerical_1.twoProduct(3 * x2, y0),
        flo_numerical_1.twoProduct(-9 * x2, y1),
        flo_numerical_1.scaleExpansion(y, -2 * x3),
        flo_numerical_1.twoProduct(-x3, y0),
        flo_numerical_1.twoProduct(3 * x3, y1)
    ]);
    //let t21 = 
    // 5*x*y0 - 9*x*y1 + 3*x*y2 + x*y3 - 5*x0*y + 6*x0*y2 - x0*y3 + 
    // 9*x1*y - 9*x1*y2 - 3*x2*y - 6*x2*y0 + 9*x2*y1 - x3*y + x3*y0;
    let t21 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, 5 * y0),
        flo_numerical_1.scaleExpansion(x, -9 * y1),
        flo_numerical_1.scaleExpansion(x, 3 * y2),
        flo_numerical_1.scaleExpansion(x, y3),
        flo_numerical_1.scaleExpansion(y, -5 * x0),
        flo_numerical_1.twoProduct(6 * x0, y2),
        flo_numerical_1.twoProduct(-x0, y3),
        flo_numerical_1.scaleExpansion(y, 9 * x1),
        flo_numerical_1.twoProduct(-9 * x1, y2),
        flo_numerical_1.scaleExpansion(y, -3 * x2),
        flo_numerical_1.twoProduct(-6 * x2, y0),
        flo_numerical_1.twoProduct(9 * x2, y1),
        flo_numerical_1.scaleExpansion(y, -x3),
        flo_numerical_1.twoProduct(x3, y0)
    ]);
    //let t20 = -3*x*y0 + 3*x*y2 + 3*x0*y - 3*x0*y2 - 3*x2*y + 3*x2*y0;
    let t20 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, -3 * y0),
        flo_numerical_1.scaleExpansion(x, 3 * y2),
        flo_numerical_1.scaleExpansion(y, 3 * x0),
        flo_numerical_1.twoProduct(-3 * x0, y2),
        flo_numerical_1.scaleExpansion(y, -3 * x2),
        flo_numerical_1.twoProduct(3 * x2, y0)
    ]);
    //---- Matrix bottom row
    //let t32 = 
    // -x*y0 + 3*x*y1 - 3*x*y2 + x*y3 + x0*y - 3*x0*y1 + 3*x0*y2 - 
    // x0*y3 - 3*x1*y + 3*x1*y0 + 3*x2*y - 3*x2*y0 - x3*y + x3*y0;
    let t32 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, -y0),
        flo_numerical_1.scaleExpansion(x, 3 * y1),
        flo_numerical_1.scaleExpansion(x, -3 * y2),
        flo_numerical_1.scaleExpansion(x, y3),
        flo_numerical_1.scaleExpansion(y, x0),
        flo_numerical_1.twoProduct(-3 * x0, y1),
        flo_numerical_1.twoProduct(3 * x0, y2),
        flo_numerical_1.twoProduct(-x0, y3),
        flo_numerical_1.scaleExpansion(y, -3 * x1),
        flo_numerical_1.twoProduct(3 * x1, y0),
        flo_numerical_1.scaleExpansion(y, 3 * x2),
        flo_numerical_1.twoProduct(-3 * x2, y0),
        flo_numerical_1.scaleExpansion(y, -x3),
        flo_numerical_1.twoProduct(x3, y0)
    ]);
    //let t31 = 
    // 3*x*y0 - 6*x*y1 + 3*x*y2 - 3*x0*y + 6*x0*y1 - 3*x0*y2 + 
    // 6*x1*y - 6*x1*y0 - 3*x2*y + 3*x2*y0;
    let t31 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, 3 * y0),
        flo_numerical_1.scaleExpansion(x, -6 * y1),
        flo_numerical_1.scaleExpansion(x, 3 * y2),
        flo_numerical_1.scaleExpansion(y, -3 * x0),
        flo_numerical_1.twoProduct(6 * x0, y1),
        flo_numerical_1.twoProduct(-3 * x0, y2),
        flo_numerical_1.scaleExpansion(y, 6 * x1),
        flo_numerical_1.twoProduct(-6 * x1, y0),
        flo_numerical_1.scaleExpansion(y, -3 * x2),
        flo_numerical_1.twoProduct(3 * x2, y0)
    ]);
    //let t30 = 
    // -3*x*y0 + 3*x*y1 + 3*x0*y - 3*x0*y1 - 3*x1*y + 3*x1*y0;
    let t30 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, -3 * y0),
        flo_numerical_1.scaleExpansion(x, 3 * y1),
        flo_numerical_1.scaleExpansion(y, 3 * x0),
        flo_numerical_1.twoProduct(-3 * x0, y1),
        flo_numerical_1.scaleExpansion(y, -3 * x1),
        flo_numerical_1.twoProduct(3 * x1, y0)
    ]);
    // Inversion formulae are in the form f(x,y) / g(x,y).
    // These formulae come from the rows of a 3x3 matrix with each row an
    // equation of the form at^2 + bt + c and where at least one row is
    // linearly dependent on the other two.
    // Here we have f(x,y) === t0 and g(x,y) === t1
    // So a solution is -t0/t1.
    // But, we should strive for the biggest t1 as this will increase numerical
    // stability and/or decrease the 'difficulty' of the problem.
    // We may end up in each case with 0/0 in which case the t value is at the
    // double point of the cubic bezier - we should then proceed to find this
    // double point and return both relevant t values.
    // subtract t12/t22 times the second row from first
    let a1;
    let b1;
    let a2;
    let b2;
    let a3;
    let b3;
    if (flo_numerical_1.sign(t12) === 0) {
        // the top row equation is already linear
        if (flo_numerical_1.sign(t11) !== 0) {
            a1 = t11;
            b1 = t10;
        } // else the top row reads 0t^2 + 0t + 0 = 0, i.e. the row is already
        // eliminated
    }
    if (flo_numerical_1.sign(t22) === 0) {
        // the middle row equation is already linear
        if (flo_numerical_1.sign(t21) !== 0) {
            a2 = t21;
            b2 = t20;
        } // else the middle row reads 0t^2 + 0t + 0 = 0, i.e. the row is already
        // eliminated
    }
    if (flo_numerical_1.sign(t32) === 0) {
        // the bottom row equation is already linear
        if (flo_numerical_1.sign(t31) !== 0) {
            a3 = t31;
            b3 = t30;
        } // else the bottom row reads 0t^2 + 0t + 0 = 0, i.e. the row is already
        // eliminated
    }
    // eliminate the coefficient of t^2 from the first row (using the second)
    if (flo_numerical_1.sign(t22) !== 0 && flo_numerical_1.sign(t12) !== 0) {
        let d = flo_numerical_1.expansionDiv(t12, t22, 4);
        a1 = flo_numerical_1.expansionDiff(t11, flo_numerical_1.expansionProduct(d, t21));
        b1 = flo_numerical_1.expansionDiff(t10, flo_numerical_1.expansionProduct(d, t20));
    }
    // eliminate the coefficient of t^2 from the second row (using the 3rd)
    if (flo_numerical_1.sign(t32) !== 0 && flo_numerical_1.sign(t22) !== 0) {
        let d = flo_numerical_1.expansionDiv(t22, t32, 4);
        a2 = flo_numerical_1.expansionDiff(t21, flo_numerical_1.expansionProduct(d, t31));
        b2 = flo_numerical_1.expansionDiff(t20, flo_numerical_1.expansionProduct(d, t30));
    }
    // eliminate the coefficient of t^2 from the third row (using the 1st)
    if (flo_numerical_1.sign(t12) !== 0 && flo_numerical_1.sign(t32) !== 0) {
        let d = flo_numerical_1.expansionDiv(t32, t12, 4);
        a3 = flo_numerical_1.expansionDiff(t31, flo_numerical_1.expansionProduct(d, t11));
        b3 = flo_numerical_1.expansionDiff(t30, flo_numerical_1.expansionProduct(d, t10));
    }
    let useRow;
    a1 = a1 || [0];
    a2 = a2 || [0];
    a3 = a3 || [0];
    if (flo_numerical_1.compare(flo_numerical_1.abs(a1), flo_numerical_1.abs(a2)) > 0) {
        if (flo_numerical_1.compare(flo_numerical_1.abs(a1), flo_numerical_1.abs(a3)) > 0) {
            useRow = 1;
        }
        else {
            useRow = 3;
        }
    }
    else {
        if (flo_numerical_1.compare(flo_numerical_1.abs(a2), flo_numerical_1.abs(a3)) > 0) {
            useRow = 2;
        }
        else {
            useRow = 3;
        }
    }
    let a = useRow === 1 ? a1 : useRow === 2 ? a2 : a3;
    let b = useRow === 1 ? b1 : useRow === 2 ? b2 : b3;
    let t = flo_numerical_1.expansionDiv(flo_numerical_1.negativeOf(b), a, 4);
    return flo_numerical_1.estimate(t);
}
/**
 * Returns the t parameter value of the point closest to the given point of the
 * given quadratic bezier curve.
 * * The bitlength of the control point coordinates of the bezier must <= 49
 * @param ps an order 2 bezier curve
 * @param p a point
 */
function inversion2(ps, p) {
    let [[x0, y0], [x1, y1], [x2, y2]] = ps;
    let [x, y] = p;
    // The formulas below was generated by the Python Sympy script.
    // Each matrix row below is an inversion formula.
    //---- Matrix top row
    //let t11 = x*y0 - 2*x*y1 + x*y2 - x0*y + x0*y2 + 2*x1*y - 2*x1*y2 - x2*y - x2*y0 + 2*x2*y1
    let t11 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, y0),
        flo_numerical_1.scaleExpansion(x, -2 * y1),
        flo_numerical_1.scaleExpansion(x, y2),
        flo_numerical_1.scaleExpansion(y, -x0),
        flo_numerical_1.twoProduct(x0, y2),
        flo_numerical_1.scaleExpansion(y, 2 * x1),
        flo_numerical_1.twoProduct(-2 * x1, y2),
        flo_numerical_1.scaleExpansion(y, -x2),
        flo_numerical_1.twoProduct(-x2, y0),
        flo_numerical_1.twoProduct(2 * x2, y1)
    ]);
    //let t10 = - x*y0 + x*y2 + x0*y - x0*y2 - x2*y + x2*y0
    let t10 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, -y0),
        flo_numerical_1.scaleExpansion(x, y2),
        flo_numerical_1.scaleExpansion(y, x0),
        flo_numerical_1.twoProduct(-x0, y2),
        flo_numerical_1.scaleExpansion(y, -x2),
        flo_numerical_1.twoProduct(x2, y0)
    ]);
    let t = flo_numerical_1.expansionDiv(flo_numerical_1.negativeOf(t10), t11, 4);
    return flo_numerical_1.estimate(t);
    //---- Matrix bottom row
    //let t22 = 
    let t21 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, y0),
        flo_numerical_1.scaleExpansion(x, -2 * y1),
        flo_numerical_1.scaleExpansion(x, y2),
        flo_numerical_1.scaleExpansion(y, -x0),
        flo_numerical_1.twoProduct(2 * x0, y1),
        flo_numerical_1.twoProduct(-x0, y2),
        flo_numerical_1.scaleExpansion(y, 2 * x1),
        flo_numerical_1.twoProduct(-2 * x1, y0),
        flo_numerical_1.scaleExpansion(y, -x2),
        flo_numerical_1.twoProduct(x2, y0)
    ]);
    //let t21 = 
    let t20 = flo_numerical_1.calculateSum([
        flo_numerical_1.scaleExpansion(x, -2 * y0),
        flo_numerical_1.scaleExpansion(x, 2 * y1),
        flo_numerical_1.scaleExpansion(y, 2 * x0),
        flo_numerical_1.twoProduct(-2 * x0, y1),
        flo_numerical_1.scaleExpansion(y, -2 * x1),
        flo_numerical_1.twoProduct(2 * x1, y0)
    ]);
}
/**
 * Returns the t parameter value of the point closest to the given point of the
 * given line.
 * * The bitlength of the control point coordinates of the bezier must <= 49
 * @param ps an order 1 bezier curve
 * @param p a point
 */
function inversion1(ps, p) {
    let [[x0, y0], [x1, y1]] = ps;
    let [x, y] = p;
    let x1_x0 = flo_numerical_1.twoDiff(x1, x0);
    let y1_y0 = flo_numerical_1.twoDiff(y1, y0);
    // the compare below ensures numerical stability
    if (flo_numerical_1.compare(x1_x0, y1_y0) > 0) {
        let t = flo_numerical_1.expansionDiv(flo_numerical_1.fastExpansionSum(x, [-x0]), x1_x0, 4);
        return flo_numerical_1.estimate(t);
    }
    let t = flo_numerical_1.expansionDiv(flo_numerical_1.fastExpansionSum(y, [-y0]), flo_numerical_1.twoDiff(y1, y0), 4);
    return flo_numerical_1.estimate(t);
}
/**
 * Returns the t parameter value of the point closest to the given point of the
 * given line.
 * * The bit-aligned bitlength of the control point coordinates of the line and
 * the given point must <= 52
 * * the result is accurate to within 1 ULP
 * @param ps an order 1 bezier curve
 * @param p a point
 */
function inversion1_BL52_1ULP(ps, p) {
    let [[x0, y0], [x1, y1]] = ps;
    let [x, y] = p;
    let x1_x0 = x1 - x0;
    let y1_y0 = y1 - y0;
    // the compare below ensures numerical stability
    return Math.abs(x1_x0) > Math.abs(y1_y0)
        ? (x - x0) / x1_x0
        : (y - y0) / y1_y0;
}
exports.inversion1_BL52_1ULP = inversion1_BL52_1ULP;
//# sourceMappingURL=inversion-old.js.map