{"version":3,"names":[],"mappings":"","sources":["index.d.ts"],"sourcesContent":["import { ICurriedMapFunction2 } from 'flo-vector2d';\nimport { ICurriedMapFunctionSpecial } from 'flo-vector2d';\nimport { getX } from './src/get-x';\nimport { getY } from './src/get-y';\nimport { getDx } from './src/get-dx';\nimport { getDy } from './src/get-dy';\nimport { evaluateX } from './src/evaluate-x';\nimport { evaluateY } from './src/evaluate-y';\nimport { evaluate } from './src/evaluate';\nimport { evaluateDx } from './src/evaluate-dx';\nimport { evaluateDy } from './src/evaluate-dy';\nimport { tangent } from './src/tangent';\nimport { normal } from './src/normal';\nimport { from0ToT } from './src/from-0-to-T';\nimport { fromTTo1 } from './src/from-T-to-1';\nimport { fromTo } from './src/from-to';\nimport { toHybridQuadratic } from './src/to-hybrid-quadratic';\nimport { coincident } from './src/coincident';\nimport { lineIntersection } from './src/line-intersection';\nimport { bezier3Intersection } from './src/bezier3-intersection/bezier3-intersection';\nimport { bezier3IntersectionSylvester } from './src/bezier3-intersection-sylvester/bezier3-intersection-sylvester';\nimport { tsAtX } from './src/ts-at-x';\nimport { tsAtY } from './src/ts-at-y';\nimport { BezDebug } from './src/debug/debug';\nimport { IDrawFunctions } from './src/debug/draw-functions';\nimport { DebugElemType } from './src/debug/debug';\nimport { FatLine } from './src/debug/fat-line';\nimport { deCasteljau } from './src/de-casteljau';\nimport { evalDeCasteljau } from './src/eval-de-casteljau';\ndeclare let rotate: ICurriedMapFunctionSpecial<number, number, number[], number[]>;\ndeclare let translate: ICurriedMapFunction2<number[], number[], number[]>;\n/**\n * Returns the second derivative of the power basis representation of the\n * bezier's x-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The twice differentiated power basis polynomial from\n * highest power to lowest, e.g. at + b is returned as [a,b]\n */\ndeclare let getDdx: (a: number[][]) => number[];\n/**\n * Returns the second derivative of the power basis representation of the\n * bezier's y-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The twice differentiated power basis polynomial from\n * highest power to lowest, e.g. at + b is returned as [a,b]\n */\ndeclare let getDdy: (a: number[][]) => number[];\n/**\n * Returns the third derivative of the power basis representation of the\n * bezier's x-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The thrice differentiated power basis polynomial (a\n * constant in array from), e.g. a is returned as [a]\n */\ndeclare let getDddx: (a: number[][]) => number[];\n/**\n * Returns the third derivative of the power basis representation of the\n * bezier's y-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The thrice differentiated power basis polynomial (a\n * constant in array from), e.g. a is returned as [a]\n */\ndeclare let getDddy: (a: number[][]) => number[];\n/**\n * Returns the convex hull of a bezier's control points. This hull bounds the\n * bezier curve. This function is memoized.\n *\n * The tolerance at which the cross product of two nearly collinear lines of the\n * hull are considered collinear is 1e-12.\n * @param ps - A bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns An ordered array of convex hull points.\n */\ndeclare let getBoundingHull: (a: number[][]) => number[][];\n/**\n * Returns a cubic bezier from the given line with evenly spaced control points.\n * @param l - a 2d line represented by two points\n * @returns Control points of the cubic bezier.\n */\ndeclare function fromLine(l: number[][]): number[][];\n/**\n * Returns the curvature, κ, at a specific t. This function is curried. Alias\n * of curvature.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param t - The parameter value where the curvature should be\n * evaluated\n */\ndeclare function κ(ps: number[][], t: number): number;\ndeclare function κ(ps: number[][]): (t: number) => number;\n/**\n * Alias of κ.\n */\ndeclare let curvature: typeof κ;\n/**\n * Helper function. This function is curried.\n * A modified version of the differential of κ (use quotient rule, ignore\n * denominator and multiply by 2/3). We need to find the zeros of this function\n * to get the min/max curvature.\n * See <a href=\"http://math.info/Calculus/Curvature_Parametric/\">this</a> for\n * more details.\n * @ignore\n**/\ndeclare function dκMod(ps: number[][], t: number): number;\ndeclare function dκMod(ps: number[][]): (t: number) => number;\n/**\n * TODO - replace this function by simply checking tangents at beginning and\n * end of curve.\n * Returns the total curvature of the bezier over the given interval using\n * Gaussian Quadrature integration with 16 wieghts and abscissas which is\n * generally very accurate and fast. This function is curried.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param interval - The interval of integration (often === [0,1])\n * @returns The total curvature.\n */\ndeclare function totalCurvature(ps: number[][], interval: number[]): number;\ndeclare function totalCurvature(ps: number[][]): (interval: number[]) => number;\n/**\n * TODO - replace this function with a more sane version where total curvature\n * is tallied by looking for inflection points and adding curvature over those\n * pieces by looking at tangent at beginning and end of the pieces.\n * Returns the total absolute curvature of the bezier over [0,1] using Gaussian\n * Quadrature integration with 16 wieghts and abscissas which is generally very\n * accurate and fast. Returns the result in radians.\n * @param ps - A cubic bezier\n * @param interval\n */\ndeclare function totalAbsoluteCurvature(ps: number[][], interval: number[]): number;\ndeclare function totalAbsoluteCurvature(ps: number[][]): (interval: number[]) => number;\n/**\n * Returns the curve length in the specified interval. This function is curried.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param interval - The paramter interval over which the lenght is\n * to be calculated (often === [0,1]).\n */\ndeclare function len(interval: number[], ps: number[][]): number;\ndeclare function len(interval: number[]): (ps: number[][]) => number;\n/**\n * Returns the t parameter value where the given cubic bezier reaches the given\n * length, s, starting from t = 0. This function is curried.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param s - The length\n * @returns {number}\n */\ndeclare function getTAtLength(ps: number[][], s: number): number;\ndeclare function getTAtLength(ps: number[][]): (s: number) => number;\n/**\n * Returns the x value of the twice differentiated (with respect to t) cubic\n * bezier when evaluated at t. This function is curried.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param t - The t parameter\n * @returns\n */\ndeclare function evaluateDdx(ps: number[][], t: number): number;\ndeclare function evaluateDdx(ps: number[][]): (t: number) => number;\n/**\n * Returns the y value of the twice differentiated (with respect to t) cubic\n * bezier when evaluated at t. This function is curried.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param t - The t parameter\n * @returns\n */\ndeclare function evaluateDdy(ps: number[][], t: number): number;\ndeclare function evaluateDdy(ps: number[][]): (t: number) => number;\n/**\n * Returns the x value of the thrice differentiated (with respect to t) cubic\n * bezier when evaluated at t. This function is curried.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param t - The t parameter\n */\ndeclare function evaluateDddx(ps: number[][], t: number): number;\ndeclare function evaluateDddx(ps: number[][]): (t: number) => number;\n/**\n * Returns the y value of the thrice differentiated (with respect to t) cubic\n * bezier when evaluated at t. This function is curried.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param t - The t parameter\n */\ndeclare function evaluateDddy(ps: number[][], t: number): number;\ndeclare function evaluateDddy(ps: number[][]): (t: number) => number;\n/**\n * Returns the tight bounding box of the given cubic bezier.\n * @returns The tight bounding box of the bezier as four ordered\n * points of a rotated rectangle.\n * TODO - test case of baseLength === 0\n */\ndeclare let getBoundingBoxTight: (a: number[][]) => number[][];\n/**\n * Returns the axis-aligned bounding box of a given bezier.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns the axis-aligned bounding box in the form\n * [[minx, miny], [maxx,maxy]\n */\ndeclare let getBoundingBox: (a: number[][]) => number[][];\n/**\n * Calculates and returns general bezier bounds.\n * @returns The axis-aligned bounding box together with the t values\n * where the bounds on the bezier are reached.\n */\ndeclare let getBounds: (a: number[][]) => {\n    ts: number[][];\n    box: number[][];\n};\n/**\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\n *\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the curve should be split\n */\ndeclare function splitAt(ps: number[][], t: number): number[][][];\n/**\n * Returns a new bezier from the given bezier by limiting its t range.\n *\n * Uses de Casteljau's algorithm.\n *\n * @param ps A bezier\n * @param tRange A t range\n */\ndeclare function bezierFromBezierPiece(ps: number[][], tRange: number[]): number[][];\n/**\n * Scales all control points of the given bezier by the given factor.\n * @param ps - A bezier curve\n * @param c - The scale factor\n */\ndeclare function scale(ps: number[][], c: number): number[][];\n/**\n * Returns the best least squares quadratic bezier approximation to the given\n * cubic bezier. Note that the two bezier endpoints differ in general.\n * @param ps - A cubic bezier curve.\n */\ndeclare function toQuadratic(ps: number[][]): number[][];\n/**\n * Evaluates the given hybrid quadratic at the given t and th parameters. (see\n * toHybridQuadratic for details).\n * @param hq - A hybrid quadratic\n * @param t - The bezier parameter value\n * @param th - The parameter value for the hybrid quadratic point.\n */\ndeclare function evaluateHybridQuadratic(hq: (number[] | number[][])[], t: number, th: number): number[];\n/**\n * Evaluates the given linear bezier (line) at a specific t value.\n * @param ps - A linear bezier curve.\n * @param t - The value where the bezier should be evaluated\n */\ndeclare function evaluateLinear(ps: number[][], t: number): number[];\n/**\n * Returns a clone of the given cubic bezier. Use sparingly; this is not in the\n * spirit of functional programming.\n * @param ps - A cubic bezier given by its array of control points\n */\ndeclare function clone(ps: number[][]): number[][];\n/**\n * Evaluates the given quadratic bezier at a specific t value.\n * @param ps - A quadratic bezier curve.\n * @param t - The value where the bezier should be evaluated\n */\ndeclare function evaluateQuadratic(ps: number[][], t: number): number[];\n/**\n * Returns the cubic version of the given quadratic bezier curve. Quadratic\n * bezier curves can always be represented by cubics - the converse is false.\n * @param ps - A quadratic bezier curve.\n */\ndeclare function toCubic(ps: number[][]): number[][];\n/**\n * Returns the given points (e.g. bezier) in reverse order.\n * @param ps\n */\ndeclare function reverse(ps: number[][]): number[][];\ndeclare function equal(psA: number[][], psB: number[][]): boolean;\nexport { rotate, getX, getY, getDx, getDy, getDdx, getDdy, getDddx, getDddy, getBounds, bezier3Intersection, bezier3IntersectionSylvester, lineIntersection, tsAtX, tsAtY, getBoundingHull, fromLine, translate, evaluate, κ, dκMod, curvature, tangent, normal, totalCurvature, totalAbsoluteCurvature, len, getTAtLength, evaluateX, evaluateY, evaluateDx, evaluateDy, evaluateDdx, evaluateDdy, evaluateDddx, evaluateDddy, getBoundingBoxTight, getBoundingBox, fromTo, splitAt, scale, toCubic, toQuadratic, toHybridQuadratic, evaluateHybridQuadratic, evaluateQuadratic, evaluateLinear, coincident, from0ToT, fromTTo1, bezierFromBezierPiece, clone, reverse, equal, deCasteljau, evalDeCasteljau };\nexport { BezDebug, IDrawFunctions, DebugElemType, FatLine };\nexport interface BezierPoint {\n    p: number[];\n    t: number;\n}\n"],"file":"index.d.ts"}