{"version":3,"names":[],"mappings":"","sources":["src/bezier3-intersection.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = require(\"flo-poly\");\nconst Vector = require(\"flo-vector2d\");\nconst evaluate_1 = require(\"./evaluate\");\nconst coincident_1 = require(\"./coincident\");\nconst from_to_1 = require(\"./from-to\");\nconst to_hybrid_quadratic_1 = require(\"./to-hybrid-quadratic\");\nconst get_distance_to_line_function_1 = require(\"./get-distance-to-line-function\");\nconst ts_at_x_1 = require(\"./ts-at-x\");\nconst ts_at_y_1 = require(\"./ts-at-y\");\nconst dst = Vector.distanceBetween;\nconst sdst = Vector.squaredDistanceBetween;\n/**\n * Robust, extremely accurate and extremely fast (cubically convergent in\n * general with fast iteration steps) algorithm that returns the intersections\n * between two cubic beziers.\n *\n * At stretches where the two curves run extremely close to (or on top of) each\n * other and curve the same direction an interval is returned instead of a\n * point.\n *\n * The algorithm is based on a <a href=\"http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd\">paper</a>\n * that finds the intersection of a fat line and a so-called geometric interval\n * making it faster and more accurate than the standard fat-line intersection\n * algorithm. The algorithm has been modified to prevent run-away recursion\n * by checking for coincident pieces at subdivision steps.\n *\n * @param ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param ps2 - Another cubic bezier\n * @param [δ] - An optional tolerance to within which the t parameter\n * should be calculated - defaults to the minimum value of 24*Number.EPSILON or\n * approximately 5e-15. Note that it might not make sense to set this to as\n * large as say 1e-5 since only a single iteration later the maximum accuracy\n * will be attained and not much speed will be gained anyway. Similarly if δ is\n * set to 1e-2 only two iterations will be saved. This is due to the algorithm\n * being cubically convergent (usually converging in about 4 to 8 iterations for\n * typical intersections).\n * @param [Δ] - A tolerance that indicates how closely a stretch of the\n * beziers can run together before being considered coincident. Defaults to the\n * minimum possible value of 1e-6 if not specified.\n * @returns An array that contains the t-value pairs at intersection\n * of the first and second beziers respectively. The array can also contain t\n * range pairs for coincident pieces that can be either used or ignored\n * depending on the application, e.g. the return value might be [[0.1,0.2],\n * [0.3,0.5],[[0.4,0.5],[0.6,0.7]]] that indicates intersection points at t\n * values of t1=0.1 and t2=0.2 for the first and second bezier respectively as\n * well as at t1=0.3 and t2=0.5 and finally indicates the curves to be nearly\n * coincident from t1=0.4 to t1=0.5 for the first bezier and t2=0.6 to t=0.7 for\n * the second bezier.\n */\nfunction bezier3Intersection(ps1, ps2, δ, Δ) {\n    // The minimum value Δ can be. If it is too small the algorithm may take too\n    // long in cases where the two curves run extremely close to each other for\n    // their entire length and curve the same direction.\n    const ΔMin = 1e-6;\n    // This is an estimate of the relative floating point error during clipping.\n    // A bound is given by |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k\n    // are the control points indexed by k=0,1,2,3 and η is machine epsilon, \n    // i.e. Number.EPSILON. We quadruple the bound to be sure.\n    const δMin = 24 * Number.EPSILON;\n    // Maximum error - limited to take rounding error into account.\n    if (δ === undefined) {\n        δ = 0;\n    }\n    δ = Math.max(δ, δMin);\n    if (Δ === undefined) {\n        Δ = ΔMin;\n    }\n    Δ = Math.max(Δ, ΔMin);\n    // Intersection t values for both beziers\n    let tss = [];\n    //let iterations = 0;\n    intersection(ps1, ps2, [0, 1], [0, 1], 1);\n    //console.log(iterations);\n    return tss;\n    // Helper function\n    function intersection(Q_, P_, qRange, pRange, idx) {\n        //iterations++;\n        let cidx = idx === 0 ? 1 : 0; // Counter flip-flop index\n        // Move intersection toward the origin to prevent serious floating point \n        // issues that are introduced specifically by the getLineEquation \n        // function. This allows us to get a relative error in the final \n        // result usually in the 10 ULPS or less range.\n        [P_, Q_] = center(P_, Q_);\n        let [Q0, Q1, Q2, Q3] = Q_;\n        let [P0, P1, P2, P3] = P_;\n        // Get the implict line equation for the line from the first to the last\n        // control point of Q. This equation gives the distance between any \n        // point and the line.\n        let dQ = get_distance_to_line_function_1.getDistanceToLineFunction([Q0, Q3]);\n        // Calculate the distance from the control points of Q to the line \n        // [Q0,Q3].\n        let dQi = (i) => dQ(Q_[i]);\n        let dQs = [1, 2].map(dQi);\n        let [dQ1, dQ2] = dQs;\n        // Calculate the fat line of Q.\n        let C = (dQ1 * dQ2 > 0) ? 3 / 4 : 4 / 9;\n        let dMin = C * Math.min(0, dQ1, dQ2);\n        let dMax = C * Math.max(0, dQ1, dQ2);\n        let { tMin, tMax } = geoClip(P_, dQ, dMin, dMax);\n        if (tMin === Number.POSITIVE_INFINITY) {\n            return; // No intersection\n        }\n        // The paper calls for a heuristic that if less than 30% will be\n        // clipped, rather split the longest curve and find intersections in the\n        // two halfs seperately.\n        if (tMax - tMin > 0.7) {\n            // Some length measure\n            let pSpan = pRange[1] - pRange[0];\n            let qSpan = qRange[1] - qRange[0];\n            let pq = coincident_1.coincident(P_, Q_);\n            if (pq !== undefined) {\n                return;\n            }\n            // Split the curve in half\n            if (pSpan <= qSpan) {\n                cidx = idx;\n                [P_, Q_] = [Q_, P_];\n                [pRange, qRange] = [qRange, pRange];\n            }\n            // Update t range.\n            let span = pRange[1] - pRange[0];\n            // 1st half\n            let tMinA = pRange[0];\n            let tMaxA = tMinA + span / 2;\n            // 2nd half\n            let tMinB = tMaxA;\n            let tMaxB = pRange[1];\n            let A = from_to_1.fromTo(P_)(0, 0.5);\n            let B = from_to_1.fromTo(P_)(0.5, 1);\n            intersection(A, Q_, [tMinA, tMaxA], qRange, cidx);\n            intersection(B, Q_, [tMinB, tMaxB], qRange, cidx);\n            return;\n        }\n        // Update t range.\n        let span = pRange[1] - pRange[0];\n        let tMin_ = (tMin * span + pRange[0]);\n        let tMax_ = (tMax * span + pRange[0]);\n        // Clip\n        P_ = from_to_1.fromTo(P_)(tMin, tMax);\n        if (Math.abs(tMax_ - tMin_) < δ) {\n            let t1 = (tMax_ + tMin_) / 2;\n            let pq = idx === 0 ? [ps1, ps2] : [ps2, ps1];\n            let t2 = calcOtherT(t1, pq[0], pq[1]);\n            if (t2 === undefined) {\n                return undefined;\n            }\n            let ts = idx === 0 ? [t1, t2] : [t2, t1];\n            tss.push(ts);\n            return;\n        }\n        // Swap Q and P and iterate.\n        intersection(P_, Q_, [tMin_, tMax_], qRange, cidx);\n    }\n}\nexports.bezier3Intersection = bezier3Intersection;\n/**\n * @private\n * @param P\n * @param dQ\n * @param dMin\n * @param dMax\n */\nfunction geoClip(P, dQ, dMin, dMax) {\n    let dPi = (i) => dQ(P[i]);\n    let dPs = [0, 1, 2, 3].map(dPi);\n    let [dP0, dP1, dP2, dP3] = dPs;\n    let hq = to_hybrid_quadratic_1.toHybridQuadratic(P);\n    let dH0 = dQ(hq[0]);\n    let dH2 = dQ(hq[2]);\n    let dH10 = dQ(hq[1][0]);\n    let dH11 = dQ(hq[1][1]);\n    let dHmin = Math.min(dH10, dH11);\n    let dHmax = Math.max(dH10, dH11);\n    let DyMin = [\n        dH0 - 2 * dHmin + dH2,\n        -2 * dH0 + 2 * dHmin,\n        dH0\n    ];\n    let DyMax = [\n        dH0 - 2 * dHmax + dH2,\n        -2 * dH0 + 2 * dHmax,\n        dH0\n    ];\n    let errorBound = 2 * Math.max(flo_poly_1.default.hornerErrorBound(DyMin, 1), flo_poly_1.default.hornerErrorBound(DyMax, 1));\n    dMin = dMin - errorBound;\n    dMax = dMax + errorBound;\n    let DyMinMin = DyMin.slice();\n    DyMinMin[2] = DyMinMin[2] - dMin;\n    let DyMinMax = DyMin.slice();\n    DyMinMax[2] = DyMinMax[2] - dMax;\n    let DyMaxMin = DyMax.slice();\n    DyMaxMin[2] = DyMaxMin[2] - dMin;\n    let DyMaxMax = DyMax.slice();\n    DyMaxMax[2] = DyMaxMax[2] - dMax;\n    let tMin = Number.POSITIVE_INFINITY;\n    let tMax = Number.NEGATIVE_INFINITY;\n    let rootsMinMin = flo_poly_1.default.allRoots(DyMinMin, 0, 1);\n    let rootsMinMax = flo_poly_1.default.allRoots(DyMinMax, 0, 1);\n    let rootsMaxMin = flo_poly_1.default.allRoots(DyMaxMin, 0, 1);\n    let rootsMaxMax = flo_poly_1.default.allRoots(DyMaxMax, 0, 1);\n    tMin = Math.min(...rootsMinMin, ...rootsMinMax, ...rootsMaxMin, ...rootsMaxMax);\n    tMax = Math.max(...rootsMinMin, ...rootsMinMax, ...rootsMaxMin, ...rootsMaxMax);\n    if (dH0 >= dMin && dH0 <= dMax) {\n        tMin = 0;\n    }\n    if (dH2 >= dMin && dH2 <= dMax) {\n        tMax = 1;\n    }\n    if (tMin < 0) {\n        tMin = 0;\n    }\n    if (tMax > 1) {\n        tMax = 1;\n    }\n    return { tMin, tMax };\n}\n/**\n * Return the given two beziers but translated such that the shorter (by\n * some length measure) is closer to the origin.\n * @private\n * @param P\n * @param Q\n */\nfunction center(P, Q) {\n    let [P0, P1, P2, P3] = P;\n    let [Q0, Q1, Q2, Q3] = Q;\n    let lengthP = sdst(P0, P1) + sdst(P1, P2) + sdst(P2, P3);\n    let lengthQ = sdst(Q0, Q1) + sdst(Q1, Q2) + sdst(Q2, Q3);\n    let moveX;\n    let moveY;\n    if (lengthQ < lengthP) {\n        moveX = (Q0[0] + Q1[0] + Q2[0] + Q3[0]) / 4;\n        moveY = (Q0[1] + Q1[1] + Q2[1] + Q3[1]) / 4;\n    }\n    else {\n        moveX = (P0[0] + P1[0] + P2[0] + P3[0]) / 4;\n        moveY = (P0[1] + P1[1] + P2[1] + P3[1]) / 4;\n    }\n    P = P.map(x => [x[0] - moveX, x[1] - moveY]);\n    Q = Q.map(x => [x[0] - moveX, x[1] - moveY]);\n    return [P, Q];\n}\n/**\n * Calculates the t-value of the closest point on Q to P(t).\n * @ignore\n * @param {number}\n * @param Q\n * @param P\n */\nfunction calcOtherT(t, P, Q) {\n    let pp = evaluate_1.evaluate(P)(t);\n    let [x, y] = pp;\n    let tqsh = ts_at_y_1.tsAtY(Q, y);\n    let tqsv = ts_at_x_1.tsAtX(Q, x);\n    if (!tqsh.length && !tqsv.length) {\n        return undefined;\n    }\n    let tqs = [...tqsh, ...tqsv];\n    let bestT = undefined;\n    let bestD = Number.POSITIVE_INFINITY;\n    for (let tq of tqs) {\n        let pq = evaluate_1.evaluate(Q)(tq);\n        let d = sdst(pp, pq);\n        if (d < bestD) {\n            bestD = d;\n            bestT = tq;\n        }\n    }\n    return bestT;\n}\n"],"file":"bezier3-intersection.js"}