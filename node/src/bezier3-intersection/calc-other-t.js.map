{"version":3,"names":[],"mappings":"","sources":["src/bezier3-intersection/calc-other-t.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_vector2d_1 = require(\"flo-vector2d\");\nconst evaluate_1 = require(\"../evaluate\");\nconst ts_at_x_1 = require(\"../ts-at-x\");\nconst ts_at_y_1 = require(\"../ts-at-y\");\n/**\n * Calculates the t-value of the closest point on Q to P(t).\n * @param Î´\n * @param t\n * @param P\n * @param Q\n */\nfunction calcOtherT(t, P, Q) {\n    // Get some length measure on P and Q\n    let max = Math.max(P[0][0], P[0][1], P[1][0], P[1][1], P[2][0], P[2][1], P[3][0], P[3][1], Q[0][0], Q[0][1], Q[1][0], Q[1][1], Q[2][0], Q[2][1], Q[3][0], Q[3][1]);\n    let pp = evaluate_1.evaluate(P)(t);\n    let [x, y] = pp;\n    let tqsh = ts_at_y_1.tsAtY(Q, y);\n    let tqsv = ts_at_x_1.tsAtX(Q, x);\n    if (!tqsh.length && !tqsv.length) {\n        return undefined;\n    }\n    let tqs = [...tqsh, ...tqsv];\n    let bestT = undefined;\n    let bestD = Number.POSITIVE_INFINITY;\n    for (let tq of tqs) {\n        let pq = evaluate_1.evaluate(Q)(tq);\n        let d = flo_vector2d_1.squaredDistanceBetween(pp, pq);\n        if (d < bestD) {\n            bestD = d;\n            bestT = tq;\n        }\n    }\n    // If the best distance > the max allowed tolerance then no intersection\n    // occured - this happens only in special cases where clipping occured at\n    // the endpoint of a curve.\n    let maxTolerance = 256 * 24 * Number.EPSILON * max;\n    if (bestD > maxTolerance * maxTolerance) {\n        return undefined;\n    }\n    return bestT;\n}\nexports.calcOtherT = calcOtherT;\n"],"file":"calc-other-t.js"}