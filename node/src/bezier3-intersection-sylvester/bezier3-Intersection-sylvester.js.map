{"version":3,"names":[],"mappings":"","sources":["src/bezier3-intersection-sylvester/bezier3-Intersection-sylvester.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = require(\"flo-poly\");\nconst flo_vector2d_1 = require(\"flo-vector2d\");\nconst get_x_1 = require(\"../get-x\");\nconst get_y_1 = require(\"../get-y\");\nlet DELTA = 10 - 6;\n// Belongs in graveyard because it is not numerically stable enough, e.g. if\n// the cubic bezier resembles a quadratic no intersection can be found.\n/**\n * Returns the intersection points between two cubic beziers. This function is\n * not numerically stable and thus not publically exposed. It can not, for\n * instance, handle cases where one or both beziers degenerate into a quadratic\n * bezier. Use for experimentation and comparison only.\n * @ignore\n * @param ps1 - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param ps2 - Another cubic bezier\n * @returns The t-value pairs at intersection of the first\n * and second beziers respectively.\n * See <a href=\"http://mat.polsl.pl/sjpam/zeszyty/z6/Silesian_J_Pure_Appl_Math_v6_i1_str_155-176.pdf\">\n * this paper</a>\n */\nfunction bezier3IntersectionSylvester(ps1, ps2) {\n    let [x1, y1] = ps1[0];\n    let [x2, y2] = ps2[0];\n    // Rotate by θ so that Δx ≡ d_0x - c_0x === 0 (as suggested by the paper)\n    let rotatedPs1;\n    let rotatedPs2;\n    if (Math.abs(x1 - x2) > 1e-12) {\n        let tanθ = (x1 - x2) / (y1 - y2);\n        let tanθ2 = tanθ * tanθ;\n        let sinθ = (tanθ2) / (1 + tanθ2); // Trig. identity\n        let cosθ = sinθ / tanθ;\n        let rotatedPs1_ = flo_vector2d_1.rotatePs(sinθ, cosθ, ps1);\n        let rotatedPs2_ = flo_vector2d_1.rotatePs(sinθ, cosθ, ps2);\n        rotatedPs1 = rotatedPs1_;\n        rotatedPs2 = rotatedPs2_;\n    }\n    else {\n        rotatedPs1 = ps1;\n        rotatedPs2 = ps2;\n    }\n    // Cache\n    let [c_3x, c_2x, c_1x, c_0x] = get_x_1.getX(rotatedPs1);\n    let [c_3y, c_2y, c_1y, c_0y] = get_y_1.getY(rotatedPs1);\n    let [d_3x, d_2x, d_1x, d_0x] = get_x_1.getX(rotatedPs2);\n    let [d_3y, d_2y, d_1y, d_0y] = get_y_1.getY(rotatedPs2);\n    let [a, b, c, d, e, f] = [d_3x, c_3x, d_2x, c_2x, d_1x, c_1x];\n    //let Δx = d_0x - c_0x; // === 0 after rotation\n    let [m, n, p, q, r, s] = [d_3y, c_3y, d_2y, c_2y, d_1y, c_1y];\n    let Δy = d_0y - c_0y;\n    let a2 = a * a;\n    let b2 = b * b;\n    let c2 = c * c;\n    let d2 = d * d;\n    let e2 = e * e;\n    let f2 = f * f;\n    let m2 = m * m;\n    let n2 = n * n;\n    let p2 = p * p;\n    let q2 = q * q;\n    let r2 = r * r;\n    let s2 = s * s;\n    let Δy2 = Δy * Δy;\n    let a3 = a2 * a;\n    let b3 = b2 * b;\n    let c3 = c2 * c;\n    let d3 = d2 * d;\n    let e3 = e2 * e;\n    let f3 = f2 * f;\n    let Δy3 = Δy2 * Δy;\n    let dΔy = d * Δy;\n    let dΔy2 = d * Δy2;\n    let bdΔy = b * dΔy;\n    let bdΔy2 = b * dΔy2;\n    let cΔy = c * Δy;\n    let cΔy2 = c * Δy2;\n    let bΔy = b * Δy;\n    let bΔy2 = b * Δy2;\n    let bΔy3 = b * Δy3;\n    // Rotate both beziers so that delta-x = 0, i.e. so that the x-coordinate of \n    // both beziers are equal. This reduces the complexity of calculating the \n    // determinant of the Sylvester matrix.\n    let k9 = -b2 * Δy * f * s2 + bdΔy * f * q * s + 2 * bΔy * f2 * n * s - d2 * Δy * f * n * s -\n        b2 * dΔy2 * s - bΔy * f2 * q2 + dΔy * f2 * n * q - 2 * b2 * Δy2 * f * q +\n        d2 * bΔy2 * q - Δy * f3 * n2 + 3 * bdΔy2 * f * n - d3 * Δy2 * n - b3 * Δy3;\n    let k8 = b2 * Δy * e * s2 + 2 * b2 * Δy * f * r * s - bdΔy * e * q * s - 4 * bΔy * e * f * n * s +\n        d2 * Δy * e * n * s - bdΔy * f * q * r - 2 * bΔy * f2 * n * r + d2 * Δy * f * n * r +\n        b2 * dΔy2 * r + 2 * bΔy * e * f * q2 - 2 * dΔy * e * f * n * q + 2 * b2 * Δy2 * e * q +\n        3 * Δy * e * f2 * n2 - 3 * bdΔy2 * e * n;\n    let k7 = -2 * b2 * Δy * e * r * s - b * cΔy * f * q * s - bdΔy * f * p * s + 2 * c * dΔy * f * n * s +\n        2 * bΔy * e2 * n * s + b2 * cΔy2 * s - b2 * Δy * f * r2 + bdΔy * e * q * r +\n        4 * bΔy * e * f * n * r - d2 * Δy * e * n * r - bΔy * e2 * q2 + 2 * bΔy * f2 * p * q -\n        cΔy * f2 * n * q + dΔy * e2 * n * q - 2 * b * c * dΔy2 * q - dΔy * f2 * n * p +\n        2 * b2 * Δy2 * f * p - b * d2 * Δy2 * p - 3 * Δy * e2 * f * n2 - 3 * b * cΔy2 * f * n +\n        3 * c * d2 * Δy2 * n;\n    let k6 = 2 * a * bΔy * f * s2 - a * dΔy * f * q * s + b * cΔy * e * q * s + bdΔy * e * p * s -\n        2 * a * Δy * f2 * n * s - 2 * c * dΔy * e * n * s - 2 * bΔy * f2 * m * s + d2 * Δy * f * m * s +\n        2 * a * bdΔy2 * s + b2 * Δy * e * r2 + b * cΔy * f * q * r + bdΔy * f * p * r -\n        2 * c * dΔy * f * n * r - 2 * bΔy * e2 * n * r - b2 * cΔy2 * r + a * Δy * f2 * q2 -\n        4 * bΔy * e * f * p * q + 2 * cΔy * e * f * n * q - dΔy * f2 * m * q + 4 * a * bΔy2 * f * q -\n        a * d2 * Δy2 * q + 2 * dΔy * e * f * n * p - 2 * b2 * Δy2 * e * p + Δy * e3 * n2 +\n        2 * Δy * f3 * m * n - 3 * a * dΔy2 * f * n + 3 * b * cΔy2 * e * n - 3 * bdΔy2 * f * m +\n        d3 * Δy2 * m + 3 * a * b2 * Δy3;\n    let k5 = -2 * a * bΔy * e * s2 - 4 * a * bΔy * f * r * s + a * dΔy * e * q * s + b * cΔy * f * p * s +\n        4 * a * Δy * e * f * n * s - c2 * Δy * f * n * s + 4 * bΔy * e * f * m * s - d2 * Δy * e * m * s +\n        a * dΔy * f * q * r - b * cΔy * e * q * r - bdΔy * e * p * r + 2 * a * Δy * f2 * n * r +\n        2 * c * dΔy * e * n * r + 2 * bΔy * f2 * m * r - d2 * Δy * f * m * r - 2 * a * bdΔy2 * r -\n        2 * a * Δy * e * f * q2 + 2 * bΔy * e2 * p * q - cΔy * e2 * n * q + 2 * dΔy * e * f * m * q -\n        4 * a * bΔy2 * e * q + b * c2 * Δy2 * q - bΔy * f2 * p2 + cΔy * f2 * n * p -\n        dΔy * e2 * n * p + 2 * b * c * dΔy2 * p - 6 * Δy * e * f2 * m * n + 3 * a * dΔy2 * e * n -\n        3 * c2 * dΔy2 * n + 3 * bdΔy2 * e * m;\n    let k4 = 4 * a * bΔy * e * r * s + a * cΔy * f * q * s + a * dΔy * f * p * s - b * cΔy * e * p * s -\n        2 * a * Δy * e2 * n * s + c2 * Δy * e * n * s - 2 * c * dΔy * f * m * s - 2 * bΔy * e2 * m * s -\n        2 * a * b * cΔy2 * s + 2 * a * bΔy * f * r2 - a * dΔy * e * q * r - b * cΔy * f * p * r -\n        4 * a * Δy * e * f * n * r + c2 * Δy * f * n * r - 4 * bΔy * e * f * m * r + d2 * Δy * e * m * r +\n        a * Δy * e2 * q2 - 2 * a * Δy * f2 * p * q + cΔy * f2 * m * q - dΔy * e2 * m * q +\n        2 * a * c * dΔy2 * q + 2 * bΔy * e * f * p2 - 2 * cΔy * e * f * n * p + dΔy * f2 * m * p -\n        4 * a * bΔy2 * f * p + a * d2 * Δy2 * p + 6 * Δy * e2 * f * m * n + 3 * a * cΔy2 * f * n +\n        3 * b * cΔy2 * f * m - 3 * c * d2 * Δy2 * m;\n    let k3 = -a2 * Δy * f * s2 - a * cΔy * e * q * s - a * dΔy * e * p * s + 2 * a * Δy * f2 * m * s +\n        2 * c * dΔy * e * m * s - a2 * dΔy2 * s - 2 * a * bΔy * e * r2 - a * cΔy * f * q * r -\n        a * dΔy * f * p * r + b * cΔy * e * p * r + 2 * a * Δy * e2 * n * r - c2 * Δy * e * n * r +\n        2 * c * dΔy * f * m * r + 2 * bΔy * e2 * m * r + 2 * a * b * cΔy2 * r +\n        4 * a * Δy * e * f * p * q - 2 * cΔy * e * f * m * q - 2 * a2 * Δy2 * f * q - bΔy * e2 * p2 +\n        cΔy * e2 * n * p - 2 * dΔy * e * f * m * p + 4 * a * bΔy2 * e * p - b * c2 * Δy2 * p -\n        2 * Δy * e3 * m * n - 3 * a * cΔy2 * e * n + c3 * Δy2 * n - Δy * f3 * m2 +\n        3 * a * dΔy2 * f * m - 3 * b * cΔy2 * e * m - 3 * a2 * bΔy3;\n    let k2 = a2 * Δy * e * s2 + 2 * a2 * Δy * f * r * s - a * cΔy * f * p * s - 4 * a * Δy * e * f * m * s +\n        c2 * Δy * f * m * s + a * cΔy * e * q * r + a * dΔy * e * p * r - 2 * a * Δy * f2 * m * r -\n        2 * c * dΔy * e * m * r + a2 * dΔy2 * r - 2 * a * Δy * e2 * p * q + cΔy * e2 * m * q +\n        2 * a2 * Δy2 * e * q - a * c2 * Δy2 * q + a * Δy * f2 * p2 - cΔy * f2 * m * p +\n        dΔy * e2 * m * p - 2 * a * c * dΔy2 * p + 3 * Δy * e * f2 * m2 - 3 * a * dΔy2 * e * m +\n        3 * c2 * dΔy2 * m;\n    let k1 = -2 * a2 * Δy * e * r * s + a * cΔy * e * p * s + 2 * a * Δy * e2 * m * s - c2 * Δy * e * m * s +\n        a2 * cΔy2 * s - a2 * Δy * f * r2 + a * cΔy * f * p * r + 4 * a * Δy * e * f * m * r -\n        c2 * Δy * f * m * r - 2 * a * Δy * e * f * p2 + 2 * cΔy * e * f * m * p + 2 * a2 * Δy2 * f * p -\n        3 * Δy * e2 * f * m2 - 3 * a * cΔy2 * f * m;\n    let k0 = a2 * Δy * e * r2 - a * cΔy * e * p * r - 2 * a * Δy * e2 * m * r + c2 * Δy * e * m * r -\n        a2 * cΔy2 * r + a * Δy * e2 * p2 - cΔy * e2 * m * p - 2 * a2 * Δy2 * e * p +\n        a * c2 * Δy2 * p + Δy * e3 * m2 + 3 * a * cΔy2 * e * m - c3 * Δy2 * m + a3 * Δy3;\n    let poly = [k9, k8, k7, k6, k5, k4, k3, k2, k1, k0];\n    let roots = flo_poly_1.default.allRoots(poly, 0);\n    let tPairs = [];\n    for (let i = 0; i < roots.length; i++) {\n        let k = roots[i];\n        let k2 = k * k;\n        let k3 = k2 * k;\n        let ps1k = {\n            x: [c_3x * k3, c_2x * k2, c_1x * k, c_0x],\n            y: [c_3y * k3, c_2y * k2, c_1y * k, c_0y]\n        };\n        let ps2k = {\n            x: [d_3x * k3, d_2x * k2, d_1x * k, d_0x],\n            y: [d_3y * k3, d_2y * k2, d_1y * k, d_0y]\n        };\n        let xx = flo_poly_1.default.subtract(get_x_1.getX(rotatedPs2), ps1k.x);\n        let yy = flo_poly_1.default.subtract(get_y_1.getY(rotatedPs2), ps1k.y);\n        let rootsx = flo_poly_1.default.allRoots(xx, 0, 1);\n        let rootsy = flo_poly_1.default.allRoots(yy, 0, 1);\n        for (let j = 0; j < rootsx.length; j++) {\n            let rootx = rootsx[j];\n            for (let l = 0; l < rootsy.length; l++) {\n                let rooty = rootsy[l];\n                if (Math.abs(rootx - rooty) < DELTA) {\n                    let t = (rootx + rooty) / 2;\n                    let tk = t * k;\n                    if (t >= 0 && t <= 1 && tk >= 0 && tk <= 1) {\n                        tPairs.push([tk, t]);\n                    }\n                }\n            }\n        }\n    }\n    return tPairs;\n}\nexports.bezier3IntersectionSylvester = bezier3IntersectionSylvester;\n"],"file":"bezier3-Intersection-sylvester.js"}