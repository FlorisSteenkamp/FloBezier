{"version":3,"names":[],"mappings":"","sources":["src/coincident.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Vector = require(\"flo-vector2d\");\nconst evaluate_1 = require(\"./evaluate\");\nconst line_intersection_1 = require(\"./line-intersection\");\nconst normal_1 = require(\"./normal\");\nconst sdst = Vector.squaredDistanceBetween;\n/**\n * Check if the two given cubic beziers are nearly coincident everywhere along\n * a finite stretch and returns the coincident stretch (if any), otherwise\n * returns undefined.\n * @param P - A cubic bezier curve.\n * @param Q - Another cubic bezier curve.\n * @param δ - An indication of how closely the curves should stay to\n * each other before considered coincident.\n */\nfunction coincident(P, Q, δ = 1e-6) {\n    //let [P0, P1, P2, P3] = P; \n    //let [Q0, Q1, Q2, Q3] = Q; \n    let PtoQs = [0.01, 0.99].map(i => calcPointAndNeighbor(P, Q, i));\n    let QtoPs = [0.01, 0.99].map(i => calcPointAndNeighbor(Q, P, i));\n    // Check if start and end points are coincident.\n    let tStartQ = 0.01;\n    let tEndQ = 0.99;\n    let tStartP = 0.01;\n    let tEndP = 0.99;\n    /*\n    let c = 0;\n    if (PtoQs[0].d <= δ) { tStartQ = PtoQs[0].t;  c++; }\n    if (PtoQs[1].d <= δ) { tEndQ   = PtoQs[1].t;  c++; }\n    if (QtoPs[0].d <= δ) { tStartP = QtoPs[0].t;  c++; }\n    if (QtoPs[1].d <= δ) { tEndP   = QtoPs[1].t;  c++; }\n    // At least 2 endpoints must be coincident.\n    if (c < 2) { return undefined; }\n    */\n    if (PtoQs[0].d <= δ) {\n        tStartQ = PtoQs[0].t;\n    }\n    if (PtoQs[1].d <= δ) {\n        tEndQ = PtoQs[1].t;\n    }\n    if (QtoPs[0].d <= δ) {\n        tStartP = QtoPs[0].t;\n    }\n    if (QtoPs[1].d <= δ) {\n        tEndP = QtoPs[1].t;\n    }\n    if (tStartP > tEndP) {\n        [tStartP, tEndP] = [tEndP, tStartP];\n    }\n    if (tStartQ > tEndQ) {\n        [tStartQ, tEndQ] = [tEndQ, tStartQ];\n    }\n    let tSpanP = tEndP - tStartP;\n    let tSpanQ = tEndQ - tStartQ;\n    // We must check at least 10 points to ensure entire curve is coincident, \n    // otherwise we may simply have found intersection points. We cannot simply \n    // check the control points for closeness since well seperated control \n    // points does not necessarily translate into well seperated curves.\n    //let lengthP = sdst(P0,P1) + sdst(P1,P2) + sdst(P2,P3);\n    //let lengthQ = sdst(Q0,Q1) + sdst(Q1,Q2) + sdst(Q2,Q3);\n    // If the overlapping part is smaller than 1/10 (a heuristical value) then\n    // do not consider pieces overlapping.\n    if (tSpanP < 0.1 && tSpanQ < 0.1) {\n        return undefined;\n    }\n    let res = true;\n    //for (let i=1; i<10; i++) {\n    for (let i = 0; i < 10; i++) {\n        let t = tStartP + tSpanP * (i / 10);\n        let { d } = calcPointAndNeighbor(P, Q, t);\n        if (d > δ) {\n            return undefined;\n        }\n    }\n    return { p: [tStartP, tEndP], q: [tStartQ, tEndQ] };\n}\nexports.coincident = coincident;\nfunction calcPointAndNeighbor(P, Q, t) {\n    // TODO - must also check crossing of normals - for if two curves open\n    // at endpoints and stop essentially at same point.\n    let pp1 = evaluate_1.evaluate(P)(t);\n    //let normalVector = normal(P)(0);\n    let normalVector = normal_1.normal(P)(t);\n    let pp2 = Vector.translate(pp1, normalVector);\n    let ts = line_intersection_1.lineIntersection(Q, [pp1, pp2]);\n    let bestT = undefined;\n    let bestQ = undefined;\n    let bestD = Number.POSITIVE_INFINITY;\n    for (let t of ts) {\n        let q = evaluate_1.evaluate(Q)(t);\n        let d = Vector.distanceBetween(q, pp1);\n        if (d < bestD) {\n            bestT = t;\n            bestQ = q;\n            bestD = d;\n        }\n    }\n    return { t: bestT, p: bestQ, d: bestD };\n}\n"],"file":"coincident.js"}