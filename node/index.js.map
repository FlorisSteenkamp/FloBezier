{"version":3,"names":[],"mappings":"","sources":["index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst flo_poly_1 = require(\"flo-poly\");\nconst Vector = require(\"flo-vector2d\");\nconst flo_memoize_1 = require(\"flo-memoize\");\nconst flo_gauss_quadrature_1 = require(\"flo-gauss-quadrature\");\nconst flo_graham_scan_1 = require(\"flo-graham-scan\");\nconst get_x_1 = require(\"./src/get-x\");\nexports.getX = get_x_1.getX;\nconst get_y_1 = require(\"./src/get-y\");\nexports.getY = get_y_1.getY;\nconst get_dx_1 = require(\"./src/get-dx\");\nexports.getDx = get_dx_1.getDx;\nconst get_dy_1 = require(\"./src/get-dy\");\nexports.getDy = get_dy_1.getDy;\nconst evaluate_x_1 = require(\"./src/evaluate-x\");\nexports.evaluateX = evaluate_x_1.evaluateX;\nconst evaluate_y_1 = require(\"./src/evaluate-y\");\nexports.evaluateY = evaluate_y_1.evaluateY;\nconst evaluate_1 = require(\"./src/evaluate\");\nexports.evaluate = evaluate_1.evaluate;\nconst evaluate_dx_1 = require(\"./src/evaluate-dx\");\nexports.evaluateDx = evaluate_dx_1.evaluateDx;\nconst evaluate_dy_1 = require(\"./src/evaluate-dy\");\nexports.evaluateDy = evaluate_dy_1.evaluateDy;\nconst tangent_1 = require(\"./src/tangent\");\nexports.tangent = tangent_1.tangent;\nconst normal_1 = require(\"./src/normal\");\nexports.normal = normal_1.normal;\nconst from_0_to_T_1 = require(\"./src/from-0-to-T\");\nexports.from0ToT = from_0_to_T_1.from0ToT;\nconst from_T_to_1_1 = require(\"./src/from-T-to-1\");\nexports.fromTTo1 = from_T_to_1_1.fromTTo1;\nconst from_to_1 = require(\"./src/from-to\");\nexports.fromTo = from_to_1.fromTo;\nconst to_hybrid_quadratic_1 = require(\"./src/to-hybrid-quadratic\");\nexports.toHybridQuadratic = to_hybrid_quadratic_1.toHybridQuadratic;\nconst coincident_1 = require(\"./src/coincident\");\nexports.coincident = coincident_1.coincident;\nconst line_intersection_1 = require(\"./src/line-intersection\");\nexports.lineIntersection = line_intersection_1.lineIntersection;\nconst bezier3_intersection_1 = require(\"./src/bezier3-intersection/bezier3-intersection\");\nexports.bezier3Intersection = bezier3_intersection_1.bezier3Intersection;\nconst bezier3_intersection_sylvester_1 = require(\"./src/bezier3-intersection-sylvester/bezier3-intersection-sylvester\");\nexports.bezier3IntersectionSylvester = bezier3_intersection_sylvester_1.bezier3IntersectionSylvester;\nconst ts_at_x_1 = require(\"./src/ts-at-x\");\nexports.tsAtX = ts_at_x_1.tsAtX;\nconst ts_at_y_1 = require(\"./src/ts-at-y\");\nexports.tsAtY = ts_at_y_1.tsAtY;\nconst debug_1 = require(\"./src/debug/debug\");\nexports.BezDebug = debug_1.BezDebug;\nconst fat_line_1 = require(\"./src/debug/fat-line\");\nexports.FatLine = fat_line_1.FatLine;\nconst de_casteljau_1 = require(\"./src/de-casteljau\");\nexports.deCasteljau = de_casteljau_1.deCasteljau;\nconst eval_de_casteljau_1 = require(\"./src/eval-de-casteljau\");\nexports.evalDeCasteljau = eval_de_casteljau_1.evalDeCasteljau;\n// Possibly typescript bug? Below line does not work\n//const { rotatePs: rotate, translatePs: translate } = Vector;\nlet rotate = Vector.rotatePs;\nexports.rotate = rotate;\nlet translate = Vector.translatePs;\nexports.translate = translate;\nconst memoize = flo_memoize_1.default.m1;\n/**\n * Returns the second derivative of the power basis representation of the\n * bezier's x-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The twice differentiated power basis polynomial from\n * highest power to lowest, e.g. at + b is returned as [a,b]\n */\nlet getDdx = memoize((ps) => flo_poly_1.default.differentiate(get_dx_1.getDx(ps)));\nexports.getDdx = getDdx;\n/**\n * Returns the second derivative of the power basis representation of the\n * bezier's y-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The twice differentiated power basis polynomial from\n * highest power to lowest, e.g. at + b is returned as [a,b]\n */\nlet getDdy = memoize((ps) => flo_poly_1.default.differentiate(get_dy_1.getDy(ps)));\nexports.getDdy = getDdy;\n/**\n * Returns the third derivative of the power basis representation of the\n * bezier's x-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The thrice differentiated power basis polynomial (a\n * constant in array from), e.g. a is returned as [a]\n */\nlet getDddx = memoize((ps) => flo_poly_1.default.differentiate(getDdx(ps)));\nexports.getDddx = getDddx;\n/**\n * Returns the third derivative of the power basis representation of the\n * bezier's y-coordinates. This function is memoized on its points parameter by\n * object reference.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns The thrice differentiated power basis polynomial (a\n * constant in array from), e.g. a is returned as [a]\n */\nlet getDddy = memoize((ps) => flo_poly_1.default.differentiate(getDdy(ps)));\nexports.getDddy = getDddy;\n/**\n * Returns the convex hull of a bezier's control points. This hull bounds the\n * bezier curve. This function is memoized.\n *\n * The tolerance at which the cross product of two nearly collinear lines of the\n * hull are considered collinear is 1e-12.\n * @param ps - A bezier curve, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns An ordered array of convex hull points.\n */\nlet getBoundingHull = memoize(flo_graham_scan_1.default);\nexports.getBoundingHull = getBoundingHull;\n/**\n * Returns a cubic bezier from the given line with evenly spaced control points.\n * @param l - a 2d line represented by two points\n * @returns Control points of the cubic bezier.\n */\nfunction fromLine(l) {\n    let [[x0, y0], [x1, y1]] = l;\n    let xInterval = (x1 - x0) / 3;\n    let yInterval = (y1 - y0) / 3;\n    return [\n        [x0, y0],\n        [x0 + xInterval, y0 + yInterval],\n        [x0 + xInterval * 2, y0 + yInterval * 2],\n        [x1, y1]\n    ];\n}\nexports.fromLine = fromLine;\n/**\n * Returns the given bezier's inflection points.\n **/\nfunction findInflectionPoints(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 4\n    let ax = x1 - x0;\n    let ay = y1 - y0;\n    let bx = x2 - x1 - ax;\n    let by = y2 - y1 - ay;\n    let cx = x3 - x2 - ax - (2 * bx);\n    let cy = y3 - y2 - ay - (2 * by);\n    // From http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html eq. 6:\n    //   infl(t) := ax*by - ay*bx + t*(ax*cy - ay*cx) + t^2*(bx*cy - by*cx);\n    // We find the roots of the quadratic - a,b,c are the quadratic coefficients\n    let a = bx * cy - by * cx;\n    let b = ax * cy - ay * cx;\n    let c = ax * by - ay * bx;\n    let inflectionTs = flo_poly_1.default.allRoots([a, b, c], 0, 1);\n    const evPs = evaluate_1.evaluate(ps);\n    return inflectionTs.map(evPs);\n}\nfunction κ(ps, t) {\n    const evDx = evaluate_dx_1.evaluateDx(ps);\n    const evDy = evaluate_dy_1.evaluateDy(ps);\n    const evDdx = evaluateDdx(ps);\n    const evDdy = evaluateDdy(ps);\n    function f(t) {\n        let dx = evDx(t);\n        let dy = evDy(t);\n        let ddx = evDdx(t);\n        let ddy = evDdy(t);\n        let a = dx * ddy - dy * ddx;\n        let b = Math.sqrt(Math.pow((dx * dx + dy * dy), 3));\n        return a / b;\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nexports.κ = κ;\n/**\n * Alias of κ.\n */\nlet curvature = κ;\nexports.curvature = curvature;\nfunction κds(ps, t) {\n    const evDx = evaluate_dx_1.evaluateDx(ps);\n    const evDy = evaluate_dy_1.evaluateDy(ps);\n    const evDdx = evaluateDdx(ps);\n    const evDdy = evaluateDdy(ps);\n    function f(t) {\n        let dx = evDx(t);\n        let dy = evDy(t);\n        let ddx = evDdx(t);\n        let ddy = evDdy(t);\n        let a = dx * ddy - dy * ddx;\n        let b = dx * dx + dy * dy;\n        return a / b;\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction dκMod(ps, t) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    function f(t) {\n        let ts = t * t;\n        let omt = 1 - t;\n        let a = ts * x3;\n        let b = ts * y3;\n        let c = 2 * t - 3 * ts;\n        let d = (3 * t - 1) * omt;\n        let e = omt * omt;\n        let f = 3 * (a + c * x2 - d * x1 - e * x0);\n        let g = 3 * (b + c * y2 - d * y1 - e * y0);\n        let h = 6 * (t * y3 - (3 * t - 1) * y2 + (3 * t - 2) * y1 + omt * y0);\n        let i = 6 * (t * x3 - (3 * t - 1) * x2 + (3 * t - 2) * x1 + omt * x0);\n        let j = Math.sqrt(f * f + g * g);\n        return 4 * (f * (y3 - 3 * y2 + 3 * y1 - y0) -\n            g * (x3 - 3 * x2 + 3 * x1 - x0)) * Math.pow(j, 3) -\n            (f * h - i * g) * (2 * h * g + 2 * i * f) * j;\n    }\n    return t === undefined ? f : f(t);\n}\nexports.dκMod = dκMod;\n/**\n * Categorizes the given cubic bezier curve according to whether it has a loop,\n * a cusp, or zero, one or two inflection points all of which are mutually\n * exclusive.\n *\n * See <a href=\"http://graphics.pixar.com/people/derose/publications/CubicClassification/paper.pdf\">\n * this</a> paper.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns A value of 'L', 'C', '0', '1', or '2' depending on whether\n * the curve has a loop, a cusp, or zero, one or two inflection points.\n */\nfunction categorize(ps) {\n    // TODO - finish\n}\nfunction totalCurvature(ps, interval) {\n    const tanPs = tangent_1.tangent(ps);\n    function f(interval) {\n        return flo_gauss_quadrature_1.default(κds(ps), interval);\n        // TODO\n        /*\n        let [a,b] = interval;\n        let tangentA = tanPs(a);\n        let tangentB = tanPs(b);\n        let sinθ = Vector.cross(tanA, tanB)\n        */\n    }\n    // Curry\n    return interval === undefined ? f : f(interval);\n}\nexports.totalCurvature = totalCurvature;\nfunction totalAbsoluteCurvature(ps, interval) {\n    function f(interval = [0, 1]) {\n        // Numerically integrate the absolute curvature\n        let result = flo_gauss_quadrature_1.default(t => Math.abs(κds(ps)(t)), interval);\n        return result;\n    }\n    // Curry\n    return interval === undefined ? f : f(interval);\n}\nexports.totalAbsoluteCurvature = totalAbsoluteCurvature;\nfunction len(interval, ps) {\n    function f(ps) {\n        if (interval[0] === interval[1]) {\n            return 0;\n        }\n        let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n        // Keep line below to ensure zero length curve returns zero!\n        if (x0 === x1 && x1 === x2 && x2 === x3 &&\n            y0 === y1 && y1 === y2 && y2 === y3) {\n            return 0;\n        }\n        const evDs = ds(ps);\n        return flo_gauss_quadrature_1.default(evDs, interval);\n    }\n    // Curry\n    return ps === undefined ? f : f(ps);\n}\nexports.len = len;\nfunction getTAtLength(ps, s) {\n    const lenAtT = (t) => len([0, t], ps);\n    function f(s) {\n        return flo_poly_1.default.brent(t => (lenAtT(t) - s), 0, 1);\n    }\n    // Curry\n    return s === undefined ? f : f(s);\n}\nexports.getTAtLength = getTAtLength;\nfunction ds(ps, t) {\n    const evDx = evaluate_dx_1.evaluateDx(ps);\n    const evDy = evaluate_dy_1.evaluateDy(ps);\n    function f(t) {\n        let dx = evDx(t);\n        let dy = evDy(t);\n        return Math.sqrt(dx * dx + dy * dy);\n    }\n    // Curry\n    return t === undefined ? f : f(t);\n}\nfunction evaluateDdx(ps, t) {\n    const ddPs = getDdx(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(ddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDdx = evaluateDdx;\nfunction evaluateDdy(ps, t) {\n    const ddPs = getDdy(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(ddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDdy = evaluateDdy;\nfunction evaluateDddx(ps, t) {\n    const dddPs = getDddx(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(dddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDddx = evaluateDddx;\nfunction evaluateDddy(ps, t) {\n    const dddPs = getDddy(ps); // Speed optimizing cache\n    const f = flo_poly_1.default.evaluate(dddPs);\n    return t === undefined ? f : f(t); // Curry\n}\nexports.evaluateDddy = evaluateDddy;\n// TODO - refactor getBounds, getBoundingBox, etc.\n/**\n * Helper function. Returns the bounding box of the normalized (i.e. first point\n * moved to origin and rotated so that last point lies on x-axis) given cubic\n * bezier.\n * @ignore\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @param sinθ - Sine of angle made by line from first bezier point to\n * last with x-axis.\n * @param cosθ - Cosine of angle made by line from first bezier point\n * to last with x-axis.\n * @returns Bounding box in the form [[minX, minY], [maxX,maxY]\n */\nfunction getNormalizedBoundingBox(ps, sinθ, cosθ) {\n    let vectorToOrigin = Vector.transform(ps[0], x => -x);\n    let boundingPs = Vector.translateThenRotatePs(vectorToOrigin, -sinθ, cosθ, ps);\n    return getBoundingBox(boundingPs);\n}\n/**\n * Returns the tight bounding box of the given cubic bezier.\n * @returns The tight bounding box of the bezier as four ordered\n * points of a rotated rectangle.\n * TODO - test case of baseLength === 0\n */\nlet getBoundingBoxTight = memoize(function (ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    let baseLength = Math.sqrt((x3 - x0) * (x3 - x0) + (y3 - y0) * (y3 - y0));\n    let sinθ = (y3 - y0) / baseLength;\n    let cosθ = (x3 - x0) / baseLength;\n    let box = getNormalizedBoundingBox(ps, sinθ, cosθ);\n    let [[p0x, p0y], [p1x, p1y]] = box;\n    let axisAlignedBox = [\n        box[0], [p1x, p0y],\n        box[1], [p0x, p1y]\n    ];\n    return Vector.rotateThenTranslatePs(sinθ, cosθ, ps[0], axisAlignedBox);\n});\nexports.getBoundingBoxTight = getBoundingBoxTight;\n/**\n * Returns the axis-aligned bounding box of a given bezier.\n * @param ps - A cubic bezier, e.g. [[0,0],[1,1],[2,1],[2,0]]\n * @returns the axis-aligned bounding box in the form\n * [[minx, miny], [maxx,maxy]\n */\nlet getBoundingBox = memoize(function (ps) {\n    return getBounds(ps).box;\n});\nexports.getBoundingBox = getBoundingBox;\n/**\n * Calculates and returns general bezier bounds.\n * @returns The axis-aligned bounding box together with the t values\n * where the bounds on the bezier are reached.\n */\nlet getBounds = memoize(function (ps) {\n    // Roots of derivative\n    let roots = [get_dx_1.getDx(ps), get_dy_1.getDy(ps)]\n        .map(poly => flo_poly_1.default.allRoots(poly, 0, 1));\n    // Endpoints\n    roots[0].push(0, 1);\n    roots[1].push(0, 1);\n    let minX = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    let tMinX = undefined;\n    let tMinY = undefined;\n    let tMaxX = undefined;\n    let tMaxY = undefined;\n    // Test points\n    for (let i = 0; i < roots[0].length; i++) {\n        let t = roots[0][i];\n        let x = evaluate_x_1.evaluateX(ps, t);\n        if (x < minX) {\n            minX = x;\n            tMinX = t;\n        }\n        if (x > maxX) {\n            maxX = x;\n            tMaxX = t;\n        }\n    }\n    for (let i = 0; i < roots[1].length; i++) {\n        let t = roots[1][i];\n        let y = evaluate_y_1.evaluateY(ps, t);\n        if (y < minY) {\n            minY = y;\n            tMinY = t;\n        }\n        if (y > maxY) {\n            maxY = y;\n            tMaxY = t;\n        }\n    }\n    let ts = [[tMinX, tMinY], [tMaxX, tMaxY]];\n    let box = [[minX, minY], [maxX, maxY]];\n    return { ts, box };\n});\nexports.getBounds = getBounds;\n/**\n * Returns 2 new beziers split at the given t parameter, i.e. for the ranges\n * [0,t] and [t,1]. Uses de Casteljau's algorithm.\n *\n * A loose bound on the accuracy of the resultant points is given by:\n * |δP| = 2n*max_k(|b_k|)η, where n = 3 (cubic), b_k are the control points\n * abd η is Number.EPSILON.\n * @param ps - A cubic bezier curve\n * @param t - The t parameter where the curve should be split\n */\nfunction splitAt(ps, t) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    let s = 1 - t;\n    let t2 = t * t;\n    let t3 = t2 * t;\n    let s2 = s * s;\n    let s3 = s2 * s;\n    let ps1 = [\n        [x0, y0],\n        [t * x1 + s * x0, t * y1 + s * y0],\n        [t2 * x2 + 2 * s * t * x1 + s2 * x0, t2 * y2 + 2 * s * t * y1 + s2 * y0],\n        [t3 * x3 + 3 * s * t2 * x2 + 3 * s2 * t * x1 + s3 * x0,\n            t3 * y3 + 3 * s * t2 * y2 + 3 * s2 * t * y1 + s3 * y0]\n    ];\n    let ps2 = [\n        ps1[3],\n        [t2 * x3 + 2 * t * s * x2 + s2 * x1, t2 * y3 + 2 * t * s * y2 + s2 * y1],\n        [t * x3 + s * x2, t * y3 + s * y2],\n        [x3, y3]\n    ];\n    return [ps1, ps2];\n}\nexports.splitAt = splitAt;\n/**\n * Returns a new bezier from the given bezier by limiting its t range.\n *\n * Uses de Casteljau's algorithm.\n *\n * @param ps A bezier\n * @param tRange A t range\n */\nfunction bezierFromBezierPiece(ps, tRange) {\n    // If tRange = [0,1] then return original bezier.\n    if (tRange[0] === 0 && tRange[1] === 1) {\n        return ps;\n    }\n    // If tRange[0] === tRange[1] then return a single point degenerated bezier.\n    if (tRange[0] === tRange[1]) {\n        let p = evaluate_1.evaluate(ps)(tRange[0]);\n        return [p, p, p, p];\n    }\n    if (tRange[0] === 0) {\n        return from_0_to_T_1.from0ToT(ps, tRange[1]);\n    }\n    if (tRange[1] === 1) {\n        return from_T_to_1_1.fromTTo1(ps, tRange[0]);\n    }\n    // At this stage we know the t range is not degenerate and tRange[0] !== 0 \n    // and tRange[1] !== 1\n    return from_0_to_T_1.from0ToT(from_T_to_1_1.fromTTo1(ps, tRange[0]), (tRange[1] - tRange[0]) / (1 - tRange[0]));\n}\nexports.bezierFromBezierPiece = bezierFromBezierPiece;\n/**\n * Returns a human readable string representation of the given bezier.\n * @param ps - A bezier curve\n */\nfunction toString(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return `[[${x0},${y0}],[${x1},${y1}],[${x2},${y2}],[${x3},${y3}]]`;\n}\n/**\n * Scales all control points of the given bezier by the given factor.\n * @param ps - A bezier curve\n * @param c - The scale factor\n */\nfunction scale(ps, c) {\n    return ps.map(x => [x[0] * c, x[1] * c]);\n}\nexports.scale = scale;\n/**\n * Returns the best least squares quadratic bezier approximation to the given\n * cubic bezier. Note that the two bezier endpoints differ in general.\n * @param ps - A cubic bezier curve.\n */\nfunction toQuadratic(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return [\n        [(19 / 20) * x0 + (3 / 20) * x1 + (-3 / 20) * x2 + (1 / 20) * x3,\n            (19 / 20) * y0 + (3 / 20) * y1 + (-3 / 20) * y2 + (1 / 20) * y3],\n        [(-1 / 4) * x0 + (3 / 4) * x1 + (3 / 4) * x2 + (-1 / 4) * x3,\n            (-1 / 4) * y0 + (3 / 4) * y1 + (3 / 4) * y2 + (-1 / 4) * y3],\n        [(1 / 20) * x0 + (-3 / 20) * x1 + (3 / 20) * x2 + (19 / 20) * x3,\n            (1 / 20) * y0 + (-3 / 20) * y1 + (3 / 20) * y2 + (19 / 20) * y3]\n    ];\n}\nexports.toQuadratic = toQuadratic;\n/**\n * Evaluates the given hybrid quadratic at the given t and th parameters. (see\n * toHybridQuadratic for details).\n * @param hq - A hybrid quadratic\n * @param t - The bezier parameter value\n * @param th - The parameter value for the hybrid quadratic point.\n */\nfunction evaluateHybridQuadratic(hq, t, th) {\n    let P0 = hq[0];\n    let P1_ = hq[1];\n    let P2 = hq[2];\n    let P1 = evaluateLinear(hq[1], th);\n    return evaluateQuadratic([P0, P1, P2], t);\n}\nexports.evaluateHybridQuadratic = evaluateHybridQuadratic;\n/**\n * Evaluates the given linear bezier (line) at a specific t value.\n * @param ps - A linear bezier curve.\n * @param t - The value where the bezier should be evaluated\n */\nfunction evaluateLinear(ps, t) {\n    let [[x0, y0], [x1, y1]] = ps;\n    let x = x0 * (1 - t) + x1 * t;\n    let y = y0 * (1 - t) + y1 * t;\n    return [x, y];\n}\nexports.evaluateLinear = evaluateLinear;\n/**\n * Returns a clone of the given cubic bezier. Use sparingly; this is not in the\n * spirit of functional programming.\n * @param ps - A cubic bezier given by its array of control points\n */\nfunction clone(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps;\n    return [[x0, y0], [x1, y1], [x2, y2], [x3, y3]];\n}\nexports.clone = clone;\n/**\n * Evaluates the given quadratic bezier at a specific t value.\n * @param ps - A quadratic bezier curve.\n * @param t - The value where the bezier should be evaluated\n */\nfunction evaluateQuadratic(ps, t) {\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    let x = x0 * Math.pow((1 - t), 2) + x1 * 2 * (1 - t) * t + x2 * Math.pow(t, 2);\n    let y = y0 * Math.pow((1 - t), 2) + y1 * 2 * (1 - t) * t + y2 * Math.pow(t, 2);\n    return [x, y];\n}\nexports.evaluateQuadratic = evaluateQuadratic;\n/**\n * Returns the cubic version of the given quadratic bezier curve. Quadratic\n * bezier curves can always be represented by cubics - the converse is false.\n * @param ps - A quadratic bezier curve.\n */\nfunction toCubic(ps) {\n    let [[x0, y0], [x1, y1], [x2, y2]] = ps;\n    return [\n        [x0, y0],\n        [(1 / 3) * x0 + (2 / 3) * x1, (1 / 3) * y0 + (2 / 3) * y1],\n        [(2 / 3) * x1 + (1 / 3) * x2, (2 / 3) * y1 + (1 / 3) * y2],\n        [x2, y2]\n    ];\n}\nexports.toCubic = toCubic;\n/**\n * Returns the given points (e.g. bezier) in reverse order.\n * @param ps\n */\nfunction reverse(ps) {\n    return ps.slice().reverse();\n}\nexports.reverse = reverse;\nfunction equal(psA, psB) {\n    let [[ax0, ay0], [ax1, ay1], [ax2, ay2], [ax3, ay3]] = psA;\n    let [[bx0, by0], [bx1, by1], [bx2, by2], [bx3, by3]] = psB;\n    return (ax0 === bx0 && ax1 === bx1 && ax2 === bx2 && ax3 === bx3 &&\n        ay0 === by0 && ay1 === by1 && ay2 === by2 && ay3 === by3);\n}\nexports.equal = equal;\n"],"file":"index.js"}