
// We *have* to do the below❗ The assignee is a getter❗ The assigned is a pure function❗ Otherwise code is too slow❗
import { operators as bigFloatOperators } from "big-float-ts";
const { 
    twoProduct, eSum, eEstimate, eDiv, expansionProduct, 
    eDiff, eNegativeOf, scaleExpansion, fastExpansionSum, twoDiff, eSign, 
    eCompare, eAbs 
} = bigFloatOperators;


/**
 * Returns the t parameter value of the point closest to the given point of the
 * given bezier curve.
 * * **don't use**: This function has numeric stability issues when the cubic is very close to 
 * a line, e.g. 0 0 1 1 2 2 3 3.00000000000001. The same problem would occur by 
 * following the example by Tom Sederberg, to quote: "If P1, P2, and P3 are 
 * not collinear", and it turns out sometimes they *are* collinear. Use closestPointOnBezierPrecise
 * or closestPointOnBezier instead
 * @param ps 
 * @param p 
 */
function inversion(ps: number[][], p: number[][]) {
    if (ps.length === 4) {
        return inversion3(ps, p);
    }

    if (ps.length === 3) {
        return inversion2(ps, p);
    }

    if (ps.length === 2) {
        return inversion1(ps, p);
    }
}


/**
 * Returns the t parameter value of the point closest to the given point of the
 * given cubic bezier curve.
 * * **don't use**: This function has numeric stability issues when the cubic is very close to 
 * a line, e.g. 0 0 1 1 2 2 3 3.00000000000001. The same problem would occur by 
 * following the example by Tom Sederberg, to quote: "If P1, P2, and P3 are 
 * not collinear", and it turns out sometimes they *are* collinear.
 * * The bitlength of the control point coordinates of the bezier must <= 49
 * @param ps an order 3 bezier curve
 * @param p a point
 */
function inversion3(ps: number[][], p: number[][]) {
    let [[x0,y0],[x1,y1],[x2,y2],[x3,y3]] = ps;
    let [x,y] = p;

    // The formulas below was generated by the Python Sympy script.
    // Each matrix row below is an inversion formula, but only one of the roots
    // of the polynomials in t is correct. Also, only 2 of the rows are linearly
    // independent.

    //---- Matrix top row

    //let t12 = 
    // -x*y0 + 3*x*y1 - 3*x*y2 + x*y3 + x0*y - x0*y3 - 3*x1*y + 3*x1*y3 + 
    // 3*x2*y - 3*x2*y3 - x3*y + x3*y0 - 3*x3*y1 + 3*x3*y2;
    let t12 = eSum([
        scaleExpansion(x,-y0),
        scaleExpansion(x,3*y1),
        scaleExpansion(x,-3*y2),
        scaleExpansion(x,y3),
        scaleExpansion(y,x0),
        twoProduct(-x0,y3),
        scaleExpansion(y,-3*x1),
        twoProduct(3*x1,y3),
        scaleExpansion(y,3*x2),
        twoProduct(-3*x2,y3),
        scaleExpansion(y,-x3),
        twoProduct(x3,y0),
        twoProduct(-3*x3,y1),
        twoProduct(3*x3,y2)
    ]);

    //let t11 = 
    // 2*x*y0 - 3*x*y1 + x*y3 - 2*x0*y + 2*x0*y3 + 3*x1*y - 
    // 3*x1*y3 - x3*y - 2*x3*y0 + 3*x3*y1;
    let t11 = eSum([
        scaleExpansion(x,2*y0),
        scaleExpansion(x,-3*y1),
        scaleExpansion(x,y3),
        scaleExpansion(y,-2*x0),
        twoProduct(2*x0,y3),
        scaleExpansion(y,3*x1),
        twoProduct(-3*x1,y3),
        scaleExpansion(y,-x3),
        twoProduct(-2*x3,y0),
        twoProduct(+3*x3,y1)
    ]);

    //let t10 = -x*y0 + x*y3 + x0*y - x0*y3 - x3*y + x3*y0;
    let t10 = eSum([
        scaleExpansion(x,-y0),
        scaleExpansion(x,y3),
        scaleExpansion(y,x0),
        twoProduct(-x0,y3),
        scaleExpansion(y,-x3),
        twoProduct(x3,y0)
    ]);


    //---- Matrix middle row
    //let t22 = 
    // -2*x*y0 + 6*x*y1 - 6*x*y2 + 2*x*y3 + 2*x0*y - 3*x0*y2 + 
    // x0*y3 - 6*x1*y + 9*x1*y2 - 3*x1*y3 + 6*x2*y + 3*x2*y0 - 9*x2*y1
    // -2*x3*y - x3*y0 + 3*x3*y1;
    let t22 = eSum([
        scaleExpansion(x,-2*y0),
        scaleExpansion(x,6*y1),
        scaleExpansion(x,-6*y2),
        scaleExpansion(x,2*y3),
        scaleExpansion(y,2*x0),
        twoProduct(-3*x0,y2),
        twoProduct(x0,y3),
        scaleExpansion(y,-6*x1),
        twoProduct(9*x1,y2),
        twoProduct(-3*x1,y3),
        scaleExpansion(y,6*x2),
        twoProduct(3*x2,y0),
        twoProduct(-9*x2,y1),
        scaleExpansion(y,-2*x3),
        twoProduct(-x3,y0),
        twoProduct(3*x3,y1)
    ]);

    //let t21 = 
    // 5*x*y0 - 9*x*y1 + 3*x*y2 + x*y3 - 5*x0*y + 6*x0*y2 - x0*y3 + 
    // 9*x1*y - 9*x1*y2 - 3*x2*y - 6*x2*y0 + 9*x2*y1 - x3*y + x3*y0;
    let t21 = eSum([
        scaleExpansion(x,5*y0),
        scaleExpansion(x,-9*y1),
        scaleExpansion(x,3*y2),
        scaleExpansion(x,y3),
        scaleExpansion(y,-5*x0),
        twoProduct(6*x0,y2),
        twoProduct(-x0,y3),
        scaleExpansion(y,9*x1),
        twoProduct(-9*x1,y2),
        scaleExpansion(y,-3*x2),
        twoProduct(-6*x2,y0),
        twoProduct(9*x2,y1),
        scaleExpansion(y,-x3),
        twoProduct(x3,y0)
    ]);

    //let t20 = -3*x*y0 + 3*x*y2 + 3*x0*y - 3*x0*y2 - 3*x2*y + 3*x2*y0;
    let t20 = eSum([
        scaleExpansion(x,-3*y0),
        scaleExpansion(x,3*y2),
        scaleExpansion(y,3*x0),
        twoProduct(-3*x0,y2),
        scaleExpansion(y,-3*x2),
        twoProduct(3*x2,y0)
    ]);

    //---- Matrix bottom row
    //let t32 = 
    // -x*y0 + 3*x*y1 - 3*x*y2 + x*y3 + x0*y - 3*x0*y1 + 3*x0*y2 - 
    // x0*y3 - 3*x1*y + 3*x1*y0 + 3*x2*y - 3*x2*y0 - x3*y + x3*y0;
    let t32 = eSum([
        scaleExpansion(x,-y0),
        scaleExpansion(x,3*y1),
        scaleExpansion(x,-3*y2),
        scaleExpansion(x,y3),
        scaleExpansion(y,x0),
        twoProduct(-3*x0,y1),
        twoProduct(3*x0,y2),
        twoProduct(-x0,y3),
        scaleExpansion(y,-3*x1),
        twoProduct(3*x1,y0),
        scaleExpansion(y,3*x2),
        twoProduct(-3*x2,y0),
        scaleExpansion(y,-x3),
        twoProduct(x3,y0)
    ]);

    //let t31 = 
    // 3*x*y0 - 6*x*y1 + 3*x*y2 - 3*x0*y + 6*x0*y1 - 3*x0*y2 + 
    // 6*x1*y - 6*x1*y0 - 3*x2*y + 3*x2*y0;
    let t31 = eSum([
        scaleExpansion(x,3*y0),
        scaleExpansion(x,-6*y1),
        scaleExpansion(x,3*y2),
        scaleExpansion(y,-3*x0),
        twoProduct(6*x0,y1),
        twoProduct(-3*x0,y2),
        scaleExpansion(y,6*x1),
        twoProduct(-6*x1,y0),
        scaleExpansion(y,-3*x2),
        twoProduct(3*x2,y0)
    ]);

    //let t30 = 
    // -3*x*y0 + 3*x*y1 + 3*x0*y - 3*x0*y1 - 3*x1*y + 3*x1*y0;
    let t30 = eSum([
        scaleExpansion(x,-3*y0),
        scaleExpansion(x,3*y1),
        scaleExpansion(y,3*x0),
        twoProduct(-3*x0,y1),
        scaleExpansion(y,-3*x1),
        twoProduct(3*x1,y0)
    ]);


    // Inversion formulae are in the form f(x,y) / g(x,y).
    // These formulae come from the rows of a 3x3 matrix with each row an
    // equation of the form at^2 + bt + c and where at least one row is
    // linearly dependent on the other two.
    // Here we have f(x,y) === t0 and g(x,y) === t1
    // So a solution is -t0/t1.
    // But, we should strive for the biggest t1 as this will increase numerical
    // stability and/or decrease the 'difficulty' of the problem.
    // We may end up in each case with 0/0 in which case the t value is at the
    // double point of the cubic bezier - we should then proceed to find this
    // double point and return both relevant t values.

    // subtract t12/t22 times the second row from first
    let a1: number[];
    let b1: number[];
    let a2: number[];
    let b2: number[];
    let a3: number[];
    let b3: number[];
    if (eSign(t12) === 0) {
        // the top row equation is already linear
        if (eSign(t11) !== 0) {
            a1 = t11;
            b1 = t10;
        } // else the top row reads 0t^2 + 0t + 0 = 0, i.e. the row is already
          // eliminated
    }

    if (eSign(t22) === 0) {
        // the middle row equation is already linear
        if (eSign(t21) !== 0) {
            a2 = t21;
            b2 = t20;
        } // else the middle row reads 0t^2 + 0t + 0 = 0, i.e. the row is already
          // eliminated
    }

    if (eSign(t32) === 0) {
        // the bottom row equation is already linear
        if (eSign(t31) !== 0) {
            a3 = t31;
            b3 = t30;
        } // else the bottom row reads 0t^2 + 0t + 0 = 0, i.e. the row is already
          // eliminated
    }


    // eliminate the coefficient of t^2 from the first row (using the second)
    if (eSign(t22) !== 0 && eSign(t12) !== 0) {
        let d = eDiv(t12, t22, 4);
        a1 = eDiff(t11, expansionProduct(d, t21));
        b1 = eDiff(t10, expansionProduct(d, t20));
    }

    // eliminate the coefficient of t^2 from the second row (using the 3rd)
    if (eSign(t32) !== 0 && eSign(t22) !== 0) {
        let d = eDiv(t22, t32, 4);
        a2 = eDiff(t21, expansionProduct(d, t31));
        b2 = eDiff(t20, expansionProduct(d, t30));
    }

    // eliminate the coefficient of t^2 from the third row (using the 1st)
    if (eSign(t12) !== 0 && eSign(t32) !== 0) {
        let d = eDiv(t32, t12, 4);
        a3 = eDiff(t31, expansionProduct(d, t11));
        b3 = eDiff(t30, expansionProduct(d, t10));
    }

    let useRow: number;
    a1 = a1 || [0];
    a2 = a2 || [0];
    a3 = a3 || [0];
    if (eCompare(eAbs(a1),eAbs(a2)) > 0) {
        if (eCompare(eAbs(a1),eAbs(a3)) > 0) {
            useRow = 1;
        } else {
            useRow = 3;
        }
    } else {
        if (eCompare(eAbs(a2),eAbs(a3)) > 0) {
            useRow = 2;
        } else {
            useRow = 3;
        }
    }

    let a = useRow === 1 ? a1 : useRow === 2 ? a2 : a3;
    let b = useRow === 1 ? b1 : useRow === 2 ? b2 : b3;

    let t = eDiv(eNegativeOf(b), a, 4);
    return eEstimate(t);
}


/**
 * Returns the t parameter value of the point closest to the given point of the
 * given quadratic bezier curve.
 * * The bitlength of the control point coordinates of the bezier must <= 49
 * @param ps an order 2 bezier curve
 * @param p a point
 */
function inversion2(ps: number[][], p: number[][]) {
    let [[x0,y0],[x1,y1],[x2,y2]] = ps;
    let [x,y] = p;

    // The formulas below was generated by the Python Sympy script.
    // Each matrix row below is an inversion formula.

    //---- Matrix top row

    //let t11 = x*y0 - 2*x*y1 + x*y2 - x0*y + x0*y2 + 2*x1*y - 2*x1*y2 - x2*y - x2*y0 + 2*x2*y1
    let t11 = eSum([
        scaleExpansion(x,y0),
        scaleExpansion(x,-2*y1),
        scaleExpansion(x,y2),
        scaleExpansion(y,-x0),
        twoProduct(x0,y2),
        scaleExpansion(y,2*x1),
        twoProduct(-2*x1,y2),
        scaleExpansion(y,-x2),
        twoProduct(-x2,y0),
        twoProduct(2*x2,y1)
    ]);

    //let t10 = - x*y0 + x*y2 + x0*y - x0*y2 - x2*y + x2*y0
    let t10 = eSum([
        scaleExpansion(x,-y0),
        scaleExpansion(x,y2),
        scaleExpansion(y,x0),
        twoProduct(-x0,y2),
        scaleExpansion(y,-x2),
        twoProduct(x2,y0)
    ]);


    let t = eDiv(eNegativeOf(t10), t11, 4);
    return eEstimate(t);


    //---- Matrix bottom row
    //let t22 = 
    let t21 = eSum([
        scaleExpansion(x,y0),
        scaleExpansion(x,-2*y1),
        scaleExpansion(x,y2),
        scaleExpansion(y,-x0),
        twoProduct(2*x0,y1),
        twoProduct(-x0,y2),
        scaleExpansion(y,2*x1),
        twoProduct(-2*x1,y0),
        scaleExpansion(y,-x2),
        twoProduct(x2,y0)
    ]);

    //let t21 = 
    let t20 = eSum([
        scaleExpansion(x,-2*y0),
        scaleExpansion(x,2*y1),
        scaleExpansion(y,2*x0),
        twoProduct(-2*x0,y1),
        scaleExpansion(y,-2*x1),
        twoProduct(2*x1,y0)
    ]);
}


/**
 * Returns the t parameter value of the point closest to the given point of the
 * given line.
 * * The bitlength of the control point coordinates of the bezier must <= 49
 * @param ps an order 1 bezier curve
 * @param p a point
 */
function inversion1(ps: number[][], p: number[][]) {
    let [[x0,y0],[x1,y1]] = ps;
    let [x,y] = p;

    let x1_x0 = twoDiff(x1, x0);
    let y1_y0 = twoDiff(y1, y0);

    // the compare below ensures numerical stability
    if (eCompare(x1_x0, y1_y0) > 0) {
        let t = eDiv(
            fastExpansionSum(x, [-x0]),
            x1_x0,
            4
        );

        return eEstimate(t);
    }

    let t = eDiv(
        fastExpansionSum(y, [-y0]),
        twoDiff(y1, y0),
        4
    );

    return eEstimate(t);
}


/**
 * Returns the t parameter value of the point closest to the given point on the
 * given line.
 * * The bit-aligned bitlength of the control point coordinates of the line and 
 * the given point must <= 52
 * * the result is accurate to within 1 ULP
 * @param ps an order 1 bezier curve
 * @param p a point
 */
function inversion1_BL52_1ULP(
        ps: number[][], 
        p: number[]) {

    let [[x0,y0],[x1,y1]] = ps;
    let [x,y] = p;

    let x1_x0 = x1 - x0;
    let y1_y0 = y1 - y0;

    // the compare below ensures numerical stability
    return Math.abs(x1_x0) > Math.abs(y1_y0)
        ? (x - x0) / x1_x0
        : (y - y0) / y1_y0;
}


export { inversion, inversion1_BL52_1ULP }
