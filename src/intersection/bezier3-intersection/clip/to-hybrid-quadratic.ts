

// TODO - put back quadratic and line versions
/**
 * Returns the hybrid quadratic version of the given cubic bezier. For a 
 * definition of hybrid quadratic bezier curves see <a href="http://scholarsarchive.byu.edu/cgi/viewcontent.cgi?article=2206&context=etd">
 * this paper</a>.
 * @param ps - A cubic bezier curve.
 * @returns An array of three quadratic bezier points where the 
 * middle point is a 'hybrid' point represented as a line (itself represented
 * by two points (a linear bezier curve)) which can be evaluated at a different 
 * t value (call it th). If evaluated at the same t value the result is the same 
 * as evaluating the original cubic bezier at t. The set generated by evaluating 
 * the hybrid quadratic curve for all (t,th) value pairs forms a geometric area
 * bound around the orginal cubic bezier curve. The length of the linear bezier
 * curve mentioned above is a measure of how closely the cubic can be
 * represented as a quadratic bezier curve.
 */
/*
function toHybridQuadratic(ps: number[][]): [
		[number, number], 
		[
			[number, number], 
			[number, number]
		], 
		[number,number]] {

	if (ps.length === 4) {
		// the below is too slow
		//const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; 

		const p0 = ps[0];
		const p1 = ps[1];
		const p2 = ps[2];
		const p3 = ps[3];
	
		const x0 = p0[0];
		const y0 = p0[1];
		const x1 = p1[0];
		const y1 = p1[1];
		const x2 = p2[0];
		const y2 = p2[1];
		const x3 = p3[0];
		const y3 = p3[1];

		return [
			[x0,y0], 					  	     // evaluated at t
			[
				[(3*x1 - x0)/2, (3*y1 - y0)/2],  // evaluated at (1-t)
				[(3*x2 - x3)/2, (3*y2 - y3)/2]   // evaluated at t
			],  
			[x3,y3] 						     // evaluated at t
		];
	} else if (ps.length === 3) {
		let [[x0,y0],[x1,y1],[x2,y2]] = ps;
		return [
			[x0,y0], 	// evaluated at t
			[[x1, y1],  // evaluated at (1-t)
			 [x1, y1]], // evaluated at t
			[x2,y2] 	// evaluated at t
		]
	} else if (ps.length === 2) {
		let [[x0,y0],[x1,y1]] = ps;
		return [
			[x0,y0], 	// evaluated at t
			[[(x1+x0)/2, (y1+y0)/2],  // evaluated at (1-t)
			 [(x1+x0)/2, (y1+y0)/2]], // evaluated at t
			[x1,y1] 	// evaluated at t
		]
	}
}
*/


function toHybridQuadratic(ps: number[][]): [
		[number, number], 
		[number, number], 
		[number, number],
		[number, number]] {

	// the below is too slow
	//const [[x0, y0], [x1, y1], [x2, y2], [x3, y3]] = ps; 

	const p0 = ps[0];
	const p1 = ps[1];
	const p2 = ps[2];
	const p3 = ps[3];

	const x0 = p0[0];
	const y0 = p0[1];
	const x1 = p1[0];
	const y1 = p1[1];
	const x2 = p2[0];
	const y2 = p2[1];
	const x3 = p3[0];
	const y3 = p3[1];

	return [
		[x0,y0],				  	     // evaluated at t
		[(3*x1 - x0)/2, (3*y1 - y0)/2],  // evaluated at (1-t)
		[(3*x2 - x3)/2, (3*y2 - y3)/2],  // evaluated at t
		[x3,y3] 						 // evaluated at t
	];

}


export { toHybridQuadratic }
